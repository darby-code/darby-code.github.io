<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,300italic,400,400italic,700,700italic|Ubuntu:300,300italic,400,400italic,700,700italic|Ubuntu:300,300italic,400,400italic,700,700italic|Ubuntu:300,300italic,400,400italic,700,700italic|Ubuntu:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="存储器管理," />










<meta name="description" content="存储器（内存，主存）是一种需要仔细管理的资源。虽然每个程序员都希望自己计算机的主存有无限大，然后一些麻烦的事情就不用考虑了。但是，这在现实中并不存在，于是，学好如何管理内存，是一个程序员（码农）需要掌握的基本功。">
<meta property="og:type" content="article">
<meta property="og:title" content="存储器管理">
<meta property="og:url" content="http://example.com/2020/11/12/%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="Doug-Wilson&#39;s blogs">
<meta property="og:description" content="存储器（内存，主存）是一种需要仔细管理的资源。虽然每个程序员都希望自己计算机的主存有无限大，然后一些麻烦的事情就不用考虑了。但是，这在现实中并不存在，于是，学好如何管理内存，是一个程序员（码农）需要掌握的基本功。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/%E4%BA%A4%E6%8D%A2.png">
<meta property="og:image" content="http://example.com/images/%E5%A2%9E%E9%95%BF%E7%A9%BA%E9%97%B4.png">
<meta property="og:image" content="http://example.com/images/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png">
<meta property="og:image" content="http://example.com/images/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84.png">
<meta property="og:image" content="http://example.com/images/MMU%E6%93%8D%E4%BD%9C.png">
<meta property="og:image" content="http://example.com/images/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8.png">
<meta property="og:image" content="http://example.com/images/%E9%A1%B5%E8%A1%A8%E9%A1%B9.png">
<meta property="og:image" content="http://example.com/images/TLB.png">
<meta property="og:image" content="http://example.com/images/%E6%97%B6%E9%92%9F%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="http://example.com/images/%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E7%9A%84NRU%E7%AE%97%E6%B3%95.png">
<meta property="article:published_time" content="2020-11-12T08:56:21.000Z">
<meta property="article:modified_time" content="2021-05-31T05:51:01.316Z">
<meta property="article:author" content="Doug-Wilson">
<meta property="article:tag" content="存储器管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/%E4%BA%A4%E6%8D%A2.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2020/11/12/存储器管理/"/>





  <title>存储器管理 | Doug-Wilson's blogs</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband">
		<a target="_blank" rel="noopener" href="https://your-url" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
	</div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Doug-Wilson's blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学无止境，积累技术</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-主页">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            主页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/about/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-目录">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            目录
          </a>
        </li>
      
        
        <li class="menu-item menu-item-归类">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-时间表">
          <a href="/schedule/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            时间表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/12/%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Doug-Wilson's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">存储器管理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-12T16:56:21+08:00">
                2020-11-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>存储器（内存，主存）是一种需要仔细管理的资源。虽然每个程序员都希望自己计算机的主存有无限大，然后一些麻烦的事情就不用考虑了。但是，这在现实中并不存在，于是，学好如何管理内存，是一个程序员（码农）需要掌握的基本功。</p>
<span id="more"></span>

<h2 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h2><p>交换是一种简单的内存管理方法。通过将各个进程完整地调入主存运行，切换进程时再将进程放回到磁盘上。比如下面的示例：</p>
<p><img src="/images/%E4%BA%A4%E6%8D%A2.png"></p>
<p>开始时只有进程A在主存，然后进程B和C被创建或从磁盘上被调入。之后当进程A结束或被交换到磁盘上，进程D被调入。接着B离开内存，E进程进入。</p>
<p>从这个过程也可以发现，当内存进行进程交换时，相邻进程间会有未使用内存部分，称之为<strong>空洞</strong>。当交换在内存中生成多个空洞时，可以将所有的进程向下移动至相互靠紧，从而将这些空洞结合成一大块，这种计数称为**内存紧缩(memory compaction)**。但通常不进行这个操作，因为需要耗费大量的CPU时间。比如一个32M的主存，假设每微秒可以拷贝16个字节，那么将内存紧缩一次需要2秒钟。</p>
<p>另一个问题就是，如果进程的数据段是可以增长的，那么进程一旦试图增长时问题就出现了。如果要增长的进程紧邻一个空洞，那这还可以通过将空洞的内存空间分配给该增长进程。然而，如果进程邻接的是另一个进程，则需要增长的进程将被移动到一个足够大的空洞中去，或者交换出多个进程以形成一个足够大的空洞。如果一个进程不能在内存中增长并且磁盘的交换分区满了，那么这个进程就必须被杀死。</p>
<p>在实际情况中，大多数进程在运行时都会增长，为了减少进程因为内存空间不够而引起的移动和交换所带来的开销，另一种方法就是：在进程被交换进内存或者在内存中移动时就额外为其多分配一些内存。如下图所示</p>
<p><img src="/images/%E5%A2%9E%E9%95%BF%E7%A9%BA%E9%97%B4.png"></p>
<p>在这个图中可以看到所示进程的栈段在进程所占用内存的顶端并向下增长，紧接在正文段后面的数据段向上增长，处于这两个段间的内存，两个段都可以使用，如果用完了，则这个进程必须必须被移动到足够大的空洞中。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>动态分配内存必须由操作系统管理，而一般有两种方法跟踪内存的使用情况：位图和</p>
<p>链表。</p>
<p>使用位图方法时，内存被划分为若干字节的分配单位，分配单位可能小到几个字节，也有可能大到几千个字节，各有优缺点。每个分配单位对应于位图中的一位，1表示占用，0表示空闲（或者相反）。</p>
<p>使用位图时，分配单位的大小是首先要考虑的设计因素。分配单位越小，位图越大，比如4字节32位内存也只需要位图中的1位，32*n位的内存也只需要n位的位图。如果分配单位选的比较大，需要的位图就比较小。</p>
<p>位图的主要问题就是，当将一个占K个分配单位的进程调入内存时，内存管理器必须搜索位图以找出一串k个连续的0，而在位图中查找长度连续的0串是一个缓慢的操作。</p>
<p><img src="/images/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png"></p>
<p>如上图所示，通过维持一个已分配和空闲的内存段的链表也可以进行内存的管理。当进程和空洞按照地址顺序存放在链表中时，可以通过几种算法来为要换进内存的进程分配空间。</p>
<p>首次适配算法：内存管理器沿着内存段链表搜索直到找到一个足够大的空洞，除非空洞的大小和要分配的空间大小刚好意义，否则这个空洞将被分成两部分，一部分供进程使用，一部分是未使用的内存，依然是空洞。</p>
<p>下次适配算法：工作方式和首次适配相同，区别是每次找到合适的空洞都记下当时的位置，在下次寻找空洞的时候不必从头开始搜索，而是从上次结束的地方开始搜索。</p>
<p>最佳适配算法：搜索整个链表以找出够用的最小的空洞，而不是将一个以后会用到的大空洞先使用。</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>当一个进程比内存还大的时候，该如何执行这个进程？这并不是笑话，随着现代计算机计数以及软件的发展，程序被设计的越来越庞大，用于处理复杂的问题。如何在有限的内存中运行这些庞然大物？这既是这里要讨论的问题。</p>
<p>这个方法被称作**虚拟内存(virtual memory)**。虚拟内存的基本思想是程序、数据】堆栈的总的大小可以超过可用物理存储器的大小，操作系统把程序当前使用的那些部分保留在内存中，而其它部分保留在磁盘上，并在需要的时候在内存和磁盘间交换程序的片段。</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>考虑这样一条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOVE REG, 1000</span><br></pre></td></tr></table></figure>

<p>该指令将地址为1000的内存单元的内容复制到REG中。</p>
<p><strong>由程序产生的地址称为虚拟地址(virtual address)<strong>，虚拟地址构成的空间称为</strong>虚拟地址空间(virtual address space)<strong>。在没有虚拟内存的计算机上，虚拟地址直接送到内存总线上，相应地址的物理内存被读写。而如果使用虚拟内存，虚拟地址不是直接被送到内存总线上，而是送到</strong>内存管理单元（MMU）</strong>，内存管理单元由一个或一组芯片组成，功能是将虚拟地址映射为物理地址。下面举例说明：</p>
<p>一台计算机只有32K的内存，现在有一个64K的程序。很明显，程序不能完全调入内存运行，在磁盘上必须有一个64K的程序的完整内核映像，以保证程序片段在需要时能被调入。</p>
<p><img src="/images/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84.png"></p>
<p>虚拟地址空间被划分成称为<strong>页(page)<strong>的单位，在物理存储器中对应的单位称为</strong>页框(page frame)<strong>。页和页框总是同样大小的，在这个例子中是4K，但现在的操作系统中常用的页的大小是512字节到64K。一定注意：</strong>内存和磁盘间传输的单位总是以页为单位的</strong>。</p>
<p>在这个例子中，一共有16个虚拟页和8个页框。</p>
<p>当程序试图访问地址0时，虚拟地址0将被送往内存管理单元MMU，MMU看到虚拟地址落在页0范围内（0<del>4095），根据对应的映射，可知虚拟页0对应的是页框2(8192</del>12287)，因此MMU将虚拟地址0转换为物理地址8192，并把物理地址8192送到内存总线上。内存板对于MMU一无所知，只知道内存总线上有一个对内存地址8192读或写的请求，并执行它。从而MMU有效地把所有从0到4095的虚拟地址映射到了8192到12287的物理地址。其它存在映射关系的虚拟页情况以此类推。</p>
<p>但是图中还有部分虚拟页并没有被映射到8个页框中的任何一个，如果程序试图访问为映射的页，会怎么样？答案是，当MMU发现页没有映射时，会使CPU陷入操作系统，该陷入称为缺页故障。操作系统会找到一个很少使用的页框并把它的内容写入磁盘，随后把需要引用的页取到刚才释放的页框中，修改映射，然后重新启动引起陷入的指令。</p>
<p>比如，假设操作系统决定放弃页框1，并装入虚拟页8。那么它将把虚拟页8装入物理地址4K，并对MMU作两处修改：1. 标记虚页1为未映射，以便使以后任何对虚拟地址4K到8K的访问都引起陷入 2. 将虚页8对应的表项改为1，因此在引起陷入的指令重新启动时，它将把虚拟地址32780映射为物理地址4108。</p>
<h3 id="MMU内部结构"><a href="#MMU内部结构" class="headerlink" title="MMU内部结构"></a>MMU内部结构</h3><p>通过一个例子：虚拟地址8096（0010 0000 0000 0100）如何在MMU中转换为物理地址24580（1100 0000 0000 0100）</p>
<p><img src="/images/MMU%E6%93%8D%E4%BD%9C.png"></p>
<p>从图中的转换过程可知，输入的16位虚拟地址被划分成4位的页号和12位的偏移量，4位的页号可以表示16个页面，12位的偏移可以 为 一页内的4096个字节 编址。</p>
<p>页号用作页表的索引，以得出对应于这个虚页的页框号。如果Present/absent位是0，则将引发一个操作系统陷入；如果是1，在页表中查到的页框号将被复制到输出寄存器的高3位中，加上输入虚拟地址中的12位偏移量，就构成了15位的物理地址。输出寄存器的内容随机被作为物理地址送到内存总线。</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>从上面的解释可以直到，虚拟地址被分为虚拟页号和偏移量两部分。偏移量直接拷贝到MMU输出寄存器中，而虚拟页号被用作页表的索引以找到该虚夜对应的页表项，从页表项中可以找到页框号（如果有的话），随后页框号直接被拼接到寄存器的高位端，形成内存的物理地址。</p>
<p>这里页表需要面对两个问题：</p>
<ol>
<li>页表可能非常大</li>
<li>地址映射必须十分迅速</li>
</ol>
<p>对于第一个问题，现代计算机的虚拟地址最少也会有32位，当页大小为4K时，意味着有一百万个页，对于64位的虚拟地址，则更多。因此，虚拟地址空间中的一百万个页需要一百万个页表项的页表，并且每个进程也需要有自己的页表。</p>
<p>对于第二个问题，虚拟地址到物理地址的映射几乎每时每刻都在进行。假如执行一条指令需要10纳秒，则页表的查找必须在几个纳秒内完成以避免成为性能的主要瓶颈。</p>
<p>那么对于以上问题，就会有两个解决的思路：第一个就是不将页表放在内存中，放在寄存器或某个特殊的硬件。第二个就是将页表全部放在内存中，这意味着所有指令的执行都需要一次或多次访问内存。这两个思路单独存在都不是最优的方法，下面是解决方案。</p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>多级页表避免将庞大的页表始终保存在内存中，特别是不需要用到的页表就不应该保留。下面是一个具体示例：</p>
<p>32位的虚拟地址被划分成10位的PT1域、10位的PT2域、12位的偏移量。因为偏移量为12位（0~4095），所以页大小为4K。</p>
<p><img src="/images/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8.png"></p>
<p>（4GB=4*1024*1024K=1024*1024个页） 4G表示4G的虚拟地址空间</p>
<p>顶级页表有1024个表项，对应于10位的PT1域，每个表项指向一块4M（1024个页）的虚拟地址空间块。当一个虚拟地址被送到MMU时，MMU首先找出虚拟地址的PT1域并将其作为访问顶级页表的索引。通过索引得到的顶级页表表项包含有二级页表的地址或页框号，<strong>顶级页表的表项0指向程序正文的页表、表项1指向数据的页表、表项1023指向堆栈的页表（这体现了动态扩展），其它表项表项表示未用</strong>。</p>
<p>PT2域用于访问选定的二级页表的索引以找到对应虚夜的页框号。</p>
<p>比如一个虚拟地址4206596，处于数据部分12292字节处，对应的PT1=1，PT2=3，Offset=4。MMU首先用PT1作为索引，访问顶级页表得到表项1，说明指向数据部分，对应地址范围为4M到8M。随后它用PT2作为索引访问刚刚找到的二级页面得到表项3，表项3对应的地址范围为它的4M块范围内的12288~16383。这个表项含有虚拟地址4206596所在页的页框号。如果这个页不在内存中，则present/absent位为0，一个页面将引起陷入；如果这个页在内存中，从二级页表得到的页框号将和偏移量4结合成物理地址并通过内存总线访问内存。</p>
<p>通过多级页表，虽然地址空间超过一百万个页，但实际上只需要4个页表：顶级页表、0<del>4M、4M</del>8M和顶端4M的二级页表。顶级页表中有1021个表项（除了0，1，1023）的present/absent为被设为0，使得访问他们时强制产生一个页面故障。如果这种情况发生了，操作系统将知道进程在试图访问一个不期望被访问的地址并采取行动，比如向进程发出一个信号或杀死进程。</p>
<p>上面所展示的只是二级页表，也可以有三级页表、四级页表等等。尽量不要超过三级页表。</p>
<p>最后讨论一下页表项的结构：</p>
<p><img src="/images/%E9%A1%B5%E8%A1%A8%E9%A1%B9.png"></p>
<ul>
<li>页框号</li>
<li>present/absent bit </li>
<li>保护位，表示这个页允许什么样的访问。最简单的形式保护位只有一位，0表示读写，1表示写。而常用的是使用3位，每个位分别指出是否允许读、写、执行</li>
<li>修改位和引用referenced用于跟踪页的使用。一个页被写入时硬件自动设置修改位。引用位在页被引用时设置</li>
<li>是否允许缓存位可禁止该页被缓存</li>
</ul>
<h4 id="TLB-Translation-Lookaside-Buffers"><a href="#TLB-Translation-Lookaside-Buffers" class="headerlink" title="TLB(Translation Lookaside Buffers)"></a>TLB(Translation Lookaside Buffers)</h4><p>TLB——转义后备缓冲器。为什么需要这个硬件，还是因为页表和内存间关系的问题：</p>
<p>如果将页表放在内存中，这种设计对性能有很大影响。比如把一个寄存器的内容复制到另一个寄存器的指令，在不使用分页时，只需要访问内存一次取出指令，而使用分页时，需要额外的内存访问去读取页表。如果是这样的话，每次访问内存都需要访问两次页表，这样会使得机器的性能降低2/3。</p>
<p>采取的解决方案就是位计算机装一个不需要经过页表就能把虚拟地址映射成物理地址的硬件设备——TLB，有时也称为**相联内存(associative memory)**。TLB通常位于MMU内部，条目的数量较少，一般在64个以内。每个条目包含一个页的信息，主要包括：虚拟页号、修改位、保护码、页所在物理框号、条目有效位（条目是否有效）。下面是一个8个条目的TLB：</p>
<p><img src="/images/TLB.png"></p>
<p>TLB工作过程：当一个虚拟地址被送到MMU时，硬件首先将它和TLB中的所有条目<strong>同时</strong>（这也就意味着TLB条目数量不能过多）进行比较，查看虚拟地址的虚拟页号是否在TLB中，如果找到了并且这个访问没有违反保护位，则它的页框号直接从TLB中取出，而不用查页表。如果虚拟页号在TLB中但是当前指令试图访问一个只读页面，这时将发生一个保护故障。</p>
<p>如果MMU发现在TLB没有名字，则随即进行一次唱歌的页表查找，然后从TLB中淘汰一个条目，并将它替换为刚刚找到的页表项。因此，如果这个页很快再用到的话，第二次访问它就能直接在TLB中找到。（一个TLB条目淘汰时，被修改的位被复制回在内存中的页表项，其他值已经存在，不需要进行复制）。当TLB从页表中装入时，所有域从内存中取得。</p>
<h2 id="页面替换算法"><a href="#页面替换算法" class="headerlink" title="页面替换算法"></a>页面替换算法</h2><p>在发生页面故障时，操作系统必须从内存中选一个页面删除掉，以便为调入的页让出空间。如果被删除的页在内存期间被修改过，则还需要将其写回到磁盘以更新该页在磁盘上的拷贝；如果这个页没有被修改过，则不需要写回，要读入的页面直接进行覆盖操作就可以了。</p>
<p>每次发生页面故障时尽管我们可以随机选择一个页替换，但是选择不常使用的页会使系统性能好很多。而如果一个经常使用的页被淘汰掉，那么极有可能它很快就要被调回来，从而引起不必要的额外开销。所以需要页面替换算法来进行解决上面的问题。</p>
<h3 id="最优页面替换算法"><a href="#最优页面替换算法" class="headerlink" title="最优页面替换算法"></a>最优页面替换算法</h3><p>最优页面算法思想为：在页面故障发生瞬间，有些页在内存中，其中一个页将被紧接着的下条指令访问，其他的页可能要到10、100、1000条指令后才会被访问，每个页都可以在该页首次被引用前所要执行的指令数进行标记，然后替换页面时，淘汰标记最大的页。</p>
<p>这个思想是好的，但是是无法实现的，因为操作系统无法知道各个页面下次被访问是什么时候。</p>
<p>该算法虽然无法实现，但是通常用于和其它实现算法做比较。如果其它实现算法和最优页面替换算法相差百分之一的性能，说明实现算法还有提升空间。</p>
<h3 id="最近未使用页面替换算法"><a href="#最近未使用页面替换算法" class="headerlink" title="最近未使用页面替换算法"></a>最近未使用页面替换算法</h3><p>每个页的页表项都会存在两个状态位：referenced(R)被引用位和modified(M)修改位。这些位在每次内存访问时都需要进行更新，并且由硬件进行设置。一旦一个位被设置成1，就一直保持1，直到操作系统用软件将它复位为0。</p>
<p>R位和M位可以用来构造这样一个简单的换页算法：在一个进程启动时，它的所有页的两个位都由操作系统设置成0。R位被定期清0，以把最近没有被访问的页和被访问的页区分开。</p>
<p>当页面发生陷入时，操作系统检查所有页面并根据当前的R位和M位将值分成4类：</p>
<ol>
<li>00：没有被访问，没有被修改</li>
<li>01：没有被访问，被修改</li>
<li>10：被访问，没有被修改</li>
<li>11：被访问，被修改</li>
</ol>
<p>最近未使用算法随机地从编号最小中 淘汰一个最近在一个时钟周期内没有被访问的已修改页。</p>
<p>NRU算法虽然性能不是最好的，但常常够用。</p>
<h3 id="先进先出页面替换算法"><a href="#先进先出页面替换算法" class="headerlink" title="先进先出页面替换算法"></a>先进先出页面替换算法</h3><p>FIFO算法：由操纵系统维持一个所有当前在内存中的页的链表，最老的页在头部，最新的页在尾部。当发生页面陷入时，淘汰表头的页，并将新调入的页放到末尾。</p>
<p>FIFO的缺陷是，可能会经常把使用的页替换出去，然后又调入加入到尾部，浪费性能。</p>
<h3 id="第二次机会页面替换算法"><a href="#第二次机会页面替换算法" class="headerlink" title="第二次机会页面替换算法"></a>第二次机会页面替换算法</h3><p>为了避免FIFO将经常使用的页替换出去的问题，做一个简单的修改：对最老页面的R位进行检查，如果R位为0，那么这个页既老又没用，应该立刻被替换掉。如果是1，则清除这个位，并将页加入到尾部，然后从头部继续搜索淘汰页面。</p>
<h3 id="时钟页面替换算法"><a href="#时钟页面替换算法" class="headerlink" title="时钟页面替换算法"></a>时钟页面替换算法</h3><p>尽管第二次机会算法是一个比较合理的算法，但是因为经常要在链表中移动页面，降低了效率又是不必要的。一个更好的办法就是把所有的页面保存在一个类似时钟表面的环形链表中。如图所示：</p>
<p><img src="/images/%E6%97%B6%E9%92%9F%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95.png"></p>
<p>一个指针指向最老的页面。当页面发生陷入时，算法首先检查指针指向的页面，如果它的R位是0就淘汰掉这个页面，然后将新页差入到这个位置，然后将指针前移一个位置。如果R位是1就清除R位并将指针前移一个位置。重复上述过程，直到找到一个R位为0的页。</p>
<h3 id="最久未使用页面替换算法"><a href="#最久未使用页面替换算法" class="headerlink" title="最久未使用页面替换算法"></a>最久未使用页面替换算法</h3><p>思想：当前被频繁使用到的页面极有可能在接下来的指令中也会被频繁用到，而已经很久没有使用的页面可能在将来一段比较长的时间内页不会被用到。所以，发生页面陷入时，淘汰掉没有使用时间最长的页。该算法称为LRU算法，和最优页面算法有些类似。</p>
<p>虽然LRU可以实现，但是代价很高。为了实现LRU，需要维持一个在内存中所有页的一个链表，最近使用的页放在头部，最久未使用的页放在尾部。当每次进行内存访问时，该链表都要进行更新，用于在链表中找到被访问的页，并将它移动到表头。这显然是一个非常耗时的操作。</p>
<p><strong>硬件实现LRU</strong></p>
<ol>
<li>要求硬件有一个64位计数器C，它在每条指令执行完后自动加1，每个页表项必须有一个足够容纳这个值的域。在每次访问内存后，当前的C计数值就被保存到被访问页的页表项中。当发生页面缺失时，操作系统检查页表中所有计数器的值，以找出最小的，这个页就是最久未使用的页。</li>
<li>要求硬件一个维持一个n×n的矩阵，开始时，所有位都是0。当页K被访问到时，硬件把K行都设置成1，把K列都设置成0。在任何时刻，<strong>二进制最小的行就是最久未使用的</strong>。</li>
</ol>
<p><strong>软件实现LRU</strong></p>
<p>虽然硬件的LRU算法可实现，但是只有非常少的计算机有这些硬件。因此，对于没有这些硬件的计算机开发者而言，基于硬件的算法是没有意义可言的。所以，需要一个能用软件实现的解决方案。</p>
<p>基于软件的LRU算法实现思想和硬件LRU算法的第一种算法很类似：每个页都和一个软件计数器相联系，计数器的初值为0。在每次时钟中断时由操作系统对内存中的页进行扫描，把每个页的R位加到它的计数器上。当页面发生页面陷入时，计数器值最小的页被选中并替换掉。</p>
<p>但是这样存在一个问题，比如前几次扫描经常使用的页，其计数值会很高。但是最近几次扫描时，之前经常使用的页的计数值都没有变化，说明没有被使用。如果要进行替换的话，结果是操作系统将删除最近使用的页（计数值低）而不是不再使用的页。</p>
<p>所以，需要进行改进，改进后的算法称为老化算法。修改两部分：1. 计数器在R位加进来之前无符号右移一位 2。 R位加到计数器最左端而不是最右端。下面给出几个示例，来验证这一思想：</p>
<p><img src="/images/%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E7%9A%84NRU%E7%AE%97%E6%B3%95.png"></p>
<p>在发生页面陷入时，计数器值最小的页将被淘汰掉。很明显，如果一个页最近被访问，那么它的高位要比不经常使用的页的高位大，这一方法也避免了上面产生的问题：之前的计数器值影响淘汰的页。</p>
<h2 id="分页系统中的设计问题"><a href="#分页系统中的设计问题" class="headerlink" title="分页系统中的设计问题"></a>分页系统中的设计问题</h2><h3 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h3><p>在单纯的分页系统中，当进程启动时它的页面设计没有一个在内存中，在CPU试图取第一条指令时就会引发一个页面故障，使操作系统撞日含有第一条指令的页，其他的由范围跟全局数据和堆栈引起的页面陷入会紧接着发生。一段时间后，进程所需的大部分页已在内存中，进程开始在页面陷入较少的情况下运行。这个策略称为**请调(demand paging)**，因为页是在需要的时候调入，而不是预先装入。</p>
<p>一个进程当前使用的页的集合称为它的**工作集(working set)**。如果整个工作集都在内存中，则进入下个运行阶段之前，进程不会陷入很多的页面陷入。如果内存太小，无法容纳整个工作集，进程运行将引起大量的页面陷入并且速度十分缓慢，因为执行一条指令通常需要几个纳秒，而从磁盘读取一个页面则要几十个毫秒。在几十毫秒内只能执行一到两个指令，这令人难以接受。</p>
<p>而且，在分时系统中，进程常会被换到磁盘上，从而让其他进程有机会占用CPU。如果当一个进程再次被调用进内存后该如何处理？什么都不做，重新开始页面陷入？还是将之前的工作集全部装入？</p>
<p>大部分系统采用第二种方式，即在进程运行前，其工作集就会装入内存中，这种方法称为<strong>工作集模型</strong>，目的就是大大减少页面陷入。而在进程运行前装入页面也叫做<strong>预调</strong>。</p>
<p>工作集模型的实现用到了之前讨论的老化算法：所有计数器的高n位含有1的页都被认为是工作集的成员；如果一个页连续n个时钟滴答都没有被访问到，那么它将从工作集中删除。对于不同系统，n值不同，因此n必须通过试验确定。</p>
<h3 id="局部与全局分配策略"><a href="#局部与全局分配策略" class="headerlink" title="局部与全局分配策略"></a>局部与全局分配策略</h3><p>如何为相互竞争的可运行进程分配内存？比如对于以下的3个进程A、B、C，如果进程A发生页面陷入，替换算法是应该只考虑分配给进程A的页？还是所有在内存中的页？</p>
<p>如果只考虑分配给进程A的页，则对应的算法称为<strong>局部页面替换算法</strong>。如果考虑所有在内存中的页，则对应的算法称为<strong>全局算法</strong>。很明显，局部算法对应于每个进程分配固定的内存片段；全局算法在可运行进程间动态地分配页框，因此分配给各个进程的页框数是随时间变化的。通常情况下，全局算法比局部算法好，尤其是当工作集的大小会在进程的运行期间发生变化时。</p>
<p>使用全局算法时，系统必须不断确定应该给各个进程分配多少页框。常用为进程分配页框的算法：1. 定期确定进程数目，并分配相等的份额，这种算法分配不合理 2. 根据进程大小的比例分配给进程相应数量的页面 3.  每个进程规定最小的页框数</p>
<h3 id="页面大小"><a href="#页面大小" class="headerlink" title="页面大小"></a>页面大小</h3><p>页面大小是一个操作系统可以选择的参数。通常情况下，页面的大小默认为512字节。</p>
<p>选择最优的页面大小需要在几个互相冲突的因素之间进行折中。1. 随便一个正文、数据或堆栈，它不会恰好装满整个页  2. 大的页面相比于小的页面，使更多没有用的程序保留在内存中 3. 小的页面意味着更大的页表，页表占用更多的空间 3. 由于内存与磁盘间的传输一般是一次一个页，所以页面越小，意味着传输时间更长</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/" rel="tag"># 存储器管理</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/11/08/Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E6%9E%90/" rel="next" title="Tomcat服务器简析">
                <i class="fa fa-chevron-left"></i> Tomcat服务器简析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/11/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" rel="prev" title="文件系统">
                文件系统 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">80</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2"><span class="nav-number">1.</span> <span class="nav-text">交换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">3.</span> <span class="nav-text">虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5"><span class="nav-number">3.1.</span> <span class="nav-text">分页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MMU%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.</span> <span class="nav-text">MMU内部结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8"><span class="nav-number">3.3.</span> <span class="nav-text">页表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">3.3.1.</span> <span class="nav-text">多级页表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TLB-Translation-Lookaside-Buffers"><span class="nav-number">3.3.2.</span> <span class="nav-text">TLB(Translation Lookaside Buffers)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">页面替换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">最优页面替换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%AA%E4%BD%BF%E7%94%A8%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">最近未使用页面替换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">先进先出页面替换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">4.4.</span> <span class="nav-text">第二次机会页面替换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">4.5.</span> <span class="nav-text">时钟页面替换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">4.6.</span> <span class="nav-text">最久未使用页面替换算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">分页系统中的设计问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.1.</span> <span class="nav-text">工作集模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E4%B8%8E%E5%85%A8%E5%B1%80%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-number">5.2.</span> <span class="nav-text">局部与全局分配策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F"><span class="nav-number">5.3.</span> <span class="nav-text">页面大小</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Doug-Wilson</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>





        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/Gantzert_Felixander.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
