<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,300italic,400,400italic,700,700italic|Ubuntu:300,300italic,400,400italic,700,700italic|Ubuntu:300,300italic,400,400italic,700,700italic|Ubuntu:300,300italic,400,400italic,700,700italic|Ubuntu:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="进程," />










<meta name="description" content="之前大致了解了进程的概念：进程实质上是一个正在执行的程序。而进程也是操作系统最核心的概念，因此这篇文章则是深入地研究进程的概念，希望学完后，自己能够掌握进程的知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="进程">
<meta property="og:url" content="http://example.com/2020/10/26/%E8%BF%9B%E7%A8%8B/index.html">
<meta property="og:site_name" content="Doug-Wilson&#39;s blogs">
<meta property="og:description" content="之前大致了解了进程的概念：进程实质上是一个正在执行的程序。而进程也是操作系统最核心的概念，因此这篇文章则是深入地研究进程的概念，希望学完后，自己能够掌握进程的知识。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png">
<meta property="og:image" content="http://example.com/images/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="http://example.com/images/%E4%BC%A0%E7%BB%9F%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="http://example.com/images/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6.png">
<meta property="og:image" content="http://example.com/images/%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="http://example.com/images/MINIX%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://example.com/images/%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png">
<meta property="article:published_time" content="2020-10-26T07:50:43.000Z">
<meta property="article:modified_time" content="2021-05-29T08:53:38.285Z">
<meta property="article:author" content="Doug-Wilson">
<meta property="article:tag" content="进程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2020/10/26/进程/"/>





  <title>进程 | Doug-Wilson's blogs</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband">
		<a target="_blank" rel="noopener" href="https://your-url" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
	</div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Doug-Wilson's blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学无止境，积累技术</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-主页">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            主页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/about/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-目录">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            目录
          </a>
        </li>
      
        
        <li class="menu-item menu-item-归类">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-时间表">
          <a href="/schedule/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            时间表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/26/%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Doug-Wilson's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">进程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-26T15:50:43+08:00">
                2020-10-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>之前大致了解了进程的概念：进程实质上是一个正在执行的程序。而进程也是操作系统最核心的概念，因此这篇文章则是深入地研究进程的概念，希望学完后，自己能够掌握进程的知识。</p>
<span id="more"></span>

<h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><p>在进程模型中，计算机上所以可运行的软件，包括操作系统，都被组织成若干进程。而一个进程就是一个正在执行的程序，包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程拥有它自己的虚拟CPU，而实际上是CPU在各进程间来回切换。这种快速的切换称作多道程序。</p>
<p>由于CPU在各进程间来回切换，每个进程执行运算的速度是不确定的，而且当同一进程再次运行，其运算速度也不可再现。所以，进程的编程不能对时序做任何固定的假设。比如，考虑一个I/O进程用流式磁带机恢复被备份的文件，它执行一个10000次的空循环以等待磁带机达到正常速度，然后发出命令读取第一个记录。如果CPU决定在空循环期间将处理机调度给其他进程，则磁带机进程可能在第一条记录通过磁头后还未被再次调度。当一个进程具有如此严格的实时要求时（某些特定实践要在指定的若干秒内发生），那么就必须采取特殊措施保证它们一定在这段时间中发生。</p>
<p>这里再区分一下进程和程序。进程和程序间的区别很微妙，但又十分重要。用一个类比来说明：想象有一位好厨艺的程序员正在为他的女儿烘培生日蛋糕。他有做生日蛋糕的食谱，厨房里有原料：鸡蛋、免费、糖等。在这个类比中，做蛋糕的食谱就是程序，程序员就是CPU，而做蛋糕的各种原料则是输入数据。<strong>进程就是厨师阅读食谱，取原料混合，以及烘焙蛋糕的一系列动作的综合</strong>。现在假设程序员的儿子哭着跑了进来，手被蜜蜂蛰了，程序员就会记下食谱完成到哪了（保存进程的当前状态），然后拿出医疗箱处理伤口。这里，就是CPU从一个进程切换到另一个进程，每个进程都有自己的程序（食谱和医疗箱）。当处理完伤口后，程序员又继续回去做蛋糕，从记录的食谱的下一步继续做下去。</p>
<h3 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h3><p>在MINIX系统中，进程通过fork系统调用来创建进程，它将创建一个与调用进程相同的进程拷贝。子进程也能进行fork调用，以此类推。因此，会形成一棵完整的进程树。注意，在这个概念中，每个进程只有一个父进程，但可以有若干个子进程（0个、1个等）。也就是说，在系统启动后，进程树必须得有个进程树的根，在MINIX系统中，进程树的根就是<strong>init进程</strong>。</p>
<p>在MINIX的引导映像中有一个称为init的特殊进程，当它开始运行时，会读取一个记录存在多少个终端文件，然后为每个终端创建一个新的进程，这些进程等待用户进行登录。如果登录成功，登录进程执行一个shell程序来接受命令，这些命令启动更多的进程，以此类推。这样，系统中的所有进程都属于一棵进程树，而init进程是进程树的根。</p>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>尽管每个进程是一个独立的实体，有自己的程序计数器和内部状态，但进程间常常需要进行通信，一个进程的输出结果可能会作为另外一个进程的输入。</p>
<p>当一个进程在逻辑上不能继续运行时，就会阻塞，比如等待用户输入的进程。还有一种可能就是进程能够运行，但被迫停止，原因就是操作系统调度另一个进程占用CPU。这两种条件是完全不同的，第一种情况，挂起的程序是程序自身所固有的；第二种情况是系统引起的。因此线程会产生3种状态：</p>
<ol>
<li>运行（Running）。CPU正在执行进程</li>
<li>就绪（Ready）。可运行，但是因为其他进程需要运行被暂时挂起</li>
<li>阻塞（Blocked）。除非某个事件发生，否则不能运行</li>
</ol>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png"></p>
<p>通过进程模型以及进程的状态，我们就可以简单地推断出系统内部的操作状况。</p>
<p>关于调度程序，它可以是如下的基本结构：</p>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B.png"></p>
<p>在调度程序上面有许多进程，所有关于中断处理、启动、中止进程的具体细节被隐藏在调度程序中。实际上它是一段非常短小的程序。操作系统的其他部分被简洁地组织成进程形式。上面的进程调度模型在MINIX中得到使用，但是对于其中的调度程序，不应该之理解为对进程的调度安排，它也包括了中断处理和所有进程间的通信。</p>
<h2 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h2><p>为了实现进程模型（进程树），操作系统维持着一张表格（一个结构数组），该表格称为**进程表(process table)**。每个进程占用一个进程表项。该表项包含了进程的状态、程序计数器、栈指针、内存分配状况、打开文件的状态、计费和调度信息，以及其他在进程由运行态转为就绪态所必须保存的信息，只有这样才能使进程随后被再次启动，就像从未被中断过一样。</p>
<table>
<thead>
<tr>
<th>进程管理</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
</tr>
<tr>
<td>程序计数器</td>
</tr>
<tr>
<td>程序状态字</td>
</tr>
<tr>
<td>栈指针</td>
</tr>
<tr>
<td>进程状态</td>
</tr>
<tr>
<td>进程开始时间</td>
</tr>
<tr>
<td>使用的CPU时间</td>
</tr>
<tr>
<td>子进程的CPU时间</td>
</tr>
<tr>
<td>下次报警时间</td>
</tr>
<tr>
<td>消息队列指针</td>
</tr>
<tr>
<td>挂起的信号位</td>
</tr>
<tr>
<td>进程标识号</td>
</tr>
<tr>
<td>各种标志位</td>
</tr>
</tbody></table>
<p><strong>调度程序工作过程：</strong></p>
<p>与每类I/O设备（硬盘、终端等）相关的都有一个靠近内存底部的位置，称为中断向量。中断向量包含了中断服务程序的入口地址。假设当一个磁盘发生中断时，用户进程3正在运行，则中断硬件会将程序计数器、程序状态字、多个寄存器压入当前堆栈，然后计算机随机跳转到磁盘中断向量所指的地址处。上面这些部分都是由硬件完成的操作，下面就开始由软件完成相关任务。</p>
<p>中断服务程序将当前进程全部寄存器的值存入进程表的表项。当前进程号以及一个指向其表项的指针被保存在全局变量中以便能够快速地找到进程表。随后将中断存入的那部分信息从堆栈中删除，并将栈指针执行一个被进程管理者所使用的临时堆栈。然后调用一个短小的汇编语言例程来保存寄存器值和设置栈指针等任务。当该例程结束后，调用一个C语言过程来完成剩下的工作。</p>
<p>在MINIX中，进程间通信通过消息完成，所以下一步是构造一条发送给磁盘进程的消息。这时，磁盘进程正在阻塞并等待该消息，这条消息通知说发生了一次中断，以此将它和那些由用户进程发送的消息加以区分。现在磁盘进程的状态由阻塞转换到就绪，然后，中断服务程序调用调度程序，如果当前磁盘进程是优先级最高的就绪进程，则它将被调度执行。如果中断进程具有与磁盘进程相等或更高的优先级，则中断进程将被再次调度运行，磁盘进程继续处于就绪状态。</p>
<p>无论磁盘进程是否得到执行，被汇编语言中断代码所调用的C过程现在返回，汇编语言代码为新的当前进程装入寄存器值和内存映像并启动它运行。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在传统进程中，每个进程只存在一条控制线程和一个程序计数器。但是在现代操作系统中，通常单个进程会有多条控制线程的支持。这些控制线索通常称为**线程(threads)<strong>，有时也称为</strong>轻量级进程(lightweight processes)**。</p>
<p><img src="/images/%E4%BC%A0%E7%BB%9F%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B.png"></p>
<p>第一个图中，我们看到三个传统的进程，每个进程有自己的地址空间和单一的控制线程。第二个图则看到一个进程有三条控制线程。尽管这两种情况都有3个线程，但是第一个图中各线程在不同的地址空间中操作，而第二个图中三个线程共享同一个地址空间。</p>
<p>使用多线程的例子：考虑一个文件服务器进程，它接收读写文件的请求并将请求的数据送回或者接受更新的数据。为了提高性能，服务器在内存中维护一个高速缓存，里面存放最近使用过的文件，需要时从缓存中读取数据或者写数据。</p>
<p>这时候就非常适合多线程模型。当一个请求到来时，将它递交给一个线程处理。如果这个线程因为等待磁盘传输而中途阻塞，其他线程仍然可以运行，这样服务器就可以在磁盘I/O的同时，继续处理新的请求。</p>
<p>需要注意的是，当一个进程的地址空间有多个线程时，就需要单独一张线程表，每个线程占用一项。针对每个线程的信息包括：程序计数器、寄存器值及状态。需要程序计数器是因为线程可以像进程一样被挂起和恢复执行。需要寄存器是因为当线程被挂起时，它的寄存器值必须被保存下来。最后，线程可以像进程一样，处于运行、就绪、阻塞状态。</p>
<p>线程的产生带来两个问题，线程是应该在用户空间进行管理还是应该在内核中进行管理。在用户空间进行管理的线程，其切换速度要比在核心调用的情况快得多。而若线程完全由用户空间管理，当一个线程阻塞时，核心会将整个进程阻塞，因为核心不知道有其他的现场存在。所以，最终的妥协结果为，两者情况的混合方案。</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程常常需要与其他进程通信。例如，在一个shell管道中，第一个进程的输出必须传送到第二个进程，这样沿着管道传递下去。因此在需要通信的进程间，最好使用一种结构较好的方式，不要使用中断。</p>
<p>进程间通信要解决3个问题：一个进程如何向另一个进程传送信息；如何保证两个或多个进程在涉及临界活动的时候不会彼此影响（设想两个进程都试图获取最后一部分内存的情况）；涉及依赖关系时进行适当的定序（进程A产生数据，进程B打印数据，那么B在打印前必须等到A产生一些数据为止）</p>
<h3 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h3><p>如果多个进程共享一些彼此都可以读写的公共存储区（内存或者磁盘），此时，一个进程修改一个文件的同时另一个进程同时也在读取该文件，那么进程得到的结果就会取决于进程运行时的时许，即不同时候得到的结果不同，这是件令人头疼的事情，这样的情况也称为**竞争条件(race conditions)**。</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>要避免竞争条件，关键就是在于找到某种手段，确保一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作。</p>
<p>对避免竞争的问题做一种抽象的方式描述：一个进程的一部分时间做内部计算和其他不会引发竞争条件的操作。在另外一些时候进程会访问共享内存或共享文件，执行一些会导致竞争的操作。我们将对共享内存进行访问的程序片段称为**临界区(critical region)或临界段(critical section)**。如果我们能够适当地安排两个进程不可能同时处于临界区，那么就能够避免竞争条件。这样的要求防止了竞争条件，但还不能保证使用期间共享数据的并发进程能够正确和高效地执行操作。我们还需要以下4个条件：</p>
<ol>
<li>任何两个进程不能同时处于临界区</li>
<li>不对CPU的数目和速度做任何目标假设</li>
<li>临界区外的进程不能阻塞其他进程</li>
<li>不得使进程在临界区外无休止地等待</li>
</ol>
<h3 id="忙等待的互斥"><a href="#忙等待的互斥" class="headerlink" title="忙等待的互斥"></a>忙等待的互斥</h3><h4 id="关中断"><a href="#关中断" class="headerlink" title="关中断"></a>关中断</h4><p>一个简单的方法是使每个进程在进入共享变量或文件的临界区后<strong>先关中断，离开前再开中断</strong>。中断被关掉后，时钟中断也会被屏蔽。而CPU只有在发生了时钟中断或者其他中断时才会切换进程，这样一来，关中断之后CPU就不会切换到其他进程执行，于是，执行关中断的进程就可以检查和修改共享内存而不必担心其他进程的介入。</p>
<p>但很明显，这种方法不行，将中断的权力交给用户是不明智的，危险的。假如一个进程关中断后并没有开中断，那么系统就会因此而终止。而且该方法对于多CPU的操作系统是不可行的，因为关中断只对执行指令的CPU有效，其他CPU仍将继续运行，并可以访问共享内存。</p>
<p>该方法违反条件1，不可行。</p>
<h4 id="锁变量"><a href="#锁变量" class="headerlink" title="锁变量"></a>锁变量</h4><p>第二种尝试是使用软件解决方案。假设有一个锁（共享变量），初始值为0。当一个进程想进入锁的临界区时，会首先尝试获取锁。如果锁的值为0，则进程将其设置为1并进入临界区。如果锁为1，则进程将等待，直到锁变成0。所以0表示临界区内没有进程，1表示有某个进程进入了临界区。</p>
<p>这种办法也有纰漏，比如当一个进程读取锁的值时发现它为0，而恰好在该进程要将锁的值置为1之前，另一个进程被调度执行，读取了锁的值并将锁的值置为1，当第一个进程再次运行时，它也将锁的值置为1，则此时会同时有两个进程处于临界区中。</p>
<p>该方法违反条件1，不可行。</p>
<h4 id="严格的轮换法"><a href="#严格的轮换法" class="headerlink" title="严格的轮换法"></a>严格的轮换法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">    <span class="keyword">while</span> (turn != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*等待*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    critical_region();  <span class="comment">//临界区</span></span><br><span class="line">    turn = <span class="number">1</span>;</span><br><span class="line">    noncritical_region();  <span class="comment">//非临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">    <span class="keyword">while</span> (turn != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/*等待*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    critical_region(); <span class="comment">//临界区</span></span><br><span class="line">    turn = <span class="number">0</span>;</span><br><span class="line">    noncritical_region();  <span class="comment">//非临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现假设有两个进程：进程0和进程1，以及一个整型变量turn。当turn=0时，进程0进入临界区，进程1如果要进入临界区，则要进行忙等待；当turn=1时，进程1进入临界区，进程0如果要进入临界区，则也要进行忙等待。</p>
<p>整型变量turn初始值为0，用于<strong>跟踪哪个进程进入临界区</strong>来检查或更新共享内存。一开始进程0检查turn，发现它是0，于是进程0进入临界区。进程1发现turn是0，于是执行一个等待循环不停检测它是否变成1。持续地检测一个变量直到它具有某一特定值就称作**忙等待(busy waiting)**。忙等待是应该避免的，因为它会浪费CPU的时间。</p>
<p>当进程0离开临界区时，它将turn置为1，以允许进程1进入临界区。当进程1离开临界区，turn值又会被置为0。此时两个进程都在临界区外。现在进程0更早地比进程1执行完了一次循环，并再次执行到非临界区部分，并将turn值置为1（看代码）。此时，进程0又结束了非临界区部分的操作并回到了循环的开始，需要执行临界区部分，但此时它并不能进入临界区，因为turn的值为1，而且进程1还在执行非临界区代码。</p>
<p>这种情况违反了条件3：临界区外的进程不能阻塞其他进程，进程1执行非临界区代码阻塞了进程0</p>
<h4 id="Peterson解决方案"><a href="#Peterson解决方案" class="headerlink" title="Peterson解决方案"></a>Peterson解决方案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLASE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N     2			<span class="comment">/*进程数量*/</span></span></span><br><span class="line"><span class="keyword">int</span> turn;				<span class="comment">/*轮到哪个进程？*/</span></span><br><span class="line"><span class="keyword">int</span> interested[N];		<span class="comment">/*初始值为FALSE*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enter_region</span><span class="params">(<span class="keyword">int</span> process)</span> </span>&#123;  <span class="comment">/*进程号为0或1*/</span></span><br><span class="line">    <span class="keyword">int</span> other;					<span class="comment">/*另一个进程的进程号*/</span></span><br><span class="line">    other = <span class="number">1</span> - process;	</span><br><span class="line">    interested[process] = TRUE;		<span class="comment">/*标识出进入临界区的进程*/</span></span><br><span class="line">    turn = process;					<span class="comment">/*设置标志位*/</span></span><br><span class="line">    <span class="keyword">while</span> (turn == process &amp;&amp; interested[other] == TRUE) &#123;&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leave_region</span><span class="params">(<span class="keyword">int</span> process)</span> </span>&#123;		<span class="comment">/*即将离开临界区的进程*/</span></span><br><span class="line">    interested[process] = FALSE;		<span class="comment">/*还原离开临界区的进程的标识*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方案工作过程：</p>
<p>起初没有任何进程处于临界区，现在进程0调用enter_region，通过将其数组元素置为TRUE和将turn置为0来标识它希望进入临界区。由于进程1并不想进入临界区，所以enter_region很快便返回。</p>
<p>现在考虑两个进程同时调用enter_region的情况。它们都将自己的进程号存入turn，但只有后一个被保存进去的进程号才会保存到turn，前一个是无效的。假设进程1后存，则turn=1。当两个进程都运行到while语句时，进程0的判断条件为 <code>1 == 0 &amp;&amp; interested[1] == TRUE</code> 进程1的判断条件为 <code>1 == 1 &amp;&amp; interested[0] == TRUE</code> 很明显进程1会执行循环，进程0不会执行循环并进入临界区。</p>
<p>该方案的神奇之处还在于是会按顺序执行的，这从上面的过程也可以看出。</p>
<h4 id="TSL指令"><a href="#TSL指令" class="headerlink" title="TSL指令"></a>TSL指令</h4><p>该方案需要硬件支持。TSL指令工作过程：该指令经一个存储器字读取到一个寄存器中，然后在该内存地址上存一个非零值。读数和写数操作保证是不可分割的——该指令结束之前，其他处理器均不允许访问该存储器字。执行TSL指令的CPU将锁住内存总线以禁止其他CPU在指令结束之前访问内存。</p>
<p>下面是使用过程：</p>
<p>为了使用TSL指令，需要使用一个共享变量lock来协调对内存的访问。当lock=0时，任何进程都可以访问，并使用TSL指令将其置为1并读写共享内存。当操作结束时，进程用一条MOVE指令将lock重新置为0.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enter_region:</span><br><span class="line">	tsl register, lock		|复制lock到寄存器，并将lock置为1</span><br><span class="line">	cmp register, #0		|lock=0 ?</span><br><span class="line">	jne enter_region		|如果不等于0，已上锁，再次循环</span><br><span class="line">	ret						|返回调用程序，进入临界区</span><br><span class="line">leave_region:</span><br><span class="line">	move lock, #0			|置lock=0</span><br><span class="line">	ret						|返回调用程序</span><br></pre></td></tr></table></figure>

<h3 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a>睡眠和唤醒</h3><p>虽然Peterson解法和TSL指令都是正确的，但它们都存在忙等待的缺点——一个进程想进入临界区，需要先检测是否允许进入，如果不允许，则进程将踏步等待，直到许可为止。这将会耗费CPU时间。</p>
<p>另外，忙等待也会导致一个问题——优先级翻转。比如有两个进程，H进程优先级高，L进程优先级低。调度规则规定只要H处于就绪态它就可以运行。而此时，如果L进程在临界区中，H进程切换到就绪态准备运行。那么H进程会开始忙等待。但由于H处于就绪状态时，L进程不会被调度，所以L进程无法离开临界区，H进程将一直忙等待下去。</p>
<p>因此，为了解决上述问题，就出现了以下进程间通信原语：**睡眠(sleep)和唤醒(wakeup)**。睡眠是指sleep系统调用将调用进程阻塞（挂起），直到另一进程将其唤醒。而唤醒则会执行wakeup系统调用，wakeup系统调用有一个参数，即要被唤醒的进程。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>使用一个整型变量来累计唤醒次数，该整型变量就称为**信号量(semaphore)**。一个信号量的值可以是0，表示没有积累下来的唤醒操作；或者是正值，表示有一个或多个被积累下来的唤醒操作。</p>
<p>对信号量有两者操作：down和up。对一信号量执行down操作是检查其值是否大于0。如果是则将其值减1并继续。如果值为0，则进程睡眠，此时down操作并未结束，而是等待信号量的值大于0。检查数值、改变数值，以及可能发生的睡眠操作均为一个单一的、不可分割的**原子操作(atomic action)**完成。即保证一但一个信号量操作开始，则在操作完成或阻塞之前，别的进程均不允许访问该信号量。</p>
<p>up操作递增信号量的值。如果一个或多个进程在该信号量上睡眠，无法完成先前的down操作，则由系统选择其中一个并允许该选择的进程完成它的down操作。因此，对一个有进程在其上睡眠的信号量执行一次up操作之后，该信号量的值仍旧是0，但睡眠进程却少了一个。递增信号量的值和唤醒一个进程同样也是不可分割的，不会有进程因为执行up操作而阻塞。</p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>使用信号量需要非常小心，一处很小的错误会导致很大的麻烦，比如死锁，竞争条件，以及其他不可预测的行为。</p>
<p>为了编写正确的程序，提出了一种高级的同步原语，称为**管程(monitor 监视器)**。一个管程是由过程、变量以及数据结构等组成的一个集合，组成一个特殊的模块或软件包。进程在任何需要的时候调用管程中的过程，但不能在管程外的过程中直接访问管程内的数据结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">monitor example</span><br><span class="line">		integer i;</span><br><span class="line">		condition c;</span><br><span class="line">		procedure producer(x);</span><br><span class="line">		......</span><br><span class="line">		end;</span><br><span class="line">		procedure consumer(x);</span><br><span class="line">		......</span><br><span class="line">		end;</span><br><span class="line">end monitor;</span><br></pre></td></tr></table></figure>

<p>管程有一个很重要的特性（这也是它取名字的原因）：任意时刻管程中只能有一个活跃进程。当一个进程调用管程中的过程时，前几条指令会检查管程中是否有其他的活跃进程，如果有，则将进程挂起，直到另一个进程离开管程。如果没有，则调用进程便进入管程。</p>
<p>对管程实现互斥由编译器负责。开发人员无需关心编译器如何实现代码互斥，他只需要知道将所有的临界区转换成管程中的过程即可，绝不会有两个进程同时执行临界区中的代码。</p>
<p>有了管程之后，还需要一种办法使得进程在无法继续运行时被阻塞，当满足条件时被唤醒.解决办法就是引入<strong>条件变量(condition variables)<strong>，以及相关的两个操作：</strong>wait和signal</strong>。当一个管程的过程发现进程无法继续时，就会在某些条件变量下执行wait操作，该动作引起调用进程阻塞，允许另一个之前被挡在管程外的进程进入管程。</p>
<p>当某些条件变量满足唤醒条件时，就会执行signal操作来唤醒正在睡眠的进程，让被唤醒的进程执行，让执行唤醒操作的进程立即退出管程。</p>
<p>下面是使用管程来解决生产者—消费者问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">	condition full, empty;</span><br><span class="line">	integer count;</span><br><span class="line">	procedure enter;</span><br><span class="line">	begin</span><br><span class="line">		if count=N then wait(full);</span><br><span class="line">		enter_item;</span><br><span class="line">		count=count+1;</span><br><span class="line">		if count=1 then signam(empty)</span><br><span class="line">	end;</span><br><span class="line">	procedure remove;</span><br><span class="line">	begin</span><br><span class="line">		if count=0 then wait(empty);</span><br><span class="line">		remove_item;</span><br><span class="line">		count=count-1;</span><br><span class="line">		if count=N-1 then signal(full);</span><br><span class="line">	end;</span><br><span class="line">	count=0;</span><br><span class="line">	end monitor;</span><br><span class="line">	</span><br><span class="line">	procedure producer;</span><br><span class="line">	begin</span><br><span class="line">		while true do</span><br><span class="line">		begin</span><br><span class="line">			produce_item;</span><br><span class="line">			ProducerConsumer.enter</span><br><span class="line">		end</span><br><span class="line">	end;</span><br><span class="line">	procedure consumer;</span><br><span class="line">	begin</span><br><span class="line">		while true do</span><br><span class="line">		begin</span><br><span class="line">			ProducerConsumer.remove;</span><br><span class="line">			consume_item</span><br><span class="line">		end</span><br><span class="line">	end;</span><br></pre></td></tr></table></figure>

<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>**消息传递(message passing)**，该进程间通信方法使用两个系统调用send和receive：</p>
<ul>
<li>send(destination, &amp;message)</li>
<li>receive(source, &amp;message)</li>
</ul>
<p>send系统调用像一个给定的目标发生一条消息，receive调用从一个给定的源接收一条消息。如果没有消息可用，则接收者可能阻塞，直到一条消息可达，或者它也可以立即返回，并带回一个错误码。</p>
<p>消息传递可以有许多变体。一种方法是为每个进程分配一个唯一的地址，按进程为消息指定地址。另一种方法则是引入一种新的数据结果，称为**信箱(mailbox)**。一个信箱就是一个用来对一定数量的消息进行缓冲的地方。当使用信箱时，send和receive系统调用中的地址参数使用信箱，而不是进程。当一个进程试图像一个满的信箱发消息时，它将被挂起，直到信箱内有消息被取走而为新消息腾出空间。</p>
<p>在MINIX中用户进程间的通信采用管道，它和信箱在效果上等价。采用信箱的消息系统和管道机制的区别在于管道没有预先设定消息的边界。换言之，如果一个进程想管道写入10条100字节的消息，而另一个进程从管道中读取1000个字节，则读进程将一次性获得这所有10条消息。此外，进程还需要达成一致：总是从管道中读写固定大小的消息还是每个消息以一个特殊的字符结束。在MINIX消息系统中，MINIX进程间使用消息大小固定的消息机制进行通信。</p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>当有多个进程就绪时，操作系统必须决定先运行哪一个。操作系统中做出这种决定的部分称为**调度程序(scheduler)<strong>，使用的算法称作</strong>调度算法(scheduling algorithm)**。</p>
<p>在讨论具体的调度算法之前，需要考虑调度程序要达到的目标：</p>
<ol>
<li>公平。确保每个进程获得合理的CPU份额</li>
<li>有效。使CPU百分百忙碌</li>
<li>响应时间。使交互用户的响应时间尽可能短</li>
<li>周转时间。使批处理用户等待输出的时间尽可能短</li>
<li>吞吐量。每小时处理的作业数最多</li>
</ol>
<p>上述条件间是存在矛盾的，比如条件3和条件4，要使响应时间短，那么对于批处理作业应该不予调度，然而这又会使得条件1无法得到保证。所以，调度算法应该尽可能在多个条件间平衡。</p>
<p>此外，为了保证不让进程运行太久，所有计算机都会内置一个时钟，它将定期发出中断，通常为每秒钟50次到60次（赫兹，Hz），操作系统也能根据需要将时钟频率设置成任意值。每发生一次时钟中断，操作系统都将运行，并决定当前进程是否应该继续运行，还是它已经占用了足够长的CPU时间，应该暂停让其他进程运行。</p>
<p>术语：允许将逻辑上可运行的进程暂时挂起的策略称为**可剥夺调度(preemptive scheduling)<strong>；运行直到结束的调度方式称为</strong>非剥夺调度(nonpreemptive scheduling)**。</p>
<h3 id="时间片轮转调度"><a href="#时间片轮转调度" class="headerlink" title="时间片轮转调度"></a>时间片轮转调度</h3><p>时间片轮转调度是最古老、最简单、最公平且使用最广泛的算法。<strong>每个进程被分配一个时间片，在时间片内进程才能够运行</strong>。如果时间片结束进程还在运行，那么执行进程的CPU将会被剥夺并分配给另外一个进程；如果进程在时间片结束前阻塞或者结束，则CPU会立即进行切换到另一个进程执行。</p>
<p>时间片轮转调度依靠调度程序维护一张就绪进程表，当进程使用完它的时间片后，就被移到队列的末尾。</p>
<p><img src="/images/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6.png"></p>
<p>时间片轮转调度需要注意的一点就是时间片的长度。从一个进程切换到另一个进程是需要一定时间的：保存和装入寄存器值和内存映像，更新各种表格和队列。假如**进程切换(process switch)，也称为上下文切换(context switch)**，需要5毫秒。再假设时间片设为20毫秒。则在做完20毫秒的有用工作之后，CPU将花费5毫秒来进行进程切换，CPU有20%的时间被浪费在管理开销上。</p>
<p>虽然为了提高CPU效率，可以将时间片的长度设置的更长，从而使得浪费的管理开销时间占比下降。但是，系统的实时性却并不出色：假如时间片长度设为500毫秒，此时，10个用户同时按下回车键，那么就会有10个进程挂在就绪队列中，而最后一个用户的进程需要等待5秒后才得到执行，这显然会使得用户无法忍受。</p>
<p>所以，可以总结如下：时间片设定的过短会导致过多的进程切换，降低了CPU效率；而设的太长，又可能会引起对短交互请求的响应变差。<strong>将时间片长度设为100毫秒，是一个比较合理的折中</strong></p>
<h3 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h3><p>基本思想：每个进程被赋予一个优先级，优先级高的就绪进程优先执行。</p>
<p>为了防止高优先级的进程无休止地运行下去，调度程序可能在每个时钟中断后降低当前进程的优先级，如果该次动作使得当前进程的优先级低于次优先级进程，则将进行进程切换。另一种做法是给每个进程设定一段它能够连续使用CPU的时间片，一旦这段时间使用完，则运行次高优先级的进程。</p>
<p>一般来说，会将一组进程按优先级分成若干类，各类之间采用优先级调度，而各类进程内部采用时间片轮转调度。如图所示：</p>
<p><img src="/images/%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png"></p>
<h3 id="多重队列"><a href="#多重队列" class="headerlink" title="多重队列"></a>多重队列</h3><p>通过设立优先级，属于最高级的进程运行1个时间片，次高优先级的进程运行2个时间片，再次一级的进程运行4个时间片，以此类推。当一个进程用完分配的时间片后，移到下一类级别。比如，一个进程需要100个时间片才能完成任务。最初被分配1个时间片，然后被换出。下次它将获得2个时间片，接下来是4、8、16、32、64。最后一次只使用了64个时间片的37个便可以结束工作。整个过程需要7次交换（包括最初的装入）。而如果纯粹是时间片轮转调度，则需要100次交换。而且，随着进程优先级的不断降低，它的运行频率开始逐渐放慢，从而为短的交互进程让出CPU。</p>
<h3 id="最短作业优先"><a href="#最短作业优先" class="headerlink" title="最短作业优先"></a>最短作业优先</h3><p>前3个算法都是为了交互系统设计的，而最短作业优先适用于运行时间可以预知的批作业的调度算法。</p>
<p>考虑4个作业：A、B、C、D，运行时间分别为8、4、4、4分钟。如果按次序执行，则A的周转时间为8分钟，B的周转时间为12分钟，C的周转时间为16分钟，D的周转时间为20分钟，平均为14分钟。</p>
<p>现考虑用最短作业优先算法，则4个作业执行次序为：B、C、D、A。则现在的周转时间分别为4、8、12、20，平均为11分钟。</p>
<p>证明最短作业优先是最优的：</p>
<p>考虑有n个作业的情况，其运行时间分别为a1、a2、… 、an</p>
<p>则第一个作业在时间a1结束</p>
<p>第二个作业在a1+a2结束</p>
<p>…… 第n个作业在a1+a2+……+an结束</p>
<p>平均周转时间为 (a1*n+a2*(n-1)+……+an) / n</p>
<p>显然，a1对平均值的影响最大，它应该是作业时间最短的那个，a2次之，以此类推。</p>
<p>现在的问题就是如何在就绪进程中找到最短的那个进程：</p>
<p>一种办法是根据进程过去的行为进行推测，并执行估计运行时间最短的那个。比如某个进程的估计运行时间为T0，现假设测量到的下一次运行时间为T1。则可以通过两个值的加权和来改进估计时间，即 a*T0+(1-a)*T1</p>
<p>当a取1/2时，可以得到如下序列：<br>$$<br>T_{0}、(T_{0}/2+T_{1}/2)、(T_{0}/4+T_{1}/4+T_{2}/2)、(T_{0}/8+T_{1}/8+T_{2}/4+T_{3}/2)<br>$$<br>可以看到，3轮过后，T0在新的估计值中占到的比重下降到1/8。这种通过将当前测量值和先前估计值进行加权平均而得到下个估计值的技术称为老化算法，适用于许多预测值必须基于先前值的情况。</p>
<h3 id="保证调度算法"><a href="#保证调度算法" class="headerlink" title="保证调度算法"></a>保证调度算法</h3><p>通过跟踪进程自创建以来已使用了多少CPU时间，然后计算各进程应该获得的CPU时间，并计算已用CPU时间的百分比。比如0.5说明一个进程只获得了应得时间的一半，2.0则说明获得了应得时间的2倍。于是，算法随后转向比率最低的进程，直到该进程的比率超过次低进程为止。</p>
<h3 id="彩票调度算法"><a href="#彩票调度算法" class="headerlink" title="彩票调度算法"></a>彩票调度算法</h3><p>该算法基本思想为：违禁词发放对系统各种资源（如CPU时间）的彩票。当调度程序需要做出决策时，随机选一张彩票，而持有该彩票的进程将获得系统资源。比如对于CPU调度，系统可能每秒钟抽50次彩票，每次的中奖者获得20毫秒的运行时间。</p>
<p>如果一些进程需要更多的机会，则给它更多的额外彩票，增加其中奖的机会。</p>
<h3 id="两级调度算法"><a href="#两级调度算法" class="headerlink" title="两级调度算法"></a>两级调度算法</h3><p>如果没有足够的内存，某些就绪的进程就会部分或全部地被放在磁盘上，这种情况对调度有很大影响，因为从磁盘上读入一个进程运行比单纯在内存中进行进程切换要慢几个数量级。</p>
<p>两级调度算法就是处理内存之外的进程。调度程序会分为低级调度程序和高级调度程序。低级调度程序对那些驻留在内存中的进程进行调度，高级调度程序周期性地将那些在内存中驻留时间足够长的进程换出，而将那些在磁盘上等候时间过长的进程换入。这样，低级调度程序只需要关心在内存中的就绪进程，而高级调度程序则关心将进程在内存和磁盘间来回交换。</p>
<h3 id="调度策略与机制"><a href="#调度策略与机制" class="headerlink" title="调度策略与机制"></a>调度策略与机制</h3><p>考虑这样的情况：一个进程有许多子进程在其控制下运行。例如，一个数据库管理系统可能会有许多子进程，每个子进程可能处理不同的请求，或者每个子进程实现不同的功能。主进程需要掌握哪个子进程最重要，哪个最不重要，这需要从用户进程中接受有关的调度决策信息，而不是从系统中得出。</p>
<p>解决该问题的方法就是将**调度机制(scheduling mechanism)和调度策略(scheduling policy)**分开。将调度算法以某种方式参数化，参数由用户进程选择。</p>
<h2 id="MINIX进程概述"><a href="#MINIX进程概述" class="headerlink" title="MINIX进程概述"></a>MINIX进程概述</h2><h3 id="MINIX系统的内部结构"><a href="#MINIX系统的内部结构" class="headerlink" title="MINIX系统的内部结构"></a>MINIX系统的内部结构</h3><p>MINIX系统被分成4层，每一层执行一套定义完好的功能。</p>
<p><img src="/images/MINIX%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84.png"></p>
<p><strong>底层</strong></p>
<p>底层捕获所有的中断和陷入，完成进程调度，并向高层提供一个采用消息进行通信的独立顺序进程模型。该层代码有两大主要功能。第一是捕获陷入和中断、保存和恢复寄存器、调度以及向高层提供一个独立顺序进程模型。第二是处理消息机制：检查目标进程的合法性、定位物理内存中发生和接收缓冲区、以及从发送方 向 接收方拷贝数据。其中中断处理的最底层部分用汇编语言编写，其余部分和其他层次用C语言编写。</p>
<p><strong>第二层</strong></p>
<p>第二层包括I/O进程，每类设备都有一个I/O进程。为了将其与普通用户进程相区别，称之为**任务(tasks)<strong>。任务与进程间的区别几乎没有，在许多系统中I/O任务也被称为</strong>设备驱动程序(device driver)**。这里的三个概念：任务、进程、设备驱动程序可以换用。</p>
<p>第二层所有任务和底层代码链接成一个单一的二进制程序，称作**核心(kernel)**。某些任务共享公共的子例程，但它们相互之间完全独立，分别进行调度，并采用消息进行通信。尽管任务和核心被编译在一起，但当核心和中断处理程序被执行时，它们被赋予比任务更改的优先级。所以，真正的核心代码可以访问任一一部分内存，以及任一处理器寄存器，这意味着和欣客运使用系统中任何地方的数据，执行任何指令。而任务则不能执行全部的机器指令，也不能访问所有CPU寄存器或者所有内存。</p>
<p><strong>第三层</strong></p>
<p>第三层包含向用户进程提供有用服务的进程。这些服务器进程在低于核心和任务优先级上运行，不能直接访问I/O端口，也不能访问属于自己的内存段以外的内存。内存管理器（Memory Manager，简称MM）负责执行所有牵涉到内存管理的系统调用，比如fork、exec、brk。文件系统（File System，简称FS）负责执行文件系统的调用，read、mount、chdir。</p>
<p>通过三层结构可以看出，在MINIX系统中，资源管理主要在核心（1，2层），系统调用的解释在第3层.</p>
<p><strong>第四层</strong></p>
<p>第四层包含所有的用户进程：shell、编译器、编辑器、用户的程序。</p>
<h2 id="MINIX进程管理概述"><a href="#MINIX进程管理概述" class="headerlink" title="MINIX进程管理概述"></a>MINIX进程管理概述</h2><p>计算机开机时，硬件从引导盘上将第一道第一扇区读入内存并从那里开始执行。具体细节根据引导盘是软盘还是硬盘而不同，这里只讨论硬盘。硬盘被分为若干分区(partition)，整个硬盘的第一个扇区包括一段小程序和磁盘分区表，通常称为<strong>主引导记录</strong>。程序部分被执行以读入分区表并选择活跃分区。活跃分区的第一个扇区有一个引导程序，它随后被装入并执行以查找启动程序boot。</p>
<p>启动程序boot会在硬盘分区上找一个包含多个部分的文件，并将各部分装到内存的适当位置。这些部分包括：核心、内存管理器、文件系统、init进程。这个部分比较复杂，这里只需要先知道一旦装入操作完成，核心便开始运行。</p>
<p>在初始化阶段，核心先启动各任务（第二层），然后是内存管理器、文件系统以及所有在第三层运行的服务器。当所有这些都开始运行并初始化完成之后，它们将阻塞，等待执行某种操作。当所有任务和服务器被阻塞后，将执行一个用户进程——init进程。init进程已位于内存中，只不过在它启动时其他部分均已就位，所有它可以作为一个独立的程序从磁盘上装入。但是，由于init进程只启动一次，而且不会再从硬盘上装入，所以最简便的方法就是把它和核心、任务、服务器一起包括在系统的核心映像文件中(iso)。</p>
<p><strong>init启动后先读/etc/ttytab文件</strong>，该文件列出了所有可能的终端设备。而终端设备都在/etc/ttytab的getty域有一项。而init进程为每个终端创建一个子进程。通常，每个子进程都执行文件/usr/bin/getty，打印出一条信心，然后等待输入一个用户名。随后将该用户名作为参数来调用/usr/bin/login。如果某个终端需要特殊的处理，则/etc/ttytab可以指定一条命令（如/usr/bin/stty），在执行getty之前执行该命令并对线路进行初始化。</p>
<p>在成功登录之后，/bin/login执行用户的shell（在/etc/passwd文件中指定，通常是/bin/sh或/usr/bin/ash）。</p>
<p>shell等待用户键入命令，并为每条命令创建一个新进程。采用这种方式时，每个shell都是init的子进程，而用户进程则是init的孙子进程，并且所有的用户进程都是一棵进程树的组成部分。</p>
<p>在MINIX进程管理中，最重要的系统调用是fork和exec系统调用。fork是创建一个新进程的唯一途径。exec允许一个进程执行一个指定的程序，当一个程序被执行时，按照文件头中指定的大小为其分配一部分内存。尽管在进程运行期间，数据段、栈段和空闲未使用部分的大小可以不时地改变，但进程分配到的内存总量将保持不变。</p>
<p>一个进程的所有信息被保存在进程表中，进程表划分成核心、内存管理和文件系统三部分，分别拥有它们各自所需要的域。当一个新进程出现，或者一个老进程结束时，内存管理器首先更新对应部分的进程表，然后向文件系统和核心发送消息，以通知它们进行相应的操作。</p>
<h2 id="MINIX进程间通信概述"><a href="#MINIX进程间通信概述" class="headerlink" title="MINIX进程间通信概述"></a>MINIX进程间通信概述</h2><p>MINIX提供三条原语来发送和接收消息，它们均通过C语言例程库例程调用：</p>
<ol>
<li>send(dest, &amp;message) 向进程dest发送一条消息</li>
<li>receive(source, &amp;message)  进程source接收一条消息</li>
<li>send_rec(src_dst, &amp;message)  发送一条消息并等待同一个进程的应答</li>
</ol>
<p>以上三条原语的第二个参数是消息数据的本地地址。核心中的消息传递机制将消息从发送者拷贝到接收者。应答消息（对于send_rec而言）则覆盖原先的消息。</p>
<p>每个进程或任务都可以从或者向同层或下一层的进程或任务发送或接收消息，用户进程不能直接与I/O任务通信，这一限制是强制的。而当一个进程或任务像一个当前没有在等待消息的进程发送一条消息时，发送者将阻塞，直到目标进程执行receive。</p>
<h2 id="MINIX进程调度概述"><a href="#MINIX进程调度概述" class="headerlink" title="MINIX进程调度概述"></a>MINIX进程调度概述</h2><p><img src="/images/%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png"></p>
<p>MINIX调度层出使用一个三级排队系统分别对应图中的第2、3、4层。任务和服务器级别的进程一直运行到阻塞，而用户进程则采用时间片轮转调度。</p>
<p>任务具有最高优先级、内存管理器和文件管理器次之，用户进程最低。</p>
<p>当调度程序选择一个进程来运行时，它首先会检查是否有就绪的任务，如果有一个或多个，则队首的任务先运行，如果没有任务就绪，则检查并运行服务器进程（MM或FS）。若没有合适的服务器进程，则运行一个用户进程。如果没有进程就绪，则选择IDLE进程，这个循环一直执行到下一个中断到来。</p>
<p>在每个时钟中断，都会检查当前进程是否是一个运行超过100毫秒的用户进程。如果是，则调用调度程序来查看是否有另一个用户进程在等待CPU，如果发现一个这样的进程，则当前进程别移到队列的末尾，而运行当前的队首进程。<strong>特别注意：任务、内存管理器、文件系统不会被时钟中断剥夺，无论它们运行了多久</strong>。</p>
<h2 id="MINIX进程的实现-源码"><a href="#MINIX进程的实现-源码" class="headerlink" title="MINIX进程的实现(源码)"></a>MINIX进程的实现(源码)</h2><p>术语：“过程”、“函数”、“例程”几个词可以混用</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E8%BF%9B%E7%A8%8B/" rel="tag"># 进程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/10/23/%E3%80%8AMinix%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="next" title="《Minix操作系统设计与实现》读书笔记">
                <i class="fa fa-chevron-left"></i> 《Minix操作系统设计与实现》读书笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/10/31/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/" rel="prev" title="输入输出系统">
                输入输出系统 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">80</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">进程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">进程的层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.2.</span> <span class="nav-text">进程的状态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.</span> <span class="nav-text">进程的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">4.</span> <span class="nav-text">进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6"><span class="nav-number">4.1.</span> <span class="nav-text">竞争条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="nav-number">4.2.</span> <span class="nav-text">临界区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%99%E7%AD%89%E5%BE%85%E7%9A%84%E4%BA%92%E6%96%A5"><span class="nav-number">4.3.</span> <span class="nav-text">忙等待的互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%B8%AD%E6%96%AD"><span class="nav-number">4.3.1.</span> <span class="nav-text">关中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E5%8F%98%E9%87%8F"><span class="nav-number">4.3.2.</span> <span class="nav-text">锁变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A5%E6%A0%BC%E7%9A%84%E8%BD%AE%E6%8D%A2%E6%B3%95"><span class="nav-number">4.3.3.</span> <span class="nav-text">严格的轮换法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Peterson%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">4.3.4.</span> <span class="nav-text">Peterson解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TSL%E6%8C%87%E4%BB%A4"><span class="nav-number">4.3.5.</span> <span class="nav-text">TSL指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9D%A1%E7%9C%A0%E5%92%8C%E5%94%A4%E9%86%92"><span class="nav-number">4.4.</span> <span class="nav-text">睡眠和唤醒</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">4.5.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B"><span class="nav-number">4.6.</span> <span class="nav-text">管程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="nav-number">4.7.</span> <span class="nav-text">消息传递</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">5.</span> <span class="nav-text">进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6"><span class="nav-number">5.1.</span> <span class="nav-text">时间片轮转调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="nav-number">5.2.</span> <span class="nav-text">优先级调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E9%98%9F%E5%88%97"><span class="nav-number">5.3.</span> <span class="nav-text">多重队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88"><span class="nav-number">5.4.</span> <span class="nav-text">最短作业优先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">5.5.</span> <span class="nav-text">保证调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%A9%E7%A5%A8%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">5.6.</span> <span class="nav-text">彩票调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">5.7.</span> <span class="nav-text">两级调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E4%B8%8E%E6%9C%BA%E5%88%B6"><span class="nav-number">5.8.</span> <span class="nav-text">调度策略与机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MINIX%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">6.</span> <span class="nav-text">MINIX进程概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MINIX%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">6.1.</span> <span class="nav-text">MINIX系统的内部结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MINIX%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="nav-number">7.</span> <span class="nav-text">MINIX进程管理概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MINIX%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0"><span class="nav-number">8.</span> <span class="nav-text">MINIX进程间通信概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MINIX%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A6%82%E8%BF%B0"><span class="nav-number">9.</span> <span class="nav-text">MINIX进程调度概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MINIX%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0-%E6%BA%90%E7%A0%81"><span class="nav-number">10.</span> <span class="nav-text">MINIX进程的实现(源码)</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Doug-Wilson</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>





        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/Gantzert_Felixander.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
