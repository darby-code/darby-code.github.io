<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,300italic,400,400italic,700,700italic|Ubuntu:300,300italic,400,400italic,700,700italic|Ubuntu:300,300italic,400,400italic,700,700italic|Ubuntu:300,300italic,400,400italic,700,700italic|Ubuntu:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="读书笔记," />










<meta name="description" content="进程 进程不等同于程序。一个进程本质上为一个程序的执行。每个进程有自己的地址空间，从0到一个最大值，进程可以读写该空间中的内容。地址空间包括可执行程序、程序的数据及堆栈。与每个进程相关的还包括一组寄存器、程序计数器、指针和其他硬件存储器，以及所有其他所需要的信息">
<meta property="og:type" content="article">
<meta property="og:title" content="《Minix操作系统设计与实现》读书笔记">
<meta property="og:url" content="http://example.com/2020/10/23/%E3%80%8AMinix%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Doug-Wilson&#39;s blogs">
<meta property="og:description" content="进程 进程不等同于程序。一个进程本质上为一个程序的执行。每个进程有自己的地址空间，从0到一个最大值，进程可以读写该空间中的内容。地址空间包括可执行程序、程序的数据及堆栈。与每个进程相关的还包括一组寄存器、程序计数器、指针和其他硬件存储器，以及所有其他所需要的信息">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/%E8%BF%9B%E7%A8%8B%E5%AD%98%E5%82%A8.png">
<meta property="og:image" content="http://example.com/images/link%E6%96%87%E4%BB%B6.png">
<meta property="og:image" content="http://example.com/images/mount%E6%96%87%E4%BB%B6%E6%A0%91.png">
<meta property="og:image" content="http://example.com/images/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81.png">
<meta property="og:image" content="http://example.com/images/%E6%95%B4%E4%BD%93%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E5%8D%95%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://example.com/images/%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="http://example.com/images/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%A2%E6%88%B7%E6%A8%A1%E5%9E%8B.png">
<meta property="article:published_time" content="2020-10-23T01:51:31.000Z">
<meta property="article:modified_time" content="2021-05-28T08:41:14.210Z">
<meta property="article:author" content="Doug-Wilson">
<meta property="article:tag" content="读书笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/%E8%BF%9B%E7%A8%8B%E5%AD%98%E5%82%A8.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2020/10/23/《Minix操作系统设计与实现》读书笔记/"/>





  <title>《Minix操作系统设计与实现》读书笔记 | Doug-Wilson's blogs</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband">
		<a target="_blank" rel="noopener" href="https://your-url" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
	</div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Doug-Wilson's blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学无止境，积累技术</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-主页">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            主页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/about/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-目录">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            目录
          </a>
        </li>
      
        
        <li class="menu-item menu-item-归类">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-时间表">
          <a href="/schedule/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            时间表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/23/%E3%80%8AMinix%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Doug-Wilson's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《Minix操作系统设计与实现》读书笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-23T09:51:31+08:00">
                2020-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><blockquote>
<p>进程不等同于程序。一个进程本质上为一个程序的执行。每个进程有自己的地址空间，从0到一个最大值，进程可以读写该空间中的内容。地址空间包括可执行程序、程序的数据及堆栈。与每个进程相关的还包括一组寄存器、程序计数器、指针和其他硬件存储器，以及所有其他所需要的信息</p>
</blockquote>
<span id="more"></span>

<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用为操作系统与程序间的接口。由于系统调用的实现往往与机器有关，并且用汇编语言描述，所以为了C语言程序能够使用系统调用，必须额外提供接口进行访问。</p>
<p>虽然不同机器的系统调用不同，但往往是细节上的不相同，多数操作系统都具有相同功能的系统调用。以MINIX系统为例，MINIX的全部系统调用可以分成53条，6大类：</p>
<ol>
<li><p>进程管理</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>pid = fork()</td>
<td>创建一个与父进程相似的进程</td>
</tr>
<tr>
<td>pid = waitpid(pid, &amp;statloc, opts)</td>
<td>等待一个子进程结束</td>
</tr>
<tr>
<td>s = wait(&amp;status)</td>
<td>waitpid的老版本</td>
</tr>
<tr>
<td>s = execve(name, argv, envp)</td>
<td>替换一个进程的核心映像</td>
</tr>
<tr>
<td>exit(status)</td>
<td>终止进程的执行并返回状态</td>
</tr>
<tr>
<td>size = brk(addr)</td>
<td>设置数据段大小</td>
</tr>
<tr>
<td>pid = getpid()</td>
<td>返回调用进程的标识号</td>
</tr>
<tr>
<td>pid = getpgrp()</td>
<td>返回调用进程的组号</td>
</tr>
<tr>
<td>pid = setsid()</td>
<td>创建一个新的会话并返回其组标识</td>
</tr>
<tr>
<td>I(大写i) = ptrace(req, pid, addr, data)</td>
<td>用于调试</td>
</tr>
</tbody></table>
<p>fork系统调用是创建进程的唯一途径。从方法描述来看，它实际上是做一个调用它的进程的精确拷贝，拷贝内容包括文件描述符，寄存器值等所有内容。fork调用完成后，原进程和拷贝进程（父进程和子进程）二者对应的变量都有相同的值，但因为各自执行，互不相关，所以任一进程变量值的改变都不会对另一个进程产生影响。</p>
<p>执行完fork后，对原进程和拷贝进程各自返回一个数值，对拷贝进程（子进程）返回0，对原进程（父进程）返回一个正整数，值为子进程的pid</p>
<p>当一个进程存在子进程时，不可直接结束，需要执行waitpid系统调用等待子进程结束。waitpid系统调用会使得调用进程阻塞，直到子进程中任意一个结束（将第一个参数pid置为-1）或者指定的子进程结束。waitpid系统调用结束时，子进程的终止状态值（正常结束或异常结束的返回值）将放在第二个参数&amp;statloc指向的地址中。waitpid系统调用方法的第三个参数opts为若干选择项，需要具体查询每个选择项功能。此外，waitpid取代了之前的wait系统调用，但依旧提供wait系统调用，这是为了保持兼容性。</p>
<p>execve的执行过程。当键入一条命令时，Shell首先创建一个新进程，该子进程执行用户命令，然后调用execve系统调用，execve用第一个参数指定的可执行文件替换其核心映像，简化过程如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">	read_command(command, parameters);  /*从终端读取输入*/</span><br><span class="line">	if (fork() != 0) &#123; /*创建子进程执行命令*/</span><br><span class="line">		/*等待子进程退出*/</span><br><span class="line">		waitpid(-1, &amp;status, 0);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		execve(command, parameters, 0); /*执行命令*/</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>execve有三个参数：待执行的文件名，指向参数数组的指针，指向环境变量数组的指针。除了execve外，系统还提供了其他接口方来简化这些参数的使用，如execl，execle，execv 。之后可以用exec来泛指所有这些系统调用。</p>
<p>举个示例来说明execve的执行过程。比如，对于命令 <code>cp file1 file2</code></p>
<p>功能是对文件file1做一个拷贝file2，在Shell创建一个子进程后，子进程执行程序cp，同时向该程序传递执行的参数：源文件名file1和目标文件名file2</p>
<p>cp程序主函数格式为：main(argc, argv, envp) 其中，第一个参数argc是命令行中包括程序名在内的参数个数，对于上述例子，argc=3。第二个参数argv是一个指向数组的指针。该数组的第i个元素就是命令行中的第i个字符串，对于上述例子argv[0]=”cp“, argv[1]=”file1”, argv[2]=”file2”。第三个参数envp是一个环境变量指针，用于将环境信息，如终端类型，用户主目录等传递给程序，对于上述例子，没有向子进程传递任何环境变量，因此envp为空。</p>
<p><strong>MINIX进程的存储空间分为3部分：正文段（text segment 程序代码）、数据段（data segment 变量）、堆栈段（stack segment）</strong>。数据段向上增长，堆栈段向下增长，两者间是空闲区。堆栈的增长随程序的执行自动进行，而数据段的扩展则是通过brk系统调用显式地完成。brk系统调用有一个参数指定数据段的结束地址，它可以比当前值大（数据段扩展）或比当前值小（数据段压缩），但是必须小于堆栈指针，否则堆栈和数据段将重叠，这是不允许的。</p>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E5%AD%98%E5%82%A8.png"></p>
<p>出于对程序员的方便考虑，系统还提供了一个库函数sbrk来改变数据段大小，它的参数是数据段的变化量（负数表示数据段缩小）。</p>
<p>getpid系统调用则是用于返回调用进程的进程标识符。注意在调用fork时，只有父进程能够获得子进程的进程标识符。如果子进程要得到自己的进程标识符，必须使用getpid。同样，getgrp返回进程的组标识符，setsid则启动一个新的会话，并将进程组的pid设置为调用者的pid。</p>
<p>最后一个ptrace系统调用，被调试器用来对被调试程序进程控制，通过ptrace，调试器可以读写被控制进程的地址空间并对其实施其他控制。</p>
</li>
<li><p>信号</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>s = sigaction(sig, &amp;act, &amp;oldact)</td>
<td>定义对信号的处理操作</td>
</tr>
<tr>
<td>s = sigreturn(&amp;context)</td>
<td>从信号返回</td>
</tr>
<tr>
<td>s = sigprocmask(how, &amp;set, &amp;old)</td>
<td>检查或修改信号屏蔽码</td>
</tr>
<tr>
<td>s = sigpending(set)</td>
<td>获取阻塞信号集合</td>
</tr>
<tr>
<td>s = kill(pid, sig)</td>
<td>替换信号频闭码并使进程挂起</td>
</tr>
<tr>
<td>residual = alarm(setconds)</td>
<td>设置时间闹钟</td>
</tr>
<tr>
<td>s = pause()</td>
<td>将调用进程挂起直到下一个信号</td>
</tr>
</tbody></table>
<p>尽管大多数进程间通信是计划好的，但同时还需要处理不可预知的通信问题。比如用户使用文本编辑器要求列出一个大文件的全部内容，但随机认识到该操作并不需要，这时就需要一种方法来中止编辑器的工作。在MINIX中，用户可以通过<kbd>Delete</kbd>键实现这一点。按<kbd>Delete</kbd>键实际上是向编辑器发送一个信号，编辑器收到此信号即停止打印文件的内容。信号还可以报告硬件捕获到的特定的陷入，比如非法指令和浮点运算溢出，超时也是通过信号实现。</p>
<p>当一个信号被发送给一个事先并未声明愿意接收它的进程时，该进程只是简单地被撤销，即被杀死。进程用sigaction系统调用来声明它准备接收的某些类型信号，并同时提供两个地址：一个是信号处理过程的地址 &amp;act ，一个是用于保存该信号的原先处理过程的地址 &amp;oldact 。执行完sigaction系统调用后，此进程如果接收到相关类型的信号，则先将该进程的当前状态压栈，然后调用指定的信号处理过程。信号处理过程可能很长，但一般情况下，它往往很短。信号处理过程结束后，就会调用sigreturn系统调用以继续执行被该信号中断的操作，类似于硬件中的中断返回。</p>
<p>信号可以被阻塞。被阻塞的信号会一直被挂起，直到阻塞解除。在阻塞的这段时间内，它不被传递，也不会丢失。sigprocmask系统调用允许一个进程定义其阻塞的信号集，实现方法是向核心提交一张位图。进程也可以通过sigpending系统调用查询当前因阻塞而挂起的信号集，该信号集以位图方式返回。而sigsuspend系统调用则可以使进程原子性地设定一张阻塞信号位图并将其挂起。</p>
<p>除了对信号进行捕获，程序也可以使用常数 SIG_IGN 来忽略指定类型的信号，或使用 SIG_DFL 来恢复缺省的信号处理过程。缺省的处理方式随信号而异，可以是撤销该进程，忽略该信号。举个例子来说明 SIG_IGN 常数的用法：</p>
<p>command &amp;</p>
<p>该命令希望DEL信号不要对后台进程产生影响，所以该命令在创建完子进程后会执行 sigaction(SIGINT, SIG_IGN, NULL) 和 sigaction(SIGQUIT, SIG_IGN, NULL) 来忽略DEL和quit信号。</p>
<p>按下<kbd>Delete</kbd>键并不是发送信号的唯一途径，使用kill系统调可以向另一个进程发送信号。比如上面的子进程，此时SIGINT和SIGQUIT都已经被屏蔽，所以只能使用kill系统调用来向该进程发送一个信号SIGKILL，撤销该进程。SIGKILL不能被捕获或者忽略。</p>
<p>对于许多实时应用，需要在一段指定时间后，中断进程的原有操作，以进行某种其他处理，为了处理此类的情况，系统提供了alarm系统调用。alarm系统调用的参数指定一个以秒为单位的时间间隔，一旦该时间段到点就会向该进程发送一个SIGALRM信号。在任意时刻，一个进程只能设定一个时间闹钟，如果进程先设定了一个10秒的时间闹钟，3秒后又设定了一个20秒的时间闹钟，那么只有第二个有效。如果alarm系统调用的参数为0，则所有挂起的SIGALRM信号都会被取消。</p>
<p>某些情况下进程在信号到达前不需要做任何操作，如果只是执行一种方法执行空操作循环来等待时间结束，这将浪费CPU时间。这时候，比较好的处理方式就是使用PAUSE调用，挂起调用进程，直到信号到来。</p>
</li>
<li><p>文件管理</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">fd = create(name, mode)</td>
<td>创建一个文件</td>
</tr>
<tr>
<td align="left">fd = mknod(name, mode, addr)</td>
<td>创建普通、设备文件或目录i-节点</td>
</tr>
<tr>
<td align="left">fd = open(file, how, …)</td>
<td>打开一个文件进行读、写或读写</td>
</tr>
<tr>
<td align="left">s = close(fd)</td>
<td>关闭一个打开的文件</td>
</tr>
<tr>
<td align="left">n = read(fd, buffer, nbytes)</td>
<td>从一个文件读数据到一个缓冲区</td>
</tr>
<tr>
<td align="left">n = write(fd, buffer, nbytes)</td>
<td>从缓冲区将数据写入文件</td>
</tr>
<tr>
<td align="left">pos = lseek(fd, offset, whence)</td>
<td>移动文件指针</td>
</tr>
<tr>
<td align="left">s = stat(name, &amp;buf)</td>
<td>获取一个文件的状态信息</td>
</tr>
<tr>
<td align="left">s = fstat(fd, &amp;buf)</td>
<td>获取一个文件的状态信息</td>
</tr>
<tr>
<td align="left">fd = dup(fd)</td>
<td>为打开文件分配一个新文件描述符</td>
</tr>
<tr>
<td align="left">s = pipe(&amp;fd[0])</td>
<td>创建一个管道文件</td>
</tr>
<tr>
<td align="left">s = ioctl(ft, request, argp)</td>
<td>对文件进行特殊操作</td>
</tr>
<tr>
<td align="left">s = access(name, amode)</td>
<td>检查文件是否可访问</td>
</tr>
<tr>
<td align="left">s = rename(old, new)</td>
<td>文件改名</td>
</tr>
<tr>
<td align="left">s = fcntl(fd, cmd, …)</td>
<td>文件加锁及其他操作</td>
</tr>
</tbody></table>
<p>以 fd = create(”abc“, 0751) 为例，该命令将创建一个名为abc的文件，其保护模式为0751（000 111 101 001），表示文件属主可读可写可执行，同组用户可读不可写可执行、其他用户不可读不可写可执行</p>
<p>create系统调用在创建文件的同时还会以写方式将其打开，而不管文件模式如何。而create系统调用返回的文件描述符fd可用于对该文件执行写操作。如果对一个已经存在的文件进行create操作，在操作权限许可的情况下，该文件内容会遭到破坏。open系统调用也可创建文件，create系统调用属于过时的系统调用，只不过为了兼容性而得以保留。</p>
<p>以 fd = mknod(“/dev/ttyc2”, 020744, 0x0402) 为例，mknod系统调用用于创建设备文件。该命令会创建一个一个名为”/dev/ttyc2”的文件（二号控制台常用文件名），并将其模式代码设置为八进制的020744（意为该文件是字符设备文件，保护模式为rwxr–r–），第三个文件参数的高字节指定其主设备号为4，低字节指定其设备号为2。主设备号可以取任意值，但是名为/dev/ttyc2的文件设备号应该只为2。mknod系统调用只能被超级用户使用。</p>
<p>读写一个文件之前必须首先用open系统调用打开，open系统调用的第一个参数指定文件路径名，可以使用绝对路径或者相对路径。第二个参数指定文件的打开方式，O_RDONLY，O_WRONLY，O_RDWR表示可读、可写、可读可写。open系统调用返回的文件描述符可以用于文件读写。文件在操作完毕后，要用close系统调用将其关闭，这样，该文件的文件描述符可以供之后的create和open系统调用再次使用。</p>
<p>read和write系统调用是最常见的系统调用，以read系统调用为例，write系统调用和其类似。多数程序对文件的读写是按顺序进行的，但有些却需要随机的访问文件的任意部分。每个文件都有一个指针指明其当前读写位置。在顺序读写时，该指针通常指向下次要读写的字节。使用lseek系统调用可以修改文件指针的值，这样随后的read或write系统调用就可以在文件的任一位置进行操作。</p>
<p>lseek系统调用有3个参数：第一个参数指定文件描述符，第二个参数指定文件的位置，第三个参数指名文件位置是相对文件开头、当前位置、还是文件尾。lseek返回值是文件指针被修改之后的绝对位置。</p>
<p>对于每个文件，MINIX系统记录下了如下文件信息：文件类型（普通文件、设备文件、目录），文件大小，最后修改时间等。程序可以通过stat系统调用或fstat系统调用获取这些信息，不同之处在于stat通过文件名来指定文件，而fstat通过文件描述符来指定文件。也正因如此，fstat系统调用适用于已经打开的文件。stat和fstat系统调用的第二个参数指定一个用于存放所获取信息的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> st_dev;				<span class="comment">/*i节点所驻留的设备*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> st_ino;		<span class="comment">/*i节点号*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> st_mode;		<span class="comment">/*模式*/</span></span><br><span class="line">    <span class="keyword">short</span> st_nlink;				<span class="comment">/*链接数*/</span></span><br><span class="line">    <span class="keyword">short</span> st_uid;				<span class="comment">/*用户标识符*/</span></span><br><span class="line">    <span class="keyword">short</span> st_gid;				<span class="comment">/*组标识符*/</span></span><br><span class="line">    <span class="keyword">short</span> st_rdev;				<span class="comment">/*设备文件的主次设备号*/</span></span><br><span class="line">    <span class="keyword">long</span> st_size;				<span class="comment">/*文件大小*/</span></span><br><span class="line">    <span class="keyword">long</span> st_atime;				<span class="comment">/*最后访问时间*/</span></span><br><span class="line">    <span class="keyword">long</span> st_mtime;				<span class="comment">/*最后修改时间*/</span></span><br><span class="line">    <span class="keyword">long</span> st_ctime;				<span class="comment">/*对i节点最后修改时间*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>dup系统调用常用于对文件描述符的操作。比如一个程序需要关闭标准输出（文件描述符为1），用一个普通文件取代成为标准输出，随后向标准输出写一些信息，最后恢复原先的状态。为了实现这些功能可以先关闭文件描述符1，再打开另一个文件，这时该文件就成为了标准输出，但这样做无法恢复原先的标准输出。解决方法就是先调用 fd = dup(1) 该操作将为标准输出分配一个新的文件描述符fd，对fd的操作和直接对标准输出的操作完全一样。随后将标准输出关闭，再打开一个新文件，该文件就会成为标准输出。当需要恢复原先的标准输出时，先关闭文件描述符1，再执行 n=dup(fd) 将最小的文件描述符符号 1 ，定向到fd所指向的文件，最后将fd关闭就恢复了最初的状态。</p>
<p>MINIX中的进程间通信使用管道。比如对于一个命令 cat file1 file2 | sort  Shell将创建一个管道并将第一个进程的标准输出信息写到管道中，于是第二个进程的标准输入就可以从该管道中读取。pipe系统调用将创建一个管道并返回两个文件的描述符，一个用于写，一个用于读。pipe系统调用格式为 pipe(&amp;fd[0]) 这里的fd是由两个整数组成的数组，fd[0] 存放供读使用的文件描述符，fd[1] 存放供写使用的文件描述符。通常典型的用法是在本条语句后调用一个fork创建一个子进程，然后父进程关掉用于读的文件描述符，子进程关掉用于写的文件描述符（或者相反），这样便可以做到一个进程从管道读取数据，另一个向管道写数据。下面的程序描述了这一过程。创建了两个进程，通过管道将进程1的输出导向进程2（只是简单描述，省略参数检查等操作）。其处理过程如下：首先创建一个管道，随后调用fork，将父进程作为管道中的进程1，子进程作为进程2，由于待运行的两个文件process1和process2并不知道它们是管道的一部分，所以必须对文件描述符进行控制以使进程1的标准输出和进程2的标准输入都指向管道。父进程首先关掉从管道读的文件描述符和标准输出，随后执行dup系统调用，这样使得文件描述符1可被用于向管道写。然后程序关闭另一个管道描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STD_INPUT 0				<span class="comment">/*标准输入的文件描述符*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STD_OUTPUT 1			<span class="comment">/*标准输出的文件描述符*/</span></span></span><br><span class="line"></span><br><span class="line">pipeline(process1, process2) &#123;</span><br><span class="line">    <span class="keyword">char</span> *process1, *process2;  <span class="comment">/*指向程序名的指针*/</span></span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];					<span class="comment">/*创建一个管道*/</span></span><br><span class="line">    pipe(&amp;fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (fork() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*父进程指向如下语句*/</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);			<span class="comment">/*进程1不需要从管道读*/</span></span><br><span class="line">        close(STD_OUTPUT);		<span class="comment">/*准备新的标准输出*/</span></span><br><span class="line">        dup(fd[<span class="number">1</span>]);				<span class="comment">/*将标准输出指向fd[1]*/</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);			<span class="comment">/*此文件描述符不再需要*/</span></span><br><span class="line">        execl(process1, process1, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(fd[<span class="number">1</span>]);			<span class="comment">/*进程2不需要向管道写*/</span></span><br><span class="line">        close(STD_INPUT);		<span class="comment">/*准备新的标准输入*/</span></span><br><span class="line">        dup(fd[<span class="number">0</span>]);				<span class="comment">/*将标准输入指向fd[0]*/</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);			<span class="comment">/*此文件描述符不再需要*/</span></span><br><span class="line">        execl(process2, process2, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在exec系统调用之后，父进程将保留文件描述符0和2，而文件描述符1则用于向管道中写。子进程的代码与父进程类似。execl的参数被重复，因为其第一个参数是待执行的文件名，而第二个参数是执行文件的第一个参数，对多数程序来说，该参数都是文件名。</p>
<p>ioctl系统调用适用于所有设备文件，可用于设备驱动程序。比如SCSI设备驱动程序用它来控制磁带机和CD-ROM。但是其主要还是用于字符设备文件，尤其是终端。POSIX定义的许多函数，最终都转换成了ioctl系统调用，比如tcgetattr和tcsetattr使用ioctl来改变终端的模式和各种属性。常见的终端模式有：Cooked模式，在该模式下，删除键和终止键能正常地工作，<kbd>Ctrl+S</kbd>用于停止终端输出，<kbd>Ctrl+Q</kbd>用于恢复终端输出，<kbd>Ctrl+D</kbd>文件结束，<kbd>Ctrl+\</kbd>退出并强制进行核心映像转储；Raw模式，所有这些功能被取消，每个字符都被不加处理地发送给程序，并且不等一行结束就将从终端读到的每个字符发送给程序；Cbreak模式介于两者之间，删除键，终止键，以及<kbd>Ctrl+D</kbd>被屏蔽，其他仍然有效。 </p>
<p>access系统调用检查对一个文件是否具有某种访问权限。rename系统调用更改文件名字，参数分别指定老文件名和新文件名。fcntl系统调用对文件进行控制，有若干个选项，常用选项就是文件加锁。使用fcntl可以对一个文件的一部分加锁解锁，也可以检测一个文件的某个部分是否被上锁。</p>
</li>
<li><p>目录及文件系统管理</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>s = mkdir(name, mode)</td>
<td>创建一个目录</td>
</tr>
<tr>
<td>s = rmdir(name)</td>
<td>删除一个空目录</td>
</tr>
<tr>
<td>s = link(name1, name2)</td>
<td>创建一个新文件name2指向name1</td>
</tr>
<tr>
<td>s = unlink(special, name, flag)</td>
<td>删除一个目录项</td>
</tr>
<tr>
<td>s = mount(special, name, flag)</td>
<td>安装一个文件系统</td>
</tr>
<tr>
<td>s = unmount(special, name, flag)</td>
<td>卸载一个文件系统</td>
</tr>
<tr>
<td>s = sync()</td>
<td>将缓冲的数据块写回到磁盘</td>
</tr>
<tr>
<td>s = chdir(dirname)</td>
<td>改变工作目录</td>
</tr>
<tr>
<td>s = chroot(dirname)</td>
<td>改变根目录</td>
</tr>
</tbody></table>
<p>mkdir和rmdir用于创建目录和删除<strong>空目录</strong>。link系统调用运行同一个文件按不同路径名出现，比如开发小组几个成员共享一个文件，同时该文件出现在每个人自己的目录下。共享一个文件不同于给每个人一个私有的拷贝，对前者，任何一个人的所有修改都对其他人可见，因为只存在一个文件；而对于后者，所有的修改只对自己可见，而不会更新其他人的拷贝。比如下面这个例子：</p>
<p><img src="/images/link%E6%96%87%E4%BB%B6.png"></p>
<p>link(“/usr/jim/memo”, “/usr/ast/note”)</p>
<p>该命令会将jim目录下的文件memo以文件名note出现在ast目录下，此后/usr/jim/memo和/usr/ast/note指的是同一个文件。而且理解link系统调用工作原理有助于理解文件。MINIX中的每个文件都有一个唯一的数字：i节点号（i-node）来标识。i节点号也是i节点表的索引值，每个文件都有一个i节点，里面存放文件属主以及该文件所占用磁盘块等信息。目录实际上也是文件，只是其内容存放的是一些i节点和文件名的对应信息。link所作的只是创建一个新的目录项，它有一个新文件名，但i节点号则是被链接的文件的i节点号。link目录项中的任何一个被unlink系统调用删除，只有存在目录项，则相关的文件也继续存在，如果都被删除，MINIX检测到没有目录项指向该文件（i节点包含一个字段，记录指向该文件的目录项数），则该文件被从磁盘上删除。</p>
<p>mount系统调用可将两个文件系统合并成一个，通常情况是现有一个存在于RAM盘上的跟文件系统，其中包含有常用命令的可执行文件及其他常用文件。然后用户可以在驱动器0中插入一张存有用户程序的软盘。使用mount系统调用就可以将软盘上的文件系统安装到根文件系统下（执行安装操作的典型C语句为：mount(“/dev/fd0”, “/mnt”, 0) 第一个参数是软驱的设备文件名，第二个参数指定在文件树中的安装点），如下图所示：</p>
<p><img src="/images/mount%E6%96%87%E4%BB%B6%E6%A0%91.png"></p>
<p>执行完mount操作后，软驱上的文件即可通过路径名访问而与具体的物理设备无关。当一个文件系统不需要时，就可用umount系统调用将其卸装。</p>
<p>MINIX在内存中开辟了一个缓冲区以保存最近经常访问的磁盘数据，这样可以避免重复地从磁盘上读取数据。如果缓冲区的某块数据被修改，而在其被写回磁盘之前系统发生崩溃，那么文件系统可能被损坏。为了避免这种现象，必须周期性地将这些缓冲区中的数据写回磁盘。sync系统调用就是用来将被修改的缓冲区数据写回磁盘。MINIX启动后，一个名为update的程序将被启动作为后台进程运作，每隔30秒执行一次sync系统调用，将更新了的数据写回磁盘。</p>
<p>和目录操作有关的另外两个系统调用是chdir和chroot，chdir改变当前工作目录，chroot改变根目录。</p>
</li>
<li><p>保护</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>s = chmod(name, mode)</td>
<td>改变文件的保护位</td>
</tr>
<tr>
<td>uid = getuid()</td>
<td>获取调用进程的uid</td>
</tr>
<tr>
<td>gid = getgid()</td>
<td>获取调用进程的gid</td>
</tr>
<tr>
<td>s = setuid(uid)</td>
<td>设置调用进程的uid</td>
</tr>
<tr>
<td>s = setgid(gid)</td>
<td>设置调用进程的gid</td>
</tr>
<tr>
<td>s = chown(name, owner, group)</td>
<td>改变文件的属主和组</td>
</tr>
<tr>
<td>oldmask = umask(complmode)</td>
<td>改变模式屏蔽码</td>
</tr>
</tbody></table>
<p>MINIX中每个文件都包含一个11比特的保护方式码，其中的9比特标识文件属主，同组用户，其他用户的操作权限。chmod系统调用可以改变文件的保护方式（详情见另外一篇文章《Linux常用命令》）。</p>
<p>当一个进程执行一个setuid或setgid设置文件时，会获得有效uid和有效gid（不同于真实uid或gid）。如果需要获得真实和有效的uid和gid，可以通过getuid和getgid系统调用获取这些信息。</p>
<p>umask和chown系统调用也见另一篇文章《Linux常用命令》</p>
</li>
<li><p>时间管理</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>seconds = time(&amp;seconds)</td>
<td>获取从1970年1月1号以来的时间</td>
</tr>
<tr>
<td>s = stime(tp)</td>
<td>设置从1970年1月1号以来的时间</td>
</tr>
<tr>
<td>s = utime(file, timep)</td>
<td>设置文件的最后访问时间</td>
</tr>
<tr>
<td>s = times(buffer)</td>
<td>获取到当前所用的用户和系统时间</td>
</tr>
</tbody></table>
<p>MINIX有4条用于管理实践的系统调用。功能见描述</p>
</li>
</ol>
<h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><h3 id="整体式系统"><a href="#整体式系统" class="headerlink" title="整体式系统"></a>整体式系统</h3><p>整体式系统是常用的组织方式，整个操作系统是一堆过程的集合，每个过程可以调用任意其他过程。系统在的每个过程都有一个定义完好的接口，有入口参数和返回值，相互间的调用不受约束。</p>
<p>在整体式系统中，为了构造最终的目标操作系统程序，开发人员首先将一些独立的过程进行边缘，然后用链接过程将其链接在一起成为一个单独的目标程序。从信息隐藏的观点看，它没有任何程度的隐藏——每个过程对其他过程可见。</p>
<p>但即使是在整体式系统中，也存在一些程度很低的结构化。比如操作系统提供的系统调用的调用过程：将参数放入预先确定的寄存器或堆栈中，然后执行一条特殊的陷入指令，称为<strong>核心调用（kernel call）</strong>指令。</p>
<p>操作系统随后检查该调用的参数以确定应执行哪条系统调用，然后，操作系统查一张系统调用表，其中记录了每条系统调用的执行古城，它确定了将调用的服务过程。当系统调用结束后，控制又返回给用户程序，于是继续执行系统调用后面的语句。</p>
<p><img src="/images/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81.png"></p>
<p>这种组织方式提出了操作系统一种基本结构：</p>
<ol>
<li>一个用来调用被请求服务例程的主程序</li>
<li>一套执行系统调用的服务例程</li>
<li>一套支持服务例程的实用过程</li>
</ol>
<p><img src="/images/%E6%95%B4%E4%BD%93%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E5%8D%95%E7%BB%93%E6%9E%84.png"></p>
<h3 id="客户-服务器系统"><a href="#客户-服务器系统" class="headerlink" title="客户/服务器系统"></a>客户/服务器系统</h3><p>现代操作系统的一个趋势是将代码移到更高层次的思想进一步发展，从操作系统中去掉尽可能多的东西，而只留一个最小的核心。通常的方法是将大多数操作系统功能由用户进程来实现。比如读取文件中的一块，用户进程将此请求发送给一个服务器进程，服务器进程随后完成此操作并将回答信息送回。</p>
<p>该模型中，核心的全部工作是处理客户与服务器间的通信，操作系统被分割成许多部分，每一部分只处理一方面的功能，如文件服务、进程服务、终端服务或存储服务。这样每一部分变得更小，更易于管理。而且由于所有服务器以用户进程的形式运行，而不是运行在核心态，所以它们不直接访问硬件。这样处理的结果是：加入文件服务器中发生错误，文件服务器可能崩溃，但不会导致整个系统崩溃。</p>
<p><img src="/images/%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B.png"></p>
<p>客户-服务器模型的另一个优点就是它适用于分布式系统。如果一个客户通过消息传递与服务器通信，客户无需知道这条消息是在本机进行处理还是通过网络传送给远程机器的服务器。在这两种情况下，客户机的处理都是一样的：发送一个请求，收回一个应答。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%A2%E6%88%B7%E6%A8%A1%E5%9E%8B.png"></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"># 读书笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/09/25/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Spring-Boot%E4%B8%AD%E7%9A%84SpringApplication/" rel="next" title="深入学习Spring Boot中的SpringApplication">
                <i class="fa fa-chevron-left"></i> 深入学习Spring Boot中的SpringApplication
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/10/26/%E8%BF%9B%E7%A8%8B/" rel="prev" title="进程">
                进程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">80</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">操作系统结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.1.</span> <span class="nav-text">整体式系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.2.</span> <span class="nav-text">客户&#x2F;服务器系统</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Doug-Wilson</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>





        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/Gantzert_Felixander.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
