<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AJAX工作原理解析</title>
    <url>/2020/04/01/AJAX%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>在前面的一篇文章《Tomcat服务器解析》中，有简单地介绍AJAX如何使用，但也仅限于此。而AJAX技术的关键，在于XMLHttpRequest对象的使用。因此，与其说AJAX是一个技术，不如说AJAX是一个XMLHttpRequest对象的使用技巧。</p>
<span id="more"></span>

<h2 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h2><h3 id="XMLHttpRequest对象概述"><a href="#XMLHttpRequest对象概述" class="headerlink" title="XMLHttpRequest对象概述"></a>XMLHttpRequest对象概述</h3><blockquote>
<p>在使用XMLHttpRequest对象发送请求和处理相应前，必须使用JavaScript创建一个XMLHttpRequest对象。由于XMLHttpRequest不是一个W3C标准，不同浏览器对其实例对象有不同实现，比如Internet Explorer将XMLHttpRequest实现为一个ActiveX对象，其它浏览器将其实现为一个本地的JavaScript对象。因此需要根据不同的浏览器，创建相应的XMLHttpRequest对象。大体上可以分为两类：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlHttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line"> 	<span class="comment">//通用浏览器</span></span><br><span class="line">	xmlHttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> 	xmlHttp = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="XMLHttpRequest对象常用方法"><a href="#XMLHttpRequest对象常用方法" class="headerlink" title="XMLHttpRequest对象常用方法"></a>XMLHttpRequest对象常用方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>abort()</td>
<td>停止当前请求</td>
</tr>
<tr>
<td>getAllResponseHeaders()</td>
<td>将响应的响应头部分数据以键值对返回</td>
</tr>
<tr>
<td>getResponseHeader(“key”)</td>
<td>获取响应头中，键对应的值</td>
</tr>
<tr>
<td>open(“method”, “url”)</td>
<td>建立对服务器的调用。method参数可以是GET/POST/PUT 而url参数可以是相对URL或绝对URL。此外，该方法还包括3个可选参数，但较少使用到</td>
</tr>
<tr>
<td>send(content)</td>
<td>向服务器发送请求</td>
</tr>
<tr>
<td>setRequestHeader(“key”, “value”)</td>
<td>设置请求头，注意，在设置请求头之前必须先调用open方法</td>
</tr>
</tbody></table>
<p><strong>open(string method, string url, boolean asynch, string username, string password)</strong></p>
<blockquote>
<p>这个方法会建立对服务器的调用，是一个初始化一个请求的纯脚本方法。该方法有两个必要参数method及url，3个可选参数asynch/username/password。三个可选参数比较常用的是asynch参数，指示这个调用是异步的还是同步的，默认为true，表示请求本质上是异步的，如果设置为false，则请求将会是同步的，处理就会等待，直到从服务器返回响应为止。另外两个参数username和password，顾名思义就是指定一个特定的用户名和密码。</p>
</blockquote>
<p><strong>void send(content)</strong></p>
<blockquote>
<p>这个方法具体向服务器发出请求。如果请求声明是异步的，这个方法就会立即返回，否则它会等待直到接收到响应为止。参数content不是必要的，如果设置了，则会作为请求体的一部分发送。</p>
</blockquote>
<p><strong>void setRequestHeader(string key, string value)</strong></p>
<blockquote>
<p>这个方法用于在请求头中设定一个键值对，该方法必须在调用open方法之后才能调用</p>
</blockquote>
<p><strong>void abort()</strong></p>
<blockquote>
<p>这个方法用于终止请求</p>
</blockquote>
<p><strong>string getAllResponseHeaders()</strong></p>
<blockquote>
<p>这个方法将响应的响应头部分数据以键值对返回</p>
</blockquote>
<p><strong>string getResponseHeader(string key)</strong></p>
<blockquote>
<p>这个方法获取响应头中，键对应的值</p>
</blockquote>
<h4 id="XMLHttpRequest对象常用属性"><a href="#XMLHttpRequest对象常用属性" class="headerlink" title="XMLHttpRequest对象常用属性"></a>XMLHttpRequest对象常用属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>onreadystatechange</td>
<td>每个状态改变时都会触发这个事件处理器，通常会调用一个JavaScript函数</td>
</tr>
<tr>
<td>readySatate</td>
<td>请求的状态。有5个值可取：0=未初始化，还没有调用open方法；1=请求已建立，但是还没有发送，即还没有调用send方法；2=请求已发送，正在处理中，可以获取响应头；3=请求正在处理中，响应有部分数据可用，但是响应还未完成；4=响应已经完成</td>
</tr>
<tr>
<td>responseText</td>
<td>服务器的响应内容表示为一个字符串，常使用json对象</td>
</tr>
<tr>
<td>responseXML</td>
<td>服务器的响应内容表示为一个XML，可以解析为一个DOM对象</td>
</tr>
<tr>
<td>status</td>
<td>http状态码，如200，404</td>
</tr>
<tr>
<td>statusText</td>
<td>http状态码对应字符，如OK，Not Found</td>
</tr>
</tbody></table>
<h4 id="XMLHttpRequest对象使用示例"><a href="#XMLHttpRequest对象使用示例" class="headerlink" title="XMLHttpRequest对象使用示例"></a>XMLHttpRequest对象使用示例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 创建XMLHttpRequest对象</span></span><br><span class="line"><span class="keyword">var</span> xmlHttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line"> <span class="comment">//通用浏览器</span></span><br><span class="line"> xmlHttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> xmlHttp = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 调用open方法设置请求参数</span></span><br><span class="line">xmlHttp.open(<span class="string">&quot;method&quot;</span>, <span class="string">&quot;url&quot;</span>, <span class="literal">true</span>); <span class="comment">//true为异步，false为同步</span></span><br><span class="line"><span class="comment">//3. 在send方法前绑定onreadystatechange事件</span></span><br><span class="line">xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (xmlHttp.readyState == <span class="number">4</span> &amp;&amp; xmlHttp.status == <span class="number">200</span>) &#123;</span><br><span class="line">     <span class="comment">//成功响应</span></span><br><span class="line">     xmlHttp.responseText(); <span class="comment">//获取响应数据</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果请求为POST请求，还需要加上下面这行代码</span></span><br><span class="line"><span class="comment">//xmlHttp.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span></span><br><span class="line"><span class="comment">//4. 调用send发送请求</span></span><br><span class="line">xmlHttp.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面是底层代码，jQuery封装了该部分，简化了使用</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line"> <span class="attr">url</span>: <span class="string">&quot;请求地址&quot;</span>,</span><br><span class="line"> <span class="attr">data</span>: <span class="string">&quot;请求数据&quot;</span>,</span><br><span class="line"> <span class="attr">type</span>: <span class="string">&quot;GET OR POST&quot;</span>,</span><br><span class="line"> <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">     <span class="comment">//data为响应数据</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="attr">dataType</span>:<span class="string">&quot;text XML JSON 根据响应内容进行设置&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</blockquote>
]]></content>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Shiro简介</title>
    <url>/2020/09/24/Apache-Shiro%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>Apache Shiro（发音为<code>shee-roh</code>，日语堡垒（Castle）的意思）是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理功能，可为任何应用提供安全保障 - 从命令行应用、移动应用到大型网络及企业应用。相较于Spring Security来说较为简单，易于上手。</p>
<span id="more"></span>

<p>Apache Shiro有三个核心的概念Subject，SecurityManager和Realms，如下图所示：</p>
<p><img src="/images/shiro%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.png"></p>
<p><strong>1、</strong><a href="http://shiro.apache.org/static/1.3.2/apidocs/org/apache/shiro/subject/Subject.html">Subject</a>：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等，即一个抽象概念。所有Subject 都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager。可以把Subject认为是一个门面，SecurityManager才是实际的执行者。</p>
<p>在shiro中通过<code>org.apache.shiro.SecurityUtils</code>类来获取Subject对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line">...</span><br><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br></pre></td></tr></table></figure>

<p><strong>2、</strong><a href="http://shiro.apache.org/static/1.3.2/apidocs/org/apache/shiro/mgt/SecurityManager.html">SecurityManager</a>：安全管理器，即所有与安全有关的操作都会与SecurityManager交互，且它管理着所有Subject，可以看出它是Shiro的核心。它负责与后边介绍的其他组件进行 交互，类似于Spring MVC中的DispatcherServlet前端控制器。</p>
<p><strong>3、</strong><a href="http://shiro.apache.org/static/1.3.2/apidocs/org/apache/shiro/realm/Realm.html">Realm</a>：域，Shiro从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法。 也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作。</p>
<p>简而言之，创建一个基本的Shiro应用过程为：</p>
<ul>
<li>应用代码通过Subject来进行认证和授权，而Subject又委托给SecurityManager；</li>
<li>我们需要给Shiro的SecurityManager注入Realm，从而让SecurityManager能得到合法的用户及其权限进行判断。</li>
</ul>
<p><strong>注意：Shiro并没有为我们提供Realm的实现，需要我们手动编写实现。基本过程为继承<code>org.apache.shiro.realm.AuthorizingRealm</code>抽象类，实现doGetAuthorizationInfo和doGetAuthenticationInfo方法。</strong></p>
<h2 id="Shiro功能模块"><a href="#Shiro功能模块" class="headerlink" title="Shiro功能模块"></a>Shiro功能模块</h2><p><img src="/images/shiro%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97.png"></p>
<p>Shiro提供了四大基本安全功能：认证，授权，会话管理和加密。</p>
<ul>
<li>**身份验证(Authentication)**：也称为登录验证，即验证用户名和密码是否正确；</li>
<li>**授权(Authorization)**：根据用户的角色和权限来控制用户可访问的资源；</li>
<li>**会话管理(Session Management)**：即使在非Web或EJB应用程序中，也可以管理用户特定的SESSION会话；</li>
<li>**密码学(Cryptography)**：使用加密算法保证数据安全，同时易于使用。</li>
</ul>
<p>除此之外，Shiro也支持以下特性：</p>
<ul>
<li>**Web支持(Web Support)**：Shiro提供的web程序API可以帮助轻松保护Web应用程序；</li>
<li>**缓存(Caching)**：缓存可确保安全验证操作保持快速高效；</li>
<li>**并发性(Concurrency)**：Apache Shiro支持具有并发功能的多线程应用程序；</li>
<li>**测试(Testing)**：测试API帮助您编写单元测试和集成测试；</li>
<li>**运行方式(Run As)**：允许用户以别的用户身份（如果允许）登录；</li>
<li>**记住我(Remember Me)**：在会话中记住用户的身份，只有在强制登录时才需要登录。</li>
</ul>
]]></content>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>BigDecimal类的使用</title>
    <url>/2020/04/21/BigDecimal%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在编程中，一些浮点数无法精确表示，比如0.1，0.12在计算机中只能近似表示（浮点数计算过程在另一篇文章《计算机程序运行基本知识》）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2^-1 = 0.5</span><br><span class="line">2^-2 = 0.25</span><br><span class="line">2^-3 = 0.125</span><br><span class="line">2^-4 = 0.0625</span><br><span class="line">2^-5 = 0.03125</span><br><span class="line">2^-6 = 0.015625</span><br><span class="line">2^-7 = 0.0078125</span><br><span class="line">...</span><br><span class="line">浮点数由这些数组合而成，因此一些数无法精确表示，比如：</span><br><span class="line">0.1 约等于 0.9765625</span><br><span class="line">0.1 + 0.2  约等于  0.300000000000004</span><br><span class="line">0.3 - 0.2 约等于 0.09999999999998</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>如果我们需要精确的计算结果，比如在物理和金融中，普通的浮点数计算就无法满足我们的需求。Java提供的BigDecimal类，则支持任何精度的浮点数，可以用它来精确计算值。</p>
<p>BigDecimal类提供了4个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal(<span class="keyword">int</span>);   <span class="comment">//将int类型转为BigDecimal类型</span></span><br><span class="line">BigDecimal(<span class="keyword">double</span>);  <span class="comment">//将double类型转为BigDecimal类型</span></span><br><span class="line">BigDecimal(<span class="keyword">long</span>);  <span class="comment">//将long类型转为BigDecimal类型</span></span><br><span class="line">BigDecimal(String);  <span class="comment">//将String类型转为BigDecimal类型</span></span><br></pre></td></tr></table></figure>

<p>在实际使用过程，一般使用 <code>BigDecimal(String);</code> 构造方法。因为，将String类型转为BigDecimal的结果是可以预知的，其他构造方法不能得到精确表示浮点数，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.1&quot;</span>));  <span class="comment">//0.1</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> BigDecimal(<span class="number">0.1</span>));   <span class="comment">//0.100000000000055511151...</span></span><br></pre></td></tr></table></figure>

<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ol>
<li><p>加法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal add=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.1&quot;</span>).add(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.2&quot;</span>));</span><br><span class="line">System.out.println(add);  <span class="comment">//0.3</span></span><br><span class="line"><span class="comment">//保留两位有效数字</span></span><br><span class="line">BigDecimal add1=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.1&quot;</span>)</span><br><span class="line">        .add(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.22222222222&quot;</span>),<span class="keyword">new</span> MathContext(<span class="number">2</span>));</span><br><span class="line">System.out.println(add1); <span class="comment">//0.32</span></span><br></pre></td></tr></table></figure></li>
<li><p>减法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal sub=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.3&quot;</span>).subtract(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.1&quot;</span>));</span><br><span class="line">System.out.println(sub);   <span class="comment">//0.2</span></span><br><span class="line"><span class="comment">//保留两位有效数字</span></span><br><span class="line">BigDecimal sub=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.3&quot;</span>)</span><br><span class="line">        .subtract(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.111111111&quot;</span>),<span class="keyword">new</span> MathContext(<span class="number">2</span>));</span><br><span class="line">System.out.println(sub);   <span class="comment">//0.19</span></span><br></pre></td></tr></table></figure></li>
<li><p>乘法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal mul=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.1&quot;</span>).multiply(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.2&quot;</span>));</span><br><span class="line">System.out.println(mul); <span class="comment">//0.02</span></span><br><span class="line"><span class="comment">//保留两位有效数字</span></span><br><span class="line">BigDecimal mul1=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.1&quot;</span>)</span><br><span class="line">     .multiply(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.2222222222&quot;</span>),<span class="keyword">new</span> MathContext(<span class="number">2</span>));</span><br><span class="line">System.out.println(mul1); <span class="comment">//0.022</span></span><br></pre></td></tr></table></figure></li>
<li><p>除法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal div=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.2&quot;</span>).divide(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;3&quot;</span>));</span><br><span class="line">System.out.println(div);﻿ <span class="comment">//0.4</span></span><br><span class="line"><span class="comment">//保留两位有效数字</span></span><br><span class="line">BigDecimal div1=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        .divide(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;3&quot;</span>),<span class="keyword">new</span> MathContext(<span class="number">2</span>));</span><br><span class="line">System.out.println(div1);  <span class="comment">//0.33</span></span><br><span class="line"><span class="comment">//四舍五入，保留两位小数</span></span><br><span class="line">BigDecimal div2=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        .divide(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;3&quot;</span>), <span class="number">2</span>, RoundingMode.HALF_UP);</span><br><span class="line">System.out.println(div2);  <span class="comment">//0.67</span></span><br></pre></td></tr></table></figure></li>
<li><p>比较大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小于，返回-1</span></span><br><span class="line"><span class="keyword">int</span> result=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.1&quot;</span>).compareTo(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.2&quot;</span>));</span><br><span class="line">System.out.println(result);   <span class="comment">//-1 </span></span><br><span class="line"><span class="comment">//等于，返回 0</span></span><br><span class="line"><span class="keyword">int</span> result=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.2&quot;</span>).compareTo(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.2&quot;</span>));</span><br><span class="line">System.out.println(result); <span class="comment">//0</span></span><br><span class="line"><span class="comment">//大于，返回 1</span></span><br><span class="line"><span class="keyword">int</span> result=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.3&quot;</span>).compareTo(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.2&quot;</span>));</span><br><span class="line">System.out.println(result);  <span class="comment">//1</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>BigDecimal</tag>
      </tags>
  </entry>
  <entry>
    <title>ClassLoader类加载器及加载机制</title>
    <url>/2020/02/03/ClassLoader%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<p>类加载器负责将Class加载到JVM中。并且对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。这意味着，比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类也必然不相等。比如下面的测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">                    InputStream inputStream = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[inputStream.available()];</span><br><span class="line">                    inputStream.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Object obj = myLoader.loadClass(<span class="string">&quot;com.doug.wilson.classloading.TestClassLoader&quot;</span>).newInstance();</span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> com.doug.wilson.classloading.TestClassLoader);</span><br><span class="line">        <span class="comment">//结果为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="ClassLoader类结构"><a href="#ClassLoader类结构" class="headerlink" title="ClassLoader类结构"></a>ClassLoader类结构</h2><blockquote>
<p>类结构主要有以下方法：</p>
<ol>
<li><p><code>Class&lt;?&gt; defineClass(byte[], int, int)</code></p>
<p>defineClass方法将字节流解析成JVM能够识别的Class对象。有了这个方法，意味着我们不仅可以通过class文件实例化对象，还可以通过其它方式，如网络传输字节文件生成Class类来实例化对象。</p>
</li>
<li><p><code>Class&lt;?&gt; findClass(String)</code></p>
<p>findClass方法通常和defineClass方法一起使用，可以通过覆盖ClassLoader的findClass方法来实现类的加载规则，从而取得要加载类的字节码，然后调用defineClass方法生成类的Class对象。注意，这时候的类对象还没有被链接，如果你想在类被加载到JVM中就被链接，那么可以调用resolveClass方法。</p>
</li>
<li><p><code>Class&lt;?&gt; loadClass(String)</code></p>
<p>load方法可以在运行时加载自己指定的一个类，通过this.getClass().getClassLoader().loadClass(“class”)需要注意的是，经过loadClass方法加载的类还没有进行链接过程(验证、准备、解析)，你可以决定在什么时候实现其其链接过程。</p>
</li>
<li><p><code>void resolveClass(Class&lt;?&gt;)</code> 完成Class类对象的链接过程</p>
</li>
</ol>
</blockquote>
<h2 id="类加载器的底层实现原理"><a href="#类加载器的底层实现原理" class="headerlink" title="类加载器的底层实现原理"></a>类加载器的底层实现原理</h2><blockquote>
<p>在介绍类加载器的加载机制前，先介绍类加载器的类别。从JVM虚拟机的角度，类加载器可以分为两类：默认类加载器和其它类加载器。启动类加载器是虚拟机的一部分。而其它类加载器则是由Java语言编写，独立于虚拟机，继承于抽象类ClassLoader。</p>
<p>默认类加载器分为以下三种：</p>
<ol>
<li>启动类加载器，BootstrapClassLoader。该类加载器负责将<strong>lib</strong>目录下或者**-Xbootclasspath**参数指定路径中的类，加载到虚拟机中</li>
<li>扩展类加载器，ExtClassLoder。该加载器负责加载lib\ext目录或者java.ext.dirs系统遍历所指定路径中的所有类</li>
<li>应用程序类加载器，AppClassLoader。该类加载器负责加载用户类路径上所指定的类。</li>
</ol>
<p>通常而言，如果我们要实现自己的类加载器，不管是直接实现抽象类ClassLoader还是继承URLClassLoader类，或者其它子类，它的父类加载器都是AppClassLoader。理由是：不管自定义的类加载器调用哪个父类构造器，创建的对象都必须最终调用getSystemClassLoader()作为父类加载器。而getSystemClassLoader()方法获取到的正是AppClassLoader扩展类加载器。</p>
<p>关系如下：</p>
<p><img src="/images/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png"></p>
<p>BootstrapClassLoader类加载器并不属于JVM的类等级层次，因为BootstrapClassLoader没有遵守ClassLoader的加载规则，既没有父类也没有子类。</p>
<p>ExtClassLoader的父类加载器不是BootstrapClassLoader，也没有父类加载器。它是我们能够访问到的顶层父类加载器。</p>
<p>AppClassLoader和ExtClassLoader的关系可用下面的一张图表示：</p>
<p><img src="/images/App%E5%92%8CExt%E5%85%B3%E7%B3%BB.png"></p>
<p>看起来，ExtClassLoader和AppClassLoader是平级关系，但是不然。ExtClassLoader和AppClassLoader都继承了URLClassLoader类，而URLClassLoader又实现了抽象类ClassLoader，在创建Launcher对象时，首先会创建ExtClassLoader，然后将ExtClassLoader对象作为父类加载器创建AppClassLoader对象，而通过Launcher.getClassLoader()方法获取到的ClassLoader就是AppClassLoader对象。所有，如果Java应用没有自定义类加载器，那么除了ExtClassLoader加载的内容外，其它的类都是由AppClassLoader进行加载。</p>
<blockquote>
<p>通过上述的描述，现在可以对类加载器的加载机制(或者说类加载器的底层实现原理)进行一个解释：</p>
<p>类加载器采用双亲委派模型(Ext和App)定义层次关系。除了ExtClassLoade扩展类加载器外，其余的类加载器都应当有自己的父类加载器。并且，这些类加载器之间的父子关系不会用过继承的关系实现，而是使用组合来复用父类加载器的代码(这点可以通过ExtClassLoader和AppClassLoader的关系可以看出)。</p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是将这个请求委派给父类加载器去完成，只有当父类加载器不存在或者父类加载器反馈自己无法完成类加载请求时，子类加载器才会尝试自己去加载类，以此类推。</p>
<p>使用双亲委派模型来组织类加载器间的关系，有一个显而易见的好处，就是Java类和它的类加载器一起具备了一种带有优先级的层次关系。比如Object类，无论哪一个类加载器加载这个类，最终都会委派给模型最顶层的类加载器进行实现，也就意味着Object类在程序的各种类加载环境中都是同一个类，即由类加载器和类本身共同确立了唯一性。</p>
<p>双亲委派的实现在ClassLoader抽象类的loadClass方法中。首先会检查类是否已经被加载过，如果没有，则调用父加载器的loadClass()方法。如果父类加载器不存在，或者父类加载器加载失败，抛出ClassNotFoundException异常，则再调用自己的findClass()方法进行加载。需要注意的是，经过上述步骤加载完成的类还没有进行链接过程，如果要对类进行链接，则需要再调用resolveClass()方法。大体过程由如下代码进行表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">//首先检查请求加载的类是否被加载过，如果c为null说明没有被加载过</span></span><br><span class="line">        <span class="comment">//如果加载过了，则什么都不做，结束方法</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果父类加载器存在，则先由父类加载器尝试加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>); <span class="comment">//false表示不进行链接</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果父类加载器不存在，则尝试由BootstrapClassLoader尝试加载</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                <span class="comment">//如果抛出该异常，说明父类加载器或启动类加载器无法完成类加载请求</span></span><br><span class="line">                <span class="comment">//则需要由当前类加载器进行类的加载</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                c = findClass(name); <span class="comment">//加载</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果resolve为true，则加载的类还要进行链接过程，为false则不进行链接过程</span></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h2 id="类加载器的类加载机制"><a href="#类加载器的类加载机制" class="headerlink" title="类加载器的类加载机制"></a>类加载器的类加载机制</h2><blockquote>
<p>虚拟机把描述的类数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的Java类型。在Java中，类的加载，链接和初始化，都是在程序运行期间完成的。虽然这种策略会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性。</p>
<p>类从被加载到虚拟机内存，到卸载出内存，整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载。其中验证、准备、解析部分统称为链接。</p>
<p>相对于类加载过程的其他阶段，一个非数组类的加载阶段(获取类的二进制流)是开发人员最可控的。因为加载阶段可以使用系统提供的类加载器来完成，也可以通过用户自定义的类加载器完成。开发人员可以通过自定义的类加载器去控制字节流的获取方式。这使得类加载阶段有一个广阔的舞台：网络获取、运行时实时生成。这也是类加载器近些年得到快速发展的原因。</p>
<p>前面这段话有一个前提，就是**”非数组类的加载”**。为什么要强调这一点？因为数组类不由类加载器创建，而是直接由虚拟机创建。但是数组类依然和类加载器有很密切的关系，因为数组的元素类型最终需要依靠类加载器加载。</p>
<h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><h5 id="加载："><a href="#加载：" class="headerlink" title="加载："></a>加载：</h5><p>加载什么时候开始？</p>
<blockquote>
<p>new一个实例对象、读取或设置一个类的静态属性、调用一个静态方法、使用反射获取类的信息、初始化一个类时，其父类也会被自动加载等等。</p>
</blockquote>
<p>加载会做些什么?</p>
<blockquote>
<ol>
<li>通过一个类的全限定名来获取类的二进制字节流</li>
<li>将二进制字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在方法区中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
</blockquote>
<h5 id="验证："><a href="#验证：" class="headerlink" title="验证："></a>验证：</h5><blockquote>
<p>验证阶段，主要确保class文件的字节码信息符合虚拟机要求，不会危害虚拟机安全。主要有以下四个阶段的验证过程：</p>
<ol>
<li>文件格式验证。验证字节流是否符合class文件规范，能否被当前版本虚拟机加载。</li>
<li>元数据验证。对字节码描述进行语义分析，确保字节码信息符合Java语言规范的要求，比如是否继承并实现了父类接口的全部方法。</li>
<li>字节码验证。通过数据流和控制流分析，确定语法和语义是合法的、符合逻辑的。</li>
<li>符号引用验证。验证能否通过符号引用找到对应的类，该类中的字段方法能否通过符号引用进行访问。</li>
</ol>
</blockquote>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><blockquote>
<p>准备阶段是正式为类变量（被static修饰的变量）分配内存并设置类变量初始值的阶段。这些变量所使用的内存都将在方法区中进行分配。而实例变量的初始化将随对象一起分配在堆内存中。</p>
<p>比如 <code>public static int value = 123;</code></p>
<p>在准备阶段过后，初始值为value = 0而不是value = 123 ，将value赋值为123的动作在初始化阶段才会完成。但是存在一种特殊情况，即当变量为常量时，在准备阶段就会进行赋值：</p>
<p><code>public static final int value = 123;</code>在准备阶段就会将value赋值为123</p>
<p><strong>该阶段还会有静态块的执行</strong></p>
</blockquote>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><blockquote>
<p>解析阶段是将常量池中的符号引用替换为直接引用的过程。</p>
</blockquote>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>初始化是类加载过程的最后一步。</p>
<p>初始化阶段，根据程序开发人员制订的主观计划，初始化类变量和其他资源。并且，编译器还会自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生&lt;clint&gt;()方法，编译器收集的顺序为语句在源码文件中出现的顺序(静态语句出现在非静态语句前等)。并且编译器会保证父类的&lt;clint&gt;()放在子类的&lt;clint&gt;()方法之前。</p>
</blockquote>
]]></content>
      <tags>
        <tag>classLoader, 类加载器, 加载机制</tag>
      </tags>
  </entry>
  <entry>
    <title>CopyOnWriteArrayList源码解析</title>
    <url>/2020/09/16/CopyOnWriteArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>CopyOnWriteArrayList为线程安全的ArrayList，本文分析下CopyOnWriteArrayList的源码，基于JDK1.8</p>
<span id="more"></span>

<h2 id="类结构关系"><a href="#类结构关系" class="headerlink" title="类结构关系"></a>类结构关系</h2><p>CopyOnWriteArrayList类关系图：</p>
<p><img src="/images/CopyOnWriteArrayList%E7%B1%BB%E5%85%B3%E7%B3%BB.png"></p>
<p>CopyOnWriteArrayList实现了List接口的所有方法，主要包含如下两个成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可重入锁，用于对写操作加锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object类型数组，存放数据，volatile修饰，目的是一个线程对这个字段的修改另外一个线程立即可见</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure>

<p>CopyOnWriteArrayList中并没有和容量有关的属性或者常量，下面通过对一些常用方法的源码解析，就可以知道原因</p>
<h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><code>CopyOnWriteArrayList()</code>空参构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无参构造函数直接创建了一个长度为0的Object数组。</p>
<p><code>CopyOnWriteArrayList(Collection&lt;? extends E&gt; c)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList.class)</span><br><span class="line">        <span class="comment">// 如果集合类型就是CopyOnWriteArrayList，则直接将其array赋值给当前CopyOnWriteArrayList</span></span><br><span class="line">        elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不是CopyOnWriteArrayList类型，则将集合转换为数组</span></span><br><span class="line">        elements = c.toArray();</span><br><span class="line">        <span class="comment">// 就如ArrayList源码分析所述那样，c.toArray()返回类型不一定是Object[].class，所以需要转换</span></span><br><span class="line">        <span class="keyword">if</span> (elements.getClass() != Object[].class)</span><br><span class="line">            elements = Arrays.copyOf(elements, elements.length, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置array值</span></span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CopyOnWriteArrayList(E[] toCopyIn)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 入参为数组，拷贝一份赋值给array</span></span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h3><p><code>add(E e)</code>往CopyOnWriteArrayList末尾添加元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 上锁，同一时间内只能有一个线程进入</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前array属性值</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 获取当前array数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 复制一份新数组，新数组长度为当前array数组长度+1</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 在新数组末尾添加元素</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 新数组赋值给array属性</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 锁释放</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，add操作通过ReentrantLock来确保线程安全。通过add方法，我们也可以看出CopyOnWriteArrayList修改操作的基本思想为：复制一份新的数组，新数组长度刚好能够容纳下需要添加的元素；在新数组里进行操作；最后将新数组赋值给array属性，替换旧数组。这种思想也称为“写时复制”，所以称为CopyOnWriteArrayList</p>
<h3 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h3><p><code>add(int index, E element)</code>指定下标添加指定元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 上锁，同一时间内只能有一个线程进入</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前array属性值</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">         <span class="comment">// 获取当前array数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 下标检查</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index+</span><br><span class="line">                                                <span class="string">&quot;, Size: &quot;</span>+len);</span><br><span class="line">        Object[] newElements;</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// numMoved为0，说明是在末尾添加，过程和add(E e)方法一致</span></span><br><span class="line">            newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则创建一个新数组，数组长度为旧数组长度值+1</span></span><br><span class="line">            newElements = <span class="keyword">new</span> Object[len + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 分两次复制，分别将index之前和index+1之后的元素复制到新数组中</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index, newElements, index + <span class="number">1</span>,</span><br><span class="line">                             numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在新数组的index位置添加指定元素</span></span><br><span class="line">        newElements[index] = element;</span><br><span class="line">        <span class="comment">// 新数组赋值给array属性，替换旧数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 锁释放</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set-int-index-E-element"><a href="#set-int-index-E-element" class="headerlink" title="set(int index, E element)"></a>set(int index, E element)</h3><p><code>set(int index, E element)</code>设置指定位置的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 上锁，同一时间内只能有一个线程进入</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// 获取当前array属性值</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 获取当前array指定index下标值</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">        	<span class="comment">// 如果新值和旧值不相等</span></span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            <span class="comment">// 复制一份新数组，长度和旧数组一致</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            <span class="comment">// 修改新数组index下标值</span></span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            <span class="comment">// 新数组赋值给array属性，替换旧数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 即使新值和旧值一致，为了确保volatile语义，需要重新设置array</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    	<span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h3><p><code>remove(int index)</code>删除指定下标元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 上锁，同一时间内只能有一个线程进入</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// 获取当前array属性值</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 获取当前array长度</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 获取旧值</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">        	<span class="comment">// 如果删除的是最后一个元素，则将当前array设置为新数组</span></span><br><span class="line">        	<span class="comment">// 新数组长度为旧数组长度-1，这样刚好截去了最后一个元素</span></span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// 分段复制，将index前的元素和index+1后的元素复制到新数组</span></span><br><span class="line">        	<span class="comment">// 新数组长度为旧数组长度-1</span></span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            <span class="comment">// 设置array</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    	<span class="comment">// 锁释放</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，CopyOnWriteArrayList中的增删改操作都是在新数组中进行的，并且通过加锁的方式确保同一时刻只能有一个线程进行操作，操作完后赋值给array属性，替换旧数组，旧数组失去了引用，最终由GC回收</p>
<h3 id="get-int-index"><a href="#get-int-index" class="headerlink" title="get(int index)"></a>get(int index)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>get(int index)</code>操作是分两步进行的：</p>
<ol>
<li>通过<code>getArray()</code>获取array属性值；</li>
<li>获取array数组index下标值。</li>
</ol>
<p>这个过程并没有加锁，所以在并发环境下可能出现如下情况：</p>
<ol>
<li>线程1调用<code>get(int index)</code>方法获取值，内部通过<code>getArray()</code>方法获取到了array属性值；</li>
<li>线程2调用CopyOnWriteArrayList的增删改方法，内部通过<code>setArray</code>方法修改了array属性的值；</li>
<li>线程1还是从旧的array数组中取值。</li>
</ol>
<p><strong>所以<code>get</code>方法是弱一致性的</strong>。</p>
<h3 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getArray().length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>size()</code>方法返回当前array属性长度，因为CopyOnWriteArrayList中的array数组每次复制都刚好能够容纳下所有元素，并不像ArrayList那样会预留一定的空间。所以CopyOnWriteArrayList中并没有size属性，元素的个数和数组的长度是相等的</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** Snapshot of the array */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">    <span class="comment">/** Index of element to be returned by subsequent call to next.  */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，迭代器也是弱一致性的，并没有在锁中进行。如果其他线程没有对CopyOnWriteArrayList进行增删改的操作，那么snapshot还是创建迭代器时获取的array，但是如果其他线程对CopyOnWriteArrayList进行了增删改的操作，旧的数组会被新的数组给替换掉，但是snapshot还是原来旧的数组的引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>CopyOnWriteArrayList体现了写时复制的思想，增删改操作都是在复制的新数组中进行的；</li>
<li>CopyOnWriteArrayList的取值方法是弱一致性的，无法确保实时取到最新的数据；</li>
<li>CopyOnWriteArrayList的增删改方法通过可重入锁确保线程安全；</li>
<li>CopyOnWriteArrayList线程安全体现在多线程增删改不会抛出<code>java.util.ConcurrentModificationException</code>异常，并不能确保数据的强一致性；</li>
<li>同一时刻只能有一个线程对CopyOnWriteArrayList进行增删改操作，而读操作没有限制，并且 CopyOnWriteArrayList增删改操作都需要复制一份新数组，增加了内存消耗，所以CopyOnWriteArrayList适合读多写少的情况。</li>
</ol>
]]></content>
      <tags>
        <tag>CopyOnWriteArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>CopyOnWriteArraySet源码解析</title>
    <url>/2020/09/16/CopyOnWriteArraySet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>CopyOnWriteArraySet为线程安全的Set实现，本文记录CopyOnWriteArraySet源码解析，基于JDK1.8</p>
<span id="more"></span>

<h2 id="类结构关系"><a href="#类结构关系" class="headerlink" title="类结构关系"></a>类结构关系</h2><p>CopyOnWriteArraySet的类层级关系图：</p>
<p><img src="/images/CopyOnWriteArraySet%E7%9A%84%E7%B1%BB%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.png"></p>
<p>内部属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 就一个属性，CopyOnWriteArraySet内部采用CopyOnWriteArrayList存储元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br></pre></td></tr></table></figure>

<p>和HashSet不一样的是，CopyOnWriteArraySet内部采用CopyOnWriteArrayList存储元素，这也是CopyOnWriteArraySet名字的由来，因为CopyOnWriteArrayList是线程安全的，CopyOnWriteArraySet的方法都是基于CopyOnWriteArrayList实现的，所以CopyOnWriteArraySet自然而然也是线程安全的，同样的，在并发环境下获取数据是弱一致性的！</p>
<h3 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空参构造函数，实际就是初始化CopyOnWriteArrayList</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入集合对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 分两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArraySet.class) &#123;</span><br><span class="line">    	<span class="comment">// 如果集合就是CopyOnWriteArraySet类型，说明数据是不重复的</span></span><br><span class="line">    	<span class="comment">// 直接全部添加到CopyOnWriteArrayList中</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> CopyOnWriteArraySet&lt;E&gt; cc =</span><br><span class="line">            (CopyOnWriteArraySet&lt;E&gt;)c;</span><br><span class="line">        al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;(cc.al);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 否则调用addAllAbsent添加所有当前集合中不存在的元素，确保数据的唯一性</span></span><br><span class="line">        al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">        al.addAllAbsent(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h4><p><code>add(E e)</code>添加指定元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 实际调用CopyOnWriteArrayList的addIfAbsent方法</span></span><br><span class="line">	<span class="comment">// 元素不存在，则添加，返回true；元素存在，则不添加，返回false</span></span><br><span class="line">    <span class="keyword">return</span> al.addIfAbsent(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CopyOnWriteArraySet的add方法通过调用CopyOnWriteArrayList的addIfAbsent来确保元素不重复，以满足Set的特性</p>
]]></content>
      <tags>
        <tag>CopyOnWriteArraySet</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS域名解析过程</title>
    <url>/2020/02/10/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>我们通过URL来发布和请求资源，而URL中的域名则主要由IP地址和端口号组成，只有知道IP地址才能对IP地址的服务器进行访问。如何解析出域名中的IP地址，需要借助DNS(Domain Name System)系统。</p>
<span id="more"></span>

<h2 id="DNS解析过程如下"><a href="#DNS解析过程如下" class="headerlink" title="DNS解析过程如下"></a>DNS解析过程如下</h2><p>当用户在浏览器地址栏输入URL回车后，会有如下解析过程：</p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><blockquote>
<p>浏览器检查缓存中是否存在域名已经解析完成的IP地址，有，则解析过程结束。</p>
<p>对于浏览器缓存这里要多说一句，浏览器缓存域名存在缓存时间限制，通常这个时间为几分钟到几小时不等。缓存时间太长或太短都不好，太长的话，当IP地址变化，用户在缓存时间内都无法对域名所在的服务器访问，太短，则用户每次访问网站都要重新解析一次域名。</p>
</blockquote>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><blockquote>
<p>如果浏览器缓存中没有域名对应解析完成的IP地址，则会到操作系统缓存中查找域名对应的DNS解析结果。操作系统也会有一个域名解析过程，在windows操作系统中，解析后的结果会放在：<code>C:/Windows/System32/drivers/etc/hosts</code>文件中，在Linux操作系统中，解析的结果则放在：<code>/etc/hosts</code>中。比如对于经常挂的GitHub，就可以将其IP地址及对应域名放入到hosts文件中，才能较快速地访问网站。</p>
<p>不过这种本地解析也是有风险的，黑客可以通过修改你的本地域名解析来将特定的域名解析到它指定的IP地址上，导致这些域名被劫持。所以，这也是为什么host文件设置成只读的，防止这个文件被轻易地修改。</p>
</blockquote>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><blockquote>
<p>当浏览器缓存和操作系统缓存中均没有域名对应的解析结果，则会真正请求域名服务器解析域名。</p>
<p>每个计算机都会有一个网络配置，网络配置中会有“DNS服务器地址”这一项。当前两步均无法完成域名的解析时，操作系统就会将域名发送给LDNS——本地区的域名服务器。比如，你在学校，那么这个本地区域名服务器就在学校中，如果在小区，则这个本地区域名服务器为接入互联网的网络供应商，大约80%的域名解析到这里就已经解析完成，也就是说LDNS主要承担了域名的解析工作。</p>
</blockquote>
<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><blockquote>
<p>如果LDNS仍然没有名中，则会到Root Server域名服务器请求解析</p>
</blockquote>
<h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><blockquote>
<p>第四步根域名服务器会返回给本地域名服务器LDNS一个所查询域的主域名服务器(gTLD Server)地址。主域名服务器gTLD大概有13台，比如 .<code>com</code>   <code>.cn</code>   <code>.org</code>等</p>
</blockquote>
<h3 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h3><blockquote>
<p>本地域名服务器LDNS向主域名服务器gTLD发送请求</p>
</blockquote>
<h3 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h3><blockquote>
<p>接收请求的gTLD主域名服务器查找域名对应的**Name Server域名服务器地址(即域名注册时的域名服务器，如果你是在某个域名服务提供商申请的域名，则该域名解析任务由该域名服务提供商完成)**。</p>
</blockquote>
<h3 id="第八步"><a href="#第八步" class="headerlink" title="第八步"></a>第八步</h3><blockquote>
<p>本地域名服务器LDNS会向gTLD主域名服务器返回的Name Server域名服务器地址发送域名解析请求。对应的Name Server域名服务器会查询存储的域名和IP的映射关系表，将查找到的目标IP连同一个**TTL(Time To Live)**值返回给LDNS本地域名服务器。</p>
</blockquote>
<h3 id="第九步"><a href="#第九步" class="headerlink" title="第九步"></a>第九步</h3><blockquote>
<p>LDNS将得到的IP地址和TTL值返回给用户主机，并缓存这个域名和IP的对应关系，缓存的时间由TTL控制。</p>
</blockquote>
<h3 id="第十步"><a href="#第十步" class="headerlink" title="第十步"></a>第十步</h3><blockquote>
<p>用户主机将IP和域名的对应关系进行缓存，缓存的时间也由TTL控制。到这里，域名解析结束，用户可以对域名对应的服务器进行访问。</p>
<p><img src="/images/DNS%E8%A7%A3%E6%9E%90%E8%AF%B7%E6%B1%82.png"></p>
</blockquote>
<h4 id="以下内容来自《Java-Web技术内幕》"><a href="#以下内容来自《Java-Web技术内幕》" class="headerlink" title="以下内容来自《Java Web技术内幕》"></a>以下内容来自《Java Web技术内幕》</h4><blockquote>
<p>在Java应用中JVM也会缓存DNS的解析结果，这个缓存是在InetAddress类中完成的，而且这个缓存时间比较特殊，它有两种缓存策略：一种是正确解析结果缓存，另一种为失败的解析结果缓存。这两个缓存时间由两个配置项控制，配置项是在%JAVA_HOME%\lib\security\java.security文件中进行配置。两个配置项分别是<strong>networkaddress.cache.ttl</strong>和<strong>networkaddress.cache.negative.ttl</strong>，默认值为-1(永不失效)和10(缓存10秒)。</p>
<p>要修改这两个值有几种方式：</p>
<ul>
<li>直接修改java.security文件中的默认值</li>
<li>在Java的启动参数中增加 <code>-Dsun.net.inetaddr.ttl=xxx</code></li>
<li>通过InetAddress类动态修改</li>
</ul>
<p>另外，如果我们需要用InetAddress类解析域名，必须是单例模式，不然会有严重性能问题，如果每次都创建InetAddress实例，则每次都要进行一次完整的域名解析，非常耗时，这点要特别注意。</p>
</blockquote>
]]></content>
      <tags>
        <tag>DNS, 域名</tag>
      </tags>
  </entry>
  <entry>
    <title>Git工作原理探究</title>
    <url>/2020/04/15/Git%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="Git存储文件过程及分支工作原理"><a href="#Git存储文件过程及分支工作原理" class="headerlink" title="Git存储文件过程及分支工作原理"></a>Git存储文件过程及分支工作原理</h2><p>在Git中提交时，会保存一个提交对象，它包含一个指向暂存内容快照的指针，作者和相关附属信息，以及一定数量（也可能没有）指向该提交对象直接祖先的指针。</p>
<p>当执行 <code>git add</code>暂存操作时。暂存操作会对每一个文件计算校验和（SHA-1哈希字符串），然后将当前版本的文件快照保存到Git仓库中（Git使用blob类型对象存储这些快照），并将校验和加入暂存区域。</p>
<p>当执行 <code>git commit</code>提交操作时，Git会先计算每一个子目录的校验和，然后在Git仓库中将这些目录保存为树对象，之后Git创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此就可以在将来需要的时候，重现此快照的内容。</p>
<p>因此，在Git仓库中，除了文件快照内容的blob对象，还会有2个对象：一个记录目录树内容及其各个文件对应blob对象索引的tree对象。以及一个包含指向tree对象（根目录）的索引和其他提交信息元数据的commit对象。如下图所示：</p>
<p><img src="/images/Git%E4%BB%93%E5%BA%93blob%E5%AF%B9%E8%B1%A1.png"></p>
<p>做些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针。两次提交后，上面的图就会变成下面的样子：</p>
<p><img src="/images/Git%E4%BF%AE%E6%94%B9%E6%8F%90%E4%BA%A4%E5%90%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%8F%98%E5%8A%A8.png"></p>
<p>而分支，实质上仅仅是个指向commit对象的可变指针。比如默认分支master，在提交若干次后，它在每次提交的时候都会向前移动，指向最新提交的commit对象。</p>
<p><img src="/images/%E5%88%86%E6%94%AFmaster%E7%A7%BB%E5%8A%A8.png"></p>
<p>当创建一个分支时，就会在当前分支上创建一个新的分支指针。比如创建一个dev1分支：</p>
<p><img src="/images/dev1%E5%88%86%E6%94%AF.png"></p>
<p>切换分支，则是将HEAD指针在分支指针间切换。比如从master分支切换到dev1分支：</p>
<p><img src="/images/%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AFmaster.png"></p>
<p><img src="/images/%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AFdev1.png"></p>
<p>在dev1分支提交修改时：</p>
<p><img src="/images/%E5%9C%A8dev1%E5%88%86%E6%94%AF%E4%B8%8A%E6%8F%90%E4%BA%A4%E4%BF%AE%E6%94%B9.png"></p>
<p>切换回master分支：</p>
<p><img src="/images/%E4%BB%8Edev1%E5%88%86%E6%94%AF%E5%88%87%E6%8D%A2%E5%9B%9Emaster%E5%88%86%E6%94%AF.png"></p>
<p>在master分支上提交修改：</p>
<p><img src="/images/%E5%9C%A8master%E5%88%86%E6%94%AF%E4%B8%8A%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0.png"></p>
<p>Git中的分支实际上是一个仅包含所指对象校验和（40个字符串长度的SHA-1字符串）的文件，所以创建和销毁一个分支十分廉价。简而言之就是，新建分支就是向一个文件写入41个字节（SHA-1字符串加一个换行符）。</p>
<p>这和大多数版本控制系统形成了鲜明的对比，它们管理分支大多数采用备份所有项目文件到特定目录的方式，所以根据项目文件数量和大小不同，花费的时间差别也相当大，快的几秒，慢的就要几分钟。而Git的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。同时，因为每次提交时都记录了parent对象信息，所以当合并分支时，也相当便捷。</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git指令</title>
    <url>/2020/04/13/Git%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>版本控制系统用于记录若干文件的内容变化，通过命令将文件或整个项目改变到某给版本。为了更好学习Git，这里先区分版本控制系统类别：</p>
<ul>
<li><em>本地版本控制系统</em>。采用某种简单的数据库来记录文件的历次更新差异。最流行的是RCS，基本工作原理为保存并管理文件补丁patch。文件补丁是一种特定格式的文本文件，记录对应文件修订前后的内容变化，根据每次修订后的补丁，计算出各个版本的文件内容。</li>
<li><em>集中化的版本控制系统</em>。通过一个单一的集中管理的服务器，保存所有文件的修订版本，协同工作的人们通过客户端连接到服务器，取出最新的文件或者提交更新。当中央服务器故障时，其它主机就无法进行提交和更新，甚至中央服务器还可能出现数据丢失的情况。</li>
<li><em>分布式版本控制系统</em>。在集中化的版本控制系统基础上，客户端每一次取文件都会把原始的代码仓库完整地镜像下来，这样，当服务器出现故障时，可以通过任何一个镜像出来的文件进行恢复。</li>
</ul>
<span id="more"></span>

<h2 id="Git和其它版本控制系统的差异"><a href="#Git和其它版本控制系统的差异" class="headerlink" title="Git和其它版本控制系统的差异"></a>Git和其它版本控制系统的差异</h2><p>Git属于分布式版本控制系统，和其它版本控制系统的主要差别在于，Git只关心文件数据的整体发生变化，而大多数其它系统则关心文件内容的具体差异，比如，每次记录有哪些文件更新，更新了什么内容。Git则是每次提交更新时，浏览一遍所有文件的指纹信息，并对文件作一快照，然后保存一个指向这次快照的索引，如果文件没有变化，Git只对上次保存的快照作一连接。（其它版本控制系统需要记录具体文件差异，Git则是对文件快照保存一个索引，文件不变，索引不变，文件改变，索引指向新的文件快照）</p>
<p><img src="/images/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B7%AE%E5%BC%82.png"></p>
<p><img src="/images/Git%E6%96%87%E4%BB%B6%E5%BF%AB%E7%85%A7.png"></p>
<p>此外，Git中的绝大部分操作都只需要访问本地文件和资源，不用联网。在本地磁盘上就保存着当前项目的历史更新，当想提交更新时，都可以进行愉快地提交更新，等到有网络时在上传到远程的镜像仓库。</p>
<h3 id="Git时刻保持数据完整性"><a href="#Git时刻保持数据完整性" class="headerlink" title="Git时刻保持数据完整性"></a>Git时刻保持数据完整性</h3><p>Git采用SHA-1算法计算数据的校验和，通过对文件的内容或目录结构计算出一个SHA-1哈希值作为指纹字符串，该指纹字符串由40个十六进制字符组成。</p>
<p>文件在保存到Git前，所有数据都要进行内容的校验和计算，并将此结构作为数据的唯一标识符和索引。换句话说，不可能你在修改文件和目录时，Git一无所知。因此，当文件在传输时变得不完整或者磁盘损坏导致文件数据缺失，Git都能立即检查到。</p>
<h3 id="Git的三种状态"><a href="#Git的三种状态" class="headerlink" title="Git的三种状态"></a>Git的三种状态</h3><ul>
<li>已提交 committed  已提交表示该文件已经被安全地保存在本地数据库中</li>
<li>已修改 modified 已修改表示修改了某个文件，但是还没有提交保存</li>
<li>已暂存 staged 已暂存表示把已修改的文件放在下次提交时要保存的清单中</li>
</ul>
<p>也因为Git三种状态的存在，Git管理项目时，文件会流转3个区域：Git的本地数据目录，工作目录，暂存区域</p>
<ul>
<li>本地数据目录。每一个项目都有一个git目录，是Git用于保存元数据和对象数据库的地方，每次克隆镜像仓库的时候，实际拷贝的就是该目录中的数据</li>
<li>工作目录。从项目取出某个版本的所有文件和目录，用于开始后续工作</li>
<li>暂存区。一个文件，存放在git目录中</li>
</ul>
<p>工作流程：在工作目录修改某些文件——&gt;对修改的文件作快照，并保存到暂存区中——&gt;提交更新，将保存在暂存区的文件快照转储到git目录中</p>
<h3 id="Git暂存区"><a href="#Git暂存区" class="headerlink" title="Git暂存区"></a>Git暂存区</h3><p>以自己的Git仓库地址为例：</p>
<p><img src="/images/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E7%9B%AE%E5%BD%95.png"></p>
<p>仓库地址：<code>F:/GitTool/repository/.git/</code></p>
<p>工作区：<code>repository目录</code>，可见的</p>
<p>版本库：<code>.git目录</code>，不可见的，隐藏的，称为Git的版本库</p>
<p>暂存区：<code>index文件</code></p>
<p>初始化Git仓库时，Git会为我们自动创建第一个分支master以及指向master的一个指针HEAD</p>
<p>当将一个文件提交到Git仓库时，会分成两步执行：</p>
<ol>
<li>$ git add 路径+文件名   将文件修改添加到暂存区</li>
<li>$ git commit -m “文件说明”  则是将暂存区的所有内容提交到当前所在分支</li>
</ol>
<h2 id="常用Git指令"><a href="#常用Git指令" class="headerlink" title="常用Git指令"></a>常用Git指令</h2><h4 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h4><blockquote>
<p>初始化仓库</p>
</blockquote>
<h4 id="cd-F-GitTool-repository"><a href="#cd-F-GitTool-repository" class="headerlink" title="cd F:/GitTool/repository/"></a>cd F:/GitTool/repository/</h4><blockquote>
<p>进入到仓库主目录</p>
</blockquote>
<h4 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h4><blockquote>
<p>查看仓库当前状态</p>
</blockquote>
<h4 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h4><blockquote>
<p>查看具体被修改的内容</p>
</blockquote>
<h4 id="git-add-路径-文件名"><a href="#git-add-路径-文件名" class="headerlink" title="git add 路径+文件名"></a>git add 路径+文件名</h4><blockquote>
<p>添加文件快照到暂存区</p>
</blockquote>
<h4 id="git-commit-m”文件说明”"><a href="#git-commit-m”文件说明”" class="headerlink" title="git commit -m”文件说明”"></a>git commit -m”文件说明”</h4><blockquote>
<p>将暂存区中的文件快照保存到git目录中</p>
</blockquote>
<h4 id="git-log-查看历史版本"><a href="#git-log-查看历史版本" class="headerlink" title="git log 查看历史版本"></a>git log 查看历史版本</h4><blockquote>
<p>一般而言，该命令会给出具体的历史版本信息，版本号从上到下，提交时间由近到远：</p>
<p><img src="/images/git%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC.png"></p>
<p>如果你不想要这么多信息，可以在该命令上加上一些参数：git log –pretty=oneline</p>
<p><img src="/images/git%E7%AE%80%E5%8C%96%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF.png"></p>
<p>前面的一串数字就是版本号，十六进制表示，通过SHA1算法计算出。在Git中，HEAD表示当前版本，也就是最新提交的版本。HEAD^表示上一个版本，HEAD^^表示上上个版本，以此类推。如果要回退的版本数很多，比如要回退10个版本，也可以通过HEAD~10进行回退。</p>
</blockquote>
<h4 id="git-reset-–hard-HEAD"><a href="#git-reset-–hard-HEAD" class="headerlink" title="git reset –hard HEAD^"></a>git reset –hard HEAD^</h4><blockquote>
<p>回退到上一个版本</p>
</blockquote>
<h4 id="git-reset-–hard-21f6306ffb4a5d8a15a0c9"><a href="#git-reset-–hard-21f6306ffb4a5d8a15a0c9" class="headerlink" title="git reset –hard  21f6306ffb4a5d8a15a0c9"></a>git reset –hard  21f6306ffb4a5d8a15a0c9</h4><blockquote>
<p>切换到版本号对应的版本</p>
</blockquote>
<blockquote>
<p>（无论是回退到历史版本还是恢复到原来的版本，都称为版本切换）版本切换的内部实现原理很简单。Git内部有个指向当前版本的HEAD指针，当回退版本时，Git只是改变HEAD的指向而已，然后将工作区的文件进行更新。所有，你让HEAD指向哪个版本号，就把当前版本定位在哪里</p>
</blockquote>
<h4 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h4><blockquote>
<p>记录每个命令以及命令对应操作文件的版本号</p>
</blockquote>
<blockquote>
<p>该命令通常和**git reset –hard 21f6306ffb4a5d8a15a0c9 **一起组合使用，切换到版本号对应的版本</p>
</blockquote>
<h4 id="git-checkout-–-文件名"><a href="#git-checkout-–-文件名" class="headerlink" title="git checkout   – 文件名"></a>git checkout   – 文件名</h4><blockquote>
<p>撤销修改</p>
</blockquote>
<blockquote>
<p>该命令只对两种情况有效：</p>
<ol>
<li>修改的文件还在工作区中，还没有进行提交，此时进行checkout，文件会回到修改前的版本号状态</li>
<li>文件提交到暂存区了，然后又对文件进行修改，那么进行checkout的文件会回到提交到暂存区时的状</li>
</ol>
<p>这意味着，只要你还没有进行commit操作，就可以撤销文件的修改。一旦commit，checkout命令就无效</p>
</blockquote>
<h4 id="rm-路径-文件名-git-rm-路径-文件名"><a href="#rm-路径-文件名-git-rm-路径-文件名" class="headerlink" title="rm  路径+文件名  git rm 路径+文件名"></a>rm  路径+文件名  git rm 路径+文件名</h4><blockquote>
<p>文件的删除</p>
</blockquote>
<blockquote>
<p>rm 路径+文件名并不会真正删除文件，而确定要真正删除文件，还需要再rm命令基础上，加上git rm命令，确定文件删除，最后执行git commit命令，提交修改。</p>
</blockquote>
<h4 id="git-remote-或者-git-remote-v"><a href="#git-remote-或者-git-remote-v" class="headerlink" title="git remote 或者 git remote -v"></a>git remote 或者 git remote -v</h4><blockquote>
<p>查看和本地仓库关联的远程仓库信息</p>
</blockquote>
<h4 id="git-remote-show-远程仓库别名"><a href="#git-remote-show-远程仓库别名" class="headerlink" title="git remote show 远程仓库别名"></a>git remote show 远程仓库别名</h4><blockquote>
<p>查看一个远程仓库的详细信息</p>
</blockquote>
<h4 id="git-remote-rename-远程仓库别名-新别名"><a href="#git-remote-rename-远程仓库别名-新别名" class="headerlink" title="git remote rename 远程仓库别名 新别名"></a>git remote rename 远程仓库别名 新别名</h4><blockquote>
<p>修改某个远程仓库的别名</p>
</blockquote>
<h4 id="git-remote-rm-远程仓库别名"><a href="#git-remote-rm-远程仓库别名" class="headerlink" title="git remote rm 远程仓库别名"></a>git remote rm 远程仓库别名</h4><blockquote>
<p>删除本地仓库与某个远程仓库的关联</p>
</blockquote>
<h4 id="git-remote-add-远程仓库别名-103-105-x74-64-x67-x69-x74-104-x75-x62-46-99-111-109-账户名-仓库名-git"><a href="#git-remote-add-远程仓库别名-103-105-x74-64-x67-x69-x74-104-x75-x62-46-99-111-109-账户名-仓库名-git" class="headerlink" title="git remote add 远程仓库别名 &#103;&#105;&#x74;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#111;&#109;:账户名/仓库名.git"></a>git remote add 远程仓库别名 <a href="mailto:&#103;&#105;&#x74;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#111;&#109;">&#103;&#105;&#x74;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#111;&#109;</a>:账户名/仓库名.git</h4><blockquote>
<p>将本地仓库与远程仓库间建立关联</p>
</blockquote>
<h4 id="git-push-u-远程仓库别名-本地仓库分支名"><a href="#git-push-u-远程仓库别名-本地仓库分支名" class="headerlink" title="git push -u 远程仓库别名 本地仓库分支名"></a>git push -u 远程仓库别名 本地仓库分支名</h4><blockquote>
<p>将本地仓库的分支推送到远程仓库中</p>
</blockquote>
<blockquote>
<p>可以不带-u参数。带上-u参数一般是在第一次推送分支的时候，这样Git不但会将本地master分支内容推送到远程仓库中，也会将本地的分支和远程的分支关联起来，在以后的推送和拉取时简化命令。</p>
</blockquote>
<h4 id="git-clone-x67-x69-x74-x40-103-x69-116-104-x75-x62-x2e-99-111-x6d-账户名-仓库名-git"><a href="#git-clone-x67-x69-x74-x40-103-x69-116-104-x75-x62-x2e-99-111-x6d-账户名-仓库名-git" class="headerlink" title="git clone &#x67;&#x69;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#x6d;:账户名/仓库名.git"></a>git clone <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#x6d;">&#x67;&#x69;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#x6d;</a>:账户名/仓库名.git</h4><blockquote>
<p>克隆远程仓库</p>
</blockquote>
<h4 id="git-fetch-远程仓库别名"><a href="#git-fetch-远程仓库别名" class="headerlink" title="git fetch 远程仓库别名"></a>git fetch 远程仓库别名</h4><blockquote>
<p>将远程仓库的数据抓取到本地（只会拉取本地仓库还没有的数据，也就是说会抓取自从你上次克隆以来，此远程仓库的所有更新），但不会自动合并到当前工作分支，必须进行手动合并</p>
</blockquote>
<h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><blockquote>
<p>从远程仓库中抓取对应内容，并自动合并到本地仓库中当前分支</p>
</blockquote>
<h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><blockquote>
<p>当我们和别人协作开发项目时，开发周期一般都为数个星期。如果没有分支，我们写完代码就往仓库中提交，因为代码是不完整的，而不完整的代码库会让别人无法继续编写代码和进行测试工作。而且我们也不能等代码全部写完一次性提交，存在丢失进度的风险。所以需要分时来帮助我们规避上面的我呢提。创建一个属于自己的分支，别人无法访问，我们在自己的分支上进行代码的提交和修改，等到开发完毕后再一次性合并到项目分支中，这样就可以解决上面的问题。</p>
</blockquote>
<p><strong>分支底层原理</strong></p>
<blockquote>
<p><img src="/images/%E5%88%86%E6%94%AF%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.png"></p>
<p>如图所示，每个分支包含的版本号为：</p>
<p>dev1分支 v2-2 v2-1 v2 v1</p>
<p>dev2分支 v4-2 v4 v3 v2 v1 </p>
<p>dev3分支 v4-3 v4 v3 v2 v1</p>
<p>master分支 v4 v3 v2 v1</p>
<ol>
<li>当创建一个分支时就是创建一个指针。比如当前分支为master，创建分支指针为dev4，则指针dev4指向v4版本号</li>
<li>切换分支就是切换指针。比如当前分支为master，那么HEAD指针就会指向master指针。如果切换到dev2分支，则HEAD指针就会指向dev2指针</li>
<li>查看分支就是查看分支指针有哪些，并在当前分支前加上*表示区别。比如当前分支为master，调用命令 git branch则会显示：dev1 dev2 dev3 *master</li>
<li>回退版本就是将分支指针移动到相应版本号，其它什么也不做</li>
<li>删除分支就是删除分支的指针。比如删除dev2分支，就表示删除dev2指针，版本号并不删除</li>
<li>合并分支时会有两种情况。一种是合并后不会冲突，一种合并后产生冲突。合并后不会冲突指两个分支有且最多只有一个分支对文件进行了修改。那么此时不会产生冲突，所做的也只是移动指针到相应的版本号。如果合并的两个分支都对文件做了修改，当合并时就会产生冲突，这时候需要在文件中手动地进行修改，然后对修改的文件重新进行add和commit。</li>
</ol>
</blockquote>
<p>常用分支命令：</p>
<h5 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h5><blockquote>
<p>查看分支</p>
</blockquote>
<h5 id="git-branch-name"><a href="#git-branch-name" class="headerlink" title="git branch name"></a>git branch name</h5><blockquote>
<p>创建分支</p>
</blockquote>
<h5 id="git-checkout-name"><a href="#git-checkout-name" class="headerlink" title="git checkout name"></a>git checkout name</h5><blockquote>
<p>切换分支</p>
</blockquote>
<h5 id="git-checkout-b-name"><a href="#git-checkout-b-name" class="headerlink" title="git checkout -b name"></a>git checkout -b name</h5><blockquote>
<p>创建并切换分支</p>
</blockquote>
<h5 id="git-merge-name"><a href="#git-merge-name" class="headerlink" title="git merge name"></a>git merge name</h5><blockquote>
<p>合并某分支到当前分支</p>
</blockquote>
<h5 id="git-merge-–no-ff-m-“合并信息描述”"><a href="#git-merge-–no-ff-m-“合并信息描述”" class="headerlink" title="git merge –no-ff -m “合并信息描述”"></a>git merge –no-ff -m “合并信息描述”</h5><blockquote>
<p>禁用ff模式进行分支合并</p>
</blockquote>
<h5 id="git-log-–graph-pretty-oneline-–abbrev-commit"><a href="#git-log-–graph-pretty-oneline-–abbrev-commit" class="headerlink" title="git log –graph -pretty=oneline –abbrev-commit"></a>git log –graph -pretty=oneline –abbrev-commit</h5><blockquote>
<p>查看分支历史</p>
</blockquote>
<h5 id="git-branch-d-name"><a href="#git-branch-d-name" class="headerlink" title="git branch -d name"></a>git branch -d name</h5><blockquote>
<p>删除分支</p>
</blockquote>
<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><blockquote>
<p>在实际开发过程中，应该按照几个基本原则进行分支管理：</p>
<ol>
<li>master分支应该是非常稳定的，仅用于发布新版本</li>
<li>dev分支是不稳定的，等需要发布版本时，再把dev分支合并到master分支上</li>
<li>团队的每个人都在dev分支上工作，每个人都有自己的分支，可以随时往dev分支上合并</li>
</ol>
<p><img src="/images/%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86.png"></p>
<p>合并时还要注意，有两种模式。Fast Forward合并模式和普通合并模式。ff合并模式下，删除分支后会丢掉分支信息。而普通合并模式则相反，删除分支后会保留分支信息。如果要禁用ff模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
</blockquote>
<h4 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h4><blockquote>
<p>需要注意的两个问题：</p>
<ol>
<li>默认情况下，从远程仓库clone时，只能看到master分支。因此，为了创建dev分支进行修改，就必须在本地创建远程仓库的dev分支：<code>git checkout -b dev 远程仓库别名/dev</code>  然后就可以在本地分支dev上修改，然后将dev分支上的内容push到远程仓库中</li>
<li>推送时产生的分支冲突。这和本地的分支冲突相同，你得先将最新的提交从远程仓库相应分支上抓取下来，然后在本地进行合并，手动解决冲突，然后进行add，commit操作，最后再push</li>
</ol>
</blockquote>
<h5 id="多人协作流程"><a href="#多人协作流程" class="headerlink" title="多人协作流程"></a>多人协作流程</h5><blockquote>
<ol>
<li>首先，试图用 <code>git push 远程仓库别名 分支</code> 推送自己的修改</li>
<li>如果推送失败，是因为远程分支比本地的分支版本更新，需要由拉取内容到本地尝试进行分支合并</li>
<li>如果合并有冲突，需要解决冲突，并在本地进行提交</li>
<li>没有冲突或冲突解决后，再通过 <code>git push 远程仓库别名 分支名</code>推送就能推送成功</li>
<li>如果 <code>git pull</code>提示“no tracking information” 则说明本地分支和远程分支的链接关系没有创建，则需要通过命令： <code>git branch -set-upstream 本地分支名 远程仓库别名/分支名</code> 进行创建</li>
</ol>
</blockquote>
<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><blockquote>
<p>Git使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是一个不会变化的分支，指向特定提交对象的引用。而含附注标签，则实际上是一个独立的对象，有自身的的校验信息，标签名称，电子邮件和日期，标签说明，标签本身也可通过GNU来签署和验证。通常而言，会更多地使用含附注标签。</p>
</blockquote>
<h5 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h5><blockquote>
<p>显示已有标签</p>
</blockquote>
<h5 id="git-show-标签名"><a href="#git-show-标签名" class="headerlink" title="git show 标签名"></a>git show 标签名</h5><blockquote>
<p>显示相应标签的详细信息，和打标签的提交对象</p>
</blockquote>
<h5 id="git-tag-标签名"><a href="#git-tag-标签名" class="headerlink" title="git tag 标签名"></a>git tag 标签名</h5><blockquote>
<p>创建一个轻量级标签</p>
</blockquote>
<h5 id="git-tag-a-标签名-m-‘标签信息描述’"><a href="#git-tag-a-标签名-m-‘标签信息描述’" class="headerlink" title="git tag -a 标签名 -m ‘标签信息描述’"></a>git tag -a 标签名 -m ‘标签信息描述’</h5><blockquote>
<p>创建一个含附注的标签</p>
</blockquote>
<h5 id="git-tag-s-标签名-m-‘标签信息描述’"><a href="#git-tag-s-标签名-m-‘标签信息描述’" class="headerlink" title="git tag -s 标签名 -m ‘标签信息描述’"></a>git tag -s 标签名 -m ‘标签信息描述’</h5><blockquote>
<p>用GPG来签署标签</p>
</blockquote>
<h5 id="git-push-远程仓库别名-标签名"><a href="#git-push-远程仓库别名-标签名" class="headerlink" title="git push 远程仓库别名 标签名"></a>git push 远程仓库别名 标签名</h5><blockquote>
<p>默认情况下，git push并不会将标签传送到远程仓库上，只有通过显示命令才能分享标签到远程仓库</p>
</blockquote>
<h4 id="git-push-远程仓库别名-–tags"><a href="#git-push-远程仓库别名-–tags" class="headerlink" title="git push 远程仓库别名 –tags"></a>git push 远程仓库别名 –tags</h4><blockquote>
<p>一次性将所有本地所有的标签推送到远程仓库上（只推送本地新增的，已推的不会再推送）</p>
</blockquote>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava RateLimiter</title>
    <url>/2020/08/09/Guava-RateLimiter/</url>
    <content><![CDATA[<p>Google Guava提供的<code>RateLimiter</code>使用的是令牌桶算法。令牌桶算法的基本思想是以固定的速率生成令牌，在执行请求之前都需要从令牌桶里获取足够的令牌。当令牌数量不足的时候，请求将被阻塞进入等待状态或者直接返回失败。<code>RateLimiter</code>常用于限制访问资源的速率。</p>
<span id="more"></span>

<h2 id="RateLimiter使用示例"><a href="#RateLimiter使用示例" class="headerlink" title="RateLimiter使用示例"></a>RateLimiter使用示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1秒钟产生0.5张令牌</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> RateLimiter limiter = RateLimiter.create(<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">5</span>).forEach(i -&gt; service.submit(RateLimiterTest::testLimiter));</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testLimiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot; waiting &quot;</span> + limiter.acquire());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，定义了一个<code>RateLimiter</code>实例，每秒钟产生0.5张令牌，即每2秒钟产生1张令牌。<code>testLimiter</code>方法中通过<code>limiter.acquire()</code>方法获取令牌（不带参数时默认获取1张令牌）。<code>Executors.newFixedThreadPool(5)</code>生成五个线程，并发调用<code>testLimiter</code>方法，执行代码，控制台输出如下所示：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Thread</span>[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main] waiting <span class="number">0</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">Thread</span>[pool-<span class="number">1</span>-thread-<span class="number">5</span>,<span class="number">5</span>,main] waiting <span class="number">1</span>.<span class="number">908947</span></span><br><span class="line"><span class="attribute">Thread</span>[pool-<span class="number">1</span>-thread-<span class="number">4</span>,<span class="number">5</span>,main] waiting <span class="number">3</span>.<span class="number">908935</span></span><br><span class="line"><span class="attribute">Thread</span>[pool-<span class="number">1</span>-thread-<span class="number">3</span>,<span class="number">5</span>,main] waiting <span class="number">5</span>.<span class="number">908919</span></span><br><span class="line"><span class="attribute">Thread</span>[pool-<span class="number">1</span>-thread-<span class="number">2</span>,<span class="number">5</span>,main] waiting <span class="number">7</span>.<span class="number">908808</span></span><br></pre></td></tr></table></figure>

<p>可以看到每个线程调用时间相隔大约为2秒钟。那为什么第一个线程没有等待2秒，直接就获取到了令牌然后执行了呢？是这样的，Guava RateLimiter允许某次请求获取超出剩余令牌数的令牌，但是下一次请求将为此付出代价，一直等到令牌亏空补上。来看个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RateLimiter limiter = RateLimiter.create(<span class="number">1</span>);</span><br><span class="line">        System.out.println(limiter.acquire(<span class="number">4</span>));</span><br><span class="line">        System.out.println(limiter.acquire(<span class="number">3</span>));</span><br><span class="line">        System.out.println(limiter.acquire(<span class="number">2</span>));</span><br><span class="line">        System.out.println(limiter.acquire(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">0</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">3</span>.<span class="number">996602</span></span><br><span class="line"><span class="attribute">2</span>.<span class="number">997448</span></span><br><span class="line"><span class="attribute">2</span>.<span class="number">000229</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，一秒钟产生一张令牌，第一次请求直接取出4张令牌，所以第二次请求需要等待4/1秒才能取到令牌。经过大约4秒后，第二次请求直接取出3张令牌，所以第三次请求需要等待3/1秒后才能取到令牌，依此类推。</p>
<h2 id="设置超时时间"><a href="#设置超时时间" class="headerlink" title="设置超时时间"></a>设置超时时间</h2><p>可以设置等待令牌的超时时间，如果等待令牌的时间大于超时时间，将直接返回false，不再等待：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RateLimiter limiter = RateLimiter.create(<span class="number">1</span>);</span><br><span class="line">        System.out.println(limiter.acquire(<span class="number">3</span>));</span><br><span class="line">        System.out.println(limiter.tryAcquire(<span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子<code>limiter.tryAcquire</code>设置了超时时间为2秒，由于第一次请求一次性获取了3张令牌，所以这里需要等待大约3秒钟，超出了2秒的超时时间，所以<code>limiter.tryAcquire</code>不会等待3秒，而是直接返回false。</p>
]]></content>
      <tags>
        <tag>guava</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava缓存</title>
    <url>/2020/08/09/Guava%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>Guava缓存是轻量级的，它将内容缓存到运行内存中。如果系统中某些值（比如一些配置表）被频繁查询使用，并且我们愿意消耗一些内存空间来提升应用的速度，减轻数据库压力的话，Guava缓存将会是一个不错的选择。由于缓存是存储在运行内存中的，所以需要确保缓存的大小不超出内存的容量。</p>
<span id="more"></span>

<h2 id="创建缓存"><a href="#创建缓存" class="headerlink" title="创建缓存"></a>创建缓存</h2><p>可以直接创建Guava缓存对象，而不使用任何的CacheLoader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">System.out.println(cache.getIfPresent(<span class="string">&quot;hello&quot;</span>)); <span class="comment">//  world</span></span><br></pre></td></tr></table></figure>

<p>key值是大小写敏感的，所以使用<code>cache.getIfPresent(&quot;HELLO&quot;)</code>将返回null值。</p>
<p>接下来看看如何使用CacheLoader创建缓存对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CacheLoader&lt;String, String&gt; loader = <span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sayHello(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(loader);</span><br><span class="line"></span><br><span class="line">String mrbird = cache.getUnchecked(<span class="string">&quot;mrbird&quot;</span>);</span><br><span class="line">System.out.println(mrbird); <span class="comment">// hello mrbird</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">sayHello</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;hello %s&quot;</span>, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法<code>getUnchecked</code>作用为：当值不存在时，会通过CacheLoader计算出值，然后存到缓存中</p>
<h2 id="驱逐机制"><a href="#驱逐机制" class="headerlink" title="驱逐机制"></a>驱逐机制</h2><p>可以定义一些驱逐缓存的机制来限制缓存的大小</p>
<h3 id="限制缓存数目"><a href="#限制缓存数目" class="headerlink" title="限制缓存数目"></a>限制缓存数目</h3><p>可以通过<code>maximumSize</code>来限制缓存的条目：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().maximumSize(<span class="number">3</span>).build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;k4&quot;</span>, <span class="string">&quot;v4&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(cache.size()); <span class="comment">// 3</span></span><br><span class="line">System.out.println(cache.getIfPresent(<span class="string">&quot;k1&quot;</span>)); <span class="comment">// null</span></span><br><span class="line">System.out.println(cache.asMap()); <span class="comment">// &#123;k3=v3, k4=v4, k2=v2&#125;</span></span><br></pre></td></tr></table></figure>

<p>限制最多只能存储3个值，所以k4的存入把最早的k1给驱逐出去了，类似于FIFO</p>
<h3 id="限制缓存大小"><a href="#限制缓存大小" class="headerlink" title="限制缓存大小"></a>限制缓存大小</h3><p>可以自定义权重函数来限制缓存的大小：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Weigher&lt;String, String&gt; weigher = (key, value) -&gt; value.length();</span><br><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().maximumWeight(<span class="number">15</span>).weigher(weigher).build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;11111&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;22222&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;33333&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;k4&quot;</span>, <span class="string">&quot;4444&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;k5&quot;</span>, <span class="string">&quot;5555&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(cache.size()); <span class="comment">// 3</span></span><br><span class="line">System.out.println(cache.getIfPresent(<span class="string">&quot;k1&quot;</span>)); <span class="comment">// null</span></span><br><span class="line">System.out.println(cache.asMap()); <span class="comment">// &#123;k3=33333, k5=5555, k4=4444&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，通过<code>maximumWeight(15)</code>指定了缓存的最大容量，权重规则为value的长度。k3，k4和k5的value长度加起来为13，所以k1和k2的值存不下了，被驱逐</p>
<h3 id="设置缓存时间"><a href="#设置缓存时间" class="headerlink" title="设置缓存时间"></a>设置缓存时间</h3><p>可以设置缓存的有效时间和缓存的活跃时间</p>
<h4 id="设置缓存的活跃时间为2s"><a href="#设置缓存的活跃时间为2s" class="headerlink" title="设置缓存的活跃时间为2s"></a>设置缓存的活跃时间为2s</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().expireAfterAccess(<span class="number">2</span>, TimeUnit.SECONDS).build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line"></span><br><span class="line">cache.getIfPresent(<span class="string">&quot;k1&quot;</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">cache.getIfPresent(<span class="string">&quot;k1&quot;</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(cache.getIfPresent(<span class="string">&quot;k1&quot;</span>)); <span class="comment">// v1</span></span><br><span class="line">System.out.println(cache.getIfPresent(<span class="string">&quot;k2&quot;</span>)); <span class="comment">// null</span></span><br><span class="line">System.out.println(cache.size()); <span class="comment">// 1</span></span><br><span class="line">System.out.println(cache.asMap()); <span class="comment">// &#123;k1=v1&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，我们通过<code>cache.getIfPresent(&quot;k1&quot;)</code>获取了k1的值，然后让线程阻塞1秒，这时候k1和k2的有效时间大约为1秒左右。接着又获取了k1的值，所以k1的有效时间还是2秒，k2为1秒，再次让线程阻塞1秒后，k1的有效时间为1秒，k2已经失效了。打印输出的结果和我们预期的一致。</p>
<h4 id="设置缓存的有效时间为2s"><a href="#设置缓存的有效时间为2s" class="headerlink" title="设置缓存的有效时间为2s"></a>设置缓存的有效时间为2s</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().expireAfterWrite(<span class="number">2</span>, TimeUnit.SECONDS).build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line"></span><br><span class="line">cache.getIfPresent(<span class="string">&quot;k1&quot;</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">cache.getIfPresent(<span class="string">&quot;k1&quot;</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(cache.getIfPresent(<span class="string">&quot;k1&quot;</span>)); <span class="comment">// null</span></span><br><span class="line">System.out.println(cache.getIfPresent(<span class="string">&quot;k2&quot;</span>)); <span class="comment">// null</span></span><br><span class="line">System.out.println(cache.size()); <span class="comment">// 0</span></span><br><span class="line">System.out.println(cache.asMap()); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>设置缓存有效时间为2秒，所以2秒后所有缓存都过期失效了，无论期间获取过多少次缓存</p>
<h3 id="weakKeys-amp-softValues"><a href="#weakKeys-amp-softValues" class="headerlink" title="weakKeys&amp;softValues"></a>weakKeys&amp;softValues</h3><p>默认情况下，Guava缓存键值都有强引用，我们可以使用weakKeys和softValues来让键值变为弱引用，这样垃圾收集器在必要的情况下将会工作：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = <span class="module-access"><span class="module"><span class="identifier">CacheBuilder</span>.</span></span><span class="keyword">new</span><span class="constructor">Builder()</span>.weak<span class="constructor">Keys()</span>.soft<span class="constructor">Values()</span>.build<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>

<h2 id="刷新缓存"><a href="#刷新缓存" class="headerlink" title="刷新缓存"></a>刷新缓存</h2><p>可以通过<code>refreshAfterWrite</code>设置缓存自动刷新间隔，或者可以直接调用<code>refresh</code>方法来手动刷新缓存：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = <span class="module-access"><span class="module"><span class="identifier">CacheBuilder</span>.</span></span><span class="keyword">new</span><span class="constructor">Builder()</span>.refresh<span class="constructor">AfterWrite(1,TimeUnit.SECONDS)</span>.build<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>

<h2 id="添加多个缓存"><a href="#添加多个缓存" class="headerlink" title="添加多个缓存"></a>添加多个缓存</h2><p>通过<code>putAll</code>来一次性添加多个缓存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build();</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; map = Maps.newHashMap();</span><br><span class="line">map.put(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>);</span><br><span class="line"></span><br><span class="line">cache.putAll(map);</span><br><span class="line">System.out.println(cache.size()); <span class="comment">// 3</span></span><br><span class="line">System.out.println(cache.asMap()); <span class="comment">// &#123;k3=v3, k1=v1, k2=v2&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="删除缓存"><a href="#删除缓存" class="headerlink" title="删除缓存"></a>删除缓存</h2><p><code>Cache.invalidate(key)</code>方法通过key来删除缓存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build();</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; map = Maps.newHashMap();</span><br><span class="line">map.put(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">cache.putAll(map);</span><br><span class="line"></span><br><span class="line">System.out.println(cache.asMap()); <span class="comment">// &#123;k1=v1&#125;</span></span><br><span class="line">cache.invalidate(<span class="string">&quot;k1&quot;</span>);</span><br><span class="line">System.out.println(cache.asMap()); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>除此之外，我们也可以通过<code>Cache.invalidateAll(keys)</code>一次性删除多个缓存或者<code>Cache.invalidateAll()</code>删除全部缓存。</p>
<p>我们还可以给删除事件添加监听器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RemovalListener&lt;String, String&gt; listener</span><br><span class="line">                = notification -&gt; System.out.println(<span class="string">&quot;监听到删除事件，key=&quot;</span> + notification.getKey() + <span class="string">&quot;，value=&quot;</span> + notification.getValue());</span><br><span class="line"></span><br><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().removalListener(listener).build();</span><br><span class="line">cache.put(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line"></span><br><span class="line">cache.invalidate(<span class="string">&quot;k1&quot;</span>); <span class="comment">// 监听到删除事件，key=k1，value=v1</span></span><br></pre></td></tr></table></figure>

<h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaCacheUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(GuavaCacheUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Cache&lt;String, String&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        RemovalListener&lt;String, String&gt; listener</span><br><span class="line">                = n -&gt; logger.info(<span class="string">&quot;监听到删除事件，key=&#123;&#125;，value=&#123;&#125;&quot;</span>, n.getKey(), n.getValue());</span><br><span class="line">        cache = CacheBuilder.newBuilder()</span><br><span class="line">                .removalListener(listener).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(key) &amp;&amp; StringUtils.isNotBlank(value)) &#123;</span><br><span class="line">            cache.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量添加缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map key,value集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        cache.putAll(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(key)) &#123;</span><br><span class="line">            cache.invalidate(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys key集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(List&lt;String&gt; keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(keys)) &#123;</span><br><span class="line">            cache.invalidateAll(keys);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cache.invalidateAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.isNotBlank(key) ? cache.getIfPresent(key) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量获取缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys 键集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ImmutableMap&lt;String, String&gt; <span class="title">get</span><span class="params">(List&lt;String&gt; keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CollectionUtils.isNotEmpty(keys) ? cache.getAllPresent(keys) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>guava</tag>
      </tags>
  </entry>
  <entry>
    <title>HashSet源码解析</title>
    <url>/2020/09/15/HashSet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>HashSet源码解析，基于JDK1.8</p>
<span id="more"></span>

<h2 id="HashSet类结构关系"><a href="#HashSet类结构关系" class="headerlink" title="HashSet类结构关系"></a>HashSet类结构关系</h2><p>HashSet类层级关系图：</p>
<p><img src="/images/HashSet%E7%B1%BB%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.png"></p>
<p>HashSet实现了Set接口，为什么叫HashSet？因为HashSet内部采用哈希表（实际就是HashMap）来存储不重复的数据，查看HashSet内部属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用HashMap存储数据，HashSet的数据实际为HashMap的key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="comment">// HashMap value占位符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<p>HashMap的key是不允许重复的，这也正好符合Set的特性。因为HashSet内部采用HashMap存储数据，所以HashSet可以存储null值，支持快速失败，非线程安全。</p>
<h3 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空参构造函数，内部初始化map属性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入集合对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化map，计算map的容量</span></span><br><span class="line">    <span class="comment">// 计算公式为 c.size/0.75f + 1，如果值小于16，则取值16。</span></span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    <span class="comment">// 将集合中的所有元素添加进去</span></span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动指定容量和加载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动指定容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，创建HashSet的本质就是初始化HashMap。</p>
<h4 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h4><p><code>add(E e)</code>添加指定元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 往map里添加元素，如果key已经存在则返回false，否则返回true</span></span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h4><p><code>size()</code>获取元素个数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 本质就是获取map的元素个数</span></span><br><span class="line">    <span class="keyword">return</span> map.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="contains-Object-o"><a href="#contains-Object-o" class="headerlink" title="contains(Object o)"></a>contains(Object o)</h4><p><code>contains(Object o)</code>判断是否包含指定元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 本质就是判断map中是否包含该key</span></span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty()"></a>isEmpty()</h4><p><code>isEmpty()</code>判断集合是否为空：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 本质就是判断map是否为空</span></span><br><span class="line">    <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h4><p><code>remove(Object o)</code>删除指定元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 本质就是通过key删除map中的元素，如果该key存在，则返回true，否则返回false</span></span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h4><p><code>clear()</code>清空集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 本质就是清空map</span></span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="iterator"><a href="#iterator" class="headerlink" title="iterator()"></a>iterator()</h4><p><code>iterator()</code>获取迭代器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 本质就是获取map key的迭代器</span></span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>HashTable源码解析</title>
    <url>/2020/09/07/HashTable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>HashTable是Map接口线程安全实现版本，数据结构和方法实现与HashMap类似，本文记录HashTable源码解析，基于JDK1.8</p>
<span id="more"></span>

<h2 id="类层级关系"><a href="#类层级关系" class="headerlink" title="类层级关系"></a>类层级关系</h2><p>HashTable类层级关系图：</p>
<p><img src="/images/HashTable%E7%B1%BB%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.png"></p>
<p>主要成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部采用Entry数组存储键值对数据，Entry实际为单向链表的表头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"><span class="comment">// HashTable里键值对个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">// 扩容阈值，当超过这个值时，进行扩容操作，计算方式为：数组容量*加载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 加载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">// 用于快速失败</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>table属性通过transient修饰，原因在介绍<a href="https://mrbird.cc/Java-HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html">HashMap源码</a>的时候分析过。</p>
<p>Entry代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Entry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Entry&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key =  key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Entry为单向链表节点，HashTable采用数组加链表的方式存储数据，不过没有类似于HashMap中当链表过长时转换为红黑树的操作</p>
<h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置指定容量和加载因子，初始化HashTable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Load: &quot;</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 容量最小为1</span></span><br><span class="line">        initialCapacity = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    table = <span class="keyword">new</span> Entry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    <span class="comment">// 初始扩容阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置指定容量初始HashTable，加载因子为0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动指定数组初始容量为11，加载因子为0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h3><p><code>put(K key, V value)</code>添加指定键值对，键和值都不能为null：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法synchronized修饰，线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">// 得到key的哈希值</span></span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">// 得到该key存在到数组中的下标</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">// 得到该下标对应的Entry</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="comment">// 如果该下标的Entry不为null，则进行链表遍历</span></span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="comment">// 遍历链表，如果存在key相等的节点，则替换这个节点的值，并返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果数组下标对应的节点为空，或者遍历链表后发现没有和该key相等的节点，则执行插入操作</span></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">// 判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">        <span class="comment">// 如果count大于等于扩容阈值，则进行扩容</span></span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line">        tab = table;</span><br><span class="line">        <span class="comment">// 扩容后，重新计算该key在扩容后table里的下标</span></span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creates the new entry.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">// 采用头插的方式插入，index位置的节点为新节点的next节点</span></span><br><span class="line">    <span class="comment">// 新节点取代inde位置节点</span></span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">// count+1</span></span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash()"></a>rehash()</h3><p><code>rehash</code>扩容操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 暂存旧的table和容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新容量为旧容量的2n+1倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 判断新容量是否超过最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果旧容量已经是最大容量大话，就不扩容了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 新容量最大值只能是MAX_ARRAY_SIZE</span></span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用新容量创建一个新Entry数组</span></span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line">    <span class="comment">// 模数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 重新计算下次扩容阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将新Entry数组赋值给table</span></span><br><span class="line">    table = newMap;</span><br><span class="line">    <span class="comment">// 遍历数组和链表，进行新table赋值操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h3><p><code>get(Object key)</code>获取指定key对应的value：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">// 根据key哈希得到index，遍历链表取值</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized修饰，线程安全</p>
<h3 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove(Object key)"></a>remove(Object key)</h3><p><code>remove(Object key)</code>删除指定key，返回对应的value：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">// 获取key对应的index</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">// 遍历链表，如果找到key相等的节点，则改变前继和后继节点的关系，并删除相应引用，让GC回收</span></span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; prev = <span class="keyword">null</span> ; e != <span class="keyword">null</span> ; prev = e, e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.next = e.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index] = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized修饰，线程安全</p>
<h2 id="和HashMap对比"><a href="#和HashMap对比" class="headerlink" title="和HashMap对比"></a>和HashMap对比</h2><ol>
<li><p>线程是否安全：HashMap是线程不安全的，HashTable是线程安全的；HashTable内部的方法基本都经过 synchronized修饰；</p>
</li>
<li><p>对Null key 和Null value的支持：HashMap中，null可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为null；HashTable中key和value都不能为null，否则抛出空指针异常；</p>
</li>
<li><p>初始容量大小和每次扩充容量大小的不同：</p>
<p>3.1. 创建时如果不指定容量初始值，Hashtable默认的初始大小为11，之后每次扩容，容量变为原来的2n+1。HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍；</p>
<p>3.2. 创建时如果给定了容量初始值，那么Hashtable会直接使用你给定的大小，而HashMap会将其扩充 为2的幂次方大小。</p>
</li>
<li><p>底层数据结构：JDK1.8及以后的HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间，Hashtable没有这样的机制。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON</title>
    <url>/2020/04/27/JSON/</url>
    <content><![CDATA[<p>JSON全称 <code>JavaScript Object Notation</code>，是一种轻量级的数据交换格式。虽然格式上和JavaScript对象很像，但是两者间没有什么直接的联系。如果硬要说关联的话，那么JSON是一个具有严格条件的JavaScript对象，比如：</p>
<table>
<thead>
<tr>
<th>对比内容</th>
<th>JSON</th>
<th>JavaScript对象</th>
</tr>
</thead>
<tbody><tr>
<td>键名</td>
<td>必须加双引号“ ”</td>
<td>可加双引号，也可不加；也可以加单引号</td>
</tr>
<tr>
<td>属性值</td>
<td>只能是数值，字符串，布尔值，null等符合JSON要求的对象，不能是函数</td>
<td>什么都可以</td>
</tr>
<tr>
<td>逗号问题</td>
<td>最后一个属性后面不能有逗号</td>
<td>可以</td>
</tr>
<tr>
<td>数值</td>
<td>不能以0开头，小数点后面必须有数字</td>
<td>没有限制</td>
</tr>
</tbody></table>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;; <span class="comment">// 这只是 JS 对象</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 可把这个称做：JSON 格式的 JavaScript 对象 </span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    <span class="string">&quot;width&quot;</span>:<span class="number">100</span>,</span><br><span class="line">    <span class="string">&quot;height&quot;</span>:<span class="number">200</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;rose&quot;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 可把这个称做：JSON 格式的字符串</span></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">	&quot;width&quot;:100,</span></span><br><span class="line"><span class="string">        &quot;height&quot;:200,</span></span><br><span class="line"><span class="string">            &quot;name&quot;:&quot;rose&quot;&#125;&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这个可叫 JSON 格式的数组，是 JSON 的稍复杂一点的形式</span></span><br><span class="line"><span class="keyword">var</span> arr = [  </span><br><span class="line">    &#123;<span class="string">&quot;width&quot;</span>:<span class="number">100</span>,<span class="string">&quot;height&quot;</span>:<span class="number">200</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;rose&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;width&quot;</span>:<span class="number">100</span>,<span class="string">&quot;height&quot;</span>:<span class="number">200</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;rose&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;width&quot;</span>:<span class="number">100</span>,<span class="string">&quot;height&quot;</span>:<span class="number">200</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;rose&quot;</span>&#125;,</span><br><span class="line">];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这个可叫稍复杂一点的 JSON 格式的字符串     </span></span><br><span class="line"><span class="keyword">var</span> str2=<span class="string">&#x27;[&#x27;</span>+  </span><br><span class="line">    <span class="string">&#x27;&#123;&quot;width&quot;:100,&quot;height&quot;:200,&quot;name&quot;:&quot;rose&quot;&#125;,&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;&#123;&quot;width&quot;:100,&quot;height&quot;:200,&quot;name&quot;:&quot;rose&quot;&#125;,&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;&#123;&quot;width&quot;:100,&quot;height&quot;:200,&quot;name&quot;:&quot;rose&quot;&#125;,&#x27;</span>+</span><br><span class="line"><span class="string">&#x27;]&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="将JavaScript对象转化为JSON字符串"><a href="#将JavaScript对象转化为JSON字符串" class="headerlink" title="将JavaScript对象转化为JSON字符串"></a>将JavaScript对象转化为JSON字符串</h2><p><strong>JSON.stringify</strong></p>
<p><code>JSON.stringify(value, replacer, space)</code></p>
<h3 id="仅使用一个参数"><a href="#仅使用一个参数" class="headerlink" title="仅使用一个参数"></a>仅使用一个参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建js对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;DougWilson&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">24</span>&#125;;</span><br><span class="line"><span class="comment">//将此对象转成json字符串</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line"><span class="comment">// &quot;&#123;&quot;name&quot;:&quot;DougWilson&quot;,&quot;age&quot;:24&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用两个参数"><a href="#使用两个参数" class="headerlink" title="使用两个参数"></a>使用两个参数</h3><h4 id="第二个参数是一个函数"><a href="#第二个参数是一个函数" class="headerlink" title="第二个参数是一个函数"></a>第二个参数是一个函数</h4><p>序列化过程的每个属性都会被这个函数进行转化和处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> friend=&#123;  </span><br><span class="line">    <span class="string">&quot;firstName&quot;</span>: <span class="string">&quot;Doug&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lastName&quot;</span>: <span class="string">&quot;Wilson&quot;</span>,</span><br><span class="line">    <span class="string">&quot;phone&quot;</span>:<span class="string">&quot;773445&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:<span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> friendAfter=<span class="built_in">JSON</span>.stringify(friend,<span class="function"><span class="keyword">function</span>(<span class="params">key,value</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(key===<span class="string">&quot;phone&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(0592-)&quot;</span>+value;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> value === <span class="string">&quot;number&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> value + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> value; <span class="comment">//如果你把这个else分句删除，那么结果会是undefined</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(friendAfter);  </span><br><span class="line"><span class="comment">//输出：&#123;&quot;firstName&quot;:&quot;Doug&quot;,&quot;lastName&quot;:&quot;Wilson&quot;,&quot;phone&quot;:&quot;(0592-)773445&quot;,&quot;age&quot;:28&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="第二个参数是一个数组"><a href="#第二个参数是一个数组" class="headerlink" title="第二个参数是一个数组"></a>第二个参数是一个数组</h4><p>只有在这个数组中的属性才会被序列化到JSON字符串结果中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> friend=&#123;  </span><br><span class="line">    <span class="string">&quot;firstName&quot;</span>: <span class="string">&quot;Doug&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lastName&quot;</span>: <span class="string">&quot;Wilson&quot;</span>,</span><br><span class="line">    <span class="string">&quot;phone&quot;</span>:<span class="string">&quot;773445&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:<span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//注意下面的数组有一个值并不是上面对象的任何一个属性名</span></span><br><span class="line"><span class="keyword">var</span> friendAfter=<span class="built_in">JSON</span>.stringify(friend,[<span class="string">&quot;firstName&quot;</span>,<span class="string">&quot;address&quot;</span>,<span class="string">&quot;phone&quot;</span>]);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(friendAfter);  </span><br><span class="line"><span class="comment">//&#123;&quot;firstName&quot;:&quot;Doug&quot;,&quot;phone&quot;:&quot;773445&quot;&#125;</span></span><br><span class="line"><span class="comment">//指定的“address”由于没有在原来的对象中找到而被忽略</span></span><br><span class="line"><span class="comment">//而age则因为不在数组中也被忽略</span></span><br></pre></td></tr></table></figure>

<h4 id="第二个参数为null"><a href="#第二个参数为null" class="headerlink" title="第二个参数为null"></a>第二个参数为null</h4><p>和没有第二个参数没有区别，但是在不想设置第二个参数，只想设置第三个参数时，就可以将第二个参数设置为null</p>
<h3 id="使用三个参数"><a href="#使用三个参数" class="headerlink" title="使用三个参数"></a>使用三个参数</h3><p>第三个参数用于美化输出：</p>
<ol>
<li>如果为1-10的某个数字，代表使用几个空白符进行缩进</li>
<li>如果是字符串，表示用该字符串代替空格，最多取该字符串前10个字符</li>
<li>没有设置该参数或者设置为null，等同于没有使用第三个参数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> friend=&#123;  </span><br><span class="line">    <span class="string">&quot;firstName&quot;</span>: <span class="string">&quot;Doug&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lastName&quot;</span>: <span class="string">&quot;Wilson&quot;</span>,</span><br><span class="line">    <span class="string">&quot;phone&quot;</span>:&#123;<span class="string">&quot;home&quot;</span>:<span class="string">&quot;1234567&quot;</span>,<span class="string">&quot;work&quot;</span>:<span class="string">&quot;7654321&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//直接转化是这样的：</span></span><br><span class="line"><span class="comment">//&#123;&quot;firstName&quot;:&quot;Doug&quot;,&quot;lastName&quot;:&quot;Wilson&quot;,&quot;phone&quot;:&#123;&quot;home&quot;:&quot;1234567&quot;,&quot;work&quot;:&quot;7654321&quot;&#125;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> friendAfter=<span class="built_in">JSON</span>.stringify(friend,<span class="literal">null</span>,<span class="number">4</span>);  </span><br><span class="line"><span class="built_in">console</span>.log(friendAfter);  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    &quot;firstName&quot;: &quot;Doug&quot;,</span></span><br><span class="line"><span class="comment">    &quot;lastName&quot;: &quot;Wilson&quot;,</span></span><br><span class="line"><span class="comment">    &quot;phone&quot;: &#123;</span></span><br><span class="line"><span class="comment">        &quot;home&quot;: &quot;1234567&quot;,</span></span><br><span class="line"><span class="comment">        &quot;work&quot;: &quot;7654321&quot;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> friendAfter=<span class="built_in">JSON</span>.stringify(friend,<span class="literal">null</span>,<span class="string">&quot;HAHAHAHA&quot;</span>);  </span><br><span class="line"><span class="built_in">console</span>.log(friendAfter);  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">HAHAHAHA&quot;firstName&quot;: &quot;Doug&quot;,  </span></span><br><span class="line"><span class="comment">HAHAHAHA&quot;lastName&quot;: &quot;Wilson&quot;,  </span></span><br><span class="line"><span class="comment">HAHAHAHA&quot;phone&quot;: &#123;  </span></span><br><span class="line"><span class="comment">HAHAHAHAHAHAHAHA&quot;home&quot;: &quot;1234567&quot;,  </span></span><br><span class="line"><span class="comment">HAHAHAHAHAHAHAHA&quot;work&quot;: &quot;7654321&quot;  </span></span><br><span class="line"><span class="comment">HAHAHAHA&#125;  </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> friendAfter=<span class="built_in">JSON</span>.stringify(friend,<span class="literal">null</span>,<span class="string">&quot;WhatAreYouDoingNow&quot;</span>);  </span><br><span class="line"><span class="built_in">console</span>.log(friendAfter);  </span><br><span class="line"><span class="comment">/* 最多只取10个字符</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">WhatAreYou&quot;firstName&quot;: &quot;Doug&quot;,  </span></span><br><span class="line"><span class="comment">WhatAreYou&quot;lastName&quot;: &quot;Wilson&quot;,  </span></span><br><span class="line"><span class="comment">WhatAreYou&quot;phone&quot;: &#123;  </span></span><br><span class="line"><span class="comment">WhatAreYouWhatAreYou&quot;home&quot;: &quot;1234567&quot;,  </span></span><br><span class="line"><span class="comment">WhatAreYouWhatAreYou&quot;work&quot;: &quot;7654321&quot;  </span></span><br><span class="line"><span class="comment">WhatAreYou&#125;  </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="需要注意的几个地方"><a href="#需要注意的几个地方" class="headerlink" title="需要注意的几个地方"></a>需要注意的几个地方</h3><ol>
<li><p>键名不是双引号的（包括没有引号或者是单引号），会自动变成双引号；字符串是单引号的，会自动变成双引号。</p>
</li>
<li><p>最后一个属性后面有逗号的，会被自动去掉。</p>
</li>
<li><p>非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中 这个好理解，也就是对非数组对象在最终字符串中不保证属性顺序和原来一致。</p>
</li>
<li><p>布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值 也就是你的什么<code>new String(“bala”)</code>会变成”bala”，<code>new Number(2017)</code>会变成2017。</p>
</li>
<li><p><code>undefined</code>、任意的函数（除了一个toJSON函数）以及 symbol值。</p>
<ul>
<li>出现在非数组对象的属性值中：在序列化过程中会被忽略。</li>
<li>出现在数组中时：被转换成 <code>null</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="attr">x</span>: <span class="literal">undefined</span>, <span class="attr">y</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;, <span class="attr">z</span>: <span class="built_in">Symbol</span>(<span class="string">&quot;&quot;</span>)&#125;);  </span><br><span class="line"><span class="comment">//出现在非数组对象的属性值中被忽略：&quot;&#123;&#125;&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify([<span class="literal">undefined</span>, <span class="built_in">Object</span>, <span class="built_in">Symbol</span>(<span class="string">&quot;&quot;</span>)]);  </span><br><span class="line"><span class="comment">//出现在数组对象的属性值中，变成null：&quot;[null,null,null]&quot;</span></span><br></pre></td></tr></table></figure>

<p> 如果在一个JavaScript对象上实现了 <code>JSON.stringify</code> 序列化对象时，调用了这个对象的 <code>toJSON</code> 函数返回值作为参数，那么该函数就不会被忽略：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> info=&#123;  </span><br><span class="line">    <span class="string">&quot;msg&quot;</span>:<span class="string">&quot;I Love You&quot;</span>,</span><br><span class="line">    <span class="string">&quot;toJSON&quot;</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> replaceMsg=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">        replaceMsg[<span class="string">&quot;msg&quot;</span>]=<span class="string">&quot;Go Die&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> replaceMsg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">JSON</span>.stringify(info);  </span><br><span class="line"><span class="comment">//返回的是：&#x27;&quot;&#123;&quot;msg&quot;:&quot;Go Die&quot;&#125;&quot;&#x27;, 函数并不会被忽略</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="将JSON字符串解析为JavaScript数据结构"><a href="#将JSON字符串解析为JavaScript数据结构" class="headerlink" title="将JSON字符串解析为JavaScript数据结构"></a>将JSON字符串解析为JavaScript数据结构</h2><p><strong>JSON.parse</strong></p>
<p><code>JSON.parse(text, reviver)</code></p>
<p>如果只使用第一个参数，如果该字符串不是合法的JSON字符串的话，就会抛出错误。这里的第二个参数如果使用的话，必须是一个函数，这个函数的作用是在属性被解析完成但是还没有返回前，将属性处理后再返回：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> friend=&#123;  </span><br><span class="line">    <span class="string">&quot;firstName&quot;</span>: <span class="string">&quot;Good&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lastName&quot;</span>: <span class="string">&quot;Man&quot;</span>,</span><br><span class="line">    <span class="string">&quot;phone&quot;</span>:&#123;<span class="string">&quot;home&quot;</span>:<span class="string">&quot;1234567&quot;</span>,<span class="string">&quot;work&quot;</span>:[<span class="string">&quot;7654321&quot;</span>,<span class="string">&quot;999000&quot;</span>]&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//我们先将其序列化</span></span><br><span class="line"><span class="keyword">var</span> friendAfter=<span class="built_in">JSON</span>.stringify(friend);  </span><br><span class="line"><span class="comment">//&#x27;&#123;&quot;firstName&quot;:&quot;Good&quot;,&quot;lastName&quot;:&quot;Man&quot;,&quot;phone&quot;:&#123;&quot;home&quot;:&quot;1234567&quot;,&quot;work&quot;:[&quot;7654321&quot;,&quot;999000&quot;]&#125;&#125;&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//再将其解析出来，在第二个参数的函数中打印出key和value</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(friendAfter,<span class="function"><span class="keyword">function</span>(<span class="params">k,v</span>)</span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(k);</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;----&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">firstName  </span></span><br><span class="line"><span class="comment">Good  </span></span><br><span class="line"><span class="comment">----</span></span><br><span class="line"><span class="comment">lastName  </span></span><br><span class="line"><span class="comment">Man  </span></span><br><span class="line"><span class="comment">----</span></span><br><span class="line"><span class="comment">home  </span></span><br><span class="line"><span class="comment">1234567  </span></span><br><span class="line"><span class="comment">----</span></span><br><span class="line"><span class="comment">0  </span></span><br><span class="line"><span class="comment">7654321  </span></span><br><span class="line"><span class="comment">----</span></span><br><span class="line"><span class="comment">1  </span></span><br><span class="line"><span class="comment">999000  </span></span><br><span class="line"><span class="comment">----</span></span><br><span class="line"><span class="comment">work  </span></span><br><span class="line"><span class="comment">[]</span></span><br><span class="line"><span class="comment">----</span></span><br><span class="line"><span class="comment">phone  </span></span><br><span class="line"><span class="comment">Object  </span></span><br><span class="line"><span class="comment">----</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">Object  </span></span><br><span class="line"><span class="comment">----</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>仔细看一下输出，可以发现这个遍历是由内而外的，这个由内而外指的是对于复合属性来说的，通俗地讲，遍历的时候，从头到尾进行遍历，如果是简单属性值（数值、字符串、布尔值和null），那么直接遍历完成，如果是遇到属性值是对象或者数组形式的，那么暂停，先遍历这个子JSON，而遍历的原则也是一样的，等这个复合属性遍历完成，那么再完成对这个属性的遍历返回。</p>
<p>本质上，这就是一个深度优先的遍历。</p>
]]></content>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP常用语法</title>
    <url>/2020/01/16/JSP%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>JSP页面本质上为一个Servlet程序，当我们第一次访问JSP页面时，服务器会将JSP页面翻译成一个Servlet类。比如，一个JSP文件为 user.jsp  那么就会被翻译成 public final class user_jsp extends HttpJspBase implements…</p>
<p>而HttpJspBase extends HttpServlet implements HttpJspPage</p>
<p>具体做的事情给个简单例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=utf-8&quot;</span> language=<span class="string">&quot;java&quot;</span>%&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    	......</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    	......</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>编译后，会将该jsp文件内容转化成servlet文件，内容大体如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">void</span> <span class="function"><span class="title">_jspService</span>(<span class="params">HttpServletRequest request, HttpServletResponse response</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//省略其它内容</span></span><br><span class="line">    out = pageContext.getOut();</span><br><span class="line">    _jspx_out = out;</span><br><span class="line">    out.write(<span class="string">&quot;rn&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;!DOCTYPE HTML PUBLIC &#x27;-//W3C//DTD HTML 4.0 Transitional//EN&#x27;&gt;rn&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;html&gt;rn&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;head&gt;rn&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;...rn&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;/head&gt;rn&quot;</span>)</span><br><span class="line">    out.write(<span class="string">&quot;&lt;body&gt;rn&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;...rn&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;/body&gt;rn&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;/html&gt;rn&quot;</span>);</span><br><span class="line">    <span class="comment">//省略其它内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h2><blockquote>
<p><strong>头部page指令：设置页面的一些参数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;&lt;%@ page  language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html;charset=utf-8&quot;</span> pageEncoding=<span class="string">&quot;utf-8&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>

<p>常用属性：</p>
<p>contentType——设置响应数据字符集</p>
<p>pageEncoding——设置页面的字符集</p>
<p>import——导入java包，用于编写JSP页面中的java代码</p>
<p>errorPage——页面出错时的跳转地址</p>
</blockquote>
<blockquote>
<p><strong>声明脚本：属性声明，静态代码块使用，方法，内部类，注释，都遵守Java语法。相当于在编译后的Servlet类中定义这些java代码</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">&lt;%! </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="comment">//静态块代码</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//方法</span></span><br><span class="line">	&#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">user_jsp</span> <span class="title">extends</span> <span class="title">HttpJspBase</span> <span class="title">implements</span>... &#123;</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="comment">//静态块代码</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> _jspService(HttpServletRequest request, HttpServletResponse response&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>表达式脚本：在页面中显示的值</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;%=在页面中展示的值%&gt;</span><br><span class="line">如：</span><br><span class="line">&lt;%=<span class="string">&quot;12 * 12 = &quot;</span> + <span class="number">12</span> * <span class="number">12</span>%&gt;</span><br><span class="line">&lt;%=request.getParameter(<span class="string">&quot;username&quot;</span>)%&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">public <span class="keyword">void</span> _jspService(HttpServletRequest request, HttpServletResponse response&#123;</span><br><span class="line">	<span class="comment">//省略其它内容</span></span><br><span class="line">    out.write(<span class="string">&quot;12 * 12 = &quot;</span> + <span class="number">12</span> * <span class="number">12</span> + <span class="string">&quot;rn&quot;</span>);</span><br><span class="line">	out.write(request.getParameter(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>JSP注释：代码说明</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;%-- 注释 --%&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>Java代码脚本：相当于在编译后的Servlet类的_jspService方法中定义代码内容</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">12</span>;</span><br><span class="line">	System.out.println(<span class="string">&quot;i的值：&quot;</span> + i);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspService</span><span class="params">(HttpServletRequest request, HttpServletResponse response&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">	//省略其它内容</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> i = <span class="number">12</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    System.out.println(<span class="string">&quot;i的值：&quot;</span> + i)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>JSP的两种include指令机制：</strong></p>
<p><code>&lt;%@ include file=”header.jsp” %&gt;</code> 也称为include指令。通过file属性来指定包含的页面，当JSP转换成Servlet时引入指定文件。</p>
<p><code>&lt;jsp:include page=”header.jsp” /&gt;</code> 也称为include动作。通过page属性来指定被包含的页面，当JSP页面被请求时引入指定文件，通常用于经常改动的JSP页面，且因为被包含的JSP的改动不会影响到包含的JSP，因此不需要对包含文件进行重新编译。</p>
<p>用法区别：</p>
<ol>
<li>引入的内容不同，执行时间不同</li>
</ol>
<p>  &lt;%@include file=””%&gt; (静态包含)将被包含的文件原封不动第插入到包含页面中使用该指令的位置，然后JSP编译器再对这个合成的文件进行编译，最终编译后的文件只有一个，在翻译阶段执行。</p>
<p>  (该指令属于编译指令，发生在JSP转换为Servlet阶段。简单来说，就是在转换阶段将被包含的文件内容复制到当前页面中，然后和当前页面一起编译生成一个Servlet文件。由于容器是把两个文件合并后再执行编译，所以编译后只会生成一个class文件，因此，不管是主文件或者是被包含文件发送改变，容器都需要重新编译主文件。所以，一般而言，include指令包含静态的资源文件，比如页眉和页脚。)</p>
<ol start="2">
<li>&lt;jsp:include page=””/&gt; (动态包含)包含文件时，当该动作标识执行后，JSP程序会将请求转发到(不是重定向)被包含页面，并将执行结果输出到浏览器中，然后继续执行后面的代码，因为web容器执行两个文件，所以JSP编译器会分别对这两个文件进行编译，在请求处理阶段执行。</li>
</ol>
<p>  (该动作属于运行时方法调用，发生再运行Servlet生成响应的阶段。简单来说，就是在运行servlet时插入被包含文件的响应内容。该动作的关键在于，容器需要根据页面属性创建出一个RequestDispatcher并调用include()方法，将被包含文件的响应插到当前响应中，然后一起输出。</p>
<p>  使用include动作时，容器会分别对主文件和被包含文件进行单独的编译，所以编译后会产生两个class文件。另外，被包含文件的编译工作是在主文件运行时发生的。因此，被包含文件发送改变时，只需要重新编译被包含文件即可，而无须重新编译主文件。一般使用include动作包含经常需要变动的文件。)</p>
<p>使用注意：<br>对于include指令，由于是在编译时包含源文件，所以被包含页面可以包含可能影响主页面的JSP构造，如文档类型的设定等，不过要避免声明相同的变量或方法，否则会产生编译错误。</p>
<p>对于include动作，由于是在运行时包含响应内容，因此被包含页面不能使用任何会影响主页面的JSP构造。另外被包含页面不能包含开始和结束html及body标签。被包含页面不能修改响应状态码或者设置首部。</p>
</blockquote>
<h2 id="JSP内置对象"><a href="#JSP内置对象" class="headerlink" title="JSP内置对象"></a>JSP内置对象</h2><blockquote>
<h4 id="request-response-session-application-out-pageContext-config-page-exception"><a href="#request-response-session-application-out-pageContext-config-page-exception" class="headerlink" title="request/response/session/application/out/pageContext/config/page/exception"></a>request/response/session/application/out/pageContext/config/page/exception</h4></blockquote>
<hr>
<blockquote>
<p><strong>request对象：</strong> HttpServletRequest，封装客户端的请求信息，主要包括HTTP头信息、系统信息、请求方式、请求参数等。常用方法如下</p>
<table>
<thead>
<tr>
<th>String getParameter(String name)</th>
<th>根据name属性的值获取请求数据</th>
</tr>
</thead>
<tbody><tr>
<td>String[] getParameterValues(String name)</td>
<td>根据name属性的值获取多个请求数据</td>
</tr>
<tr>
<td>void setCharacterEncoding(String enc)</td>
<td>设定解析请求数据的编码格式，防止读取的数据的编码格式和请求数据编码格式的不一致出现乱码问题</td>
</tr>
<tr>
<td>request getRequestDispatcher(String path)</td>
<td>请求转发</td>
</tr>
<tr>
<td>void setAttribute(String name, Object)</td>
<td>将数据保存到request范围的变量中</td>
</tr>
<tr>
<td>Object getAttribute(String name)</td>
<td>获取request范围的变量中的数据</td>
</tr>
<tr>
<td>void removeAttribute(String name)</td>
<td>删除request范围的变量中的数据</td>
</tr>
<tr>
<td>Cookie[] getCookies()</td>
<td>获取所有Cookie对象</td>
</tr>
</tbody></table>
<p><strong>request作用域：一次请求过程</strong></p>
</blockquote>
<hr>
<blockquote>
<p><strong>response对象：</strong> HttpServletResponse，对客户端的响应，想客户端输出信息。常用方法如下：</p>
<table>
<thead>
<tr>
<th>sendRedirect(String path)</th>
<th>网页重定向</th>
</tr>
</thead>
<tbody><tr>
<td>setHeader(String name, String value)</td>
<td>设置HTTP响应报头信息</td>
</tr>
</tbody></table>
<p><strong>response作用域：在JSP页面内有效</strong></p>
</blockquote>
<hr>
<blockquote>
<p><strong>session对象：</strong>HttpSession，由于HTTP协议为无状态协议，当一个客户端向服务器发出请求，服务器接收到请求并返回响应后，该连接就结束了，而服务器并不保存相关的信息。为了弥补这一缺点，HTTP协议提供的session，通过session可以在应用程序的web页面间进行跳转时，保存用户的状态，使整个用户会话一直存在下去，直到浏览器关闭。</p>
<p><strong>session作用域：</strong>一次会话内有效(浏览器关闭前)</p>
</blockquote>
<hr>
<blockquote>
<p><strong>application对象：</strong>ServletContext，保存所有应用中共有数据，在服务器启动时自动创建，在服务器停止时销毁，所有用户均可访问，类似于全局变量</p>
<p><strong>application作用域：</strong>整个应用中都有效，保存的信息为全局变量</p>
</blockquote>
<hr>
<blockquote>
<p><strong>out对象：</strong>JspWriter，用于在浏览器内输出信息，并管理应用服务器上的输出缓冲区</p>
<p><strong>out作用域：</strong>当前页面内有效</p>
</blockquote>
<hr>
<blockquote>
<p><strong>pageContext对象：</strong>PageContext，由容器进行初始化和创建，可以获取当前页面的request/response/session/out/exception等对象</p>
<p><strong>pageContext作用域：</strong>当前页面内有效</p>
</blockquote>
<hr>
<blockquote>
<p><strong>config对象：</strong>ServletConfig，读取web.xml配置信息。当一个Servlet初始化时，容器会把某些信息通过config对象传递给这个Servlet。开发者可以在web.xml文件中为应用程序环境中的Servlet程序和JSP页面提供初始化参数。</p>
</blockquote>
<hr>
<blockquote>
<p><strong>page对象：</strong>JspPage，代表JSP页面本身</p>
<p><strong>page作用域：</strong>当前页面内有效</p>
</blockquote>
<hr>
<blockquote>
<p><strong>exception：</strong>JspException，处理JSP文件执行时发生的所有错误和一次，只要在page指令中设置isErrorPage属性值为true的页面中才可使用</p>
</blockquote>
<hr>
<h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><blockquote>
<p><strong>EL表达式主要用于代替JSP页面中的表达式脚本&lt;%=…%&gt;</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;%=request.getAttribute(<span class="string">&quot;username&quot;</span>)%&gt;</span><br><span class="line">用EL表达式代替：$&#123;username&#125;</span><br></pre></td></tr></table></figure>

<p>因为一个页面内存在多个域对象，而域对象间是会存在相同key名称的键值对。因此，EL在进行数据搜索时，会按照如下的顺序搜索：pageContext域（当前页面）——&gt;request域（当前请求）——&gt;session域（会话）——&gt;application域（ServletContext）</p>
<p>当4个域对象都有同名键值对时，EL表达式只会搜索到pageContext域对象中的键值对。</p>
<p>此外，因为四个域对象的setAttribute(String key, Object value)方法签名相同，所有EL表达式的写法固定，均为${key}，而因为获取到的value是Object类型的，这意味着${key}得到的可以是对象，数组，链表，基本数据类型，Map等任何数据。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String[] school;</span><br><span class="line">    List&lt;String&gt; city;</span><br><span class="line">    Map&lt;String, String&gt; family;</span><br><span class="line">    <span class="comment">//对应的getter和setter方法省略</span></span><br><span class="line">&#125;</span><br><span class="line">Person person = <span class="keyword">new</span> Person(省略);</span><br><span class="line">request.setAttribute(<span class="string">&quot;doug&quot;</span>, person);</span><br><span class="line">通过EL表达式，我们就可以对属性(必须要有getter和setter方法)进行如下操作:</span><br><span class="line">$&#123;darby&#125;  获取person对象</span><br><span class="line">$&#123;darby.name&#125;  获取person对象的name属性(通过getName方法)</span><br><span class="line">$&#123;darby.school&#125;  获取person对象的school属性(通过getSchool方法)</span><br><span class="line">$&#123;darby.school[<span class="number">0</span>]&#125; 获取shool属性中的值</span><br><span class="line">$&#123;darby.city&#125;</span><br><span class="line">$&#123;darby.city[<span class="number">0</span>]&#125;</span><br><span class="line">$&#123;darby.family&#125;  获取family属性(通过getFamily方法)</span><br><span class="line">$&#123;darby.family.mother&#125;  获取family属性某个特定键值对中的value</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h2><blockquote>
<p>全称：Jsp Standard Tag Library Jsp标准标签库</p>
<p><strong>主要用于替换JSP在的java代码脚本 &lt;%    %&gt;</strong></p>
<p>主要标签库：</p>
<p><strong>核心标签库：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span>%&gt;</span><br></pre></td></tr></table></figure>

<p>格式化标签库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;fmt&quot;</span> uri=<span class="string">&quot;http://java.sum.com/jsp/jstl/fmt&quot;</span>%&gt;</span><br></pre></td></tr></table></figure>

<p>函数标签库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;fmt&quot;</span> uri=<span class="string">&quot;http://java.sum.com/jsp/jstl/functions&quot;</span>%&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <tags>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC之CountDownLatch</title>
    <url>/2020/08/27/JUC%E4%B9%8BCountDownLatch/</url>
    <content><![CDATA[<p>CountDownLatch允许一个或多个线程等待其他线程完成操作。定义CountDownLatch的时候，需要传入一个正数来初始化计数器（虽然传入0也可以，但这样的话CountDownLatch没什么实际意义）。其<code>countDown</code>方法用于递减计数器，<code>await</code>方法会使当前线程阻塞，直到计数器递减为0。所以CountDownLatch常用于多个线程之间的协调工作。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>假设现在有这样一个需求：</p>
<ol>
<li>从数据库获取数据</li>
<li>对这批数据进行处理</li>
<li>保存这批数据</li>
</ol>
<p>为了让程序执行效率更高，第2步中我们可以使用多线程来并行处理这批数据，大致过程如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 模拟从数据库获取数据</span></span><br><span class="line">        <span class="keyword">int</span>[] data = query();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取数据完毕&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 数据处理</span></span><br><span class="line">        IntStream.range(<span class="number">0</span>, data.length).forEach(i -&gt; &#123;</span><br><span class="line">            ExecutorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;处理第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> value = data[i];</span><br><span class="line">                <span class="keyword">if</span> (value % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    data[i] = value * <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    data[i] = value * <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;所有数据都处理完了&quot;</span>);</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        ExecutorService.shutdown();</span><br><span class="line">        <span class="comment">// 3. 保存数据</span></span><br><span class="line">        save(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] query() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存数据 - &quot;</span> + Arrays.toString(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于线程获取CPU时间片的不确定性，所以有可能数据还没有处理完毕，第3步就执行完了：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">获取数据完毕</span><br><span class="line">所有数据都处理完了</span><br><span class="line">保存数据 - [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">2</span>,<span class="number">5</span>,main]处理第<span class="number">2</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">1</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">2</span>,<span class="number">5</span>,main]处理第<span class="number">3</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">4</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">6</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">2</span>,<span class="number">5</span>,main]处理第<span class="number">5</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">7</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">9</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">2</span>,<span class="number">5</span>,main]处理第<span class="number">8</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">10</span>条数据</span><br></pre></td></tr></table></figure>

<p>可以借助CountDownLatch解决这个问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService ExecutorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 模拟从数据库获取数据</span></span><br><span class="line">        <span class="keyword">int</span>[] data = query();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取数据完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 数据处理</span></span><br><span class="line">        IntStream.range(<span class="number">0</span>, data.length).forEach(i -&gt; &#123;</span><br><span class="line">            ExecutorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;处理第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> value = data[i];</span><br><span class="line">                <span class="keyword">if</span> (value % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    data[i] = value * <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    data[i] = value * <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有数据都处理完了&quot;</span>);</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        ExecutorService.shutdown();</span><br><span class="line">        <span class="comment">// 3. 保存数据</span></span><br><span class="line">        save(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] query() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存数据 - &quot;</span> + Arrays.toString(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码定义一个CountDownLatch，计数器值为10，和数据量一致。然后在第2步中，当每个线程执行完毕的时候调用<code>countDown</code>方法，让计数器减1。在第3步前调用<code>await</code>方法让main线程阻塞等待，直到计数器被减为0。所以这就保证了只有当所有数据加工完毕才执行保存数据操作。</p>
<p>执行方法，程序输出如下所示：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">获取数据完毕</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">1</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">3</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">4</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">5</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">6</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">7</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">8</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">9</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">10</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">2</span>,<span class="number">5</span>,main]处理第<span class="number">2</span>条数据</span><br><span class="line">所有数据都处理完了</span><br><span class="line">保存数据 - [<span class="number">10</span>, <span class="number">4</span>, <span class="number">30</span>, <span class="number">8</span>, <span class="number">50</span>, <span class="number">12</span>, <span class="number">70</span>, <span class="number">16</span>, <span class="number">90</span>, <span class="number">20</span>]</span><br></pre></td></tr></table></figure>

<p><code>await</code>有重载方法：<code>await(long timeout, TimeUnit unit)</code>，设置最大等待时间，超过这个时间程序将继续执行不再被阻塞：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;线程执行完毕&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"> </span><br><span class="line">        latch.await(<span class="number">3</span>, TimeUnit.SECONDS); <span class="comment">// 最多等待 3秒</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main线程执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">main</span>线程执行完毕</span><br><span class="line"><span class="attribute">Thread</span>[thread<span class="number">1</span>,<span class="number">5</span>,main]线程执行完毕</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>countDownLatch</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC之CyclicBarrier</title>
    <url>/2020/08/27/JUC%E4%B9%8BCyclicBarrier/</url>
    <content><![CDATA[<p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。CyclicBarrier默认的构造方法是<code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用<code>await</code>方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>使用“人满发车”的例子来演示CyclicBarrier：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;快上车来不及解释了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;已上车&quot;</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;所有人已上车，发车&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Jane&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;已上车&quot;</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;所有人已上车，发车&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Mike&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中我们定义了一个等待2个线程完成的CyclicBarrier，在两个线程内部调用了<code>await</code>方法，让其阻塞等待，并告知CyclicBarrier我已经到达屏障了。只有当两个线程都执行到<code>barrier.await()</code>这一行时，屏障开启，线程才会继续往下执行。程序输出如下所示：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">快上车来不及解释了</span><br><span class="line"><span class="keyword">Thread</span>[Mike,<span class="number">5</span>,main]已上车</span><br><span class="line"><span class="keyword">Thread</span>[Jane,<span class="number">5</span>,main]已上车</span><br><span class="line">所有人已上车，发车</span><br><span class="line">所有人已上车，发车</span><br></pre></td></tr></table></figure>

<p>CyclicBarrier的构造函数支持传入一个回调方法：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier<span class="function"><span class="params">(n, () -&gt; &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    System.out.println(<span class="string">&quot;当所有线程到达屏障时，执行该回调&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span>;</span></span><br></pre></td></tr></table></figure>



<p>改造上面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发车，嘟嘟嘟&quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;快上车来不及解释了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;已上车&quot;</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;所有人已上车&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Jane&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;已上车&quot;</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;所有人已上车&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Mike&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下所示：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">快上车来不及解释了</span><br><span class="line"><span class="keyword">Thread</span>[Mike,<span class="number">5</span>,main]已上车</span><br><span class="line"><span class="keyword">Thread</span>[Jane,<span class="number">5</span>,main]已上车</span><br><span class="line">发车，嘟嘟嘟</span><br><span class="line">所有人已上车，发车</span><br><span class="line">所有人已上车，发车</span><br></pre></td></tr></table></figure>

<h2 id="设置超时时间"><a href="#设置超时时间" class="headerlink" title="设置超时时间"></a>设置超时时间</h2><p><code>await</code>的重载方法：<code>await(long timeout, TimeUnit unit)</code>可以设置最大等待时长，超出这个时间屏障还没有开启的话则抛出<code>TimeoutException</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;继续执行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier.await(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;继续执行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/cyclicBarrier%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE.png"></p>
<h2 id="BrokenBarrierException"><a href="#BrokenBarrierException" class="headerlink" title="BrokenBarrierException"></a>BrokenBarrierException</h2><p>抛出<code>BrokenBarrierException</code>异常时表示屏障破损，此时标志位broken=true。抛出<code>BrokenBarrierException</code>异常的情况主要有：</p>
<ol>
<li>其他等待的线程被中断，则当前线程抛出<code>BrokenBarrierException</code>异常；</li>
<li>其他等待的线程超时，则当前线程抛出<code>BrokenBarrierException</code>异常；</li>
<li>当前线程在等待时，其他线程调用CyclicBarrier.reset()方法，则当前线程抛出BrokenBarrierException异常。</li>
</ol>
<p>模拟第1种情况，其他等待的线程被中断，则当前线程抛出<code>BrokenBarrierException</code>异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;继续执行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;继续执行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread2.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/BrokenBarrierException%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></p>
<p>上面例子中thread2线程睡眠1秒后先到达屏障点，然后进入等待状态。2秒后main线程执行<code>thread2.interrupt()</code>中断等待中的thread2线程，所以程序抛出<code>BrokenBarrierException</code>异常。3秒后thread1线程到达屏障点，此时屏障已经被破坏了，所以也抛出<code>BrokenBarrierException</code>异常。</p>
<p>模拟第2种情况：其他等待的线程超时，则当前线程抛出<code>BrokenBarrierException</code>异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;继续执行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                barrier.await(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;继续执行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException | TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="/images/BrokenBarrierException%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C2.png"></p>
<p>上面例子中thread2睡眠1秒后到达屏障点，然后进入等待状态（最多等待1秒），然而因为thread1要3秒后才能到达屏障点，所以thread2将抛出<code>TimeoutException</code>。3秒后，thread1到达屏障点，但这时候由于thread2的<code>await</code>方法抛出的异常破坏了屏障，所以thread1将抛出<code>BrokenBarrierException</code>异常。</p>
<p>模拟第3中情况：当前线程在等待时，其他线程调用CyclicBarrier.reset()方法，则当前线程抛出BrokenBarrierException异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;继续执行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;继续执行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        System.out.println(barrier.getNumberWaiting());</span><br><span class="line">        barrier.reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="/images/BrokenBarrierException%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C3.png"></p>
<p>上面例子中，thread2睡眠1秒后到达屏障点，然后进入等待状态。2秒后main线程调用<code>reset</code>方法重置了屏障，所以在等待状态中的thread2抛出<code>BrokenBarrierException</code>异常。3秒后，thread1到达屏障点，由于<code>reset</code>方法重置了屏障，所以thread1并不会抛出<code>BrokenBarrierException</code>异常，而是一直在屏障点进行等待别的线程到达屏障点。</p>
<p><strong>从上面的三个例子中可以看到，无论是哪种情况导致屏障破坏，屏障点后面的代码都没有被执行，main方法也没有退出。</strong></p>
<h2 id="和CountDownLatch区别"><a href="#和CountDownLatch区别" class="headerlink" title="和CountDownLatch区别"></a>和CountDownLatch区别</h2><ol>
<li>CountDownLatch：一个线程(或者多个)，等待另外N个线程完成某个事情之后才能执行；CyclicBarrier：N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。</li>
<li>CountDownLatch：一次性的；CyclicBarrier：可以重复使用。</li>
</ol>
]]></content>
      <tags>
        <tag>cyclicBarrier</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC之Exchanger</title>
    <url>/2020/08/24/JUC%E4%B9%8BExchanger/</url>
    <content><![CDATA[<p>JUC中的Exchanger允许<strong>成对的</strong>线程在指定的同步点上通过<code>exchange</code>方法来交换数据。如果第一个线程先执行<code>exchange</code>方法，它会一直等待第二个线程也 执行<code>exchange</code>方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将当前线程生产 出来的数据传递给对方。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>两个线程通过Exchanger交换数据的简单示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1开始&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">&quot;来自thread1的数据&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收thread2发送的数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2开始&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">&quot;来自thread2的数据&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收thread1发送的数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在定义Exchanger的时候需要指定交换的数据类型，这里为String类型。<code>exchange</code>方法用于向另一个线程发送数据，方法的返回值为另一个线程发送过来的数据。上面例子输出如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">thread1开始</span><br><span class="line">thread2开始</span><br><span class="line">接收thread2发送的数据：来自thread2的数据</span><br><span class="line">thread1结束</span><br><span class="line">接收thread1发送的数据：来自thread1的数据</span><br><span class="line">thread2结束</span><br></pre></td></tr></table></figure>

<p>只有当成对的线程都到达同步点的时候，才会执行数据交换操作。现在让thread2休眠一会儿，看看thread1是否会进入等待：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> ExchangerTest &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        final Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Thread(()</span> -&gt; &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;thread1开始&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">&quot;来自thread1的数据&quot;</span>);</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;接收thread2发送的数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;thread1结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Thread(()</span> -&gt; &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;thread2开始&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">TimeUnit</span>.</span><span class="module"><span class="identifier">SECONDS</span>.</span></span>sleep(<span class="number">3</span>); <span class="comment">// thread1也会进入等待，直到双方都准备好交换数据。</span></span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">&quot;来自thread2的数据&quot;</span>);</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;接收thread1发送的数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;thread2结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">thread1开始</span><br><span class="line">thread2开始</span><br><span class="line"><span class="regexp">//</span> 等待几秒后</span><br><span class="line">接收thread1发送的数据：来自thread1的数据</span><br><span class="line">thread2结束</span><br><span class="line">接收thread2发送的数据：来自thread2的数据</span><br><span class="line">thread1结束</span><br></pre></td></tr></table></figure>

<p>如果线程不成对会出现什么情况呢？我们添加thread3线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1开始&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">&quot;发送数据-thread1&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2开始&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">&quot;发送数据-thread2&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread3开始&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">&quot;发送数据-thread3&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread3结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread3&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下所示：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">thread1开始</span><br><span class="line">thread3开始</span><br><span class="line">接收数据：发送数据-thread1</span><br><span class="line">thread3结束</span><br><span class="line">thread2开始</span><br><span class="line">接收数据：发送数据-thread3</span><br><span class="line">thread1结束</span><br></pre></td></tr></table></figure>

<p>可看到thread1和thread3交换了数据然后正常停止了，而thread2由于没有线程和它交换数据而苦苦等待，线程永远不会停止。查看线程快照可以证明这点：</p>
<p><img src="/images/thread2%E5%BF%AB%E7%85%A7.png"></p>
<p>线程匹配是随机的，所以也有可能thread1和thread2匹配，thread3进入无休止的等待</p>
<p>另一个值得一提的点就是通过Exchanger交换的是同一个对象，而不是对象的拷贝：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;Object&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1开始&quot;</span>);</span><br><span class="line">            Object object = <span class="keyword">new</span> Object();</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1发送数据：&quot;</span> + object);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object exchange = exchanger.exchange(object);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收thread2发送的数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2开始&quot;</span>);</span><br><span class="line">            Object object = <span class="keyword">new</span> Object();</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2发送数据：&quot;</span> + object);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object exchange = exchanger.exchange(object);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收thread1发送的数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">thread<span class="number">1</span>开始</span><br><span class="line">thread<span class="number">2</span>开始</span><br><span class="line">thread<span class="number">2</span>发送数据：java.lang.Object<span class="title">@6</span>d<span class="number">559005</span></span><br><span class="line">thread<span class="number">1</span>发送数据：java.lang.Object<span class="title">@7702</span><span class="keyword">c</span><span class="number">19</span></span><br><span class="line">接收thread<span class="number">2</span>发送的数据：java.lang.Object<span class="title">@6</span>d<span class="number">559005</span></span><br><span class="line">接收thread<span class="number">1</span>发送的数据：java.lang.Object<span class="title">@7702</span><span class="keyword">c</span><span class="number">19</span></span><br><span class="line">thread<span class="number">2</span>结束</span><br><span class="line">thread<span class="number">1</span>结束</span><br></pre></td></tr></table></figure>

<p>可以看到thread1发送的对象和thread2接收的对象句柄是一致的。</p>
<h2 id="设置超时时间"><a href="#设置超时时间" class="headerlink" title="设置超时时间"></a>设置超时时间</h2><p>如果不想线程在交换数据的时候等待过长的时间，我们可以使用<code>exchanger</code>的重载方法<code>exchange(V x, long timeout, TimeUnit unit)</code>来指定超时时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1开始&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">&quot;来自thread1的数据&quot;</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收thread2发送的数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2开始&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">&quot;来自thread2的数据&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收thread1发送的数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中，thread2休眠10秒后才开始交换数据，而thread1在等待5秒后没能成功交换数据就抛出<code>TimeoutException</code>异常了。10秒后由于没有线程再和thread2交换数据，所以thread2会一直等待：</p>
<p><img src="/images/thread2%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C.png"></p>
<p><img src="/images/%E8%B6%85%E6%97%B6%E5%BF%AB%E7%85%A7.png"></p>
]]></content>
      <tags>
        <tag>juc, exchanger</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC之Semaphore</title>
    <url>/2020/08/27/JUC%E4%B9%8BSemaphore/</url>
    <content><![CDATA[<p>JUC的Semaphore俗称信号量，可用来控制同时访问特定资源的线程数量。通过它的构造函数可以指定信号量（称为许可证permits可能更为明确）的数量，线程可以调用Semaphore对象的<code>acquire</code>方法获取一个许可证，调用<code>release</code>来归还一个许可证。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面举个Semaphore的基本使用示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 定义许可证数量</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">4</span>).forEach(i -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire(); <span class="comment">// 一次拿一个许可证</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取许可证&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;释放许可证&quot;</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">            &#125;, <span class="string">&quot;thread&quot;</span> + (i + <span class="number">1</span>)).start();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，定义许可证的数量为2个，然后4个线程通过<code>acquire</code>方法去获取许可证，结束行通过<code>release</code>方法释放许可证。<code>acquire</code>方法默认一次只拿一个许可证，所以上面的例子中，同一时刻最多只有两个线程同时执行。</p>
<p>程序输出如下所示：</p>
<p><img src="/images/samphore%E6%B5%8B%E8%AF%951.gif"></p>
<p><code>acquire</code>的重载方法<code>acquire(int permits)</code>允许线程一次性获取N个许可证；同样的<code>release</code>的重载方法<code>release(int permits)</code>允许线程一次性释放N个许可证。</p>
<p>Semaphore还有一个<code>tryAcquire</code>，它允许线程尝试去获取1个许可证，如果许可证不足没有获取到的话，线程也会继续执行，而非阻塞等待。<code>tryAcquire</code>方法的重载方法<code>tryAcquire(long timeout, TimeUnit unit)</code>可以指定尝试获取许可证的超时时间。</p>
<h2 id="acquireUninterruptibly"><a href="#acquireUninterruptibly" class="headerlink" title="acquireUninterruptibly"></a>acquireUninterruptibly</h2><p>从上面的例子会发现<code>acquire</code>方法会抛出<code>InterruptedException</code>异常，说明这个方法是可以被打断的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;semaphore InterruptedException&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.MICROSECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子thread1线程获取2个许可证，但许可证总数只有1个，所以会阻塞等待。main线程通过调用thread1的<code>interrupt</code>方法去打断thread1线程，结果如下：</p>
<p><img src="/images/samephore%E7%BA%BF%E7%A8%8B%E8%A2%AB%E6%89%93%E6%96%AD.png"></p>
<p>而通过<code>acquireUninterruptibly</code>方法去获取许可证是不可被打断的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            semaphore.acquireUninterruptibly(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.MICROSECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序并不会抛出<code>InterruptedException</code>，thread1会一直处于阻塞状态。</p>
<h2 id="drainPermits"><a href="#drainPermits" class="headerlink" title="drainPermits"></a>drainPermits</h2><p><code>drainPermits</code>方法一次性获取所有许可证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;availablePermits: &quot;</span> + semaphore.availablePermits());</span><br><span class="line">            semaphore.drainPermits(); <span class="comment">// 获取所有许可证，抽干</span></span><br><span class="line">            System.out.println(<span class="string">&quot;availablePermits: &quot;</span> + semaphore.availablePermits());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            semaphore.release(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>availablePermits</code>方法用于获取当前可用许可证数量的预估值。程序输出如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">availablePermits</span>：<span class="number">5</span></span><br><span class="line"><span class="attribute">availablePermits</span>：<span class="number">0</span></span><br><span class="line"><span class="attribute">thread1</span>结束</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>hasQueuedThreads</code>方法用于判断是否有处于等待获取许可证状态的线程；<code>getQueueLength</code>用于获取处于等待获取许可证状态的线程的数量；<code>getQueuedThreads</code>用于获取处于等待获取许可证状态的线程集合。</p>
<p><code>getQueuedThreads</code>是<code>protected</code>的，所以要使用它，我们得自定义一个Semaphore的子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义许可证数量</span></span><br><span class="line">        <span class="keyword">final</span> MySemaphore semaphore = <span class="keyword">new</span> MySemaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">4</span>).forEach(i -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取许可证&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;释放许可证&quot;</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">            &#125;, <span class="string">&quot;thread&quot;</span> + (i + <span class="number">1</span>)).start();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (semaphore.hasQueuedThreads()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;等待线程数量：&quot;</span> + semaphore.getQueueLength());</span><br><span class="line">                Collection&lt;Thread&gt; queuedThreads = semaphore.getQueuedThreads();</span><br><span class="line">                System.out.println(<span class="string">&quot;等待线程：&quot;</span> + queuedThreads.stream().map(Thread::getName).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MySemaphore</span> <span class="keyword">extends</span> <span class="title">Semaphore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2595494765642942297L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MySemaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MySemaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(permits, fair);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.getQueuedThreads();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下所示（截取一部分）：</p>
<p><img src="/images/semaphore%E7%BB%93%E6%9E%9C.png"></p>
<h2 id="常用方法总结"><a href="#常用方法总结" class="headerlink" title="常用方法总结"></a>常用方法总结</h2><p>Semaphore常用的方法：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>acquire()</code></td>
<td align="left">获取一个许可证，可以被打断，没有足够的许可证时阻塞等待</td>
</tr>
<tr>
<td align="left"><code>acquire(int permits)</code></td>
<td align="left">获取指定数量的许可证，可以被打断，没有足够的许可证时阻塞等待</td>
</tr>
<tr>
<td align="left"><code>acquireUninterruptibly()</code></td>
<td align="left">获取一个许可证，不可被打断，没有足够的许可证时阻塞等待</td>
</tr>
<tr>
<td align="left"><code>acquireUninterruptibly(int permits)</code></td>
<td align="left">获取指定数量的许可证，不可被打断，没有足够的许可证时阻塞等待</td>
</tr>
<tr>
<td align="left"><code>tryAcquire()</code></td>
<td align="left">尝试获取一个许可证，没有足够的许可证时程序继续执行，不会被阻塞</td>
</tr>
<tr>
<td align="left"><code>tryAcquire(int permits)</code></td>
<td align="left">尝试获取指定数量的许可证，没有足够的许可证时程序继续执行，不会被阻塞</td>
</tr>
<tr>
<td align="left"><code>tryAcquire(long timeout, TimeUnit unit)</code></td>
<td align="left">在指定的时间范围内尝试获取1个许可证，没有足够的许可证时程序继续执行， 不会被阻塞，在该时间方位内可以被打断</td>
</tr>
<tr>
<td align="left"><code>tryAcquire(int permits, long timeout, TimeUnit unit)</code></td>
<td align="left">在指定的时间范围内尝试获取指定数量的许可证，没有足够的许可证时程序 继续执行，不会被阻塞，在该时间方位内可以被打断</td>
</tr>
<tr>
<td align="left"><code>release()</code></td>
<td align="left">释放一个许可证</td>
</tr>
<tr>
<td align="left"><code>drainPermits()</code></td>
<td align="left">一次性获取所有可用的许可证</td>
</tr>
<tr>
<td align="left"><code>availablePermits()</code></td>
<td align="left">获取当前可用许可证数量的预估值</td>
</tr>
<tr>
<td align="left"><code>hasQueuedThreads()</code></td>
<td align="left">判断是否有处于等待获取许可证状态的线程</td>
</tr>
<tr>
<td align="left"><code>getQueueLength()</code></td>
<td align="left">获取处于等待获取许可证状态的线程的数量的预估值</td>
</tr>
<tr>
<td align="left"><code>getQueuedThreads()</code></td>
<td align="left">获取处于等待获取许可证状态的线程集合</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>juc, semaphore</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM相关知识</title>
    <url>/2020/01/31/JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h3><blockquote>
<p>JVM由以下四部分组成：</p>
<ol>
<li>类加载器。在JVM启动时或者在类运行时将需要的class字节码文件加载到JVM中。</li>
<li>执行引擎。负责执行class文件中的字节码指令，相当于实际机器上的CPU。</li>
<li>内存区。将内存划分成若干个区，以模拟在实际机器上的存储、记录、调度功能模块。这是很重要的一部分。</li>
<li>本地方法调用，调用C或C++实现的本地方法代码。</li>
</ol>
<p><img src="/images/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"></p>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>之前一篇文章讲述过该方面知识，这里不再过多说明。</p>
<h4 id="JVM内存管理"><a href="#JVM内存管理" class="headerlink" title="JVM内存管理"></a>JVM内存管理</h4><p>不管是在Windows系统还是Linux系统下，我们要运行程序，都要向操作系统先申请内存地址。通常操作系统管理内存的申请空间是按照进程来管理的，每个进程拥有一段独立的地址空间，每个进程间不会相互重合，操作系统也会保证每个进程只能访问自己的内存空间。但是随着程序越来越庞大，以及设计的多样性，有可能程序所需的内存空间大于物理内存大小，这时候怎么办？虚拟内存出现。虚拟内存只将程序运行需要的数据页加载到内存中，而暂时还未用到的数据则继续留在磁盘中。当程序运行需要用到磁盘上的数据时，会先让访问磁盘数据的操作”陷入陷阱”，然后将磁盘中的数据读取到内存中，再执行该”陷入陷阱”的操作。虚拟内存使得多个进程在同时运行时可以共享物理内存。这里的共享只是空间的共享，只是让进程共享物理内存，提高内存利用率，逻辑上进程间仍然不能相互访问。当进程不活动时，操作系统就会将物理内存中的数据移到一个磁盘文件中(Windows系统上的页面文件，Linux上的交换分区)，而真正高效的物理内存留给正在活动的程序使用。<strong>注意，这种交换要尽可能地减少，如果操作系统频繁地交换内存和磁盘的数据，效率会非常低下。</strong></p>
<blockquote>
<p>内核空间与用户空间</p>
<p>一个计算机有一定大小的内存空间，但是程序并不能完全使用这些地址空间。程序不能访问的空间称为内核空间，能够访问的内存空间称为用户空间。</p>
<p>之所以这么划分，主要是要保证操作系统的稳定性及安全性。内核空间主要用于存放操作系统运行时所需要的——程序调度、虚拟内存的使用、连接硬件资源的程序逻辑等。</p>
</blockquote>
<h5 id="JVM中需要分配内存的组件"><a href="#JVM中需要分配内存的组件" class="headerlink" title="JVM中需要分配内存的组件"></a>JVM中需要分配内存的组件</h5><blockquote>
<p><strong>再次强调：请牢记这些组件，当内存泄漏时，就可以从这些组件中排查。</strong></p>
<ul>
<li><strong>Java堆，存放对象</strong></li>
<li><strong>线程，程序的执行实体，每个线程都包括栈和程序计数器。通常一个线程大小在256KB~756KB之间</strong></li>
<li><strong>方法区，存放加载的类以及类加载器</strong></li>
<li><strong>NIO，NIO使用java.io.ByteBuffer.allocateDirect()方法分配内存，这里的内存是直接内存而不是Java内存，要特别注意</strong></li>
<li><strong>JNI，调用本地方法需要占用本机内存</strong></li>
</ul>
</blockquote>
<h5 id="Java内存分配"><a href="#Java内存分配" class="headerlink" title="Java内存分配"></a>Java内存分配</h5><blockquote>
<ol>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>Java堆</li>
<li>方法区</li>
<li>本地方法栈</li>
</ol>
</blockquote>
<p>Java堆和方法区是被所有线程共享的一块内存。Java堆用于存放对象实例，如果在堆中没有完成实例分配，并且堆也无法进行扩展时，就会抛出OutOfMemoryError异常；方法区则用于存储已经被虚拟机加载的类信息、常量、静态变量等数据，当方法区无法满足内存分配需求时，也会抛出OutOfMemoryError异常。</p>
<p>虚拟机栈、程序计数器都属于线程私有内容，生命周期和线程一致。每个方法在执行的时候都会在虚拟机栈中创建栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。当方法执行完毕，栈帧就会出栈。当线程请求的栈深度大于虚拟机所允许的值，就会抛出StakOverflowError异常；程序计数器或者称为PC寄存器，用于确保线程的指令能够正确地执行。</p>
<p>本地方法栈，则是用于调用本地方法时使用的内存区域。</p>
<h4 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h4><p>执行引擎是JVM的核心部分，作用就是解析JVM字节码指令，得到执行结果。执行引擎其实质是一个Java线程，即每个Java线程都是一个执行引擎的实例，因此，同一时刻会同时有多个执行引擎（Java线程）在工作，有的执行用户程序，有的执行垃圾回收等。</p>
<p>接下来，就是要探究JVM是如何工作的。</p>
</blockquote>
<h3 id="JVM工作机制"><a href="#JVM工作机制" class="headerlink" title="JVM工作机制"></a>JVM工作机制</h3><blockquote>
<p>计算机只执行机器指令，因此高级语言必须经过编译器编译成机器指令才能正确地被计算机正确执行，所以从高级语言到机器语言之间必须要有个翻译的过程。通常而言，机器指令和硬件是密切相关的，不同机器间的机器指令存在差异。而高级语言则不存在这种差异，这种差异被屏蔽就是得益于编译环节过程。因此，对于高级语言，不同的硬件平台，所需要的编译器是不同的。这种硬件差异在计算机发展的早期十分明显，但是随着计算机的发展，这种硬件差异逐渐被软件平台所代替，我们开始常常说，你这是装在Windows操作系统上还是Linux系统上，而不会说你的CPU是什么型号等等。</p>
<p>通常，一个程序从编写到执行会经历以下一些阶段：</p>
<p>源代码(source code) ——&gt; 预处理器(preprocessor) ——&gt; 编译器(compiler) ——&gt; 汇编程序(assembler) ——&gt; 目标代码(object code) ——&gt; 链接器(Linker) ——&gt; 可执行程序(executables)</p>
<p>除了源代码和最后的可执行程序，中间的所有环节都是由编译器统一完成。比如在Linux操作系统中，安装一个软件需要经过<strong>configure/make/make install/make clean四个步骤</strong>。</p>
<ul>
<li>configure为这个程序在当前操作系统环境下选择合适的编译器来编译程序代码</li>
<li>make则对程序代码执行编译操作，将源码编译成可执行的目标文件</li>
<li>make install将已经编译好的可执行文件安装到操作系统指定或默认的安装目录下</li>
<li>make clean用于删除编译时临时产生的目录或文件</li>
</ul>
<h5 id="JVM基于栈的架构"><a href="#JVM基于栈的架构" class="headerlink" title="JVM基于栈的架构"></a>JVM基于栈的架构</h5><p>JVM执行字节码指令是基于栈的架构，所有的操作数必须先入栈，然后根据指令中的操作码选择从栈顶弹出若干元素进行计算后在压入栈中。这和一般的基于寄存器的操作有所不同，基于栈的操作需要频繁地入栈和出栈，比如进行一个加法运算，如果两个操作数都在本地变量中，那么一个加法操作需要有5次栈操作：两个操作数入栈，两个操作数出栈，执行完后的结果入栈。</p>
</blockquote>
]]></content>
      <tags>
        <tag>JVM, 虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Base64算法</title>
    <url>/2020/08/05/Java-Base64%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>Base64算法并不是加密算法，它的出现是为了解决ASCII码在传输过程中可能出现乱码的问题。Base64是网络上最常见的用于传输8bit字节码的可读性编码算法之一。可读性编码算法不是为了保护数据的安全性，而是为了可读性。可读性编码不改变信息内容，只改变信息内容的表现形式。Base64使用了64种字符：大写A到Z、小写a到z、数字0到9、“+”和“/”，故得此名。</p>
<span id="more"></span>

<h2 id="中文字符在不同编码下所占的字节数"><a href="#中文字符在不同编码下所占的字节数" class="headerlink" title="中文字符在不同编码下所占的字节数"></a>中文字符在不同编码下所占的字节数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    String a = <span class="string">&quot;威&quot;</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] utf8Bytes = a.getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">byte</span> b : utf8Bytes) &#123;</span><br><span class="line">        System.out.print(b);</span><br><span class="line">        System.out.print(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">        System.out.println(Integer.toBinaryString(b));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="keyword">byte</span>[] gbkBytes = a.getBytes(<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">byte</span> b : gbkBytes) &#123;</span><br><span class="line">        System.out.print(b);</span><br><span class="line">        System.out.print(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">        System.out.println(Integer.toBinaryString(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-23    11111111111111111111111111101001</span></span><br><span class="line"><span class="deletion">-72    11111111111111111111111110111000</span></span><br><span class="line"><span class="deletion">-97    11111111111111111111111110011111</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-60    11111111111111111111111111000100</span></span><br><span class="line"><span class="deletion">-15    11111111111111111111111111110001</span></span><br></pre></td></tr></table></figure>

<p>所以在UTF-8编码下，一个中文占3个字节；在GBK编码下，一个中文占2个字节</p>
<h2 id="Base64编码原理"><a href="#Base64编码原理" class="headerlink" title="Base64编码原理"></a>Base64编码原理</h2><p>Base64编码表：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>索引</strong></td>
<td><strong>对应字符</strong></td>
<td><strong>索引</strong></td>
<td><strong>对应字符</strong></td>
<td><strong>索引</strong></td>
<td><strong>对应字符</strong></td>
<td><strong>索引</strong></td>
<td><strong>对应字符</strong></td>
</tr>
<tr>
<td>0</td>
<td><strong>A</strong></td>
<td>17</td>
<td><strong>R</strong></td>
<td>34</td>
<td><strong>i</strong></td>
<td>51</td>
<td><strong>z</strong></td>
</tr>
<tr>
<td>1</td>
<td><strong>B</strong></td>
<td>18</td>
<td><strong>S</strong></td>
<td>35</td>
<td><strong>j</strong></td>
<td>52</td>
<td><strong>0</strong></td>
</tr>
<tr>
<td>2</td>
<td><strong>C</strong></td>
<td>19</td>
<td><strong>T</strong></td>
<td>36</td>
<td><strong>k</strong></td>
<td>53</td>
<td><strong>1</strong></td>
</tr>
<tr>
<td>3</td>
<td><strong>D</strong></td>
<td>20</td>
<td><strong>U</strong></td>
<td>37</td>
<td><strong>l</strong></td>
<td>54</td>
<td><strong>2</strong></td>
</tr>
<tr>
<td>4</td>
<td><strong>E</strong></td>
<td>21</td>
<td><strong>V</strong></td>
<td>38</td>
<td><strong>m</strong></td>
<td>55</td>
<td><strong>3</strong></td>
</tr>
<tr>
<td>5</td>
<td><strong>F</strong></td>
<td>22</td>
<td><strong>W</strong></td>
<td>39</td>
<td><strong>n</strong></td>
<td>56</td>
<td><strong>4</strong></td>
</tr>
<tr>
<td>6</td>
<td><strong>G</strong></td>
<td>23</td>
<td><strong>X</strong></td>
<td>40</td>
<td><strong>o</strong></td>
<td>57</td>
<td><strong>5</strong></td>
</tr>
<tr>
<td>7</td>
<td><strong>H</strong></td>
<td>24</td>
<td><strong>Y</strong></td>
<td>41</td>
<td><strong>p</strong></td>
<td>58</td>
<td><strong>6</strong></td>
</tr>
<tr>
<td>8</td>
<td><strong>I</strong></td>
<td>25</td>
<td><strong>Z</strong></td>
<td>42</td>
<td><strong>q</strong></td>
<td>59</td>
<td><strong>7</strong></td>
</tr>
<tr>
<td>9</td>
<td><strong>J</strong></td>
<td>26</td>
<td><strong>a</strong></td>
<td>43</td>
<td><strong>r</strong></td>
<td>60</td>
<td><strong>8</strong></td>
</tr>
<tr>
<td>10</td>
<td><strong>K</strong></td>
<td>27</td>
<td><strong>b</strong></td>
<td>44</td>
<td><strong>s</strong></td>
<td>61</td>
<td><strong>9</strong></td>
</tr>
<tr>
<td>11</td>
<td><strong>L</strong></td>
<td>28</td>
<td><strong>c</strong></td>
<td>45</td>
<td><strong>t</strong></td>
<td>62</td>
<td><strong>+</strong></td>
</tr>
<tr>
<td>12</td>
<td><strong>M</strong></td>
<td>29</td>
<td><strong>d</strong></td>
<td>46</td>
<td><strong>u</strong></td>
<td>63</td>
<td><strong>/</strong></td>
</tr>
<tr>
<td>13</td>
<td><strong>N</strong></td>
<td>30</td>
<td><strong>e</strong></td>
<td>47</td>
<td><strong>v</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>14</td>
<td><strong>O</strong></td>
<td>31</td>
<td><strong>f</strong></td>
<td>48</td>
<td><strong>w</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td><strong>P</strong></td>
<td>32</td>
<td><strong>g</strong></td>
<td>49</td>
<td><strong>x</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>16</td>
<td><strong>Q</strong></td>
<td>33</td>
<td><strong>h</strong></td>
<td>50</td>
<td><strong>y</strong></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Base64编码的过程：</p>
<ol>
<li>将字符串转换为字符数组；</li>
<li>将每个字符转换为ASCII码；</li>
<li>将ASCII码转换为8bit二进制码；</li>
<li>然后每3个字节为一组（一个字节为8个bit，所以每组24个bit）；</li>
<li>将每组的24个bit分为4份，每份6个bit；</li>
<li>在每6个bit前补0，补齐8bit（前面补0不影响数值大小）；</li>
<li>然后将每8bit转换为10进制数，根据上面的Base64编码表进行转换。</li>
</ol>
<p>（上面步骤中，之所以将每组24个bit分为4份，每份6个bit是因为6bit的最大值为111111，转换为十进制为63，所以6bit的取值范围为0~63，这和base64编码表长度一致。）</p>
<p>根据上面的过程，举个例子：现要对hello这个字符串进行Base64编码，过程如下：</p>
<ol>
<li>hello转换为字符数组：h e l l o；</li>
<li>对应的ASCII码为：104 101 108 108 111；</li>
<li>转换为8bit二进制数：01101000 01100101 01101100 01101100 01101111</li>
<li>分组，每组24个bit（不足24个bit的用00000000补齐）： 011010000110010101101100 011011000110111100000000；</li>
<li>每组24bit分为4份，每份6bit：011010 000110 010101 101100 011011 000110 111100 000000；</li>
<li>在每6个bit前补0，补齐8bit：00011010 00000110 00010101 00101100 00011011 00000110 00111100 00000000；</li>
<li>将每8bit转换为10进制数：26 6 21 44 27 6 60 0</li>
<li>从上面Base64编码表中找到十进制数对应的字符（末尾的0并不是A，而是用=等号补位）：a G V s b G 8 =</li>
</ol>
<p>所以hello经过Base64编码的结果为aGVsbG8=</p>
<p>可以用代码验证下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base64Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Base64.getEncoder().encodeToString(<span class="string">&quot;hello&quot;</span>.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">测试结果：</span><br><span class="line"><span class="attribute">aGVsbG8</span>=</span><br></pre></td></tr></table></figure>

<h2 id="URL-Base64算法"><a href="#URL-Base64算法" class="headerlink" title="URL Base64算法"></a>URL Base64算法</h2><p>Base64编码值通过URL传输会出现问题，因为Base64编码中的“+”和“/”符号是不允许出现在URL中的。同样，符号“=”用做参数分隔符，也不允许出现在URL中，根据RFC 4648中的建议，“<del>”和“.”符都有可能替代“=”符号。但“</del>”符号与文件系统相冲突，不能使用；如果使用“.”符号，某些文件系统认为该符号连续出现两次则为错误。</p>
<p>所以common codec包下的URL Base64算法舍弃了填充符，使用了不定长URL Base64编码</p>
<p>引入common codec依赖包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base64Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String value = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(Base64.encodeBase64String(value.getBytes()));</span><br><span class="line">     System.out.println(Base64.encodeBase64URLSafeString(value.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">aG<span class="attr">VsbG8</span>=</span><br><span class="line">aG<span class="attr">VsbG8</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>base64算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Javac为我们做了哪些工作</title>
    <url>/2020/01/28/Javac%E4%B8%BA%E6%88%91%E4%BB%AC%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<p>Javac能够将Java源码编译成字节码文件，然后被JVM识别并执行。虽然从文件名上看，只是从.java文件转化成.class文件，但实际上是将Java源码转化成一连串二进制数字，只不过这些二进制数是有格式的。为了自己能够将编码这件事情做的更出色，尝试了解编译过程，看看自己能否从中学习到什么。</p>
<span id="more"></span>

<h2 id="Javac编译器"><a href="#Javac编译器" class="headerlink" title="Javac编译器"></a>Javac编译器</h2><blockquote>
<p>Javac编译器的作用就是将Java源码转换成JVM能识别的字节码。这个过程如何转换？</p>
<ol>
<li>首先是以字节为单位读取源码，并找出字节中哪些是定义的语法关键词，如if/else/for/while等，这需要借助词法分析。词法分析就是从源码中找出规范化的标记流，也称为Token流。就好比我们说中文，我们从说出的一句话中，知道哪些是主语，哪些是谓语，那些是动词，哪些是名词。比如，你今天吃饭了吗？<em>你</em>是主语，<em>吃</em>是动词，<em>了吗</em>是语气词。</li>
<li>对第一步的Token流进行<strong>语法分析</strong>，检查关键词的组合是否符合Java语法规范。比如if后面是否是一个布尔类型的判断表达式，一个类是否实现了继承接口的全部方法等等。</li>
<li>语法分析完成后，其产生的结果就是会形成一棵符合java语法的抽象语法树，将语言的主要词法用一个结构化的形式组织在一起。然后就会进行<strong>语义分析</strong>。经过语法分析后，说明Token流不存在语法问题，那么就会验证语义的正确性，并将复杂的语法简单化。比如将foreach转换成for循环结构。</li>
<li>最后就会通过字节码生成器生成字节码。</li>
</ol>
<p><img src="/images/%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png"></p>
<p>总结来说，Javac编译器主要模块为：词法分析、语法分析、语义分析、字节码生成器。</p>
</blockquote>
<h4 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h4><blockquote>
<p>借助一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lexer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> jump;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后的内容</span></span><br><span class="line">Compiled from <span class="string">&quot;Lexer.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">doug</span>.<span class="title">wilson</span>.<span class="title">javac</span>.<span class="title">Lexer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> jump;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.doug.wilson.javac.Lexer();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: aload_0</span><br><span class="line">       <span class="number">5</span>: iconst_3</span><br><span class="line">       <span class="number">6</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field num:I</span></span><br><span class="line">       <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>词法分析的类结构(忽略一些内容)：</p>
<p><img src="/images/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%BB%84%E4%BB%B6.png"></p>
<p>接口为Lexer和Parser</p>
<p>Lexer的默认实现为Scanner，Parser的默认实现为JavaParser。JavaParser规定了哪些词是符合Java语言规范规定的，而具体读取和归类不同语法的操作由Scanner完成。Scanner会逐个读取源码的单个字符，然后解析出符合Java语言规范的Token序列。图中还有两个比较重要的没有画出来，一个为枚举类Token，规定了所有Java语法关键词。一个为Names，存储和表示解析后的语法。</p>
<p>词法分析的结果就是一个类的所有关键词都要匹配到Token中的关键词，如果没有匹配成功说明类不符合Java语法规范，而且通常匹配还是具有顺序的：</p>
<ol>
<li>Token.PACKAGE  Name: package</li>
<li>Token.IDENTIFIER  Name: compile</li>
<li>Token.SEMI Name: ;</li>
<li>Token.PUBLIC  Name: public</li>
<li>Token.CLASS  Name: class</li>
<li>Token.IDENTIFIER  Name:Lexer</li>
<li>Token.LBRACE  Name: {</li>
<li>Token.BOOLEAN  Name: boolean</li>
<li>Token.IDENTIFIER   Name: jump</li>
<li>Token.SEMI  Name: ;</li>
<li>Token.INT  Name: int</li>
<li>Token.IDENTIFIER  Name: num</li>
<li>Token.EQ  Name: =</li>
<li>Token.INTLITERAL  stringVal: 3</li>
<li>Token.SEMI  Name: ;</li>
<li>Token.EBRACE  Name: }</li>
</ol>
<p>上面就是Token流，除了定义Java语言规范保留的关键字，Token.IDENTIFIER可以用于表示用户自定义名称，如包名，类名，变量名，方法名等。</p>
<p>接下来就是探究词法分析是怎么得到上面的Token流的。比如Javac怎么区分关键字和用户自定义变量?Javac是如何分辨一个词，它怎么知道是compiler而不是com或者piler?如何知道一个词是Token的关键字?如何对字符流进行划分，得到Token?</p>
<ul>
<li><p>如何读取Token关键词？这主要通过Java语言规范得到实现。比如在编写类的时候，要求要有class关键字，class关键字后需要跟一个自定义名称，然后是{括号。定义变量时，要求先给出变量类型，然后给出变量名。定义方法时，先定义方法返回类型，然后定义方法名称，接着是括号内的形参，由形参类型和形参名构成，多个形参间用逗号,隔开。词法分析就是根据Java语法规范来区分关键字和自定义名称。</p>
</li>
<li><p>如何读取下一个Token关键字？这也是通过语法规范。比如，当读取完{括号时，下一个词一定是关键词或者是用户自定义的名称；当读取完分号; 道理也是同前一条；以及类的定义，方法定义，变量定义，都可以得到下一个Token关键词的线索。</p>
</li>
<li><p>源码和Token关键字的转换？比如package是如何转换到Token.PACKAGE的。首先我们知道了Token是一个Enum枚举类，保存所有的Java关键字。而源码转换成关键字这个任务是在一个名为Keywords类中完成，Keywords负责将所有字符集合对应到Token集合中。具体过程为：</p>
<p>在Keywords中，源码中每个字符集合都是一个Name对象，存储在Name.Table内部类中，Keywords会将Token中所有关键字转换成Name对象，然后建立起Name对象和Token对象的对应关系，并将建立起的联系存储在Keywords类的key数组中。当联系建立完成，剩下的字符集合都会对应到Token.IDENTIFIER类型。如此，一个类的源码的所有字符集合才算完全转化成Token。(简而言之就是Keywords会把要编译的类的每个词视为一个字符集合，比如public class Lexer就会视为3各字符集合。然后将其分别存储为Name对象。接着，Keywords将Token中的关键字也转换成Name对象，然后在字符集合中除了Token.IDENTIFIER以外，一一寻找对应关系。当所有关系寻找完以后，剩下的一定是用户自定义的名称，那么就都视为是Token.IDENTIFIER类型。)</p>
</li>
</ul>
</blockquote>
<h4 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h4><blockquote>
<p>在将Java源文件的字符流转化为Token流后，就可以进行语法分析。语法分析是将得到的Token流组件成更加结构化的语法树，将一个个单词组装成一个完整的语句。</p>
<p>语法分析类结构：</p>
<p><img src="/images/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E7%B1%BB%E7%BB%93%E6%9E%84.png"></p>
<p>如图所示，每个语法节点都会实现一个接口××Tree，而××Tree接口又会继承Tree接口。在图中，继承IfTree语法接口表示一个if类型的表达式，继承BinaryTree语法接口表示一个二元操作表达式。并且所有语法节点，都要继承JCTree。</p>
<p>JCTree类有3各重要的属性项：</p>
<ul>
<li>Tree tag：每个语法节点都会用一个整型常数表示，并且每个节点类型的数值在前一个基础上加1。这是为了表示层级关系，比如根节点算顶层节点，它的Tree tag是1。根节点的子节点算次级节点，其Tree tage是2，以此类推。</li>
<li>pos：一个整数，存储的是语法节点在源码中的起始位置。</li>
<li>type：表示这个节点是什么Java类型，int/float/String等</li>
</ul>
<p>JCTree有几个常用子节点：</p>
<ul>
<li>JCIdent语法节点  </li>
<li>JCFieldAccess语法节点  </li>
<li>JCImport语法节点  </li>
</ul>
<p>通常而言，语法分析会分几步进行：</p>
<ol>
<li><p>package节点解析</p>
</li>
<li><p>import节点解析并构造import语法树。构造import语法树的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">JCTree <span class="title">importDeclaration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = S.pos(); <span class="comment">//获取节点在源码中的起始位置</span></span><br><span class="line">    S.nextToken();  </span><br><span class="line">    <span class="keyword">boolean</span> importStatic = <span class="keyword">false</span>;  <span class="comment">//是否为静态导入</span></span><br><span class="line">    <span class="keyword">if</span> (S.token() == STATIC) &#123;</span><br><span class="line">        <span class="comment">//如果为import static ...的情况</span></span><br><span class="line">        <span class="comment">//则由checkStaticImports()方法进行处理</span></span><br><span class="line">        checkStaticImports();</span><br><span class="line">        importStatic = <span class="keyword">true</span>;</span><br><span class="line">        S.nextToken();</span><br><span class="line">    &#125;</span><br><span class="line">    JCExpression pid = toP(F.at(S.pos()).Ident(ident()));</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> pos1 = S.pos(); <span class="comment">//在源码文件中起始位置</span></span><br><span class="line">        accept(DOT);  <span class="comment">//消耗一个.</span></span><br><span class="line">        <span class="keyword">if</span> (S.token() == STAR) &#123;</span><br><span class="line">            <span class="comment">//如果读取到尾部，例如import java.util.* 则将*构造成节点加入</span></span><br><span class="line">            pid = to(F.at(pos1).Select(pid, names.asterisk));</span><br><span class="line">            S.nextToken();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果没有读取到尾部，则正常读取字符串</span></span><br><span class="line">            pid = toP(F.at(pos1).Select(pid, ident()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (S.token() == DOT);  <span class="comment">//如果为.说明一个import语句还未结束</span></span><br><span class="line">    accept(SEMI);  <span class="comment">//一个import结束，消耗一个;</span></span><br><span class="line">    <span class="keyword">return</span> toP(F.at(pos).Import(pid, importStatic));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JCImport节点语法树：(import java.util.*;)</p>
<p><img src="/images/import%E8%AF%AD%E6%B3%95%E6%A0%91.png"></p>
</li>
<li><p>类的解析并构造成语法树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">JCClassDecl <span class="title">classDeclaration</span><span class="params">(JCModifiers mods, String dc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = S.pos();  <span class="comment">//获取在源码文件中的起始位置</span></span><br><span class="line">    accept(CLASS);  <span class="comment">//消耗掉class关键字</span></span><br><span class="line">    Name name = ident();  <span class="comment">//获取类名</span></span><br><span class="line">    List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();</span><br><span class="line">    JCTree extending = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (S.token() == EXTENDS) &#123;</span><br><span class="line">        <span class="comment">//存在类的继承或接口间的继承</span></span><br><span class="line">        S.nextToken();</span><br><span class="line">        extending = parseType()</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;JCExpression&gt; implementing = List.nil();</span><br><span class="line">    <span class="keyword">if</span> (S.token() == IMPLEMENTS) &#123;</span><br><span class="line">        <span class="comment">//存在继承接口</span></span><br><span class="line">        S.nextToken();</span><br><span class="line">        implementing = typeList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始分析类的主体部分</span></span><br><span class="line">    List&lt;JCTree&gt; defs = classOrInterfaceBody(name, <span class="keyword">false</span>);</span><br><span class="line">    JCClassDecl result = toP(F.at(pos).ClassDef(mods, name, typarams, extending, implementing, defs));</span><br><span class="line">    attach(result, dc);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的主体部分分析比较复杂，没有看的很明白，但是通过其语法树还是能够对其分析过程有个具体了解。比如有下面这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Doug</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight = height / <span class="number">3</span>;</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么可以得到其语法树：</p>
<p><img src="/images/class%E7%B1%BB%E8%AF%AD%E6%B3%95%E6%A0%91.png"></p>
</li>
</ol>
</blockquote>
<h4 id="语义分析器"><a href="#语义分析器" class="headerlink" title="语义分析器"></a>语义分析器</h4><blockquote>
<p>在通过词法分析器解析成Token流，语法分析器将Token流结构化形成语法树，一个类的基本语法树已经基本完成。但是还不够，还没有对其语义的正确性进行检查。比如final修饰的变量是否经过初始化，一个类是否继承接口的全部方法，类是否定义了构造器方法，方法是否有返回值，返回值的类型是否正确等等都需要进一步检查。这些需要通过语义分析器完成。一般有以下几个步骤：</p>
<ol>
<li><p>将类中的符号输入到未处理符号表中，并为类创建一个默认构造器(如果需要的话)</p>
<ul>
<li><p>将类中出现的符号输入到类自身的符号表中，内容有：类符号、参数类型符号(包括泛型参数类型)、超类符号、继承的接口类型符号</p>
</li>
<li><p>对上一步进一步处理，对符号表中所有的类再各自解析到各自的类符号表中</p>
</li>
<li><p>为类创建默认构造器并加入到语法树中(如果需要的话)</p>
<p>对第二步的解释，因为一个类中除了类本身会定义一些符号变量外，还会引用其他类的符号，这些符号会调用其他类的方法或变量，并且其他类还可能会继承超类或接口。这些符号都是在其它类中定义的，因此需要将这些类的符号也解析到符号表中</p>
</li>
</ul>
</li>
<li><p>处理注解</p>
</li>
<li><p>标注阶段。检查语义的合法性并进行逻辑判断，有如下几点：</p>
<ul>
<li>变量的类型是否匹配。由com.sun.tools.javac.comp.Check类完成</li>
<li>变量在使用前是否已经初始化。由com.sun.tools.javac.comp.Resolve类完成</li>
<li>能否推导出泛型方法的参数类型。由com.sun.tools.javac.comp.Infer类完成</li>
<li>字符串常量的合并。由com.sun.tools.javac.comp.ConstFold类完成，将多个字符串合并成一个字符串，比如：”hello” + “world”会合并成”helloworld”</li>
</ul>
</li>
<li><p>由com.sun.tools.javac.comp.Flow类完成数据流分析。主要内容如下：</p>
<ul>
<li>检查变量在使用前是否均被正确赋值</li>
<li>保证final修饰的变量不会被重复赋值</li>
<li>确定方法的返回类型</li>
<li>检查异常是否被捕获，或向上抛出</li>
<li>所有语句都要被执行到，比如return方法后面的语句永远也不会被执行</li>
<li>执行语义分析，消除无用代码；去除永不为真的条件判断；解除语法糖；将foreach语法形式解析成标准的for循环形式；自动装箱和自动拆箱</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h4><blockquote>
<p>经过语义分析后，Javac编译器就会调用com.sun.tools.javac.jvm.Gen类遍历语法树，生成最终的Java字节码。步骤如下：</p>
<ol>
<li>将Java方法中的代码转换成符合JVM语法的命令形式。</li>
<li>按照JVM文件组织格式将字节码输出到class扩展名的文件中。</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>javac, 编译器</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的流</title>
    <url>/2020/05/14/Java%E4%B8%AD%E7%9A%84%E6%B5%81/</url>
    <content><![CDATA[<p>Java中的 Stream 称为流，它和 java.io 包中的 InputStream 和 OutputStream 是完全不同的概念。Stream 用于对集合对象进行各种非常遍历、高效的聚合操作，或者大批量数据操作。Stream API借助于 Lambda表达式，极大提高编程效率和程序可读性。同时，Stream 提高串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势。</p>
<span id="more"></span>

<h2 id="Stream概述"><a href="#Stream概述" class="headerlink" title="Stream概述"></a>Stream概述</h2><p>下面有一个列表List，现在要从中筛选出以 <code>J </code>开头的元素，然后转换为大写，最后输出结果。如果不使用流我们是这样做的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;python&quot;</span>, <span class="string">&quot;PHP&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>);</span><br><span class="line">List&lt;String&gt; filterList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.startsWith(<span class="string">&quot;J&quot;</span>)) &#123;</span><br><span class="line">        filterList.add(str.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String str : filterList) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果使用 Stream ，则是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;python&quot;</span>, <span class="string">&quot;PHP&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">&quot;J&quot;</span>))</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>上面的例子中，集合使用 <code>stream()</code> 方法创建了一个流，然后使用 <code>filter</code> 进而 <code>map</code> 方法处理这个集合，他们都称为 <strong>中间操作</strong> 。中间操作会返回处理过后的流，以便将各种对集合的操作连接起来形成一条流水线。最后，使用了 <code>forEach</code> 方迭代筛选结果，这种位于流的末端，对流进行处理并且生成结果的方法称为 <strong>终端操作</strong>。</p>
<p>从上面的过程我们可以总结出，流的使用需要做3件事情：</p>
<ol>
<li>一个 <strong>数据源</strong> 来执行一次查询</li>
<li>一个 <strong>中间操作</strong> 链，形成一条流的流水线</li>
<li>一个 <strong>终端操作</strong> ，执行流水线，并能生成结果</li>
</ol>
<p>常用的中间操作和终端操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>操作类型</th>
<th>返回类型</th>
<th>使用的类型/函数式接口</th>
<th>描述符</th>
</tr>
</thead>
<tbody><tr>
<td>filter</td>
<td>中间操作</td>
<td>Stream&lt;T&gt;</td>
<td>Predicate&lt;T&gt;</td>
<td>T -&gt; boolean</td>
</tr>
<tr>
<td>distinct</td>
<td>中间操作</td>
<td>Stream&lt;T&gt;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>skip</td>
<td>中间操作</td>
<td>Stream&lt;T&gt;</td>
<td>long</td>
<td></td>
</tr>
<tr>
<td>limit</td>
<td>中间操作</td>
<td>Stream&lt;T&gt;</td>
<td>long</td>
<td></td>
</tr>
<tr>
<td>map</td>
<td>中间操作</td>
<td>Stream&lt;R&gt;</td>
<td>Function&lt;T, R&gt;</td>
<td>T -&gt; R</td>
</tr>
<tr>
<td>flatMap</td>
<td>中间操作</td>
<td>Stream&lt;R&gt;</td>
<td>Function&lt;T, Stream&lt;R&gt;&gt;</td>
<td>T -&gt; Stream&lt;R&gt;</td>
</tr>
<tr>
<td>sorted</td>
<td>中间操作</td>
<td>Stream&lt;T&gt;</td>
<td>Comparator&lt;T&gt;</td>
<td>(T, T) -&gt; int</td>
</tr>
<tr>
<td>anyMatch</td>
<td>终端操作</td>
<td>boolean</td>
<td>Predicate&lt;T&gt;</td>
<td>T -&gt; boolean</td>
</tr>
<tr>
<td>noneMatch</td>
<td>终端操作</td>
<td>boolean</td>
<td>Predicate&lt;T&gt;</td>
<td>T -&gt; boolean</td>
</tr>
<tr>
<td>findAny</td>
<td>终端操作</td>
<td>Optional&lt;T&gt;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>findFirst</td>
<td>终端操作</td>
<td>Optional&lt;T&gt;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>forEach</td>
<td>终端操作</td>
<td>void</td>
<td>Consumer&lt;T&gt;</td>
<td>T -&gt; void</td>
</tr>
<tr>
<td>collect</td>
<td>终端操作</td>
<td>R</td>
<td>Collector&lt;T, A, R&gt;</td>
<td></td>
</tr>
<tr>
<td>reduce</td>
<td>终端操作</td>
<td>Optional&lt;T&gt;</td>
<td>BinaryOperator&lt;T&gt;</td>
<td>(T, T) -&gt; T</td>
</tr>
<tr>
<td>count</td>
<td>终端操作</td>
<td>long</td>
<td></td>
<td></td>
</tr>
<tr>
<td>allMatch</td>
<td>终端操作</td>
<td>boolean</td>
<td>Predicate&lt;T&gt;</td>
<td>T -&gt; boolean</td>
</tr>
</tbody></table>
<p>很蒙，光看这些符号完全不知什么意思，写一些演示表示其功能，日后使用。</p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>由表可知，filter是个中间操作，该方法接收一个 <code>Predicate&lt;T&gt;</code> , 函数描述符为 <code>T -&gt; boolean</code> ,功能是对集合进行筛选，返回集合中符合要求的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">		.filter(s -&gt; s.contains(<span class="string">&quot;#&quot;</span>))<span class="comment">// 也就是说，filter方法返回值为boolean，筛选出为true的元素</span></span><br><span class="line">		.forEach(System.out::println);</span><br><span class="line"><span class="comment">// 结果输出： C#</span></span><br></pre></td></tr></table></figure>

<h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p>distinct方法用于排除流中重复的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 筛选集合中的所有偶数，并排除重复结果</span></span><br><span class="line">numbers.stream()</span><br><span class="line">    	.filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    	.distinct()</span><br><span class="line">    	.forEach(System.out::println);</span><br><span class="line"><span class="comment">// 结果输出：2 4</span></span><br></pre></td></tr></table></figure>

<h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p>skip方法用于跳过流的前n个元素，如果集合元素小于n，则返回空流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line"><span class="comment">// 筛选出以J开头的元素并排除第一个</span></span><br><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">&quot;J&quot;</span>))</span><br><span class="line">    .skip(<span class="number">1</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"><span class="comment">// 结果输出：JavaScript</span></span><br></pre></td></tr></table></figure>

<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>limit方法返回一个长度不超过n的流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .limit(<span class="number">3</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"><span class="comment">// 结果输出：Java JavaScript Python</span></span><br></pre></td></tr></table></figure>

<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map方法接收一个函数作为参数，这个函数会被用到每个元素上，并将其映射成一个新的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .map(String :: length)</span><br><span class="line">	.forEach(System.out::println);</span><br><span class="line"><span class="comment">// 结果输出：4 10 6 3 2 6 5 3 4</span></span><br></pre></td></tr></table></figure>

<p><code>map</code> 还支持将流转化为原始类型的流，比如通过 <code>mapToInt, mapToDouble, mapToLong</code> 方法，可以将流转化为 <code>IntStream, DoubleStream, LongStream</code> 。转化后的流支持一些方法，如 <code>sum, min, max</code> 方法来对流中的元素进行计算。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">IntStream intStream = numbers.stream().mapToInt(a -&gt; a);</span><br><span class="line">System.out.println(intStream.sum()); </span><br><span class="line"><span class="comment">// 结果输出为：16</span></span><br></pre></td></tr></table></figure>

<h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><p>flatMap用于将多个流合并成一个流，俗称流的扁平化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .map(s -&gt; s.split(<span class="string">&quot;&quot;</span>))</span><br><span class="line">    .map(Arrays :: stream)</span><br><span class="line">    .distinct()</span><br><span class="line">    .forEach(s -&gt; System.out.print(s + <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="comment">// 结果输出：J a v S c r i p t y h o n P H C # G l g w f + R u b</span></span><br></pre></td></tr></table></figure>

<h4 id="anyMatch"><a href="#anyMatch" class="headerlink" title="anyMatch"></a>anyMatch</h4><p>anyMatch方法用于判断流中是否有符合判断条件的元素，返回值为boolean类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line"><span class="comment">// 判断list中是否含有SQL元素</span></span><br><span class="line">list.stream()</span><br><span class="line">    .anyMatch(s -&gt; <span class="string">&quot;SQL&quot;</span>.equals(s));</span><br><span class="line"><span class="comment">// 输出结果：false</span></span><br></pre></td></tr></table></figure>

<h4 id="allMatch"><a href="#allMatch" class="headerlink" title="allMatch"></a>allMatch</h4><p>allMatch方法用于判断流中是否所有元素都满足给定的判断条件，返回值为boolean类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line"><span class="comment">// 判断list中收费所有元素长度都小于等于10</span></span><br><span class="line">list.stream()</span><br><span class="line">    .allMatch(s -&gt; s.length() &lt;= <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 结果输出：true</span></span><br></pre></td></tr></table></figure>

<h4 id="noneMatch"><a href="#noneMatch" class="headerlink" title="noneMatch"></a>noneMatch</h4><p>noneMatch方法用于判断流中是否所有元素都不满足给定的判断条件，返回值为boolean类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .noneMatch(s -&gt; s.length() &gt; <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 结果输出：true</span></span><br></pre></td></tr></table></figure>

<h4 id="findAny"><a href="#findAny" class="headerlink" title="findAny"></a>findAny</h4><p>findAny方法用于返回流中任意元素的Optional类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line"><span class="comment">// 筛选出list中任意一个以J开头的元素，如果存在，则输出它</span></span><br><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">&quot;J&quot;</span>))</span><br><span class="line">    .findAny()</span><br><span class="line">    .ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// 结果输出：Java</span></span><br></pre></td></tr></table></figure>

<h4 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h4><p>findFirst方法用于返回流中第一个元素的Optional类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line"><span class="comment">// 筛选出list中长度大于5的元素，如果存在，输出第一个</span></span><br><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.length() &gt; <span class="number">5</span>)</span><br><span class="line">    .findFirst()</span><br><span class="line">    .ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// 结果输出：JavaScript</span></span><br></pre></td></tr></table></figure>

<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>reduce方用于数字类型流的求和，求最大值，最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">numbers.stream()</span><br><span class="line">    	.reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"><span class="comment">// 结果输出：16</span></span><br><span class="line">numbers.stream()</span><br><span class="line">    	.reduce(Integer::max)</span><br><span class="line">    	.ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// 结果输出：4</span></span><br><span class="line">numbers.stream()</span><br><span class="line">    	.reduce(Integer::min)</span><br><span class="line">    	.ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// 结果输出：1</span></span><br></pre></td></tr></table></figure>

<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>forEach用于迭代流中的每个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"><span class="comment">// 结果输出：Java JavaScript Python C# Golang Swift C++ Ruby</span></span><br></pre></td></tr></table></figure>

<h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><p>count方法用于统计流中元素的个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .count();</span><br><span class="line"><span class="comment">// 结果输出：9</span></span><br></pre></td></tr></table></figure>

<h4 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h4><p>collect方法用于收集流中的元素，并放到不同类型的结果中，比如 <code>List, Set,Map </code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line">List&lt;String&gt; filterList = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;J&quot;</span>)).collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 如果要用Set或Map,只需要修改方法为toSet() toMap</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>流</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数字签名算法</title>
    <url>/2020/08/03/Java%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>数字签名算法可以看成是带秘钥的消息摘要算法，用于验证数据完整性、认证数据来源，并起到抗否认的作用。遵循私钥加签，公钥验签的规则，数字签名算法是非对称加密算法和消息摘要算法的结合体。数字签名算法主要包括RSA和DSA。本文主要记录下这两种算法在Java中的实现。</p>
<p>数字签名加签验签流程分为以下几步：</p>
<ol>
<li>A在本地构建秘钥对，并将公钥发布给B；</li>
<li>A使用私钥对数据进行签名；</li>
<li>A发送签名和数据给B；</li>
<li>B使用公钥对签名和数据进行验签。</li>
</ol>
<span id="more"></span>

<h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>RSA数字签名算法主要分为MD系列和SHA系列两大类。MD系列主要包括MD2withRSA和MD5withRSA共2种数字签名算法；SHA系列主要包括SHA1withRSA、SHA224withRSA、SHA256withRSA、SHA384withRSA和SHA512withRSA共5种数字签名算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RsaSignatureDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String value = <span class="string">&quot;Doug Wilson&quot;</span>;</span><br><span class="line">        <span class="comment">// 非对称加密算法</span></span><br><span class="line">        String algorithm = <span class="string">&quot;RSA&quot;</span>;</span><br><span class="line">        <span class="comment">// 签名算法，RSA+SHA</span></span><br><span class="line">        String signAlgorithm = <span class="string">&quot;SHA256withRSA&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ----- 公私钥生成 --------</span></span><br><span class="line">        <span class="comment">// 实例化秘钥对生成器</span></span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化，秘钥长度512~16384位，64倍数</span></span><br><span class="line">        keyPairGenerator.initialize(<span class="number">512</span>);</span><br><span class="line">        <span class="comment">// 生成秘钥对</span></span><br><span class="line">        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        <span class="comment">// 公钥</span></span><br><span class="line">        PublicKey publicKey = keyPair.getPublic();</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA公钥: &quot;</span> + Base64.getEncoder().encodeToString(publicKey.getEncoded()));</span><br><span class="line">        <span class="comment">// 私钥</span></span><br><span class="line">        PrivateKey privateKey = keyPair.getPrivate();</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA私钥: &quot;</span> + Base64.getEncoder().encodeToString(privateKey.getEncoded()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ----- 私钥加签 ---------</span></span><br><span class="line">        <span class="comment">// 获取签名对象</span></span><br><span class="line">        Signature signature = Signature.getInstance(signAlgorithm);</span><br><span class="line">        signature.initSign(privateKey);</span><br><span class="line">        signature.update(value.getBytes());</span><br><span class="line">        <span class="keyword">byte</span>[] sign = signature.sign();</span><br><span class="line">        System.out.println(<span class="string">&quot;签名值: &quot;</span> + Base64.getEncoder().encodeToString(sign));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ----- 公钥验签 ---------</span></span><br><span class="line">        signature.initVerify(publicKey);</span><br><span class="line">        signature.update(value.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;验签结果: &quot;</span> + signature.verify(sign));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">RSA公钥: MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAIAdlGVnjHPrQgrXiCaBOCHN1UmD9VVyE3qYprM3Ggds7Xiw7rnCyYluQu6AwLHxw3VQ3zndd9GsLIa4MmPpz/<span class="number">0</span>CAwEAAQ==</span><br><span class="line">RSA私钥: MIIBVQIBADANBgkqhkiG9w0BAQEFAASCAT8wggE7AgEAAkEAgB2UZWeMc+tCCteIJoE4Ic3VSYP1VXITepimszcaB2zteLDuucLJiW5C7oDAsfHDdVDfOd130awshrgyY+nP<span class="regexp">/QIDAQABAkBhj6T5D8CqaaXyQa2BvPd07p0UjbOe7O8ede7EHRrqOZpLFlf6i4FAzAeFOwUY6kHBZgJE3wlmp3x6k5YwgbMVAiEAttPcPwhg58gc1B3H4iWLtI8yftgVrbEioe49HYmNYWcCIQCzZAlLZpNl+k+cOc7rZ0TsTUpSrnsbTb1G+kpgrrgw+wIgQ8Ok98wANwjJ/</span>qkHJEAsVwFYgwFOj7F<span class="regexp">/F6v5BRCt0XMCIQCXMF5s/</span><span class="number">9</span>yGe<span class="regexp">/oQjuAHoheCmHllScxTbKdzZIq/</span>BUITdQIhAK/XnRymiY6mckZhIeCmHXV5tipnD0cRr78AYunQrLal</span><br><span class="line">签名值: eCg6+<span class="number">1</span>ziXVBRSoPYFb7Bb0NwGbVB69glB558krDHnQL6oXugKgLe0iyZUCjGd27AvwWiDzdfI7KRWvR39WJFBw==</span><br><span class="line">验签结果: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是不同签名算法需要的秘钥长度最小值不同</p>
<h2 id="DSA"><a href="#DSA" class="headerlink" title="DSA"></a>DSA</h2><p>DSA算法与RSA算法都是数字证书中不可或缺的两种算法。两者不同的是，DSA算法仅包含数字签名算法，使用DSA算法的数字证书无法进行加密通信，而RSA算法既包含加密/解密算法，同时兼有数字签名算法。</p>
<p>JDK8支持SHA1withDSA、SHA224withDSA、SHA256withDSA、SHA384withDSA和SHA512withDSA这五种DSA数字签名算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DsaSignatureDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String value = <span class="string">&quot;Doug Wilson&quot;</span>;</span><br><span class="line">        <span class="comment">// 非对称加密算法</span></span><br><span class="line">        String algorithm = <span class="string">&quot;DSA&quot;</span>;</span><br><span class="line">        <span class="comment">// 签名算法，DSA+SHA</span></span><br><span class="line">        String signAlgorithm = <span class="string">&quot;SHA224withDSA&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ----- 公私钥生成 --------</span></span><br><span class="line">        <span class="comment">// 实例化秘钥对生成器</span></span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化，秘钥长度512~1024位，64倍数</span></span><br><span class="line">        keyPairGenerator.initialize(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 生成秘钥对</span></span><br><span class="line">        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        <span class="comment">// 公钥</span></span><br><span class="line">        PublicKey publicKey = keyPair.getPublic();</span><br><span class="line">        System.out.println(<span class="string">&quot;DSA公钥: &quot;</span> + Base64.getEncoder().encodeToString(publicKey.getEncoded()));</span><br><span class="line">        <span class="comment">// 私钥</span></span><br><span class="line">        PrivateKey privateKey = keyPair.getPrivate();</span><br><span class="line">        System.out.println(<span class="string">&quot;DSA私钥: &quot;</span> + Base64.getEncoder().encodeToString(privateKey.getEncoded()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ----- 私钥加签 ---------</span></span><br><span class="line">        <span class="comment">// 获取签名对象</span></span><br><span class="line">        Signature signature = Signature.getInstance(signAlgorithm);</span><br><span class="line">        signature.initSign(privateKey);</span><br><span class="line">        signature.update(value.getBytes());</span><br><span class="line">        <span class="keyword">byte</span>[] sign = signature.sign();</span><br><span class="line">        System.out.println(<span class="string">&quot;签名值: &quot;</span> + Base64.getEncoder().encodeToString(sign));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ----- 公钥验签 ---------</span></span><br><span class="line">        signature.initVerify(publicKey);</span><br><span class="line">        signature.update(value.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;验签结果: &quot;</span> + signature.verify(sign));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">DSA公钥: MIIBtzCCASwGByqGSM44BAEwggEfAoGBAP1<span class="regexp">/U4EddRIpUt9KnC7s5Of2EbdSPO9EAMMeP4C2USZpRV1AIlH7WT2NWPq/</span>xfW6MPbLm1Vs14E7gB00b<span class="regexp">/JmYLdrmVClpJ+f6AR7ECLCT7up1/</span><span class="number">63</span>xhv4O1fnxqimFQ8E+<span class="number">4</span>P208UewwI1VBNaFpEy9nXzrith1yrv8iIDGZ3RSAHHAhUAl2BQjxUjC8yykrmCouuEC<span class="regexp">/BYHPUCgYEA9+GghdabPd7LvKtcNrhXuXmUr7v6OuqC+VdMCz0HgmdRWVeOutRZT+ZxBxCBgLRJFnEj6EwoFhO3zwkyjMim4TwWeotUfI0o4KOuHiuzpnWRbqN/</span>C<span class="regexp">/ohNWLx+2J6ASQ7zKTxvqhRkImog9/</span>hWuWfBpKLZl6Ae1UlZAFMO<span class="regexp">/7PSSoDgYQAAoGAZgGsjZjO3p24cR37gPFXfxwcL8sR2dinWMDMZMCT/</span>R4EuwvFyQYzKBE/rTPT14ffalfpAbutD+FGOCxiQt18wuglU6Pm9PjkmD2B573Jp7dJTEL4x5RcaSnSl8GKhPvtk17TbwfBEePCRz17DqM8T034Fm4pGjhGDcWh3zPwx8g=</span><br><span class="line">DSA私钥: MIIBTAIBADCCASwGByqGSM44BAEwggEfAoGBAP1<span class="regexp">/U4EddRIpUt9KnC7s5Of2EbdSPO9EAMMeP4C2USZpRV1AIlH7WT2NWPq/</span>xfW6MPbLm1Vs14E7gB00b<span class="regexp">/JmYLdrmVClpJ+f6AR7ECLCT7up1/</span><span class="number">63</span>xhv4O1fnxqimFQ8E+<span class="number">4</span>P208UewwI1VBNaFpEy9nXzrith1yrv8iIDGZ3RSAHHAhUAl2BQjxUjC8yykrmCouuEC<span class="regexp">/BYHPUCgYEA9+GghdabPd7LvKtcNrhXuXmUr7v6OuqC+VdMCz0HgmdRWVeOutRZT+ZxBxCBgLRJFnEj6EwoFhO3zwkyjMim4TwWeotUfI0o4KOuHiuzpnWRbqN/</span>C<span class="regexp">/ohNWLx+2J6ASQ7zKTxvqhRkImog9/</span>hWuWfBpKLZl6Ae1UlZAFMO/<span class="number">7</span>PSSoEFwIVAJH8km7u6HjEejjeHdyqhQ5SwFqi</span><br><span class="line">签名值: MCwCFBijyn5WxOug7e/<span class="number">9</span>jcJgZbud8mGUAhRzvLqvwprJQ7m5TpU50IFzM2k9og==</span><br><span class="line">验签结果: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数字签名, 算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型数组的创建及底层原理</title>
    <url>/2020/01/09/Java%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>今天在写数据结构的时候，碰到了泛型数组的创建。因为在Java中，泛型在编译过程会被擦除到边界(比如<strong>List&lt;T extends Number&gt; 泛型参数T在编译时会被擦除成Number</strong>)，你无法通过反射获取到泛型参数的有关信息，你唯一知道的就是你在使用一个对象。因此，对于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T array = <span class="keyword">new</span> T[size];</span><br></pre></td></tr></table></figure>

<p>是无法创建成功的。</p>
<span id="more"></span>

<h2 id="泛型的概述"><a href="#泛型的概述" class="headerlink" title="泛型的概述"></a>泛型的概述</h2><blockquote>
<p>一般的类和方法，只能使用具体的类型：要么是基本的类型，要么是自定义类，如果要编写可以应用于多种类型的代码，这种刻板的限制就会对代码的束缚很大——Java编程思想</p>
</blockquote>
<p>在Java中，解除这种限制的一个思想为多态，具体手段为面向接口编程。但是这种束缚依然存在，依然需要通过继承接口创建一个新的类来做到这一点。是否有一个手段“不受限于某种具体类型”，这便是泛型的概念。</p>
<p>泛型的概念普遍存在于容器的实现过程，这也是泛型的主要目的之一，通过泛型的使用，使得容器能够使用于不同类型对象中，达成代码的复用。而通常，指定容器持有什么类型对象由编译器保证类型的正确性，这么做的意义在于，我们经常只将容器存储于某一种类型的对象。</p>
<p>泛型的两个局限性：一是基本类型无法作为泛型的类型参数，类型参数必须为对象，而这可以通过自动拆装箱弥补。二是，在泛型代码内部，无法获取关于具体类型参数的任何信息，具体类型参数在通过检查并被编译后都将被擦除为边界类型，比如List&lt;T extends Person&gt; T将擦除到边界Person，而如果没有具体定义边界，则将被擦除到Object，例如List&lt;String&gt;和List&lt;Integer&gt; ，在编译后都将被擦除为原生List，即List&lt;Integer&gt;和List&lt;String&gt;在运行时事实上是相同的类型。</p>
<p>理解Java泛型的擦除应该从其历史的发展来进行。因为在一开始Java并没有出现泛型，而是在发展过程中将泛型作为一种技术加入到Java类库中，因此Java开发团队必须采用一种折中的处理方式，向前兼容之前的类库，不破坏原来类库中的代码，使泛型与非泛型代码共存。</p>
<p><strong>在编写泛型代码时，你要时刻告诉自己——这是一个Object!</strong></p>
<h2 id="Java泛型数组创建方法及实现原理"><a href="#Java泛型数组创建方法及实现原理" class="headerlink" title="Java泛型数组创建方法及实现原理"></a>Java泛型数组创建方法及实现原理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T[] array = <span class="keyword">new</span> T[size];</span><br></pre></td></tr></table></figure>

<p>此时上面这个代码也便好理解。我们想通过创建一个泛型数组来满足T在不同类型参数下的实现，但是Java泛型擦除告诉我们，上面这段代码等同于</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">Object[]<span class="built_in"> array </span>=<span class="built_in"> new </span>Object[size];</span><br></pre></td></tr></table></figure>

<p>我们无法在编译后获取到任何关于具体类型T的任何有关信息，也就无法创建一个具体类型T的数组。因此，要创建泛型数组，就必须在创建数组时，显示地指定类型T的具体参数信息。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">T[]<span class="built_in"> array </span>= (T[])new Object[size];</span><br></pre></td></tr></table></figure>

<p>这是一种创建数组的办法，你要问了？泛型不是会被擦除到边界吗，那上面这行代码的意义在于何处？从最终结果来看，</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">T[]<span class="built_in"> array </span>= (T[])new Object[size];  //等同于Object[]<span class="built_in"> array </span>= (T[])new Object[size];</span><br></pre></td></tr></table></figure>

<p>但是，不要忘了，在编译期间T还是一个有信息的类型参数，可以用于检查具体T参数是否符合期望。比如当你希望T是一个<code>Integer</code>时，<code>T[] array = (T[])new Object[size];</code>显然能在编译器进行检查，当检查到T的具体参数不是Integer类型时，编译不通过。</p>
<p>因此 <code>T[] array = (T[])new Object[size];</code>是一种创建泛型数组的手段。</p>
<p>另一种创建泛型数组的手段也是推荐的方式，通过<code>Array.newInstance</code>来创建一个泛型数组：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"> JDK中<span class="module-access"><span class="module"><span class="identifier">Array</span>.</span></span>newInstance源码</span><br><span class="line"> public static Object <span class="keyword">new</span><span class="constructor">Instance(Class&lt;?&gt; <span class="params">componentType</span>, <span class="params">int</span> <span class="params">length</span>)</span></span><br><span class="line">        throws NegativeArraySizeException &#123;</span><br><span class="line">        return <span class="keyword">new</span><span class="constructor">Array(<span class="params">componentType</span>, <span class="params">length</span>)</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// ComponentType为具体参数类型的class对象，length为希望创建的数组大小</span></span><br><span class="line"><span class="comment">//我们需要对其进行二次封装</span></span><br><span class="line">public static &lt;T&gt; T<span class="literal">[]</span> get<span class="constructor">Array(Class&lt;T&gt; <span class="params">componentType</span>, <span class="params">int</span> <span class="params">length</span>)</span> &#123;</span><br><span class="line">	return (T<span class="literal">[]</span>) <span class="module-access"><span class="module"><span class="identifier">Array</span>.</span></span><span class="keyword">new</span><span class="constructor">Instance(<span class="params">componentType</span>, <span class="params">length</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这道理和T[] array = (T[])new Object[size];相同，但是更加规范</span></span><br></pre></td></tr></table></figure>

<p>这里补充一个泛型使用技巧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortWithTopDown</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> E[] aux; <span class="comment">//辅助数组</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(E[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = array.length;</span><br><span class="line">        aux = (E[]) <span class="keyword">new</span> Object[n];</span><br><span class="line">        sort(array, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码在编译的时候，会报错：<code>java.lang.Object cannot be cast to Comparable...</code>，我想了很久，也没有找到解决办法，但是回过头来看资料“泛型可以定义多个边界，只会被擦除到第一个边界”，就想说通过定义第一个边界来消除这个错误，于是上面的代码变成了下面这样，将Object作为第一个边界，这确实可行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortWithTopDown</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Object</span> &amp; <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> E[] aux; <span class="comment">//辅助数组</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(E[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = array.length;</span><br><span class="line">        aux = (E[]) <span class="keyword">new</span> Object[n]; </span><br><span class="line">        sort(array, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Java泛型数组, Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda(一)</title>
    <url>/2020/05/13/Lambda(%E4%B8%80)/</url>
    <content><![CDATA[<p>Java中的Lambda表达式借鉴了其他语言的类似特性，简化了匿名函数的表达方式。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p>使用Lambda表达式后为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p>功能相同，但是更加简洁。Lambda表达式这种直接以内联的形式为函数式接口的抽象方法提供实现，并将整个表达式作为函数式接口的实例。（函数式接口简单来说就是只包含一个抽象方法的接口）</p>
<span id="more"></span>

<h2 id="Lambda表达式解析"><a href="#Lambda表达式解析" class="headerlink" title="Lambda表达式解析"></a>Lambda表达式解析</h2><p>Lambda表达式基本语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt; <span class="function">expression</span></span><br><span class="line"><span class="function">    <span class="title">or</span></span></span><br><span class="line"><span class="function"><span class="params">(Parameters)</span> -&gt; </span>&#123; statements; &#125;</span><br></pre></td></tr></table></figure>

<p>由三部分构成：</p>
<ol>
<li>参数列表</li>
<li><code>-&gt;</code> 将参数列表和Lambda表达式主体分隔开</li>
<li>Lambda主体，只有一行代码时才可以省略大括号和return关键字</li>
</ol>
<p>合法的Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(String str) -&gt; str.length()</span><br><span class="line">(String str) -&gt; &#123; <span class="keyword">return</span> str.length(); &#125; <span class="comment">// 和上面的功能一样</span></span><br><span class="line"></span><br><span class="line">() -&gt; Systm.out.println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">() -&gt; &#123;&#125;</span><br><span class="line">() -&gt; <span class="number">17</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lambda表达式使用场合"><a href="#Lambda表达式使用场合" class="headerlink" title="Lambda表达式使用场合"></a>Lambda表达式使用场合</h2><p>使用条件：</p>
<ol>
<li>实现的对象是函数式接口的抽象方法，比如Runnable的run方法</li>
<li>函数式接口的抽象方法的函数描述和Lambda表达式函数描述符一致</li>
</ol>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>常见的函数式接口有：<code>java.util.Comparator</code> ，<code>java.lang.Runnable</code> 等</p>
<p>比如 <code>java.lang.Runnable</code> 其源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口只有一个抽象方法，并使用 <code>@FunctionalInterface</code> 注解标注</p>
<p>接口可以有默认方法，而且可以有多个，这不影响接口是否为函数式接口，但是抽象方法只能有一个。</p>
<h3 id="函数描述符"><a href="#函数描述符" class="headerlink" title="函数描述符"></a>函数描述符</h3><p>函数描述符也可以理解为方法的签名。比如上述的Runnable抽象方法不接受参数，并且返回void，所以其函数描述符为 <code>() -&gt; void</code> 。而 <code>() -&gt; System.out.println(&quot;hello&quot;)</code> Lambda表达式也是不接受参数，并且返回void，所以其函数描述符也是 <code>() -&gt; void</code> 。所以代码 <code>Runnable r = () -&gt; System.out.println(&quot;hello&quot;);</code> 是合法的。</p>
<h2 id="更简洁的Lambda表达式"><a href="#更简洁的Lambda表达式" class="headerlink" title="更简洁的Lambda表达式"></a>更简洁的Lambda表达式</h2><p>自定义一个类型转化的函数式接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transform</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">transform</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未简化的Lambda表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transform&lt;String, Integer&gt; t = (String str) -&gt; Integer.valueOf(str);</span><br><span class="line">System.out.println(t.transform(<span class="string">&quot;123&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>简化后的Lambda表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transform&lt;String, Integer&gt; t = (str) -&gt; Integer.valueOf(str);</span><br><span class="line">System.out.println(t.transform(<span class="string">&quot;123&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>简化和的表达式不需要写出参数的类型，因为Java编译器会从上下文推断出用什么函数式接口来配合Lambda表达式，这意味着它可以推断出合适Lambda的签名。比如在上面这个例子中，Transform的抽象方法transform的函数描述符为 <code>(String) -&gt; Integer</code>  ，所以对应的Lambda的签名也是如此，即使Lambda的参数不声明类型，Java编译器可以知道其参数实际上为String类型。</p>
<p>上面的还不是最简的Lambda表达式，还可以优化成：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Transform</span>&lt;String, <span class="type">Integer</span>&gt; t = <span class="type">Integer</span>::valueOf;</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(t.<span class="keyword">transform</span>(&quot;123&quot;));</span><br></pre></td></tr></table></figure>

<p>虽然好像和Lambda表达式的3个结构不同，这种写法也有它的名称：<strong>方法的引用</strong></p>
<p>方法引用可以被看作仅仅调用特定方法的Lambda的一种快捷写法。它的基本思想是，如果一个Lambda代表的只是“直接调用这个方法”，那最好还是用名称来调用它，而不是去描述如何调用它，这样代码可读性更好。</p>
<p>方法引用格式为：<code>目标引用::方法名称</code></p>
<p>常见的方法引用：</p>
<table>
<thead>
<tr>
<th>Lambda表达式</th>
<th>等效方法引用</th>
</tr>
</thead>
<tbody><tr>
<td>(String s) -&gt; System.out.println(s)</td>
<td>System.out::println</td>
</tr>
<tr>
<td>(str, i) -&gt; str.substring(i)</td>
<td>String::substring</td>
</tr>
<tr>
<td>() -&gt; Thread.currentThread().dumpStack()</td>
<td>Thread.currentThread()::dumpStack</td>
</tr>
</tbody></table>
<h2 id="Lambda表达式访问遍历"><a href="#Lambda表达式访问遍历" class="headerlink" title="Lambda表达式访问遍历"></a>Lambda表达式访问遍历</h2><p>Lambda表达式可以访问 <code>局部final变量, 成员变量, 静态变量</code></p>
<p>这里主要说明局部final变量，有没有final关键字不重要，重要的是要确保该变量的值不会改变，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String hello = <span class="string">&quot;hello lambda&quot;</span>;</span><br><span class="line">Runnable r = () -&gt; System.out.println(hello);</span><br><span class="line"><span class="comment">// 该例子可以编译通过</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String hello = <span class="string">&quot;hello lambda&quot;</span>;</span><br><span class="line">Runnable r = () -&gt; System.out.println(hello);</span><br><span class="line">hello = <span class="string">&quot;change hello&quot;</span>;</span><br><span class="line"><span class="comment">// 该例子可以编译不通过</span></span><br></pre></td></tr></table></figure>

<h2 id="不使用Lambda表达式和使用Lambda表达式的对比"><a href="#不使用Lambda表达式和使用Lambda表达式的对比" class="headerlink" title="不使用Lambda表达式和使用Lambda表达式的对比"></a>不使用Lambda表达式和使用Lambda表达式的对比</h2><p>假设有如下需求：有一个包含了各种颜色不同重量的苹果框（假设为List），编写一个方法，从中筛选出：红色的苹果；红色的苹果并且重量大于1kg；绿色苹果并且重量小于0.5kg；红色的苹果并且重量大于0.5kg。</p>
<p>首先定义一个筛选接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppleFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据不同条件编写不同实现类：</p>
<h4 id="不使用Lambda表达式"><a href="#不使用Lambda表达式" class="headerlink" title="不使用Lambda表达式"></a>不使用Lambda表达式</h4><p>红色的苹果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedApple</span> <span class="keyword">implements</span> <span class="title">AppleFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;red&quot;</span>.equalsIgnoreCase(apple.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>红色的苹果并且重量大于1kg：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedAndMoreThan1kgApple</span> <span class="keyword">implements</span> <span class="title">AppleFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;red&quot;</span>.equalsIgnoreCase(apple.getColor()) &amp;&amp; apple.getWeight() &gt; <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>绿色苹果并且重量小于0.5kg，红色的苹果并且重量大于0.5kg：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenAndLessThan05OrRedAndMoreThan05Apple</span> <span class="keyword">implements</span> <span class="title">AppleFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;green&quot;</span>.equalsIgnoreCase(apple.getColor()) &amp;&amp; apple.getWeight() &lt; <span class="number">0.5</span>)</span><br><span class="line">                || (<span class="string">&quot;red&quot;</span>.equalsIgnoreCase(apple.getColor()) &amp;&amp; apple.getWeight() &gt; <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>筛选苹果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFilterMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterApple</span><span class="params">(List&lt;Apple&gt; list, AppleFilter filter)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; filterList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Apple apple : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (filter.test(apple)) &#123;</span><br><span class="line">                filterList.add(apple);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> filterList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; appleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;red&quot;</span>, <span class="number">0.4</span>));</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;red&quot;</span>, <span class="number">0.6</span>));</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;red&quot;</span>, <span class="number">1.3</span>));</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;green&quot;</span>, <span class="number">0.2</span>));</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;green&quot;</span>, <span class="number">0.35</span>));</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;green&quot;</span>, <span class="number">1.1</span>));</span><br><span class="line"></span><br><span class="line">		List&lt;Apple&gt; appleFilterList = filterApple(appleList, <span class="keyword">new</span> RedApple());</span><br><span class="line">		<span class="keyword">for</span> (Apple apple : appleFilterList) &#123;</span><br><span class="line">    		System.out.println(apple.getColor() + <span class="string">&quot; apple,weight:&quot;</span> + 					apple.getWeight());</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">red apple,weight:0.4</span><br><span class="line">red apple,weight:0.6</span><br><span class="line">red apple,weight:1.3</span><br></pre></td></tr></table></figure>

<h4 id="使用Lambda表达式"><a href="#使用Lambda表达式" class="headerlink" title="使用Lambda表达式"></a>使用Lambda表达式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFilterMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterApple</span><span class="params">(List&lt;Apple&gt; list, AppleFilter filter)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; filterList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Apple apple : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (filter.test(apple)) &#123;</span><br><span class="line">                filterList.add(apple);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> filterList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; appleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;red&quot;</span>, <span class="number">0.4</span>));</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;red&quot;</span>, <span class="number">0.6</span>));</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;red&quot;</span>, <span class="number">1.3</span>));</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;green&quot;</span>, <span class="number">0.2</span>));</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;green&quot;</span>, <span class="number">0.35</span>));</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;green&quot;</span>, <span class="number">1.1</span>));</span><br><span class="line"></span><br><span class="line">		List&lt;Apple&gt; appleFilterList = filterApple(appleList, (apple) -&gt; <span class="string">&quot;red&quot;</span>.equalsIgnoreCase(apple.getColor()));</span><br><span class="line">		<span class="keyword">for</span> (Apple apple : appleFilterList) &#123;</span><br><span class="line">    		System.out.println(apple.getColor() + <span class="string">&quot; apple,weight:&quot;</span> + 					apple.getWeight());</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="keyword">red</span> apple,weigh<span class="variable">t:0</span>.<span class="number">4</span></span><br><span class="line"><span class="keyword">red</span> apple,weigh<span class="variable">t:0</span>.<span class="number">6</span></span><br><span class="line"><span class="keyword">red</span> apple,weigh<span class="variable">t:1</span>.<span class="number">3</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>lamda</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用组合键</title>
    <url>/2020/03/27/Linux%E5%B8%B8%E7%94%A8%E7%BB%84%E5%90%88%E9%94%AE/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><blockquote>
<ul>
<li><kbd>Ctrl</kbd>+<kbd>A</kbd>  移动到光标到行首</li>
<li><kbd>Ctrl</kbd>+<kbd>E</kbd>  移动光标到行尾</li>
<li><kbd>Ctrl</kbd>+<kbd>F</kbd>  光标向前移动一个字符 和 <kbd>←</kbd> 作用一样</li>
<li><kbd>Ctrl</kbd>+<kbd>B</kbd> 光标向后移动一个字符 和<kbd>→</kbd>作用一样</li>
<li><kbd>Ctrl</kbd>+<kbd>L</kbd> 清屏</li>
</ul>
</blockquote>
<h2 id="修改文本"><a href="#修改文本" class="headerlink" title="修改文本"></a>修改文本</h2><blockquote>
<ul>
<li><kbd>Ctrl</kbd>+<kbd>D</kbd>  删除光标处的字符</li>
<li><kbd>Ctrl</kbd>+<kbd>T</kbd>  使光标处的字符和其前面的字符交换位置</li>
<li><kbd>Alt</kbd>+<kbd>L</kbd>   从光标到字尾的字符转换成小写字母形式</li>
<li><kbd>Alt</kbd>+<kbd>U</kbd>  从光标到字尾的字符转换成大写字母形式</li>
</ul>
</blockquote>
<h2 id="自动补齐"><a href="#自动补齐" class="headerlink" title="自动补齐"></a>自动补齐</h2><blockquote>
<p>输入命令时，按下Tab键将触发自动补齐功能。但需要注意的是，只有输入的内容不模棱两可，没有多个匹配的内容，是确定性的匹配时，才会自动补齐。比如在当前目录：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">目录下有Desktop  Downloads  Documents文件目录</span><br><span class="line">当在命令行输入：</span><br><span class="line"><span class="keyword">ls</span> <span class="keyword">D</span></span><br><span class="line">按下<span class="keyword">Tab</span>键不会自动补齐，因为此时匹配结果有3个。继续输入：</span><br><span class="line"><span class="keyword">ls</span> <span class="keyword">Do</span></span><br><span class="line">按下<span class="keyword">Tab</span>键不会自动补齐，因为此时匹配结果有2个。继续输入：</span><br><span class="line"><span class="keyword">ls</span> Dow</span><br><span class="line">按下<span class="keyword">Tab</span>键会自动补齐，此时匹配结果唯一：</span><br><span class="line"><span class="keyword">ls</span> Downloads/</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="历史命令记录"><a href="#历史命令记录" class="headerlink" title="历史命令记录"></a>历史命令记录</h2><blockquote>
<ul>
<li><kbd>Ctrl</kbd>+<kbd>P</kbd>   移动到前一条历史记录，相当于向上键</li>
<li><kbd>Ctrl</kbd>+<kbd>N</kbd>  移动到后一条历史记录，相当于向下键</li>
<li><kbd>Alt</kbd>+<kbd><</kbd>   移动到历史记录列表的开始处</li>
<li><kbd>Alt</kbd>+<kbd>></kbd>  移动到历史记录列表结尾处</li>
<li><kbd>Ctrl</kbd>+<kbd>R</kbd>  从当前命令行向前递增搜索</li>
<li><kbd>Ctrl</kbd>+<kbd>O</kbd>  执行历史记录当前项，执行完跳到下一项</li>
<li><kbd>Alt</kbd>+<kbd>P</kbd>  逆向非递增搜索</li>
<li><kbd>Alt</kbd>+<kbd>N</kbd>  向前非递增搜索</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>linux, 组合键</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2020/01/09/MarkDown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>主要为平时更好地写博客，省去网上查找资料的麻烦，自己对Markdown常用语法做了一个总结，并做了一些排版，便于查看。</p>
<span id="more"></span>

<h1 id="Markdown标题，使用-创建标题"><a href="#Markdown标题，使用-创建标题" class="headerlink" title="Markdown标题，使用 # 创建标题"></a>Markdown标题，使用 # 创建标题</h1><blockquote>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p><code># 一级标题</code></p>
<blockquote>
<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p><code>## 二级标题</code></p>
</blockquote>
<blockquote>
<blockquote>
<h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p><code>### 三级标题</code></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p><code>#### 四级标题</code></p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><p><code>##### 五级标题</code></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p><code>###### 六级标题</code></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h1 id="Markdown段落格式"><a href="#Markdown段落格式" class="headerlink" title="Markdown段落格式"></a>Markdown段落格式</h1><blockquote>
<blockquote>
<p>段落的换行：两个空格+回车</p>
</blockquote>
<blockquote>
<p>字体：</p>
</blockquote>
<blockquote>
<p>​            <em>斜体</em>        <code>*斜体文本*</code></p>
</blockquote>
<blockquote>
<p>​            <em>斜体</em>         <code>_斜体文本_</code></p>
</blockquote>
<blockquote>
<p>​            <strong>粗体</strong>         <code>**粗体文本**</code></p>
</blockquote>
<blockquote>
<p>​            <strong>粗体</strong>         <code>__粗体文本__</code> </p>
</blockquote>
<blockquote>
<p>​            <em><strong>斜粗体</strong></em>      <code>***斜粗体文本***</code></p>
</blockquote>
<blockquote>
<p>​            <em><strong>斜粗体</strong></em>      <code>___斜粗体文本___</code></p>
</blockquote>
<blockquote>
<p>分隔线：在一行中用三个以上的 星号 * 或者 减号 -  或者 下划线 _ 来建立一个分隔线。注意，行内不能有其他东西，但你可以在每个符号间插入空格。比如：***    或者   *  *  *  或者 ---  或者 -  -  -   或者 ___    或者 _  _  _  都是允许的，效果如下：</p>
</blockquote>
<blockquote>
<hr>
</blockquote>
<blockquote>
<p>删除线：</p>
<p>​            <del>Doug Wilson</del>     <code>~~Doug Wilson~~</code></p>
</blockquote>
<blockquote>
<p>下划线：</p>
<p>​            <u>Doug Wilson</u>       <code>&lt;u&gt;Doug Wilson&lt;/u&gt;</code></p>
</blockquote>
<blockquote>
<p>脚注：</p>
<p>​        脚注格式：<a href="%E9%BC%A0%E6%A0%87%E7%A7%BB%E5%8A%A8%E5%88%B0%E8%84%9A%E6%B3%A8%E4%B8%8A%E5%B0%B1%E4%BC%9A%E6%98%BE%E7%A4%BA%E5%86%85%E5%AE%B9">^我是脚注</a></p>
</blockquote>
<blockquote>
<p>​        <code>脚注格式：[^我是脚注]</code></p>
<p>​    <code>[^我是脚注]:鼠标移动到脚注上就会显示内容</code></p>
</blockquote>
</blockquote>
<h1 id="Markdown列表"><a href="#Markdown列表" class="headerlink" title="Markdown列表"></a>Markdown列表</h1><blockquote>
<p>无序列表：</p>
</blockquote>
<ul>
<li><p>第一项               <code>* 第一项</code></p>
</li>
<li><p>第二项               <code>* 第二项</code></p>
</li>
<li><p>第三项               <code>* 第三项</code></p>
<p>或者 用 + 或者 - 代替 * 也可以实现无序列表</p>
</li>
</ul>
<blockquote>
<p>有序列表：</p>
</blockquote>
<ol>
<li><p>第一项               <code>1. 第一项</code></p>
</li>
<li><p>第二项               <code>2. 第二项</code></p>
</li>
<li><p>第三项               <code>3. 第三项</code></p>
<p> 即采用  数字.空格 列名称</p>
</li>
</ol>
<blockquote>
<p>列表嵌套：在子列表的选项前面添加4个空格即可</p>
</blockquote>
<ol>
<li>第一项<ul>
<li>子第一项</li>
<li>子第二项</li>
</ul>
</li>
<li>第二项<ul>
<li>子第一项</li>
<li>子第二项</li>
</ul>
</li>
</ol>
<h1 id="Markdown区块"><a href="#Markdown区块" class="headerlink" title="Markdown区块"></a>Markdown区块</h1><p>区块：</p>
<blockquote>
<p>区块第一行           <code>&gt; 区块第一行</code></p>
<p>区块第二行           <code>&gt; 区块第二行</code></p>
<p>区块第三行           <code>&gt; 区块第三行</code></p>
</blockquote>
<p>区块嵌套：</p>
<blockquote>
<p>区块最外层                                 <code>&gt;区块最外层</code></p>
<blockquote>
<p>区块第二层                            <code>&gt;&gt;区块第二层</code></p>
<blockquote>
<p>区块第三层                       <code>&gt;&gt;&gt;区块第三层</code></p>
</blockquote>
</blockquote>
</blockquote>
<p>区块中要使用别的内容，只需要在对应的符号 &gt; 后面加上需要的内容即可，比如我想加一个粗体：</p>
<blockquote>
<p><strong>粗体</strong> </p>
<p><code>&gt;**粗体**</code></p>
</blockquote>
<h1 id="Markdown代码"><a href="#Markdown代码" class="headerlink" title="Markdown代码"></a>Markdown代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Java代码块&quot;</span>);</span><br><span class="line"><span class="comment">//使用Ctrl+Shift+K</span></span><br></pre></td></tr></table></figure>

<h1 id="Markdown链接"><a href="#Markdown链接" class="headerlink" title="Markdown链接"></a>Markdown链接</h1><p><a href="https://gitee.com/doug-wilson">我的作品地址：</a></p>
<p>​        <code>[我的作品地址：](链接地址)</code></p>
<p>这可以和脚注配合使用，具体用法自己尝试</p>
<h1 id="Markdown图片"><a href="#Markdown图片" class="headerlink" title="Markdown图片"></a>Markdown图片</h1><img src="/C:/Users\HMY-computer\Pictures\timg76C2063E.jpg" alt="图片介绍" style="zoom:50%;">

<p>语法格式：</p>
<p>​            <code>![alt 图片文本](图片地址)</code></p>
<h1 id="Markdown表格"><a href="#Markdown表格" class="headerlink" title="Markdown表格"></a>Markdown表格</h1><table>
<thead>
<tr>
<th>表头1</th>
<th>表头2</th>
<th>表头3</th>
</tr>
</thead>
<tbody><tr>
<td>单元1</td>
<td>单元2</td>
<td>单元3</td>
</tr>
</tbody></table>
<p>语法格式：</p>
<p>​            |表头1|表头2|表头3|</p>
<p>​            |----|----|----|</p>
<p>​            |单元1|单元2|单元3|</p>
<p>设置对齐：</p>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="center">居中对齐</th>
<th align="right">右对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元1</td>
<td align="center">单元2</td>
<td align="right">单元3</td>
</tr>
</tbody></table>
<p>​        语法格式：</p>
<p>​            |左对齐|居中对齐|右对齐|</p>
<p>​            | :—- | :—-: | —-: |</p>
<p>​            |单元1|单元2|单元3|</p>
<h1 id="Markdown转义字符"><a href="#Markdown转义字符" class="headerlink" title="Markdown转义字符"></a>Markdown转义字符</h1><p>反斜线  <br>反引号  `<br>星号    *<br>下划线  _<br>花括号  {}<br>方括号  []<br>小括号  ()<br>井号    #<br>加号    +<br>减号      -<br>英文句点  .<br>感叹号   !</p>
<p>通过在转义字符前加反斜杠\来获取字符，取消其特殊含义</p>
<h1 id="Markdown支持的HTML元素"><a href="#Markdown支持的HTML元素" class="headerlink" title="Markdown支持的HTML元素"></a>Markdown支持的HTML元素</h1><p>&lt;kbd&gt; &lt;b&gt;  &lt;i&gt;  &lt;em&gt;  &lt;sup&gt;  &lt;sub&gt;  &lt;br&gt;</p>
<p>如：使用<kbd>Ctrl</kbd>+<kbd>Shift</kbd>回到行首</p>
<p>​    语法格式：使用&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;回到行首</p>
<h1 id="Markdown数学公式"><a href="#Markdown数学公式" class="headerlink" title="Markdown数学公式"></a>Markdown数学公式</h1><p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}<br>$$</p>
<p>语法格式：</p>
<p>$$</p>
<p>\mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}</p>
<p>$$</p>
<p>通过两个美元符号$$包裹由TeX或LaTeX格式的数学公式进行实现</p>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis映射器</title>
    <url>/2020/10/08/MyBatis%E6%98%A0%E5%B0%84%E5%99%A8/</url>
    <content><![CDATA[<span id="more"></span>

<p>映射器的配置：</p>
<table>
<thead>
<tr>
<th><strong>元素名称</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>select</td>
<td>查询语句</td>
</tr>
<tr>
<td>insert</td>
<td>插入语句</td>
</tr>
<tr>
<td>update</td>
<td>更新语句</td>
</tr>
<tr>
<td>delete</td>
<td>删除语句</td>
</tr>
<tr>
<td>sql</td>
<td>允许定义一部分SQL，然后各个地方引用</td>
</tr>
<tr>
<td>resultMap</td>
<td>用于定义结果集</td>
</tr>
<tr>
<td>cache</td>
<td>给定命名控件的缓存配置</td>
</tr>
<tr>
<td>cache-ref</td>
<td>其它命名控件缓存配置的引用</td>
</tr>
</tbody></table>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h3 id="mapUnderscoreToCamelCase"><a href="#mapUnderscoreToCamelCase" class="headerlink" title="mapUnderscoreToCamelCase"></a>mapUnderscoreToCamelCase</h3><p>数据库字段名一般采用下划线命名规则，而java中的字段名用的是驼峰命名规则：</p>
<table>
<thead>
<tr>
<th>JavaBean</th>
<th>数据库</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>id</td>
</tr>
<tr>
<td>roleName</td>
<td>role_name</td>
</tr>
<tr>
<td>note</td>
<td>note</td>
</tr>
<tr>
<td>isGirl</td>
<td>is_girl</td>
</tr>
</tbody></table>
<p>如果数据库字段命名规范，我们可以在settins中配置mapUnderscoreToCamelCase为true：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>MyBatis就会自动将数据库字段名转换为JavaBean的字段名，比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;role&quot;</span>&gt;</span></span><br><span class="line">	&lt;![CDATA[select * from t_role where id = #&#123;id&#125;]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果不将mapUnderscoreToCamelCase设置为true，则select元素必须指明字段别名：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;role&quot;</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[select id,role_name as roleName,</span><br><span class="line">        note,is_girl as isGirl from t_role where id = #&#123;id&#125;]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>否则没有对应上的字段值为null。</p>
<h3 id="传递多个参数"><a href="#传递多个参数" class="headerlink" title="传递多个参数"></a>传递多个参数</h3><ol>
<li><p>使用Map传参</p>
<p>定义一个抽象方法：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Role&gt; <span class="title">getRole</span><span class="params">(Map&lt;String,String&gt; params)</span></span>;</span><br></pre></td></tr></table></figure>

<p>映射文件中配置select：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;role&quot;</span> <span class="attr">id</span>=<span class="string">&quot;roleList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;role_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;roleName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;note&quot;</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;is_girl&quot;</span> <span class="attr">property</span>=<span class="string">&quot;isGirl&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">javaType</span>=<span class="string">&quot;Boolean&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getRole&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;roleList&quot;</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[select * from t_role where role_name like </span><br><span class="line">        concat(&#x27;%&#x27;,#&#123;roleName&#125;,&#x27;%&#x27;) and note like </span><br><span class="line">        concat(&#x27;%&#x27;,#&#123;note&#125;,&#x27;%&#x27;)</span><br><span class="line">    ]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = <span class="module-access"><span class="module"><span class="identifier">SqlSessionFactoryUtil</span>.</span></span><span class="keyword">open</span><span class="constructor">SqlSession()</span>;</span><br><span class="line">RoleMapper mapper = sqlSession.get<span class="constructor">Mapper(RoleMapper.<span class="params">class</span>)</span>;</span><br><span class="line">Map&lt;String,String&gt; params = <span class="keyword">new</span> HashMap&lt;String,String&gt;<span class="literal">()</span>;</span><br><span class="line">params.put(<span class="string">&quot;roleName&quot;</span>, <span class="string">&quot;雏田&quot;</span>);</span><br><span class="line">params.put(<span class="string">&quot;note&quot;</span>, <span class="string">&quot;日向&quot;</span>);</span><br><span class="line">List&lt;Role&gt; roleList = mapper.get<span class="constructor">Role(<span class="params">params</span>)</span>;</span><br><span class="line"><span class="keyword">for</span>(Role r : roleList)&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(r.get<span class="constructor">RoleName()</span>+<span class="string">&quot; is a girl:&quot;</span>+r.get<span class="constructor">IsGirl()</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">雏田 <span class="keyword">is</span> a girl:<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用注解传参</li>
</ol>
<p>修改抽象方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Role&gt; getRole(<span class="meta">@Param(<span class="meta-string">&quot;roleName&quot;</span>)</span>String roleName,</span><br><span class="line">    <span class="meta">@Param(<span class="meta-string">&quot;note&quot;</span>)</span>String note);</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = <span class="module-access"><span class="module"><span class="identifier">SqlSessionFactoryUtil</span>.</span></span><span class="keyword">open</span><span class="constructor">SqlSession()</span>;</span><br><span class="line">RoleMapper mapper = sqlSession.get<span class="constructor">Mapper(RoleMapper.<span class="params">class</span>)</span>;</span><br><span class="line">List&lt;Role&gt; roleList = mapper.get<span class="constructor">Role(<span class="string">&quot;雏田&quot;</span>, <span class="string">&quot;日向&quot;</span>)</span>;</span><br><span class="line"><span class="keyword">for</span>(Role r : roleList)&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(r.get<span class="constructor">RoleName()</span>+<span class="string">&quot; is a girl:&quot;</span>+r.get<span class="constructor">IsGirl()</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">雏田 <span class="keyword">is</span> a girl:<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用JavaBean传参</li>
</ol>
<p>定义一个传递参数JavaBean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleParams</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoleName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> roleName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoleName</span><span class="params">(String roleName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roleName = roleName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNote</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> note;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNote</span><span class="params">(String note)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.note = note;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Role&gt; <span class="title">getRole</span><span class="params">(RoleParams params)</span></span>;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = <span class="module-access"><span class="module"><span class="identifier">SqlSessionFactoryUtil</span>.</span></span><span class="keyword">open</span><span class="constructor">SqlSession()</span>;</span><br><span class="line">RoleMapper mapper = sqlSession.get<span class="constructor">Mapper(RoleMapper.<span class="params">class</span>)</span>;</span><br><span class="line">RoleParams params = <span class="keyword">new</span> <span class="constructor">RoleParams()</span>;</span><br><span class="line">params.set<span class="constructor">RoleName(<span class="string">&quot;鸣人&quot;</span>)</span>;</span><br><span class="line">params.set<span class="constructor">Note(<span class="string">&quot;旋涡&quot;</span>)</span>;</span><br><span class="line">List&lt;Role&gt; roleList = mapper.get<span class="constructor">Role(<span class="params">params</span>)</span>;</span><br><span class="line"><span class="keyword">for</span>(Role r : roleList)&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(r.get<span class="constructor">RoleName()</span>+<span class="string">&quot; is a girl:&quot;</span>+r.get<span class="constructor">IsGirl()</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">鸣人 <span class="keyword">is</span> a girl:<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><h3 id="主键回填和自定义"><a href="#主键回填和自定义" class="headerlink" title="主键回填和自定义"></a>主键回填和自定义</h3><p>开发中有时候需要获取到插入行的主键值，MyBatis的主键回填可以完成这个功能。</p>
<p>定义一个createRole抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">createRole</span><span class="params">(Role role)</span></span>;</span><br></pre></td></tr></table></figure>

<p>映射：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;createRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;role&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">        insert into t_role(role_name,note,is_girl) values (#&#123;roleName&#125;,#&#123;note&#125;,</span><br><span class="line">        #&#123;isGirl,typeHandler=mrbird.leanote.typehandler.BooleanTypeHandler&#125;)</span><br><span class="line">    ]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>useGeneratedKeys会使MyBatis使用JDBC的getGeneratedKeys方法来获取出由数据库内部生成的主键，keyProperty表示以哪个列为属性的主键。</p>
<p>测试获取主键：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = <span class="module-access"><span class="module"><span class="identifier">SqlSessionFactoryUtil</span>.</span></span><span class="keyword">open</span><span class="constructor">SqlSession()</span>;</span><br><span class="line">RoleMapper mapper = sqlSession.get<span class="constructor">Mapper(RoleMapper.<span class="params">class</span>)</span>;</span><br><span class="line">Role role = <span class="keyword">new</span> <span class="constructor">Role()</span>;</span><br><span class="line">role.set<span class="constructor">RoleName(<span class="string">&quot;佐助&quot;</span>)</span>;</span><br><span class="line">role.set<span class="constructor">Note(<span class="string">&quot;宇智波&quot;</span>)</span>;</span><br><span class="line">role.set<span class="constructor">IsGirl(Boolean.FALSE)</span>;</span><br><span class="line">mapper.create<span class="constructor">Role(<span class="params">role</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(role.get<span class="constructor">Id()</span>); <span class="comment">//7</span></span><br><span class="line">sqlSession.commit<span class="literal">()</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>页面输出 7，查询数据库：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="section">mysql&gt; select * from t_role;</span></span><br><span class="line"><span class="section">+----+-----------+----------+---------+</span></span><br><span class="line"><span class="section">| id | role_name | note     | is_girl |</span></span><br><span class="line"><span class="section">+----+-----------+----------+---------+</span></span><br><span class="line">|  1 | 雏田      | 日向雏田  | Y       |</span><br><span class="line">|  2 | 鸣人      | 旋涡鸣人  | N       |</span><br><span class="line"><span class="section">|  7 | 佐助      | 宇智波    | N       |</span></span><br><span class="line"><span class="section">+----+-----------+----------+---------+</span></span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>假如数据库主键没有设置自增，我们的要求是：如果表t_role没有记录，则id设置为1，否则我们取最大id加2。这时候我们可以对映射文件的insert标签稍作修改：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;createRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;role&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- resultType必须和POJO里id的类型一致 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span>&gt;</span></span><br><span class="line">        &lt;![CDATA[</span><br><span class="line">            select if(max(id) is null,1,max(id)+2) as id from t_role</span><br><span class="line">        ]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">        insert into t_role(id,role_name,note,is_girl) values (#&#123;id&#125;,#&#123;roleName&#125;,</span><br><span class="line">        #&#123;note&#125;,</span><br><span class="line">        #&#123;isGirl,typeHandler=mrbird.leanote.typehandler.BooleanTypeHandler&#125;)</span><br><span class="line">    ]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = <span class="module-access"><span class="module"><span class="identifier">SqlSessionFactoryUtil</span>.</span></span><span class="keyword">open</span><span class="constructor">SqlSession()</span>;</span><br><span class="line">RoleMapper mapper = sqlSession.get<span class="constructor">Mapper(RoleMapper.<span class="params">class</span>)</span>;</span><br><span class="line">Role role = <span class="keyword">new</span> <span class="constructor">Role()</span>;</span><br><span class="line">role.set<span class="constructor">RoleName(<span class="string">&quot;小樱&quot;</span>)</span>;</span><br><span class="line">role.set<span class="constructor">Note(<span class="string">&quot;春野樱&quot;</span>)</span>;</span><br><span class="line">role.set<span class="constructor">IsGirl(Boolean.TRUE)</span>;</span><br><span class="line">mapper.create<span class="constructor">Role(<span class="params">role</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(role.get<span class="constructor">Id()</span>); <span class="comment">//9</span></span><br><span class="line">sqlSession.commit<span class="literal">()</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>输出9和我们预期的一致，查询数据库：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="section">mysql&gt; select * from t_role;</span></span><br><span class="line"><span class="section">+----+-----------+----------+---------+</span></span><br><span class="line"><span class="section">| id | role_name | note     | is_girl |</span></span><br><span class="line"><span class="section">+----+-----------+----------+---------+</span></span><br><span class="line">|  1 | 雏田      | 日向雏田  | Y       |</span><br><span class="line">|  2 | 鸣人      | 旋涡鸣人  | N       |</span><br><span class="line">|  7 | 佐助      | 宇智波    | N       |</span><br><span class="line"><span class="section">|  9 | 小樱      | 春野樱    | Y       |</span></span><br><span class="line"><span class="section">+----+-----------+----------+---------+</span></span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="update-amp-delete"><a href="#update-amp-delete" class="headerlink" title="update &amp; delete"></a>update &amp; delete</h2><p>update和delete较为简单，一个简单的更新和删除例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;role&quot;</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">        update t_role set role_name = #&#123;roleName&#125;,</span><br><span class="line">        note = #&#123;note&#125; where id = #&#123;id&#125;</span><br><span class="line">    ]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">        delete from t_role where id = #&#123;id&#125;</span><br><span class="line">    ]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>参数除了可以指定javaType，jdbcType和typeHandler外，还可以对数值类型的参数设置精度：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">#&#123;price,javaType=<span class="type">double</span>,jdbcType=<span class="type">NUMERIC</span>,numericScale=<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="与"><a href="#与" class="headerlink" title="$与#"></a>$与#</h3><p>#{}的值被作为sql的参数，而${}则会被当作sql的一部分。</p>
<h2 id="sql元素"><a href="#sql元素" class="headerlink" title="sql元素"></a>sql元素</h2><p>sql元素的作用是可以定义sql语句的一部分，然后导出引用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;t_role_column&quot;</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[id,role_name as roleName,note,is_girl as isGirl]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getRole&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;roleList&quot;</span>&gt;</span></span><br><span class="line">    select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;t_role_column&quot;</span>/&gt;</span></span><br><span class="line">    from t_role where role_name like </span><br><span class="line">    concat(&#x27;%&#x27;,#&#123;roleName&#125;,&#x27;%&#x27;) and note like </span><br><span class="line">    concat(&#x27;%&#x27;,#&#123;note&#125;,&#x27;%&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码定义了一个id为t_role_column的sql，然后在select元素中使用include元素引用了它，从而达到了重用的功能。</p>
<p>还可以在sql元素中指定标签：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;t_role_column&quot;</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[$&#123;prefix&#125;.id,$&#123;prefix&#125;.role_name as roleName,</span><br><span class="line">    $&#123;prefix&#125;.note,$&#123;prefix&#125;.is_girl as isGirl]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getRole&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;roleList&quot;</span>&gt;</span></span><br><span class="line">    select </span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;t_role_column&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;t&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    from t_role t where t.role_name like </span><br><span class="line">    concat(&#x27;%&#x27;,#&#123;roleName&#125;,&#x27;%&#x27;) and t.note like </span><br><span class="line">    concat(&#x27;%&#x27;,#&#123;note&#125;,&#x27;%&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis架构及映射原理</title>
    <url>/2020/03/17/MyBatis%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>MyBtis通过SQL Map将Java对象映射成SQL语句，将结果集转换成Java对象。与其他的ORM框架相比，解决了Java对象与查询结果集的映射，又能方便地编写SQL语句。</p>
<span id="more"></span>

<h2 id="MyBatis类层次结构"><a href="#MyBatis类层次结构" class="headerlink" title="MyBatis类层次结构"></a>MyBatis类层次结构</h2><blockquote>
<p>MyBatis总的来说，主要完成两件事：</p>
<ol>
<li>根据JDBC规范建立与数据库的连接</li>
<li>通过反射完成Java对象与数据库参数间相互转化的关系</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Quarz定时任务框架</title>
    <url>/2020/01/12/Quarz%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>Quarz为一个开源项目，可以用于执行定时任务。因为今天后台需要用到一个周期性线程来处理任务，就去网上看了看，觉得Quarz还不错，试试用用看。</p>
<span id="more"></span>

<blockquote>
<p>Quarz主要由以下部分组成：</p>
<p><strong>Job：执行任务。JobDetail</strong></p>
<p><strong>Trigger：触发条件。SimpleTrigger或CronTrigger</strong></p>
<p><strong>Schedule：调度器，用于协调Job和Trigger。Scheduler</strong></p>
</blockquote>
<h3 id="常用Cron表达式"><a href="#常用Cron表达式" class="headerlink" title="常用Cron表达式"></a>常用Cron表达式</h3><blockquote>
<p>10 * * * * ?  每分钟的10秒执行一次任务。比如   10:08:10  10:09:10   10:10:10</p>
<p>30 10 * * * ? 每小时的10分30秒执行一次任务。比如 10:10:30  11:10:30 12:10:30</p>
<p>30 10 1 * * ? 每天的1点10分30秒执行任务</p>
<p>30 10 1 20 * ? 每月20号的1点10分30秒执行任务</p>
<p>30 10 1 20 10? * 每年的10月20号1点10分30秒触发任务</p>
</blockquote>
]]></content>
      <tags>
        <tag>Quarz, 定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet工作原理解析</title>
    <url>/2020/02/13/Servlet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>Java Web技术是当今主流的互联网Web应用技术之一，而核心基础就是Servlet。Servlet如何工作？Servlet容器如何工作？一个Web工程在Servlet容器中如何启动？Servlet容器如何解析web.xml文件？用户的请求如何找到对应的Servlet类进行处理？Servlet容器如何管理Servlet生命周期？等等问题，都需要自己慢慢探究。</p>
<span id="more"></span>

<blockquote>
<p>首先要解释Servlet和Servlet容器的关系。Servlet是一个由Java语言编写的组件，运行在服务器端。而Servlet容器也称为Servlet引擎，是服务器的一部分，用于在Servlet生命周期内管理Servlet。</p>
<p>看起来Servlet容器和Servlet相互依赖，虽然从结果上确实如此。但是，从技术上来说，Servlet和Servlet容器是相互独立发展，通过标准化接口来进行相互协作。</p>
<p>Servlet容器随着发展，大体上有两类Servlet容器较为流行。一种为以Jetty为代表，在定制化和移动领域发展较好。一种以Tomcat的Servlet容器为代表，广泛应用于Web领域。</p>
</blockquote>
<h3 id="Tomcat的Servlet容器"><a href="#Tomcat的Servlet容器" class="headerlink" title="Tomcat的Servlet容器"></a>Tomcat的Servlet容器</h3><blockquote>
<p><img src="/images/Tomcat%E5%AE%B9%E5%99%A8%E6%A8%A1%E5%9E%8B.png"></p>
<p>Tomcat容器分为4个等级：Container容器、Engine、Host、Context。为什么没有Servlet容器？在Tomcat中，Servlet容器实际上就是Context容器。</p>
<p>从图中我们可以看出，在Tomcat中，Context容器直接管理Servlet在容器中的包装类Wrapper（为什么不直接管理Servlet类，而是要管理包装类，问题先放在这里）。所以，Context容器如何运行则会影响Servlet的工作方式。</p>
<p>通常，一个web工程对应一个context容器，不同的web工程属于不同的context容器，这在图中可以体现。</p>
<p>因此，从上面这些知识可知，在Tomcat中创建web工程，它会被context容器管理，而context容器会将servlet类构建成包装类Wrapper然后进行管理。</p>
<p>所以，如何构建Servlet类？如何解析Context容器？就是接下来的内容。</p>
<h4 id="如何解析Context容器"><a href="#如何解析Context容器" class="headerlink" title="如何解析Context容器"></a>如何解析Context容器</h4><p>先看两段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加一个web工程到一个Context容器</span></span><br><span class="line"><span class="comment">//以webapp目录下examples为例</span></span><br><span class="line">Tomcat tomcat = getTomcatInstance();</span><br><span class="line"><span class="comment">//工程url</span></span><br><span class="line">File appDir = <span class="keyword">new</span> File(getBuildDirectory(), <span class="string">&quot;webapps/examples&quot;</span>);</span><br><span class="line"><span class="comment">//将工程添加到Context容器中</span></span><br><span class="line">tomcat.addWebapp(<span class="keyword">null</span>, <span class="string">&quot;/examples&quot;</span>, appDir.getAbsolutePath());</span><br><span class="line"><span class="comment">//启动tomcat服务器</span></span><br><span class="line">tomcat.start();</span><br><span class="line">ByteChunk res = getUrl(<span class="string">&quot;http://localhost:&quot;</span> + getPort() + <span class="string">&quot;/examples/servlets/servlet/HelloWorldExample&quot;</span>);</span><br><span class="line">assertTrue(res.toString().indexOf(<span class="string">&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;</span>) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>主要就是addWebapp方法，得到添加web工程后的Context容器：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Context <span class="title">addWebapp</span><span class="params">(Host host, String url, String path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    silence(url);</span><br><span class="line">    Context ctx = <span class="keyword">new</span> StandardContext();</span><br><span class="line">    ctx.setPath(url);</span><br><span class="line">    ctx.setDocBase(path);</span><br><span class="line">    <span class="keyword">if</span> (defaultRealm == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//Context容器的默认作用范围</span></span><br><span class="line">        initSimpleAuth();</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.setRealm(defaultRealm);</span><br><span class="line">    <span class="comment">//添加解析配置文件的对象</span></span><br><span class="line">    ctx.addLifecycleListener(<span class="keyword">new</span> DefaultWebXmlListener());</span><br><span class="line">    <span class="comment">//ContextConfig，负责整个web工程配置的解析工作</span></span><br><span class="line">    ContextConfig ctxCfg = <span class="keyword">new</span> ContextConfig();</span><br><span class="line">    <span class="comment">//添加ContextConfig对象</span></span><br><span class="line">    ctx.addLifecycleListener(ctxCfg);</span><br><span class="line">   	<span class="comment">//设置配置文件</span></span><br><span class="line">  ctxCfg.setDefaultWebXml(<span class="string">&quot;org/apache/catalin/startup/NO_DEFAULT_XML&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (host == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//将Context容器添加到父容器Host中</span></span><br><span class="line">        getHost().addChild(ctx);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        host.addChild(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可知，一个web工程部署到Tomcat服务器并运行大体上有以下三步：</p>
<ol>
<li><p>获取web工程的实际的路径</p>
</li>
<li><p>将web工程添加到Context容器，并将Context容器添加到父容器Host中</p>
</li>
<li><p>调用Tomcat的start方法启动Tomcat服务器。Tomcat的启动逻辑是基于观察者模式设计的，所有的容器都会继承至Lifecycle接口。它管理容器的整个生命周期，所有容器的修改和状态的改变都会由它去通知注册的观察者(Listener)。这一点，也很明显可以从第二段代码中看出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ctx.addLifecycleListener(<span class="keyword">new</span> DefaultWebXmlListener());</span><br><span class="line">ctx.addLifecycleListener(ctxCfg);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>Tomcat启动大体过程如下(4个层级的容器依次启动)</p>
<ol>
<li>Tomcat的start方法被调用</li>
<li>StandardServer启动并初始化</li>
<li>StandardService根据配置初始化，然后启动</li>
<li>StandardEngine根据配置初始化，然后启动</li>
<li>StandardHost根据配置初始化，然后启动</li>
<li>StandardContext初始化，由ContextConfig配置类完成web工程初始化工作</li>
<li>启动后台线程，进行一些定时操作和监控</li>
<li>初始化HTTP服务并启动，这时候服务器启动完毕，处于运行状态</li>
</ol>
<p>在Context初始化步骤中，ContextConfig类至关重要，负责整个web应用的配置文件的解析工作。主要步骤如下：</p>
<p>第一步，init方法进行初始化。其init方法主要完成以下工作：</p>
<ul>
<li>创建解析xml配置文件的contextDigester对象</li>
<li>读取默认的context.xml配置文件，存在则解析</li>
<li>读取默认的host配置文件，存在则解析</li>
<li>读取context自身的配置文件，存在则解析</li>
<li>设置Context的DocBase</li>
</ul>
<p>第二步，执行startInternal方法。主要完成以下工作：</p>
<ul>
<li>创建读取资源文件的对象</li>
<li>创建ClassLoader对象</li>
<li>设置应用的工作目录</li>
<li>启动相关的辅助类，如logger/realm/resources等</li>
<li>子容器的初始化</li>
<li>获取ServletContext并设置必要参数</li>
<li>初始化”load on startup”的Servlet</li>
</ul>
<p>第三步，执行configureStart方法完成web应用的初始化工作，主要是解析web.xml文件，将web.xml文件中的各个配置项解析成相应的属性保存在WebXml对象中</p>
<p>第四步，将WebXml对象中的属性设置到Context容器中，参考下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (ServletDef servlet : servlets.values()) &#123;</span><br><span class="line">    <span class="comment">//Servlet的包装类</span></span><br><span class="line">    Wrapper wrapper = context.createWrapper();</span><br><span class="line">    <span class="comment">//JSP也是一个Servlet，这里会首先判断当前的对象是否为jsp文件</span></span><br><span class="line">    String jspFile = servlet.getJspFile();</span><br><span class="line">    <span class="keyword">if</span> (jspFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        wrapper.setJspFile(jspFile);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (servlet.getLoadOnStartup() != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//是否设置启动顺序</span></span><br><span class="line">        wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue());</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.setName(servlet.getServletName());</span><br><span class="line">    Map&lt;String, String&gt; params = servlet.getParameterMap();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : params.entrySet()) &#123;</span><br><span class="line">        <span class="comment">//设置Servlet配置的参数</span></span><br><span class="line">        <span class="comment">//通常是&lt;init-param&gt;中的</span></span><br><span class="line">        wrapper.addInitParameter(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.setRunAs(servlet.getRunAs());</span><br><span class="line">    <span class="comment">//角色权限及安全设置</span></span><br><span class="line">    Set&lt;SecurityRoleRef&gt; roleRefs = servlet.getSecurityRoleRefs();</span><br><span class="line">    <span class="keyword">for</span> (SecurityRoleRef roleRef : roleRefs) &#123;</span><br><span class="line">        wrapper.addSecurityReference(roleRef.getName(), roleRef.getLink());</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.setServletClass(servlet.getServletClass());</span><br><span class="line">    </span><br><span class="line">    MultipartDef multipartdef = servlet.getMultipartDef();</span><br><span class="line">    <span class="keyword">if</span> (multipartdef != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (multipartdef.getMaxFileSize() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           multipartdef.getMaxRequestSize() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           multipartdef.getFileSizeThreshold() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//添加注解</span></span><br><span class="line">            wrapper.setMultipartConfigElement(<span class="keyword">new</span> MultipartConfigElement(</span><br><span class="line">            	multipartdef.getLocation(), Long.parseLong(multipartdef.getMaxFileSize()), Long.parseLong(multipartdef.getMaxRequestSize()),</span><br><span class="line">           Integer.parseInt(multipartdef.getFileSizeThreshold())));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否支持同步</span></span><br><span class="line">    <span class="keyword">if</span> (servlet.getAsyncSupported() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        wrapper.setAsyncSupported(servlet.getAsyncSupported().booleanValue());</span><br><span class="line">    &#125;</span><br><span class="line">    context.addChild(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以回答前面遗留的问题：<strong>为什么要将Servlet包装成StandardWrapper而不直接使用Servlet对象？</strong>这是因为StandardWrapper是Tomcat容器的一部分，具有容器的特征。如果直接使用Servlet对象，则会将容器与Servlet对象强耦合。而Servlet作为一个独立的web开发标准，不应该强耦合在Tomcat中。</p>
<p>从以上过程可知道，Servlet被包装成StandardWrapper并作为子容器并添加到Context中，并且web.xml属性也都会被解析到Context中，因此web.xml的作用就是配置context容器的属性并配置servlet。回到第一个容器框架图中，现在更能理解Context容器才是真正运行Servlet的Servlet容器，一个web工程对应一个Context容器。</p>
<h4 id="如何构建Servlet类"><a href="#如何构建Servlet类" class="headerlink" title="如何构建Servlet类"></a>如何构建Servlet类</h4><p>如果Servlet的load-on-startup配置项大于0，那么在Context容器启动的时候Servlet就会被实例化。另外有两个默认的Servlet，分别为 <code>org.apache.catalina.servlets.DefaultServlet</code> 和</p>
<p><code>org.apache.jasper.servlet.JspServlet</code>，它们的load-on-startup分别是1和3，当Tomcat启动时，这两个Servlet就会被启动。</p>
<p>构建Servlet实例从Wrapper.loadServlet()方法开始。loadServlet()方法主要获取servletClass，然后将class类交给InstanceManager去创建一个基于servletClass.class的对象。如果这个Servlet配置了jsp-file，那么这个servletClass就是在conf/web.xml中定义的org.apache.jasper.servlet.JspServlet。</p>
<p>构建完成后，就会对Servlet进行初始化。</p>
</blockquote>
<h3 id="Servlet体系结构"><a href="#Servlet体系结构" class="headerlink" title="Servlet体系结构"></a>Servlet体系结构</h3><blockquote>
<p>Servlet的体系结构涉及到几个接口：</p>
<ul>
<li>Servlet</li>
<li>ServletContext</li>
<li>ServletConfig</li>
<li>ServletRequest</li>
<li>ServletResponse</li>
</ul>
<p>ServletRequest和ServletResponse接口的重要性和功能不需要过多介绍，这是平时中运用最多的。</p>
<p>ServletConfig接口主要是为了获取这个Servlet的一些配置属性。</p>
<p>ServletContext则是用于获取和配置全局参数，作用于整个context容器中的web工程。</p>
<p><img src="/images/Servlet%E9%A1%B6%E5%B1%82%E7%B1%BB%E5%85%B3%E8%81%94%E5%9B%BE.png"></p>
<p>从图中可以看出，与Servlet主动关联的是三个类，分别是ServletConfig/ServletRequest/ServletResponse。其中，ServletConfig在Servlet初始化时就已经和Servlet主动关联(用于初始化web工程)。而ServletRequest和ServletResponse是在用户请求时才会传递给Servlet。</p>
<p><img src="/images/ServletConfig%E5%92%8CServletContext%E4%B8%8EServlet%E5%85%B3%E7%B3%BB.png"></p>
<p>可以从图中看出，Servlet的包装类StandardWrapper和StandardWrapperFacade实现了ServletConfig接口，其中StandardWrapperFacade是StandardWrapper的外观类，也是实际传递给Servlet的对象，用于保证从StandardWrapper中拿到ServletConfig的数据，而不暴露ServletConfig不需要的数据给Servlet。</p>
<p>同理，ServletContext与ServletConfig具有类似的结构。ApplicationContextFacade也是实际传递给Sevlet的对象，保证从ApplicationContext拿到ServletContext数据而不暴露ServletContext不需要的数据给Servlet。</p>
<p><strong>对于ServletRequest和ServletResponse</strong>。通常我们使用的时候都是HttpServletRequest和HttpServletResponse对象，它们继承了ServletRequest和ServletResponse，也就是说我们实际使用的是HttpServletRequest和HttpServletResponse而不是ServletRequest和ServletResponse。那么这个转换过程是如何进行的？</p>
<ol>
<li><p>Tomcat接收到用户请求后，首先会创建org.apache.coyote.Request和org.apache.coyote.Response，这两个类是轻量级的类，作用就是在服务器接收到请求后，经过简单解析后将这个请求快速分配给后续线程处理。</p>
</li>
<li><p>当一个后续用户线程处理请求时，又会创建org.apache.catalina.connector.Request和org.apache.catalina.connector.Response两个对象，存在于Servlet容器中。</p>
</li>
<li><p>当要将值传递给Servlet时，传递给Servlet的是RequestFacade和ResponseFacade，目的也是一样，封装数据，不暴露不需要的数据</p>
</li>
</ol>
</blockquote>
<h3 id="Servlet的工作过程"><a href="#Servlet的工作过程" class="headerlink" title="Servlet的工作过程"></a>Servlet的工作过程</h3><blockquote>
<p>用户的一个请求通常会包含如下信息：</p>
<p><code>HTTP://hostname:port/contextpath/servletpath</code></p>
<p>那么服务器要做的就是根据请求找到相应的servlet处理请求，然后响应用户。关键就在于如何根据这个URL找到对应的Servlet容器中的Servlet类。</p>
<p>在Tomcat服务器中，这个映射工作由一个专门的类org.apache.tomcat.util.http.mapper完成，这个类保存了Tomcat的Container容器的所有子容器信息。当一个org.apache.catalina.connector.Request类要进入Container容器前，mapper会根据Request请求的hostname和conextpath将对应的host容器和context容器设置到Request对象的mappingData属性中，然后Request根据这个属性寻找对应的Context容器，根据Context容器配置文件的映射路径对应关系，找到对应的Servlet进行处理。</p>
</blockquote>
<h3 id="Filter如何工作"><a href="#Filter如何工作" class="headerlink" title="Filter如何工作"></a>Filter如何工作</h3><blockquote>
<p>Filter是在web.xml中一个常用的配置项，通过&lt;filter&gt;和&lt;filter-mapping&gt;组合来使用Filter。</p>
<p>实际上，Filter可以完成和Servlet同样的工作，甚至使用起来比Servlet更加灵活，因为它除了提供ServletRequest和ServletResponse对象以外，还提供了一个FilterChain对象控制请求的流转与拦截，如下图所示：</p>
<p><img src="/images/Filter%E7%B1%BB%E5%85%B3%E7%B3%BB.png"></p>
<p>在Tomcat中，FilterConfig和FilterChain的实现类分别是ApplicationFilterConfig和ApplicationFilterChain，而Filter的实现类由用户自定义，只要实现Filter接口中定义的3个方法：</p>
<ul>
<li>init(FilterConfig) 在用户自定义的Filter初始化时被调用</li>
<li>doFilter(ServletRequest, ServletResponse, FilterChain) 在用户的请求进来时，该方法都会被调用，并在Servlet的service方法之前调用。其中，FilterChain代表当前的整个请求链，通过FilterChain.doFilter方法可以将请求继续传递下去，如果想拦截请求，不调用该方法即可，那么请求就会直接返回</li>
<li>destroy() 当Filter对象被销毁时这个方法被调用</li>
</ul>
<p>Filter类的核心方法是FilterChain对象，这个对象保存了最终Servlet对象的所有Filter对象，这些对象都保存在ApplicationFilterChain对象的filters数组中。在FilterChain调用链上每执行一个Filter对象，数组的当前计数都会加1，直到计数等于数组长度并且FilterChain上的所有Filter对象执行完后，就会执行最终的Servlet。</p>
</blockquote>
]]></content>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet相关知识</title>
    <url>/2020/03/01/Servlet%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>Servlet是sun公司制订的一种用于扩展web服务器功能的组件规范。其运行原理如下：</p>
<p><img src="/images/servlet%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p>
<ol>
<li>浏览器根据IP地址和端口号port建立与服务器Servlet容器（Connection和Container）的连接</li>
<li>浏览器将请求数据打包（包含请求资源路径）</li>
<li>向容器发送请求数据包</li>
<li>容器解析请求数据包</li>
<li>容器将解析结果封装到request对象，同时创建一个response对象</li>
<li>容器根据请求资源的url地址找到servlet配置（web.xml）</li>
<li><ol start="8">
<li>创建servlet对象，调用servlet对象的service方法，在service方法中，通过request对象获取请求数据并进行相应处理，然后将要输出的结果输入的response对象中</li>
<li>容器从response对象上获取结果及数据，打包</li>
<li>将包发送给浏览器</li>
<li>浏览器从响应数据包中取出处理结果，生成相应的页面</li>
</ol>
</li>
</ol>
<span id="more"></span>

<h2 id="重定向和请求转发"><a href="#重定向和请求转发" class="headerlink" title="重定向和请求转发"></a>重定向和请求转发</h2><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><blockquote>
<p>重定向时，服务器向浏览器发送一个302状态码以及一个Location响应头消息（该消息头是一个重定向地址），浏览器收到后会立即向重定向地址发送请求。</p>
<p>特点：</p>
<ol>
<li>重定向地址可以是任意的地址</li>
<li>重定向之后，地址栏地址会变</li>
</ol>
</blockquote>
<h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><blockquote>
<p>一个web组件（通常是servlet/jsp）将问完成的处理通过容器转交给另一个web组件继续完成。常见的情况是：一个servlet获得数据之后，讲过这些数据转发给一个jsp，由这个jsp来展现这些数据。</p>
<p>请求转发特点：</p>
<ol>
<li>转发之后浏览器地址栏地址不变</li>
<li>转发的目的地必须是同一个应用内部的某个地址</li>
<li>转发所涉及的各个web组件会共享同一个request对象和response对象</li>
</ol>
<p>请求转发过程：</p>
<p><img src="/images/%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E8%BF%87%E7%A8%8B.png"></p>
</blockquote>
<h3 id="请求转发和重定向的区别"><a href="#请求转发和重定向的区别" class="headerlink" title="请求转发和重定向的区别"></a>请求转发和重定向的区别</h3><ol>
<li>转发所涉及的各个web组件会共享同一个request对象和response对象，而重定向不行。说明：当请求到达容器，容器会创建request对象和response对象，当响应发送完毕，容器会立即删除request对象和response对象。即request对象和response对象的生存时间是一次请求与响应期间。</li>
<li>转发之后，浏览器地址栏的地址不变，重定向会变。</li>
<li>转发的地址必须是同一个应用内部某个地址，而重定向没有这个限制。</li>
<li>转发是一件事情未做完，调用另外一个组件继续做；而重定向是一件事情已经做完，再调用一个组件做另外一件事情。</li>
</ol>
<h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><p>Servlet生命周期过程主要包括以下内容：Servlet容器（Wrapper）如何创建Servlet对象，如何为Servlet对象分配、准备资源、如何调用对应的方法来处理请求以及如何销毁Servlet对象。</p>
<ol>
<li>实例化，容器调用Servlet类的构造器，创建一个Servlet对象。容器在默认情况下，对某个类型的Servlet，只会创建一个实例</li>
<li>初始化，容器在创建号Servlet对象后，会立即调用该对象的init方法。一般情况下，不需要写init方法，因为GenericServlet以及提供了init方法的实现（将容器传递过来的ServletConfig对象保存下来，并且提供getServletConfig方法获取ServletConfig对象）</li>
<li>就绪，容器收到请求后，调用Servlet对象的service方法处理请求</li>
<li>销毁，容器根据自身的算法删除Servlet对象，被删除的Servlet对象被垃圾回收器收集。容器在销毁Servlet对象前会调用该对象的destroy方法（只执行一次）。可以在该方法中定义一些处理逻辑。</li>
</ol>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.Tomcat会自动调用默认构造器创建Servlet</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifeServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建LifeServlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 2.Tomcat会自动为当前的Servlet创建一个ServletConfig，用来给它预置一些数据；</span></span><br><span class="line">    <span class="comment">// 3.Tomcat会自动调用init方法，来为此Servlet初始化一些数据；</span></span><br><span class="line">    <span class="comment">// 注意，ServletConfig中预置的数据，可以在init时使用，也可以在service时使用。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化Servlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 4.当请求传入时，Tomcat会自动调用该方法来处理本次请求。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse res)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    	</span><br><span class="line">        System.out.println(<span class="string">&quot;调用service()&quot;</span>);</span><br><span class="line">        res.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        PrintWriter w = res.getWriter();</span><br><span class="line">        w.println(<span class="string">&quot;&lt;h1&gt;LifeServlet&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        w.close();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 5.Tomcat在关闭前，会自动调用该方法来销毁该Servlet。通常是将此Servlet所依赖的数据释放（=null）。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与LifeServlet相关的几个类结构图：</p>
<p><img src="/images/LifeCycle%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><p>JSP（Java Server Page）是sun公司制订的一种服务器端动态页面技术的组件规范。JSP页面中既包含HTML静态标记用于表现页面，也包含Java代码，用于生成动态内容。</p>
<p>JSP作为简化Servlet开发的一种技术，实质上依然要转变为Servlet才能运行，这个转变过程由Servlet容器完成。</p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p><img src="/images/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p>
<p>更多关于过滤器知识，参考另一篇文章《Servlet工作原理解析》</p>
]]></content>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Bean的生命周期</title>
    <url>/2021/05/25/Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>传统的Java应用，Bean的生命周期很简单。使用Java关键字new进行Bean的实例化，然后该Bean就可以使用了。一旦该Bean不再被使用，则有GC选择回收。</p>
<p>相比之下，在Spring容器中，Bean的生命周期要细腻的多。</p>
<span id="more"></span>

<p>大致过程如下：</p>
<p><img src="/images/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p>
<ol>
<li>Spring对Bean进行实例化</li>
<li>Spring将值和对Bean的引用注入到Bean对应的属性中</li>
<li>如果Bean实现了BeanNameAware接口，Spring将Bean的ID传递给setBeanName()接口方法</li>
<li>如果Bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()接口方法，将BeanFactory容器实例传入</li>
<li>如果Bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()接口方法，将应用上下文的引用传入</li>
<li>如果Bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessBeforeInitialization()接口方法</li>
<li>如果Bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet()接口方法。类似的，如果Bean使用init-method声明了初始化方法，该方法也会被调用</li>
<li>如果Bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessAfterInitialization()方法</li>
<li>Bean已经准备就绪，可以被使用了。它们将一直驻留在Spring容器中，直到容器被销毁</li>
<li>如果Bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果Bean使用destroy-method声明了销毁方法，该方法也会被调用</li>
</ol>
]]></content>
      <tags>
        <tag>spring, bean</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot Shiro用户认证</title>
    <url>/2020/09/24/Spring-Boot-Shiro%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<p>在Spring Boot中集成Shiro进行用户的认证过程主要可以归纳为以下三点：</p>
<ol>
<li><p>定义一个ShiroConfig，然后配置SecurityManager Bean，SecurityManager为Shiro的安全管理器，管理着所有Subject；</p>
</li>
<li><p>在ShiroConfig中配置ShiroFilterFactoryBean，其为Shiro过滤器工厂类，依赖于SecurityManager；</p>
</li>
<li><p>自定义Realm实现，Realm包含<code>doGetAuthorizationInfo()</code>和<code>doGetAuthenticationInfo()</code>方法，因为本文只涉及用户认证，所以只实现<code>doGetAuthenticationInfo()</code>方法。</p>
</li>
</ol>
<span id="more"></span>

<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MyBatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- thymeleaf --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- shiro-spring --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- oracle驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.oracle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ojdbc6<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- druid数据源驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="ShiroConfig"><a href="#ShiroConfig" class="headerlink" title="ShiroConfig"></a>ShiroConfig</h2><p>定义一个Shiro配置类，名称为ShiroConfig：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilterFactoryBean</span><span class="params">(SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        <span class="comment">// 设置securityManager</span></span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">// 登录的url</span></span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">        <span class="comment">// 登录成功后跳转的url</span></span><br><span class="line">        shiroFilterFactoryBean.setSuccessUrl(<span class="string">&quot;/index&quot;</span>);</span><br><span class="line">        <span class="comment">// 未授权url</span></span><br><span class="line">        shiroFilterFactoryBean.setUnauthorizedUrl(<span class="string">&quot;/403&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        LinkedHashMap&lt;String, String&gt; filterChainDefinitionMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义filterChain，静态资源不拦截</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/css/**&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/js/**&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/fonts/**&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/img/**&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        <span class="comment">// druid数据源监控页面不拦截</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/druid/**&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        <span class="comment">// 配置退出过滤器，其中具体的退出代码Shiro已经替我们实现了 </span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/logout&quot;</span>, <span class="string">&quot;logout&quot;</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        <span class="comment">// 除上以外所有url都必须认证通过才可以访问，未通过认证自动访问LoginUrl</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="comment">// 配置SecurityManager，并注入shiroRealm</span></span><br><span class="line">        DefaultWebSecurityManager securityManager =  <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        securityManager.setRealm(shiroRealm());</span><br><span class="line">        <span class="keyword">return</span> securityManager;  </span><br><span class="line">    &#125; </span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroRealm <span class="title">shiroRealm</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="comment">// 配置Realm，需自己实现</span></span><br><span class="line">        ShiroRealm shiroRealm = <span class="keyword">new</span> ShiroRealm();  </span><br><span class="line">        <span class="keyword">return</span> shiroRealm;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是filterChain基于短路机制，即最先匹配原则，如：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/user/</span>**=anon</span><br><span class="line"><span class="regexp">/user/</span>aa=authc 永远不会执行</span><br></pre></td></tr></table></figure>

<p>其中<code>anon</code>、<code>authc</code>等为Shiro为我们实现的过滤器，具体如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">Filter Name</th>
<th align="left">Class</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">anon</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/AnonymousFilter.html">org.apache.shiro.web.filter.authc.AnonymousFilter</a></td>
<td align="left">匿名拦截器，即不需要登录即可访问；一般用于静态资源过滤；示例<code>/static/**=anon</code></td>
</tr>
<tr>
<td align="left">authc</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/FormAuthenticationFilter.html">org.apache.shiro.web.filter.authc.FormAuthenticationFilter</a></td>
<td align="left">基于表单的拦截器；如<code>/**=authc</code>，如果没有登录会跳到相应的登录页面登录</td>
</tr>
<tr>
<td align="left">authcBasic</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/BasicHttpAuthenticationFilter.html">org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</a></td>
<td align="left">Basic HTTP身份验证拦截器</td>
</tr>
<tr>
<td align="left">logout</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/LogoutFilter.html">org.apache.shiro.web.filter.authc.LogoutFilter</a></td>
<td align="left">退出拦截器，主要属性：redirectUrl：退出成功后重定向的地址（/），示例<code>/logout=logout</code></td>
</tr>
<tr>
<td align="left">noSessionCreation</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/session/NoSessionCreationFilter.html">org.apache.shiro.web.filter.session.NoSessionCreationFilter</a></td>
<td align="left">不创建会话拦截器，调用<code>subject.getSession(false)</code>不会有什么问题，但是如果<code>subject.getSession(true)</code>将抛出<code>DisabledSessionException</code>异常</td>
</tr>
<tr>
<td align="left">perms</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/PermissionsAuthorizationFilter.html">org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter</a></td>
<td align="left">权限授权拦截器，验证用户是否拥有所有权限；属性和roles一样；示例<code>/user/**=perms[&quot;user:create&quot;]</code></td>
</tr>
<tr>
<td align="left">port</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/PortFilter.html">org.apache.shiro.web.filter.authz.PortFilter</a></td>
<td align="left">端口拦截器，主要属性<code>port(80)</code>：可以通过的端口；示例<code>/test= port[80]</code>，如果用户访问该页面是非80，将自动将请求端口改为80并重定向到该80端口，其他路径/参数等都一样</td>
</tr>
<tr>
<td align="left">rest</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/HttpMethodPermissionFilter.html">org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter</a></td>
<td align="left">rest风格拦截器，自动根据请求方法构建权限字符串；示例<code>/users=rest[user]</code>，会自动拼出user:read,user:create,user:update,user:delete权限字符串进行权限匹配（所有都得匹配，isPermittedAll）</td>
</tr>
<tr>
<td align="left">roles</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/RolesAuthorizationFilter.html">org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</a></td>
<td align="left">角色授权拦截器，验证用户是否拥有所有角色；示例<code>/admin/**=roles[admin]</code></td>
</tr>
<tr>
<td align="left">ssl</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/SslFilter.html">org.apache.shiro.web.filter.authz.SslFilter</a></td>
<td align="left">SSL拦截器，只有请求协议是https才能通过；否则自动跳转会https端口443；其他和port拦截器一样；</td>
</tr>
<tr>
<td align="left">user</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/UserFilter.html">org.apache.shiro.web.filter.authc.UserFilter</a></td>
<td align="left">用户拦截器，用户已经身份验证/记住我登录的都可；示例<code>/**=user</code></td>
</tr>
</tbody></table>
<p>配置完ShiroConfig后，接下来对Realm进行实现，然后注入到SecurityManager中。</p>
<h2 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h2><p>自定义Realm实现只需继承AuthorizingRealm类，然后实现doGetAuthorizationInfo()和doGetAuthenticationInfo()方法即可。这两个方法名乍看有点像，authorization发音[ˌɔ:θəraɪˈzeɪʃn]，为授权，批准的意思，即获取用户的角色和权限等信息；authentication发音[ɔ:ˌθentɪ’keɪʃn]，认证，身份验证的意思，即登录时验证用户的合法性，比如验证用户名和密码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取用户角色和权限</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录认证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 获取用户输入的用户名和密码</span></span><br><span class="line">        String userName = (String) token.getPrincipal();</span><br><span class="line">        String password = <span class="keyword">new</span> String((<span class="keyword">char</span>[]) token.getCredentials());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;用户&quot;</span> + userName + <span class="string">&quot;认证-----ShiroRealm.doGetAuthenticationInfo&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过用户名到数据库查询用户信息</span></span><br><span class="line">        User user = userMapper.findByUserName(userName);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException(<span class="string">&quot;用户名或密码错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!password.equals(user.getPassword())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IncorrectCredentialsException(<span class="string">&quot;用户名或密码错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (user.getStatus().equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockedAccountException(<span class="string">&quot;账号已被锁定,请联系管理员！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleAuthenticationInfo info = <span class="keyword">new</span> SimpleAuthenticationInfo(user, password, getName());</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只讲述用户认证，所以<code>doGetAuthorizationInfo()</code>方法先不进行实现。</p>
<p>其中<code>UnknownAccountException</code>等异常为Shiro自带异常，Shiro具有丰富的运行时<code>AuthenticationException</code>层次结构，可以准确指出尝试失败的原因。你可以包装在一个<code>try/catch</code>块，并捕捉任何你希望的异常，并作出相应的反应。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    currentUser.login(token);</span><br><span class="line">&#125; <span class="keyword">catch</span> ( UnknownAccountException uae ) &#123; ...</span><br><span class="line">&#125; <span class="keyword">catch</span> ( IncorrectCredentialsException ice ) &#123; ...</span><br><span class="line">&#125; <span class="keyword">catch</span> ( LockedAccountException lae ) &#123; ...</span><br><span class="line">&#125; <span class="keyword">catch</span> ( ExcessiveAttemptsException eae ) &#123; ...</span><br><span class="line">&#125; ... <span class="keyword">catch</span> your own ...</span><br><span class="line">&#125; <span class="keyword">catch</span> ( AuthenticationException ae ) &#123;</span><br><span class="line">    <span class="comment">//unexpected error?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然我们可以准确的获取异常信息，并根据这些信息给用户提示具体错误，但最安全的做法是在登录失败时仅向用户显示通用错误提示信息，例如“用户名或密码错误”。这样可以防止数据库被恶意扫描。</p>
<p>另外需要注意的是，在Realm中UserMapper为Dao层，标准的做法应该还有Service层，但这里为了方便就不再定义Service层了。</p>
<h2 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h2><p>库表对应的实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5440372534300871944L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get,set略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义接口UserMapper：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">findByUserName</span><span class="params">(String userName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xml实现：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.springboot.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.springboot.pojo.User&quot;</span> <span class="attr">id</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;java.lang.Integer&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;NUMERIC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;passwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;create_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createTime&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;java.util.Date&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;DATE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;status&quot;</span> <span class="attr">property</span>=<span class="string">&quot;status&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByUserName&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from t_user where username = #&#123;userName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要配置的就差不多是以上这些。</p>
]]></content>
      <tags>
        <tag>shiro, spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring JPA</title>
    <url>/2020/04/29/Spring-JPA/</url>
    <content><![CDATA[<p>Spring JPA是一个持久层框架，用于与数据库交互。JPA （Java Persistence API 称为java持久层API ）底层使用Hibernate的JPA技术实现，引用JPQL查询语言，是对JPA规范的再次封装。一般而言，Spring JPA和Spring Boot、Spring Cloud一起使用，组成有机整体。JPA上手简单，开发效率高，具有较大的灵活性（根据接口中的方法或者自定义方法就可以完成查询，十分灵活）</p>
<span id="more"></span>

<h2 id="Spring-JPA内容"><a href="#Spring-JPA内容" class="headerlink" title="Spring JPA内容"></a>Spring JPA内容</h2><ol>
<li><p>一套API标准。根据接口中的方法即可完成CRUD操作，框架代替我们完成所有事情，开发者不用再去写繁琐的SQL和JDBC语句。</p>
</li>
<li><p>面对对象查询语言 JPQL java persistence query language 用于定义自定义方法名，JPA会根据JPQL解析方法签名完成CRUD操作</p>
</li>
<li><p>ORM object/relational metadata 元数据映射 JPA的注解威力强大</p>
</li>
</ol>
<h2 id="Spring-JPA类结构"><a href="#Spring-JPA类结构" class="headerlink" title="Spring JPA类结构"></a>Spring JPA类结构</h2><p><img src="/images/JPA%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<ul>
<li><p>Repository接口：最顶层的父类，一个空接口。仅仅起到表示的作用，定义操作所需要的实体和唯一的主键</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>CrudRepository接口：继承Repository接口，定义11个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CrudRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 保存实体到数据库表中</span></span><br><span class="line">    &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S var1)</span></span>;</span><br><span class="line">    &lt;S extends T&gt; <span class="function">Iterable&lt;S&gt; <span class="title">saveAll</span><span class="params">(Iterable&lt;S&gt; var1)</span></span>;</span><br><span class="line">    <span class="comment">// 根据主键查询实体</span></span><br><span class="line">    <span class="function">Optional&lt;T&gt; <span class="title">findById</span><span class="params">(ID var1)</span></span>;</span><br><span class="line">    <span class="comment">// 根据主键查询实体再数据库表中是否存在</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">existsById</span><span class="params">(ID var1)</span></span>;</span><br><span class="line">    <span class="comment">// 在数据库表中查询实体，并返回</span></span><br><span class="line">    <span class="function">Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Iterable&lt;T&gt; <span class="title">findAllByID</span><span class="params">(Iterable&lt;ID&gt; var1)</span></span>;</span><br><span class="line">    <span class="comment">// 查询总数</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 根据某些条件从数据库表中删除实体</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(ID var1)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(T var1)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">(Iterable&lt;? extends T&gt; var1)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>PagingAndSortingRepository接口：继承CrudRepository接口所有方法，并新增两个方法，支持对查询结果的排序和分页</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PagingAndSortingRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 对查询结果进行排序</span></span><br><span class="line">    <span class="function">Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">(Sort var1)</span></span>;</span><br><span class="line">    <span class="comment">// Pageable对象包含分页和Sort对象，该方法的作用是对查询结果进行排序和分页</span></span><br><span class="line">    <span class="function">Page&lt;T&gt; <span class="title">findAll</span><span class="params">(Pageable var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>QueryByExampleExecutor接口：新功能接口，增加一些方法，但较少用到，一般使用其子接口 JpaRepositroy</p>
</li>
<li><p>JpaRepositroy接口：继承QueryByExampleExecutor接口和PagingAndSortingRepository接口的所有方法，并且，从这里开始，基本上接口新增的方法都是对关系型数据库操作的具体封装，而之前的接口方法基本都是兼容NoSQL和关系型数据库</p>
</li>
<li><p>JpaRepositoryImplementation和JpaSpecificationExecutor接口，增加一些方法，可用于自定义CRUD操作的方法，JPA根据方法签名进行相应操作</p>
</li>
<li><p>2个实现类：SimpleJpaRepository和QuerydslJpaRepository 。SimpleJpaRepository是JPA整个关联数据库的所有Repository接口的实现类，QuerydslJpaRepository是SimpleJpaRepository的扩展类，增添了一部分实现功能。</p>
</li>
</ul>
<h2 id="JPA基本开发流程"><a href="#JPA基本开发流程" class="headerlink" title="JPA基本开发流程"></a>JPA基本开发流程</h2><ol>
<li><p>创建JPA工程，添加WEB/JPA/对应关系数据库(如MYSQL)的依赖</p>
</li>
<li><p>修改工程中application.properties文件，添加如下内容spring.datasource.url=jdbc:mysql://localhost:3306/db_example？serverTimezone=GTM&amp;rewriteBatchedStatements</p>
<p>spring.datasource.username=springuser</p>
<p>spring.datasource.password=090900</p>
</li>
<li><p>创建实体类@Entity，并且该实体类有且仅有一个主键@ID@GeneratedValue(strategy=Generation.AUTO 或者别的策略)</p>
</li>
<li><p>创建一个实体类的Repository，继承某一个接口，该接口通常为CrudRepository&lt;实体类, ID&gt; 或者PagingAndSortingRepository 或者JpaRepository等接口</p>
</li>
<li><p>创建一个Controller @Controller,用于请求和数据库打交道</p>
</li>
</ol>
<h2 id="JPA自定义查询方法"><a href="#JPA自定义查询方法" class="headerlink" title="JPA自定义查询方法"></a>JPA自定义查询方法</h2><p>两种方式：</p>
<ol>
<li><p>根据方法名称查询</p>
</li>
<li><p>使用@Query手动定义查询语句</p>
</li>
</ol>
<p><strong>要求：</strong></p>
<p>自定义查询方法所在的接口必须继承Repository或者其子接口，并选择性地暴露一些CRUD方法或暴露全部的CRUD方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴露全部方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择性暴露一些方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function">T <span class="title">findOne</span><span class="params">(ID id)</span></span>;</span><br><span class="line">	<span class="function">T <span class="title">save</span><span class="params">(T entity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="根据方法名称查询"><a href="#根据方法名称查询" class="headerlink" title="根据方法名称查询"></a>根据方法名称查询</h3><p>这种查询方法一定要注意，实体类中一定要有对应的属性名称，并且必须一致，否则无法编译成功，至于方法中的参数名称可以不同。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function">User <span class="title">findByEmail</span><span class="params">(String emailAddress)</span></span>;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findByEmailAndName</span><span class="params">(String emailAddress, String name)</span></span>;</span><br><span class="line">    <span class="comment">// 实体类中一定要有属性名为email和name的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般而言，根据方法名称查询的格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">前缀+连接符+驼峰属性名+连接符+驼峰属性名...+驼峰属性名</span><br></pre></td></tr></table></figure>

<p>常用前缀：find/exists/delete  </p>
<p>常用连接符：And/Or/Between/LessThan/LessThanEqual/GreaterThan/GreaterThanEqual/IsNull/IsNotNull/IgnoreCase</p>
<p>替代过程：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">List<span class="operator">&lt;</span><span class="keyword">User</span><span class="operator">&gt;</span> findByEmailAndName(String emailAddress, String name);</span><br><span class="line">相当于 <span class="keyword">where</span> x.email<span class="operator">=</span>?<span class="number">1</span> <span class="keyword">and</span> x.name<span class="operator">=</span>?<span class="number">2</span></span><br><span class="line">占位符由括号的参数填充： <span class="keyword">where</span> x.email<span class="operator">=</span>emailAddress <span class="keyword">and</span> x.name<span class="operator">=</span>name</span><br><span class="line"></span><br><span class="line">List<span class="operator">&lt;</span><span class="keyword">User</span><span class="operator">&gt;</span> findByStartDateBetween(<span class="type">int</span> <span class="keyword">one</span>, <span class="type">int</span> two);</span><br><span class="line">相当于 <span class="keyword">where</span> x.startDate <span class="keyword">between</span> ?<span class="number">1</span> <span class="keyword">and</span> ?<span class="number">2</span></span><br><span class="line">占位符由括号的参数填充： <span class="keyword">where</span> x.startDate <span class="keyword">between</span> <span class="keyword">one</span> <span class="keyword">and</span> two</span><br></pre></td></tr></table></figure>

<h3 id="注解式查询-Query"><a href="#注解式查询-Query" class="headerlink" title="注解式查询@Query"></a>注解式查询@Query</h3><p>主要关注@Query注解中的两个参数：value和nativeQuery</p>
<ul>
<li>value用于保存编写的查询语句，默认值为空；nativeQuery用于设定value保存查询语句的类别，默认值为false</li>
<li>nativeQuery=false 则value中的查询语句为JPQL查询语句</li>
<li>nativeQuery=true 则value中的查询语句为SQL原生语句</li>
</ul>
<p>JPQL与SQL区别，请看下面两个例子：</p>
<ul>
<li>JPQL查询语句：SELECT u FROM User u WHERE u.name=?1</li>
<li>SQL查询语句：SELECT * FROM user WHERE name=?1</li>
</ul>
<p>JPQL与实体类关联，SQL则与实体类对应的库表关联。上面两个查询语句在@Query中可以写成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Query</span>(<span class="keyword">value</span><span class="operator">=</span>”<span class="keyword">SELECT</span> u <span class="keyword">FROM</span> <span class="keyword">User</span> u <span class="keyword">WHERE</span> u.name<span class="operator">=</span>?<span class="number">1</span>”)</span><br><span class="line"></span><br><span class="line"><span class="variable">@Query</span>(nativeQuery<span class="operator">=</span><span class="literal">true</span>,<span class="keyword">value</span><span class="operator">=</span>”<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> name<span class="operator">=</span>?<span class="number">1</span>”)</span><br></pre></td></tr></table></figure>

<h4 id="Query与-Param"><a href="#Query与-Param" class="headerlink" title="@Query与@Param"></a>@Query与@Param</h4><p>默认情况下，如果没有@Param，方法的参数是按顺序绑定到@Qeury中的占位符？  例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">@(nativeQuery<span class="operator">=</span><span class="literal">true</span>, <span class="keyword">value</span><span class="operator">=</span>”<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> name<span class="operator">=</span>?<span class="number">1</span> <span class="keyword">AND</span> email<span class="operator">=</span>?<span class="number">2</span>”)</span><br><span class="line">List<span class="operator">&lt;</span><span class="keyword">User</span><span class="operator">&gt;</span> findByNameAndEmail(String name, String email);</span><br></pre></td></tr></table></figure>

<p>如果方法中的参数顺序错乱，就会导致查询结果的不同。为此，可以使用@Param注解，来指定占位符对应的方法参数具体名称：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Query</span>(nativeQuery<span class="operator">=</span><span class="literal">true</span>, <span class="keyword">value</span><span class="operator">=</span>”<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> name<span class="operator">=</span>:name <span class="keyword">AND</span> email<span class="operator">=</span>:email”)</span><br><span class="line">List<span class="operator">&lt;</span><span class="keyword">User</span><span class="operator">&gt;</span> findByNameAndEmail(<span class="variable">@Param</span>(“email”)String email, <span class="variable">@Param</span>(“name”)String name);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>spring, jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC工作机制</title>
    <url>/2020/02/26/Spring-MVC%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Spring MVC的M、V、C是什么？Spring MVC用于帮助我们处理什么工作？Spring MVC如何允许？Spring MVC和Spring有什么关系？我希望自己能掌握明白。</p>
<span id="more"></span>

<h2 id="Spring-MVC概述"><a href="#Spring-MVC概述" class="headerlink" title="Spring MVC概述"></a>Spring MVC概述</h2><blockquote>
<p>Spring MVC含有三个模块：模型(Model)、视图(View)、控制器(Controller)。模型封装了应用的数据和业务逻辑，视图负责应用的展示，控制器负责接收用户的请求，用于改变模型和调整视图的显示。</p>
<p>Spring MVC中，DispatcherServlet用于负责接收并处理所有web请求，并根据具体的处理逻辑，委派给下一控制器实现。</p>
<p>Spring MVC作用就是处理web请求，将请求分派给对应的业务逻辑处理。其处理请求过程如下：</p>
<ol>
<li>web请求到达DispatcherServlet后，DispatcherServlet将寻求HandlerMapping的具体实现类，HandlerMapping根据web请求返回具体的Controller处理类</li>
<li>Controller根据web请求参数进行逻辑处理，并返回一个ModelAndView实例，该实例包含两部分信息：视图的逻辑名称和模型数据</li>
<li>DispatcherServlet根据Controller返回的视图逻辑名称，通过ViewResolver找到逻辑视图名称对应的View实现类，并将查找结构返回到DispatcherServlet</li>
<li>DispatcherServlet会将ModelAndView中模型数据交给具体的View实现类，委派该View实现类将模型数据渲染到对应的视图中，完成最终的视图渲染工作</li>
<li>DispatcherServlet将最终的视图结构通过HttpServletResponse输出到客户端</li>
</ol>
<p>时序图如下：</p>
<p>![](/images/Spring MVC请求时序图.png)</p>
<p>组件图如下：</p>
<p><img src="/images/spring-MVC%E7%BB%84%E4%BB%B6%E5%9B%BE.png"></p>
</blockquote>
<h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><blockquote>
<p>实际上Spring MVC的使用十分简单，只需要扩展一个路径映射关系，定义一个视图解析器，再定义一个业务逻辑的处理流程规则，剩余的事情就可以让Spring MVC帮你完成。</p>
<p>要搞清楚Spring MVC如何工作，主要看DispatcherServlet代码。先查看其类结构图：</p>
<p><img src="/images/DispatcherServlet%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<p>DispatcherServlet类继承了HttpServlet，在Servlet的init方法调用时，DispatcherServlet就会执行Spring MVC的初始化工作。DispatcherServlet的初始化内容，在initStrategies方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化MultipartResolver，用于处理文件上传服务，如果有文件上传，那么会将当前的HttpServletRequest包装成DefaultMultipartHttpServletRequest，并且将每个上传的内容封装成CommonsMultipartFile对象</span></span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理应用的国际化问题，通过解析请求的Locale和设置响应的Locale来控制应用中的字符编码问题</span></span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个主题，设置访问页面的样式，将样式作为一个Theme Name保存，保存在用于请求的Cookie中或者保存在服务端的Session中，以后每次请求根据这个Theme Name 返回特定内容</span></span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义设置的请求映射关系，用于将用户请求的URL映射成一个个Handler实例。对HandlerMapping如果没有定义，则会使用默认的两个HandlerMapping：BeanNameUrlHandlerMapping和DefaultAnnotationHandlerMapping</span></span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据Handler类型定义不同的处理规则。比如SimpleControllerHandlerAdapter处理所有的Controller实例对象，则在HandlerMapping中会将URL映射成一个Controller实例，Spring MVC在解析时，SimpleControllerHandlerAdapter就会调用这个Controller实例。如果HandlerAdapters没有自定义，也会获取DispatcherServlet.properties文件中默认的4个HandlerAdapters：HttpRequestHandlerAdapter/SimpleControllerAdapter/ThrowawayControllerHandlerAdapter/AnnotationMethodHandlerAdapter</span></span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当Handler处理出错，就会通过这个Handler来统一处理，默认实现类是SimpleMappingExceptionResolver，将错误日志记录在log文件中，并转到默认的错误页面</span></span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将指定的ViewName按照定义的RequestToViewNameTranslator替换成想要的格式，如加上前缀或者后缀</span></span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于将View解析成页面，在ViewResolvers中可以设置多个解析策略，如按照JSP解析，按照Velocity模板解析。默认的解析策略是InternalResourceViewResolver，按照JSP页面来解析</span></span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>DispatcherServlet启动时的工作：</strong></p>
<p><strong>HttpServlet初始化时会调用HttpServletBean的init方法，以获取Servlet中的init参数，并创建一个BeanWrapper对象，然后由HttpServletBean的子类执行BeanWrapper的初始化工作。但是HttpServletBean的子类FrameworkServlet和DispatcherServlet都没有覆盖initBeanWrapper方法，因此无法对BeanWrapper执行初始化工作，所以创建的BeanWrapper对象没有任何作用，Spring容器Context也不是通过BeanWrapper来创建的。</strong></p>
<p><strong>Spring容器的创建是在FrameworkServlet的initServletBean方法中完成，initServletBean方法会创建WebApplicationContext对象，并调用refresh方法完成配置文件的加载。配置文件的加载会先查找Servlet的init-param参数中设置的路径，如果没有，则会根据namespace+Servlet的名称查找XML文件。</strong></p>
<p><strong>Spring容器创建完成后，在加载时会调用DispatcherServlet的initStrategies方法完成DispatcherServlet中定义的初始化工作。在initStrategies方法中会初始化Spring MVC框架需要的8个组件，这8个组件对应的8个Bean对象保存在DispatcherServlet类中。</strong></p>
<p>至此，Spring MVC初始化完成，可以接受HTTP请求</p>
</blockquote>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><blockquote>
<p>Spring MVC中的Controller是处理请求的核心，主要由HandlerMapping和HandlerAdapters两个组件提供。HandlerMapping负责映射用户的请求和对应的处理类。类似于Servlet中Filter的FilterChain，HandlerMapping接口也定义了一个由HandlerExecutionChain代表的处理链，通过在这个处理链添加HandlerAdapters实例来处理用户请求。</p>
<h4 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h4><p>HandlerMapping的作用就是帮助我们管理请求URL和处理类Controller的映射关系，默认的HandlerMapping为BeanNameUrlHandlerMapping。比如我们定义这样一个Bean：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">name</span>=<span class="string">&quot;/test&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.doug.wilson.controller.Test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewPage&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">value</span>&gt;</span>/test.html<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果没有定义其他HandlerMapping，那么Spring MVC就会将/test.html映射到com.doug.wilson.controller.Test处理类。也就是说，如果需要映射的URL很多，那么所有的URL的匹配规则都需要在配置文件中定义。</p>
<p>HandlerMapping的初始化工作主要有两个比较重要的部分：</p>
<ol>
<li>将URL于Handler的对应关系保存在handlerMap集合中</li>
<li>将所有的实现HandlerInterceptor接口的interceptor对象保存在adaptedInterceptors数组中，等请求到来时执行adaptedInterceptors数组中所有的interceptor对象</li>
</ol>
<h4 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h4><p>HandlerMapping定义URL与Handler关系，HandlerAdapter则用于定义Handler，并且该Handler必定得符合某种规则，才能被Spring MVC识别，常见的就是继承一个接口。大部分框架都是采用这种方法，Spring MVC也不例外。下面是HandlerAdapter相关的类结构图：</p>
<p><img src="/images/HandlerAdapter%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<ul>
<li>HttpRequestHandlerAdapter。通过继承HttpRequestHandler接口，并重写void handleRequest(HttpServletRequest request，HttpServletResponse response)方法</li>
<li>SimpleControllerHandlerAdapter。通过继承Controller接口，并重写 ModelAndView handle(HttpServletRequest request，HttpServletResponse response，Object handler)方法</li>
<li>SimpleServletHandlerAdapter。通过继承Servlet接口，将一个Servlet作为一个Handler来处理请求</li>
</ul>
<p>HandlerAdapter的初始化过程为：创建一个HandlerAdapter对象，将这个对象保存在DispatcherServlet的handlerAdapters集合中。当Spring MVC将某个URL对应到某个Handler时，在handlerAdapters集合中查询到对应的handler，然后将该handler对应的handlerAdapter对象返回，并调用handlerAdapter相应类型对应的方法。</p>
</blockquote>
<h3 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><blockquote>
<p>ModelAndView对象是连接业务逻辑层和View展示层的桥梁，对于Spring MVC具体来说，则是连接Handler与View的桥梁。</p>
<p>ModelAndView对象会持有一个ModelMap对象和一个View对象(也可以是View名称)。ModelMap就是执行模板渲染时所需要的变量，Handler会将模板所需要的数据存在这个Map中，然后传递到View对象对应的ViewResolvers中。不同的ViewResolvers对ModelMap的处理方式不同，如Velocity将该ModelMap保存到org.apache.velocity.VelocityContext中，JSP则将ModelMap中的元素设置到request.setAttribute(modelName, modelValue)中。</p>
</blockquote>
<h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><blockquote>
<p>View主要由两个组件支持：RequestToViewNameTranslator和ViewResolver。</p>
<p>RequestToViewNameTranslator顾名思义就是对ViewName的解析，比如在请求的ViewName加上前缀或后缀，替换相应的字符串等。</p>
<p>ViewResolver则是根据请求的ViewName创建合适的模板引擎来渲染最终的页面。ViewResolver会根据ViewName创建一个View对象，调用View对象的void render(Map model, HttpRequest request, HttpServletResponse response)方法渲染页面。</p>
</blockquote>
]]></content>
      <tags>
        <tag>spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring声明式事务原理</title>
    <url>/2020/06/03/Spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="事务回顾"><a href="#事务回顾" class="headerlink" title="事务回顾"></a>事务回顾</h2><p>通过一个实例回顾事务的使用：</p>
<p>创建实体类实体类User：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略构造器和getter，setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建UserMapper：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into user(user_id,username,age) values(#&#123;userId&#125;,#&#123;username&#125;,#&#123;age&#125;)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建Service接口UserService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实现类UserServiceImpl：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserMapper userMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userMapper.save(user);</span><br><span class="line">        <span class="comment">// 测试事务回滚</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(user.getUsername())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;username不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Spring入口类上加上<code>@EnableTransactionManagement</code>注解，以开启事务，并简单写一些测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(TransactionApplication.class, args);</span><br><span class="line">        UserService userService = context.getBean(UserService.class);</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;1&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;18&quot;</span>);</span><br><span class="line">        userService.saveUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<ol>
<li>事务生效，数据将没有被插入到数据库中</li>
<li>注释掉UserServiceImpl的saveUser方法上的<code>@Transactional</code>注解，重新运行程序，事务没有生效，数据被插入到数据库中</li>
</ol>
<h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><h3 id="EnableTransactionManagement"><a href="#EnableTransactionManagement" class="headerlink" title="@EnableTransactionManagement"></a>@EnableTransactionManagement</h3><p>上面例子中，通过注解<code>@EnableTransactionManagement</code>开启了事务管理功能，查看其源码：</p>
<p><img src="/images/EnableTransactionManagement%E6%BA%90%E7%A0%81.png"></p>
<p>接着查看TransactionManagementConfigurationSelector的源码：</p>
<p><img src="/images/TransactionManagementConfigurationSelector%E6%BA%90%E7%A0%81.png"></p>
<p>重点关注AutoProxyRegistrar和ProxyTransactionManagementConfiguration的逻辑</p>
<h4 id="AutoProxyRegistrar"><a href="#AutoProxyRegistrar" class="headerlink" title="AutoProxyRegistrar"></a>AutoProxyRegistrar</h4><p>AutoProxyRegistrar的源码：</p>
<p><img src="/images/AutoProxyRegistrar%E6%BA%90%E7%A0%81.png"></p>
<p>查看<code>AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)</code>源码：</p>
<p><img src="/images/AopConfigUtils.registerAutoProxyCreatorIfNecessary%E6%BA%90%E7%A0%81.png"></p>
<p>查看<code>InfrastructureAdvisorAutoProxyCreator</code>的层级关系图：</p>
<p><img src="/images/infrastructureAdvisorAutoProxyCreator%E7%9A%84%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.png"></p>
<p>这和AOP原理中的AnnotationAwareAspectJAutoProxyCreator的层级关系图一致，由此可以推断出InfrastructureAdvisorAutoProxyCreator的作用为：为目标Service创建代理对象，增强目标Service方法，用于事务控制</p>
<h4 id="ProxyTransactionManagementConfiguration"><a href="#ProxyTransactionManagementConfiguration" class="headerlink" title="ProxyTransactionManagementConfiguration"></a>ProxyTransactionManagementConfiguration</h4><p>查看ProxyTransactionManagementConfiguration源码：</p>
<p><img src="/images/ProxyTransactionManagementConfiguration%E6%BA%90%E7%A0%81.png"></p>
<p>分析上述步骤：</p>
<ol>
<li><p>注册BeanFactoryTransactionAttributeSourceAdvisor增强器，该增强器需要如下两个Bean：</p>
<ul>
<li>TransactionAttributeSource</li>
<li>TransactionInterceptor</li>
</ul>
</li>
<li><p>注册TransactionAttributeSource</p>
<p><img src="/images/%E6%B3%A8%E5%86%8CTransactionAttributeSource.png"></p>
<p>方法体内部创建了一个类型为AnnotationTransactionAttributeSource的Bean，查看其源码：</p>
<p><img src="/images/AnnotationTransactionAttributeSource%E7%9A%84Bean.png"></p>
<p>查看SpringTransactionAnnotationParser源码：</p>
<p><img src="/images/SpringTransactionAnnotationParser%E6%BA%90%E7%A0%81.png"></p>
</li>
<li><p>注册TransactionInterceptor事务拦截器：</p>
<p><img src="/images/TransactionInterceptor%E4%BA%8B%E5%8A%A1%E6%8B%A6%E6%88%AA%E5%99%A8.png"></p>
<p>查看TransactionInterceptor源码，其实现了MethodInterceptor方法拦截器接口，MethodBeforeAdviceInterceptor、AspectJAfterAdvice、AfterReturningAdviceInterceptor和AspectJAfterThrowingAdvice等增强器都是MethodInterceptor的实现类，目标方法执行的时候，对应拦截器的invoke方法会被执行，所以重点关注TransactionInterceptor实现的invoke方法：</p>
<p><img src="/images/TransactionInterceptor%E5%AE%9E%E7%8E%B0%E7%9A%84invoke%E6%96%B9%E6%B3%95.png"></p>
<p>查看invokeWithinTransaction方法源码：</p>
<p><img src="/images/invokeWithinTransaction%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png"></p>
<p>completeTransactionAfterThrowing源码如下：</p>
<p><img src="/images/completeTransactionAfterThrowing%E6%BA%90%E7%A0%81.png"></p>
<p>这里，假如没有在@Transactional注解上指定回滚的异常类型的话，默认只对RunTimeExcetion和Error类型异常进行回滚：</p>
<p><img src="/images/%E9%BB%98%E8%AE%A4%E5%8F%AA%E5%AF%B9RunTimeExcetion%E5%92%8CError%E7%B1%BB%E5%9E%8B%E5%BC%82%E5%B8%B8%E8%BF%9B%E8%A1%8C%E5%9B%9E%E6%BB%9A.png"></p>
<p>commitTransactionAfterReturning源码如下：</p>
<p><img src="/images/commitTransactionAfterReturning%E6%BA%90%E7%A0%81.png"></p>
</li>
</ol>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>打开UserServiceImpl的saveUser方法上的<code>@Transactional</code>注解，然后在如下所示位置打个断点：</p>
<p><img src="/images/saveUser%E6%96%B9%E6%B3%95%E6%89%93%E6%96%AD%E7%82%B9.png"></p>
<p>以debug的方式启动程序：</p>
<p><img src="/images/%E4%BB%A5debug%E7%9A%84%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F.png"></p>
<p>可以看到目标对象已经被JDK代理（目标对象实现了接口，默认走JDK动态代理。可以通过spring.aop.proxy-target-class=true配置来强制使用cglib代理，需要额外引入AOP自动装配依赖）。</p>
<p>在断点处执行Step Into，程序跳转到JdkDynamicAopProxy的invoke方法：</p>
<p><img src="/images/JdkDynamicAopProxy%E7%9A%84invoke%E6%96%B9%E6%B3%95.png"></p>
<p><img src="/images/JdkDynamicAopProxy%E7%9A%84invoke%E6%96%B9%E6%B3%952.png"></p>
<p>程序跳转到TransactionInterceptor的invoke方法：</p>
<p><img src="/images/%E7%A8%8B%E5%BA%8F%E8%B7%B3%E8%BD%AC%E5%88%B0TransactionInterceptor%E7%9A%84invoke%E6%96%B9%E6%B3%95.png"></p>
<p><img src="/images/TransactionInterceptor%E7%9A%84invoke%E6%96%B9%E6%B3%952.png"></p>
<h2 id="事务不生效场景"><a href="#事务不生效场景" class="headerlink" title="事务不生效场景"></a>事务不生效场景</h2><p>对Spring事务机制不熟悉时，经常会遇到事务不生效的场景，这里列举两个最为常见的场景，并给出对应的解决方案</p>
<h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><p>Service方法抛出的异常不是RuntimeException或者Error类型，并且@Transactional注解上没有指定回滚异常类型。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserMapper userMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        userMapper.save(user);</span><br><span class="line">        <span class="comment">// 测试事务回滚</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(user.getUsername())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;username不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，Spring并不会进行事务回滚操作。</p>
<p><strong>默认情况下，Spring事务只对RuntimeException或者Error类型异常（错误）进行回滚，检查异常（通常为业务类异常）不会导致事务回滚。</strong>。</p>
<p>所以要解决上面这个事务不生效的问题，我们主要有以下两种方式：</p>
<ol>
<li><p>手动在@Transactional注解上声明回滚的异常类型（方法抛出该异常及其所有子类型异常都能触发事务回滚）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserMapper userMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        userMapper.save(user);</span><br><span class="line">        <span class="comment">// 测试事务回滚</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(user.getUsername())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;username不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法内手动抛出的检查异常类型改为RuntimeException子类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamInvalidException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParamInvalidException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserMapper userMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userMapper.save(user);</span><br><span class="line">        <span class="comment">// 测试事务回滚</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(user.getUsername())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ParamInvalidException(<span class="string">&quot;username不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><p>非事务方法直接通过this调用本类事务方法</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserMapper userMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUserTest</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.saveUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userMapper.save(user);</span><br><span class="line">        <span class="comment">// 测试事务回滚</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(user.getUsername())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ParamInvalidException(<span class="string">&quot;username不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在UserServiceImpl中，我们新增了saveUserTest方法，该方法没有使用@Transactional注解标注，为非事务方法，内部直接调用了saveUser事务方法</p>
<p><strong>这种情况下事务失效的原因为：Spring事务控制使用AOP代理实现，通过对目标对象的代理来增强目标方法。而上面例子直接通过this调用本类的方法的时候，this的指向并非代理类，而是该类本身。</strong></p>
<p>使用debug来验证this是否为代理对象：</p>
<p><img src="/images/%E9%AA%8C%E8%AF%81this%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1.png"></p>
<p>这种情况下要让事务生效主要有如下两种解决方式（原理都是使用代理对象来替代this）：</p>
<ol>
<li><p>从IOC容器中获取UserService Bean，然后调用它的saveUser方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserMapper userMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUserTest</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        UserService userService = context.getBean(UserService.class);</span><br><span class="line">        userService.saveUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userMapper.save(user);</span><br><span class="line">        <span class="comment">// 测试事务回滚</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(user.getUsername())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ParamInvalidException(<span class="string">&quot;username不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过实现ApplicationContextAware接口注入了应用上下文ApplicationContext，然后从中取出UserService Bean来代替this。</p>
</li>
<li><p>从AOP上下文中取出当前代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserMapper userMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUserTest</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        UserService userService = (UserService) AopContext.currentProxy();</span><br><span class="line">        userService.saveUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userMapper.save(user);</span><br><span class="line">        <span class="comment">// 测试事务回滚</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(user.getUsername())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ParamInvalidException(<span class="string">&quot;username不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>spring, 事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat服务器简析</title>
    <url>/2020/01/23/Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>Tomcat服务器目录：</p>
<ul>
<li>bin   存放服务器可执行程序</li>
<li>conf  存放服务器配置文件</li>
<li>lib  存放服务器的jar包</li>
<li>logs  存放服务器的运行日志</li>
<li>temp  存放服务器运行时产生的临时数据</li>
<li>webapps  存放部署在服务器上的web工程</li>
<li>work  服务器工作时的目录</li>
</ul>
</blockquote>
<span id="more"></span>

<h2 id="文件的上传与下载"><a href="#文件的上传与下载" class="headerlink" title="文件的上传与下载"></a>文件的上传与下载</h2><h3 id="文件的上传"><a href="#文件的上传" class="headerlink" title="文件的上传"></a>文件的上传</h3><blockquote>
<ol>
<li>form标签的设置</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;url&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">encType</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义file标签</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;上传文件名&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>通常，请求正文如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">----AbDAcb134</span><br><span class="line">Content-Disposition:form-data;</span><br><span class="line">name=&quot;username&quot;</span><br><span class="line"></span><br><span class="line">doug</span><br><span class="line">----AbDacb134</span><br><span class="line">Content-Disposition:form-data;</span><br><span class="line">name=&quot;password&quot;</span><br><span class="line"></span><br><span class="line">090900</span><br><span class="line">----AbDacb134</span><br><span class="line">Content-Disposition:form-data;</span><br><span class="line">name=&quot;photo&quot;;filename=&quot;a.jpg&quot;</span><br><span class="line">Content-Type:image/jpeg</span><br><span class="line"></span><br><span class="line">文件数据</span><br><span class="line">----AbDacb134--</span><br><span class="line"></span><br><span class="line">需要说明的就是AbDacb134是浏览器随机生成的分隔字符串，用于分隔请求数据，生成后会放在请求头中。当服务器收到请求后，就会从请求头中查找该分隔字符串，对请求数据进行解析。更重要的是最后一个分隔字符串还多了两个--，表示结束。</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编写服务器代码接收数据，这里需要用到第三方jar包</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第三方jar包：commons-fileupload.jar  和  commons-io.jar</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ServletFileUpload.isMultipartContent(request)) &#123;</span><br><span class="line">        <span class="comment">//检查请求是否包含上传文件</span></span><br><span class="line">        <span class="comment">//是则创建FileItemFactory工厂实现类</span></span><br><span class="line">        FileItemFactory fileItemFactory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">        <span class="comment">//创建解析上传数据的工具类</span></span><br><span class="line">        ServletFileUpload servletFileUpload = <span class="keyword">new</span> ServletFileUpload(fileItemFactory);</span><br><span class="line">        <span class="comment">//解析请求中的上传文件</span></span><br><span class="line">        List&lt;FileItem&gt; files = servletFileUpload.parseRequest(request);</span><br><span class="line">        <span class="comment">//解析的FileItem中包含普通表单项，需要对其进行剔除</span></span><br><span class="line">        <span class="keyword">for</span> (FileItem item : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.isFormField) &#123;</span><br><span class="line">                <span class="comment">//处理普通表单项</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//处理上传的文件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="文件的下载"><a href="#文件的下载" class="headerlink" title="文件的下载"></a>文件的下载</h3><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取用户要下载的文件名</span></span><br><span class="line">    String fileName = <span class="string">&quot;2.jpg&quot;</span>;  <span class="comment">//假设是这样的</span></span><br><span class="line">    <span class="comment">//2. 创建读取文件的输入流</span></span><br><span class="line">    ServletContex application = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">    InputStream inStream = application.getResourceAsStream(<span class="string">&quot;/url/&quot;</span> + fileName);</span><br><span class="line">    <span class="comment">//3. 文件类型设置</span></span><br><span class="line">    String fileType = application.getMimeType(<span class="string">&quot;/url/&quot;</span> + fileName);</span><br><span class="line">    response.setContentType(fileType);</span><br><span class="line">    <span class="comment">//4. 创建响应的输出流</span></span><br><span class="line">    OutputStream outStream = response.getOutputStream();</span><br><span class="line">    IOUtils.copy(inStream, outStream);</span><br><span class="line">    <span class="comment">//5. 告知浏览器如何处理文件，下载还是显示在页面中</span></span><br><span class="line">    <span class="comment">//如果是显示在页面中，这是默认行为，第5步可以省略</span></span><br><span class="line">    <span class="comment">//如果是下载，则进行如下设置</span></span><br><span class="line">    response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + <span class="string">&quot;文件下载后的名字&quot;</span>);</span><br><span class="line">    <span class="comment">//如果文件名只有英文，以下情况忽略</span></span><br><span class="line">    <span class="comment">//如果文件名包含中文，则还要根据不同浏览器进行处理</span></span><br><span class="line">    <span class="comment">//谷歌浏览器和IE浏览器：</span></span><br><span class="line">    <span class="comment">//response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + URLEncoder.encode(&quot;包含中文的文件名.jpg&quot;, &quot;UTF-8&quot;));</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//火狐浏览器：</span></span><br><span class="line">    <span class="comment">//response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename==?UTF-8?B?&quot; + </span></span><br><span class="line">    <span class="keyword">new</span> BASE64Encoder().encode(<span class="string">&quot;包含中文的文件名.jpg&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)) + <span class="string">&quot;?=&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="网页请求流程"><a href="#网页请求流程" class="headerlink" title="网页请求流程"></a>网页请求流程</h2><blockquote>
<p><img src="/images/%E7%BD%91%E9%A1%B5%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B.png"></p>
<p>从图中，可知，服务器和客户端的基本交互流程如下：</p>
<ol>
<li>用户端通过浏览器发起请求和附带请求数据</li>
<li>服务器接收并解析请求，交给相应的Servlet类处理</li>
<li>Servlet处理完毕后，将相应的响应数据和响应页面返回给客户端</li>
<li>客户端浏览器解析响应数据和响应页面，并显示给用户</li>
</ol>
</blockquote>
<h2 id="GET和POST请求格式及响应数据格式"><a href="#GET和POST请求格式及响应数据格式" class="headerlink" title="GET和POST请求格式及响应数据格式"></a>GET和POST请求格式及响应数据格式</h2><blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt;POST请求：</span><br><span class="line">&gt;请求行  POST url HTTP协议版本</span><br><span class="line">&gt;请求头  key1=value1</span><br><span class="line">   key2=value2</span><br><span class="line">&gt;空行</span><br><span class="line">&gt;请求正文 name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt;GET请求：</span><br><span class="line">&gt;请求行  <span class="builtin-name">GET</span> url&amp;<span class="attribute">name1</span>=value1&amp;name2=value2 HTTP协议版本</span><br><span class="line">&gt;请求头  <span class="attribute">key1</span>=value1</span><br><span class="line">   <span class="attribute">key2</span>=value2</span><br><span class="line">&gt;空行</span><br><span class="line">&gt;请求正文 空</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">响应数据格式：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">响应行   HTTP协议版本 状态码 状态字符</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">响应头   key1=value1</span></span><br><span class="line">	key2=value2</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">空行</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">响应正文 响应数据+响应页面</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="服务器如何解析请求"><a href="#服务器如何解析请求" class="headerlink" title="服务器如何解析请求"></a>服务器如何解析请求</h2><blockquote>
<p>服务器接收到用户请求后，先会知道该次请求是GET请求还是POST请求，然后以对应请求的方式解析请求数据。比如对于url为<code>http://主机地址:端口号/工程名/映射路径或文件</code>如果为文件，则服务器会直接将文件以响应数据格式传回给用户，通常文件为.html或.jsp。而如果为映射路径的话，yin那么服务器就会解析web.xml文件，根据映射路径找到对应的Servlet类。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--web.xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.doug.wilson.servlet.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/my<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>服务器在解析用户请求时，会将请求数据以键值对的方式读取和保存，并将数据封装成HttpServletRequest对象供程序使用，并提供方法获取该对象中的数据。同时也会提供HttpServletResponse对象，用于设置相应数据和响应内容。</p>
</blockquote>
<h2 id="请求转发和重定向"><a href="#请求转发和重定向" class="headerlink" title="请求转发和重定向"></a>请求转发和重定向</h2><blockquote>
<p><strong>请求转发：由服务器内部多个servlet进行请求处理，共有同一个请求对象，并可以通过请求对象中的setAttribute添加信息，方便下一个servlet处理。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">&quot;url&quot;</span>).forward(request, response);</span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line">&lt;jsp:forward:<span class="string">&quot;url&quot;</span>&gt;&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure>

<p><strong>重定向：接收请求的servlet处理不了用户请求，但知道哪一个资源可以处理请求，通过设置请求头，并将该资源url返回给客户端，让客户端重新发一次新的请求到资源地址，完成请求处理。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line">response.setStatus(<span class="string">&quot;302&quot;</span>);</span><br><span class="line">response.setHeader(<span class="string">&quot;Location&quot;</span>, <span class="string">&quot;url&quot;</span>);</span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line">response.sendRedirect(<span class="string">&quot;url&quot;</span>); <span class="comment">//等同于方式1，只不过进行了封装，简便使用</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%8F%8A%E9%87%8D%E5%AE%9A%E5%90%91.png"></p>
</blockquote>
<h2 id="Session和Cookie"><a href="#Session和Cookie" class="headerlink" title="Session和Cookie"></a>Session和Cookie</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><blockquote>
<p>Cookie为服务器通知客户端浏览器保存键值对的一种技术，主要是由于HTTP为无状态协议，每次请求不能够主动携带数据，影响用户某些功能的体验，比如购物车。</p>
<ol>
<li><p>Cookie的创建和回传给浏览器保存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">response.addCookie(c);</span><br></pre></td></tr></table></figure></li>
<li><p>服务器端Cookie的获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="comment">//如果要获取某个特定的Cookie，只能通过遍历进行获取</span></span><br></pre></td></tr></table></figure></li>
<li><p>Cookie常用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比如获取到了一个Cookie  cookie</span></span><br><span class="line">cookie.getDomain();  <span class="comment">//获取域名</span></span><br><span class="line">cookie.getMaxAge();  <span class="comment">//获取cookie的存活时间</span></span><br><span class="line">cookie.getName();    <span class="comment">//cookie的key</span></span><br><span class="line">cookie.getValue();   <span class="comment">//cookie的value</span></span><br></pre></td></tr></table></figure></li>
<li><p>Cookie的有效路径path。通过path可以过滤Cookie，哪些需要发送给浏览器，哪些不发</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">现假设有两个Cookie，path设置成</span><br><span class="line">Cookie cookieA  path=/工程路径</span><br><span class="line">Cookie cookieB  path=/工程路径/abc</span><br><span class="line">当请求地址为：</span><br><span class="line">http://localhost:8888/工程路径 cookieA发送，cookieB不发送</span><br><span class="line">http://localhost:8888/工程路径/abc  cookieA和cookieB都发送</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><blockquote>
<p>客户端和服务器间的会话，一次会话的结束为客户端关闭浏览器。服务器会为每个客户端创建一个会话，并分配一个唯一的id，用于标识存储的用户信息。</p>
<ol>
<li><p>创建或获取HttpSession </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpSession session = request.getSession(); <span class="comment">//没有则创建，有则获取</span></span><br><span class="line"><span class="comment">//可以通过下面的方法判断session是否是刚创建的</span></span><br><span class="line">session.isNew(); <span class="comment">//为true说明是刚创建的</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取session唯一标识符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.getId();</span><br></pre></td></tr></table></figure></li>
<li><p>往session中存储数据或者从session中读取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.setAttribute(String key, Object value);</span><br><span class="line">session.getAttribute(<span class="string">&quot;key&quot;</span>);  <span class="comment">//得到Object</span></span><br></pre></td></tr></table></figure></li>
<li><p>session的生命周期设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.setMaxInactiveInterval(<span class="keyword">int</span>);  <span class="comment">//单位为秒，超过时长，session自动销毁</span></span><br><span class="line"><span class="comment">//默认时长为1800秒——30分钟</span></span><br><span class="line"><span class="comment">//如果设置为负数，则session永远不会被销毁</span></span><br><span class="line"><span class="comment">//没有0</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">//强制销毁</span></span><br><span class="line">session.invalidate();</span><br><span class="line">      </span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h3 id="Cookie和Session的关联，以及Session如何工作"><a href="#Cookie和Session的关联，以及Session如何工作" class="headerlink" title="Cookie和Session的关联，以及Session如何工作"></a>Cookie和Session的关联，以及Session如何工作</h3><blockquote>
<p><img src="/images/session%E5%92%8Ccookie.png"></p>
<p>大体步骤如下：</p>
<ol>
<li>解析Request中的Parameters，拿到Session ID并设置到Request对象中</li>
<li>如果支持Cookie，则从Cookie中拿到Session ID并覆盖第一步中的ID</li>
<li>根据Session ID在sessions集合中查找已经存在的Session对象，如果存在则返回，不存在则创建一个新的Session对象(Session失效)并添加到sessions集合中</li>
<li>根据返回的Session对象新增一个Cookie，并将这个Cookie设置到响应头中</li>
<li>对Session对象进行操作，如修改和删除等</li>
</ol>
<p>从Request中获取的Session对象保存在org.apache.catalina.Manager类中，其实现类为org.apache.catalina.session.StandardManager。我们可以通过SessionId从StandardManager的sessions集合中取出StandardSession对象。综上，我们可以知道，StandardManager是帮助我们管理StandardSession对象的一个类。</p>
<p><img src="/images/Manager%E4%B8%8ESession%E5%85%B3%E7%B3%BB.png"></p>
<p>StandardManager类负责Servlet容器中所有StandardSession对象生命周期的管理。当Servlet容器重启或关闭时，StandardManager负责持久化没有过期的StandardSession对象，将对象保存到”SESSIONS.ser”为文件名的文件中。当Servlet容器重启时，它会重新读取这个文件并解析出所有的Session对象，重新保存在StandardManager的sessions集合中。</p>
</blockquote>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><blockquote>
<p>Filter常用于：<strong>拦截请求，过滤响应，权限检查</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> </span>&#123;</span><br><span class="line">     	<span class="comment">//逻辑代码，进行拦截请求或过滤响应、或权限检查</span></span><br><span class="line">        <span class="comment">//符合权限时，执行</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/filter%E8%BF%87%E6%BB%A4%E5%99%A8.png"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--过滤器配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.doug.wilson.MyFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>拦截请求的方式<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="拦截请求的方式"><a href="#拦截请求的方式" class="headerlink" title="拦截请求的方式"></a>拦截请求的方式</h4><blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&gt;精确匹配：<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/admin/a.jpg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> 具体到文件</span><br><span class="line">&gt;目录匹配：<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/admin/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> 匹配某个目录下的所有内容</span><br><span class="line">&gt;后缀名匹配：<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> 拦截以.html结尾的请求</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><blockquote>
<p><strong>异步请求：Asynchronous Javascript and XML 通过js异步发起请求，局部更新页面或者获取数据的技术</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 创建XMLHttpRequest对象</span></span><br><span class="line"><span class="keyword">var</span> ajaxObj;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    <span class="comment">//通用浏览器</span></span><br><span class="line">    ajaxObj = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ajaxObj = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 调用open方法设置请求参数</span></span><br><span class="line">ajaxObj.open(<span class="string">&quot;method&quot;</span>, <span class="string">&quot;url&quot;</span>, <span class="literal">true</span>); <span class="comment">//true为异步，false为同步</span></span><br><span class="line"><span class="comment">//3. 在send方法前绑定onreadystatechange事件</span></span><br><span class="line">ajaxObj.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ajaxObj.readyState == <span class="number">4</span> &amp;&amp; ajaxObj.status == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">//成功响应</span></span><br><span class="line">        ajaxObj.responseText(); <span class="comment">//获取响应数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果请求为POST请求，还需要加上下面这行代码</span></span><br><span class="line"><span class="comment">//ajaxObj.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span></span><br><span class="line"><span class="comment">//4. 调用send发送请求</span></span><br><span class="line">ajaxObj.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面是底层代码，jQuery封装了该部分，简化了使用</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;请求地址&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: <span class="string">&quot;请求数据&quot;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;GET OR POST&quot;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//data为响应数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">dataType</span>:<span class="string">&quot;text XML JSON 根据响应内容进行设置&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">readyState:</span><br><span class="line">0: 请求未初始化——还没有调用open()</span><br><span class="line">1: 请求已经建立，但是还没有发送——还没有调用send()</span><br><span class="line">2: 请求已经发送，正在处理中，可以获取响应头</span><br><span class="line">3: 请求正在处理中，响应已经有部分数据可用，但是服务器还没有完成响应的生成</span><br><span class="line">4: 响应已经完成，可以获取并使用服务器响应</span><br><span class="line">status:</span><br><span class="line">即HTTP响应码</span><br></pre></td></tr></table></figure>

</blockquote>
]]></content>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat系统架构</title>
    <url>/2020/02/15/Tomcat%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>了解Tomcat组件、Tomcat如何分发请求、Tomcat多级容器的关系以及如何协调工作。目前先了解这么多，后面再回来补。</p>
<span id="more"></span>

<h3 id="Tomcat总体结构"><a href="#Tomcat总体结构" class="headerlink" title="Tomcat总体结构"></a>Tomcat总体结构</h3><blockquote>
<p><img src="/images/Tomcat%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png"></p>
<p>总的来说，Tomcat有两个核心组件：Connector和Container。一个Container对应多个Connector，并且<strong>一个Container和多个Connector就形成了一个Service</strong>。有了Service就可以对外提供服务了。但是这还不够，我们需要给Service提供一个运行环境，并控制Service的生命周期，所以，所有的Service还必须由Server进行控制，作用就是Server为每个Service提供运行环境和控制其生命周期。</p>
<p>在Tomcat中，Service接口的标准实现类是StandardService，并且StandardService也实现了Lifycycle接口，这样它就可以控制下面组件的生命周期。和结构图中的一样，StandardService中核心的方法也是和Container、Connector以及Service有关：<strong>setContainer方法、addConnector方法以及addService方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContainer</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//清空父类容器Engine中原来的内容，然后进行container设置</span></span><br><span class="line">    Container oldContainer = <span class="keyword">this</span>.container;</span><br><span class="line">    <span class="keyword">if</span> ((oldContainer != <span class="keyword">null</span>) &amp;&amp; (oldContainer <span class="keyword">instanceof</span> Engine)) &#123;</span><br><span class="line">        ((Engine) oldContainer).setService(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对传入的container的父类容器(如果存在的话)进行清空</span></span><br><span class="line">    <span class="keyword">this</span>.container = container;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">this</span>.container != <span class="keyword">null</span>) &amp;&amp; (<span class="keyword">this</span>.container <span class="keyword">instanceof</span> Engine)) &#123;</span><br><span class="line">        ((Engine) <span class="keyword">this</span>.container).setService(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//启动新的Container的生命周期</span></span><br><span class="line">    <span class="keyword">if</span> (started &amp;&amp; (<span class="keyword">this</span>.container != <span class="keyword">null</span>) &amp;&amp; (<span class="keyword">this</span>.container <span class="keyword">instanceof</span> Lifecycle)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((Lifecycle) <span class="keyword">this</span>.container).start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifycycleException e) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectors) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connectors.length; i++) &#123;</span><br><span class="line">            <span class="comment">//将Connector和Container进行关联</span></span><br><span class="line">            connectors[i].setContainer(<span class="keyword">this</span>.container);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束oldContainer的生命周期</span></span><br><span class="line">    <span class="keyword">if</span> (started &amp;&amp; (oldContainer != <span class="keyword">null</span>) &amp;&amp; (oldContainer <span class="keyword">instanceof</span> Lifecycle)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//停止oldContainer运行</span></span><br><span class="line">            ((Lifecycle) oldContainer).stop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    support.firePropertyChange(<span class="string">&quot;container&quot;</span>, oldContainer, <span class="keyword">this</span>.container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总体来说，setContainer主要就是首先判断当前这个Service有没有以及关联Container，如果关联了就去掉这个关联关系。如果oldContainer已经启动了，则结束它的生命周期，然后再替换新的关联，初始化并开始新的Container的生命周期。最后将结果通知给相关事件的监听程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addConnector</span><span class="params">(Connector connector)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加一个新connector组件</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectors) &#123;</span><br><span class="line">        <span class="comment">//设置关联</span></span><br><span class="line">        connector.setContainer(<span class="keyword">this</span>.container);</span><br><span class="line">        connector.setService(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//新Connector数组，拷贝，加入新Connector组件，更改引用</span></span><br><span class="line">        Connector[] results = <span class="keyword">new</span> Connector[connectors.length + <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(connectors, <span class="number">0</span>, results, <span class="number">0</span>, connectors.length);</span><br><span class="line">        results[connectors.length] = connector;</span><br><span class="line">        connectors = results;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connector.initialize();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">                e.printStackTrace(System.err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始生命周期</span></span><br><span class="line">        <span class="keyword">if</span> (started &amp;&amp; (connector <span class="keyword">instanceof</span> Lifecycle)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((Lifecycle) connector).start();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通知相关组件</span></span><br><span class="line">        support.firePropertyChange(<span class="string">&quot;connector&quot;</span>, <span class="keyword">null</span>, connector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addConnector方法首先先设置关联关系，然后进行初始化，开始生命周期。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置关联关系</span></span><br><span class="line">    service.setServer(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (services) &#123;</span><br><span class="line">        <span class="comment">//采用和connector一样的添加，创建新数组，然后插入，修改引用</span></span><br><span class="line">        Service[] results = <span class="keyword">new</span> Service[services.length + <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(services, <span class="number">0</span>, results, <span class="number">0</span>, services.length);</span><br><span class="line">        results[services.length] = service;</span><br><span class="line">        services = results;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">            service.initialize();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始新的生命周期</span></span><br><span class="line">    <span class="keyword">if</span> (started &amp;&amp; (service <span class="keyword">instanceof</span> Lifecycle)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((Lifecycle) service).start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    support.firePropertyChange(<span class="string">&quot;service&quot;</span>, <span class="keyword">null</span>, service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Connector组件"><a href="#Connector组件" class="headerlink" title="Connector组件"></a>Connector组件</h3><blockquote>
<p>Connector组件主要任务就是负责接收浏览器的TCP连接请求，创建一个Request和Response对象分别用于请求和响应数据。然后产生一个线程来处理请求，并将产生的Request和Response对象传给处理这个请求的线程，线程如何执行就是Container组件要做的事情。</p>
<p>Connector处理一次请求大概流程如下：</p>
<ol>
<li>初始化一个ServerSocket</li>
<li>初始化一个线程，等待新的连接请求</li>
<li>创建一定大小的线程池，构建request和response对象</li>
<li>所有线程进入await()，等待请求到来被激活</li>
<li>当请求到来，将socket分配给HttpProcessor</li>
<li>HttpProcessor激活一个线程，并执行线程run方法</li>
<li>创建SocketInputStream和OutputStream为input和output对象，并解析请求，将请求中的内容都组装到request和response对象中。</li>
<li>将request和response两个对象传给Container组件执行，由对应的servlet处理，处理完成后，将处理结果装入request和response对象中返回</li>
<li>调用output对象，output.flush()将结果返回给客户端</li>
<li>request和response对象生命周期结束，关闭当前socket。</li>
</ol>
<p>由这个过程可知，Connector内部必然是多线程的，那么它是如何处理多线程的连接请求？就是接下来的内容：</p>
<p>该多线程的连接请求涉及到两个类：HttpConnector和HttpProcessor。主要代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HttpConnector的start方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> throws LifecycleException </span>&#123;</span><br><span class="line">    <span class="comment">//如果连接已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (started) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">LifecycleException</span>(sm.<span class="built_in">getString</span>(<span class="string">&quot;httpConnector.alreadyStarted&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新的连接</span></span><br><span class="line">    threadName = <span class="string">&quot;HttpConnector[&quot;</span> + port + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    lifecycle.<span class="built_in">fireLifecycleEvent</span>(START_EVENT, null);</span><br><span class="line">    started = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">threadStart</span>();  <span class="comment">//到这里，start()方法就会处于等待被激活状态，直到有请求进来</span></span><br><span class="line">    <span class="keyword">while</span> (curProcessors &lt; minProcessors) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((maxProcessors &gt; <span class="number">0</span>) &amp;&amp; (curProcessors &gt;= maxProcessors)) &#123;</span><br><span class="line">            <span class="comment">//处理连接的处理对象达到上限</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有达到上限则创建处理对象处理连接</span></span><br><span class="line">        HttpProcessor processor = <span class="built_in">newProcessor</span>();</span><br><span class="line">        <span class="built_in">recycle</span>(processor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>theadStart()方法的激活是在HttpProcessor的assign方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建HttpProcessor时，available为false，当请求到来时不会进入到循环中</span></span><br><span class="line">    <span class="comment">//只有将socket赋值给当前的HttpProcessor，available才会为true，阻止其他请求获取当前</span></span><br><span class="line">    <span class="comment">//的HttpProcessor</span></span><br><span class="line">    <span class="keyword">while</span> (available) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InnterruptedException e) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    available = <span class="keyword">true</span>;</span><br><span class="line">    notifyAll(); <span class="comment">//激活线程处理请求</span></span><br><span class="line">    <span class="keyword">if</span> ((debug &gt;= <span class="number">1</span>) &amp;&amp; (socket != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        log(<span class="string">&quot;An incoming request is beging assigned&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过上面的步骤后，处理请求的线程就会被激活来执行请求处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!stopped) &#123;</span><br><span class="line">        Socket socket = await(); <span class="comment">//等待notifyAll()</span></span><br><span class="line">        <span class="comment">//被激活</span></span><br><span class="line">        <span class="keyword">if</span> (socket == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//解析Socket，处理请求线程的核心方法</span></span><br><span class="line">            process(socket);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            log(<span class="string">&quot;process.invoke&quot;</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">        connector.recycle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (threadSync) &#123;</span><br><span class="line">        threadSync.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理请求线程的核心方法process:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化一些过程变量</span></span><br><span class="line">    <span class="keyword">boolean</span> ok = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishResponse = <span class="keyword">true</span>;</span><br><span class="line">    SocketInputStream input = <span class="keyword">null</span>;</span><br><span class="line">    OutputStream output = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//开始解析socket</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取socket信息</span></span><br><span class="line">        input = <span class="keyword">new</span> SocketInputStream(socket.getInputStream(), connector.getBufferSize());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log(<span class="string">&quot;process.create&quot;</span>, e);</span><br><span class="line">        <span class="comment">//ok为false，说明没有获取到socket信息，解析过程无法进行</span></span><br><span class="line">        ok = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    keepAlive = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stopped &amp;&amp; ok &amp;&amp; keepAlive) &#123;</span><br><span class="line">        <span class="comment">//解析sokect核心过程</span></span><br><span class="line">        finishResponse = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//必要初始化设置</span></span><br><span class="line">            request.setStream(input);</span><br><span class="line">            request.setResponse(response);</span><br><span class="line">            output = socket.getOutputStream();</span><br><span class="line">            response.setStream(output);</span><br><span class="line">            response.setRequest(request);</span><br><span class="line">            ((HttpServletResponse) response.getResponse())</span><br><span class="line">            	.setHeader(<span class="string">&quot;Server&quot;</span>, SERVER_INFO);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log(<span class="string">&quot;process.create&quot;</span>, e);</span><br><span class="line">            ok = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始解析</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                parseConnection(socket);</span><br><span class="line">                parseRequest(input, output);</span><br><span class="line">                <span class="keyword">if</span> (!request.getRequest().getProtocol.startsWith(<span class="string">&quot;HTTP/0&quot;</span>)) &#123;</span><br><span class="line">                    parseHeaders(input);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (httpll) &#123;</span><br><span class="line">                    ackRequest(output);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (connector.isChunkingAllowed()) &#123;</span><br><span class="line">                    response.setAllowChunking(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//省略部分内容</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将request对象和response对象交给container容器</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((HttpServletResponse) response).setHeader(<span class="string">&quot;Date&quot;</span>, FastHttpDateFormat.getCurrentDate());</span><br><span class="line">            <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                connector.getContainer().invoke(request, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//省略部分内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//后续处理</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        shutdownInput(input);</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        log(<span class="string">&quot;process.invoke&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    socket = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Container组件"><a href="#Container组件" class="headerlink" title="Container组件"></a>Container组件</h3><blockquote>
<p>Container容器是四个子容器的父接口，四个子容器Engine/Host/Context/Wrapper必须实现该接口。</p>
<p>另一篇文章学过，这四个子容器也是父子关系：Engine包含Host，Host包含Context，Context包含Wrapper。并且一个Servlet.class对应一个Wrapper，一个Context对应多个Wrapper。</p>
<p>当一个请求交给Container，Container如何处理这个请求？四个子容器组件如何分工？如何把请求交给特定子容器？又如何将请求交给Servlet？</p>
<p>Tomcat采用一个Pipeline+Valve（管道+阀门）的组合来实现请求的处理。从Engine/Host/Context/Wrapper开始，每个容器都会执行Pipeline并有自己的Valve集合</p>
<ul>
<li>StandardEngine  StandardEngineValve</li>
<li>StandardHost  StandardHostValve</li>
<li>StandardContext  StandardContextValve</li>
<li>StandardWrapper  StandardWrapperValve</li>
</ul>
<p>通过激活每个容器的Valve将请求在管道Pipeline中依次传递，传递过程如下：</p>
<ol>
<li>在StandardEngine激活自己的Valve并激活Host容器的Valve，将请求传递到Host容器中</li>
<li>在StandardHost激活Context容器的Valve，将请求传递到Context容器中</li>
<li>在StandardContext激活Wrapper容器的Valve，将请求传递到Wrapper容器中</li>
<li>在StandardWrapperValve中加载servlet，执行init方法。并创建filter链，执行Servlet的service方法，将请求交给Servlet类处理</li>
</ol>
<p>到这里，请求就执行完成，容器会释放所有资源，结束事件的监听。</p>
</blockquote>
]]></content>
      <tags>
        <tag>tomcat, 系统架构</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora快捷键</title>
    <url>/2020/01/09/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h6 id="保存：Ctrl-S"><a href="#保存：Ctrl-S" class="headerlink" title="保存：Ctrl+S"></a>保存：<kbd>Ctrl</kbd>+<kbd>S</kbd></h6><h6 id="关闭：Ctrl-W"><a href="#关闭：Ctrl-W" class="headerlink" title="关闭：Ctrl+W"></a>关闭：<kbd>Ctrl</kbd>+<kbd>W</kbd></h6><h6 id="撤销：Ctrl-Z"><a href="#撤销：Ctrl-Z" class="headerlink" title="撤销：Ctrl+Z"></a>撤销：<kbd>Ctrl</kbd>+<kbd>Z</kbd></h6><h6 id="复制：Ctrl-C"><a href="#复制：Ctrl-C" class="headerlink" title="复制：Ctrl+C"></a>复制：<kbd>Ctrl</kbd>+<kbd>C</kbd></h6><span id="more"></span>

<h6 id="粘贴：Ctrl-V"><a href="#粘贴：Ctrl-V" class="headerlink" title="粘贴：Ctrl+V"></a>粘贴：<kbd>Ctrl</kbd>+<kbd>V</kbd></h6><h6 id="剪切：Ctrl-X"><a href="#剪切：Ctrl-X" class="headerlink" title="剪切：Ctrl+X"></a>剪切：<kbd>Ctrl</kbd>+<kbd>X</kbd></h6><h6 id="全选：Ctrl-A"><a href="#全选：Ctrl-A" class="headerlink" title="全选：Ctrl+A"></a>全选：<kbd>Ctrl</kbd>+<kbd>A</kbd></h6><h6 id="选中当前行：Ctrl-L"><a href="#选中当前行：Ctrl-L" class="headerlink" title="选中当前行：Ctrl+L"></a>选中当前行：<kbd>Ctrl</kbd>+<kbd>L</kbd></h6><h6 id="选中当前格式文本：Ctrl-E"><a href="#选中当前格式文本：Ctrl-E" class="headerlink" title="选中当前格式文本：Ctrl+E"></a>选中当前格式文本：<kbd>Ctrl</kbd>+<kbd>E</kbd></h6><h6 id="选中当前词：Ctrl-D"><a href="#选中当前词：Ctrl-D" class="headerlink" title="选中当前词：Ctrl+D"></a>选中当前词：<kbd>Ctrl</kbd>+<kbd>D</kbd></h6><h6 id="提升标题级别：Ctrl"><a href="#提升标题级别：Ctrl" class="headerlink" title="提升标题级别：Ctrl++="></a>提升标题级别：<kbd>Ctrl</kbd>+<kbd>+=</kbd></h6><h6 id="降低标题级别：Ctrl"><a href="#降低标题级别：Ctrl" class="headerlink" title="降低标题级别：Ctrl+_-"></a>降低标题级别：<kbd>Ctrl</kbd>+<kbd>_-</kbd></h6><h6 id="表格：Ctrl-T"><a href="#表格：Ctrl-T" class="headerlink" title="表格：Ctrl+T"></a>表格：<kbd>Ctrl</kbd>+<kbd>T</kbd></h6><h6 id="代码块：Ctrl-Shift-K"><a href="#代码块：Ctrl-Shift-K" class="headerlink" title="代码块：Ctrl+Shift+K"></a>代码块：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>K</kbd></h6><p>数学公式：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>M</kbd></p>
<p>引用：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Q</kbd></p>
<p>有序列表：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>[</kbd></p>
<p>无序列表：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>]</kbd></p>
<p>代码：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>`</kbd></p>
<p>删除线：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>5</kbd></p>
<p>大纲视图：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>1</kbd></p>
<p>搜索：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>F</kbd></p>
]]></content>
      <tags>
        <tag>typora</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/05/15/~$mcat%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<p>������                                                ĞOeZ  iSO  T i m e ptqN% �        �            }pjqZ&amp; �p&lt;W�  p&lt;W�   t h E dsphq ’ ��&lt;W�  �&lt;W</p>
]]></content>
  </entry>
  <entry>
    <title>了解Linux</title>
    <url>/2020/03/20/%E4%BA%86%E8%A7%A3Linux/</url>
    <content><![CDATA[<p>我喜欢一段比喻，用于说明Windows和Linux的区别(引用自 《Linux命令行大全》)：</p>
<blockquote>
<p>Windows就像Game Boy游戏机。你去商店买了一个全新的游戏机。你把它带回家，启动，玩游戏机中的游戏，漂亮的画面，优美的声音，人性化的操作。但是，不久，你对这款游戏玩腻了，于是你回到商店，买了另一款游戏机。就这样一遍一遍重复着，然后当你想玩一个不一样的游戏时，你回到商店，对柜台的售货员说：“我想要这样这样的游戏”，但却被告知没有这样的游戏。然后你对售货员说：“只需要更换游戏中的某个东西就可以了”。售货员对你说：“你不能更换它，这个游戏机盒子是密封好的”。你很沮丧，你只能由别人决定你可以玩的游戏，并没有更多的选项可以选择。</p>
<p>而Linux就像是世界上最大的拼装玩具。你打开它，它是一个零件集，螺丝钉，齿轮，马达，等等。你可以拼装成任何基于你想象的内容，拼装完一个参考样式后，再拼装另一种。你不再需要回到商店，因为你已经有了拼装所需要的所有东西。</p>
</blockquote>
<span id="more"></span>

<h2 id="Linux软件包系统"><a href="#Linux软件包系统" class="headerlink" title="Linux软件包系统"></a>Linux软件包系统</h2><blockquote>
<p>不同的Linux用不同的软件包系统，并且原则上，适用于一种发行版的软件包和其他版本是不兼容的。多数Linux发行版采用两种软件包，**Debian的 .deb 和Red Hat的 .rpm ** </p>
<table>
<thead>
<tr>
<th>软件包系统</th>
<th>发行版本</th>
</tr>
</thead>
<tbody><tr>
<td>.deb</td>
<td>Debian/Ubuntu/Xandros/Linspire</td>
</tr>
<tr>
<td>.rpm</td>
<td>Fedora/CentOS/Red Hat/openSUSE/Mandriva/PCLinuxOS</td>
</tr>
</tbody></table>
<p>包文件是组成软件包系统的基本软件单元。是由组成软件包的文件压缩而成的文件集。</p>
<p>一个包可能含有大量的程序以及支持这些程序的数据文件。此外，许多软件包中还包含了安装软件包前后执行配置任务的安装脚本。</p>
<p>包文件通常由软件包维护者创建。包维护者从程序的作者处或供应商获得软件源码，然后进行编译，并创建包的元数据及其他所必须的安装脚本。</p>
<h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><p>Linux用户可以从其所使用的Linux版本的中心库获得软件包。所谓的中心库，一般包含了成千上万个软件包，每个软件包都是为相应的发行版本建立和维护的。</p>
<p>用户必须充分了解每个软件包的信息，然后手动将其加入到软件包文件管理系统的配置文件中，才能使用它们。</p>
<h3 id="高级和低级软件包工具"><a href="#高级和低级软件包工具" class="headerlink" title="高级和低级软件包工具"></a>高级和低级软件包工具</h3><p>软件包管理系统通常包含两类工具——执行安装、删除软件包文件等任务的低级工具。以及进行元数据搜索和提供依赖性解决的高级工具。</p>
<table>
<thead>
<tr>
<th>发行版本</th>
<th>低级工具</th>
<th>高级工具</th>
</tr>
</thead>
<tbody><tr>
<td>Debian系统</td>
<td>dpkg</td>
<td>apt-get/aptitude</td>
</tr>
<tr>
<td>Red Hat系统</td>
<td>rpm</td>
<td>yum</td>
</tr>
</tbody></table>
<h3 id="在库中查找软件包，安装软件包"><a href="#在库中查找软件包，安装软件包" class="headerlink" title="在库中查找软件包，安装软件包"></a>在库中查找软件包，安装软件包</h3><p>通过使用高级工具来搜索库元数据时，可以根据包文件名来查找对应的包文件：</p>
<table>
<thead>
<tr>
<th>系统类型</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>Debian系统</td>
<td>apt-get update/apt-cache search package-name</td>
</tr>
<tr>
<td>Red Hat系统</td>
<td>yum search package-name</td>
</tr>
</tbody></table>
<p>安装包文件：</p>
<table>
<thead>
<tr>
<th>系统类型</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>Debian系统</td>
<td>apt-get update/apt-get install package-name</td>
</tr>
<tr>
<td>Red Hat系统</td>
<td>yum install package-name</td>
</tr>
</tbody></table>
<h3 id="卸载软件包和更新软件包"><a href="#卸载软件包和更新软件包" class="headerlink" title="卸载软件包和更新软件包"></a>卸载软件包和更新软件包</h3><p>卸载软件包：</p>
<table>
<thead>
<tr>
<th>系统类型</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>Debian系统</td>
<td>apt-get remove package-name</td>
</tr>
<tr>
<td>Red Hat系统</td>
<td>yum erase package-name</td>
</tr>
</tbody></table>
<p>更新软件包：</p>
<table>
<thead>
<tr>
<th>系统类型</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>Debian系统</td>
<td>apt-get update;apt-get upgrade</td>
</tr>
<tr>
<td>Red Hat系统</td>
<td>yum update</td>
</tr>
</tbody></table>
<h3 id="列出已安装的软件包列表"><a href="#列出已安装的软件包列表" class="headerlink" title="列出已安装的软件包列表"></a>列出已安装的软件包列表</h3><table>
<thead>
<tr>
<th>系统类型</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>Debian系统</td>
<td>dpkg –list</td>
</tr>
<tr>
<td>Red Hat系统</td>
<td>rpm -qa</td>
</tr>
</tbody></table>
</blockquote>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用dom4j</title>
    <url>/2020/04/21/%E4%BD%BF%E7%94%A8dom4j/</url>
    <content><![CDATA[<p>今天看书的时候看到dom4j可以解析和生成xml文件，因此想记录一下，供之后需要的时候使用。</p>
<span id="more"></span>

<h2 id="dom4j解析xml文件大致步骤"><a href="#dom4j解析xml文件大致步骤" class="headerlink" title="dom4j解析xml文件大致步骤"></a>dom4j解析xml文件大致步骤</h2><ol>
<li>创建SAXReader</li>
<li>使用SAXReader解析指定的XML文档信息，并返回对应的Document对象。Document对象包含该xml文件所有信息及结构</li>
<li>根据document文档结构，读取信息</li>
</ol>
<p>举例说明：现有一个xml文件：player.xml文件，一个实体类 Player ，一个解析类ParseXml</p>
<p><strong>player.xml文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">players</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">player</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>乔丹<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">number</span>&gt;</span>23<span class="tag">&lt;/<span class="name">number</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">salary</span>&gt;</span>30000000<span class="tag">&lt;/<span class="name">salary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">player</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">player</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>科比<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">number</span>&gt;</span>24<span class="tag">&lt;/<span class="name">number</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">salary</span>&gt;</span>27000000<span class="tag">&lt;/<span class="name">salary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">player</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">player</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>詹姆斯<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">number</span>&gt;</span>23<span class="tag">&lt;/<span class="name">number</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">salary</span>&gt;</span>27000000<span class="tag">&lt;/<span class="name">salary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">player</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">player</span> <span class="attr">id</span>=<span class="string">&quot;4&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>库里<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">number</span>&gt;</span>30<span class="tag">&lt;/<span class="name">number</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">salary</span>&gt;</span>25000000<span class="tag">&lt;/<span class="name">salary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">player</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">player</span> <span class="attr">id</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>冬基奇<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">number</span>&gt;</span>77<span class="tag">&lt;/<span class="name">number</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">salary</span>&gt;</span>23000000<span class="tag">&lt;/<span class="name">salary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">player</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">players</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>实体类 Player</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> number, String gender, <span class="keyword">long</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析类 ParseXml</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseXml</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Player&gt; <span class="title">parsePlayerXml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">            Document document = reader.read(<span class="keyword">new</span> File(<span class="string">&quot;F:/GitTool/repository/DougCoding/pratice/src/com/doug/wilson/dom4j/player.xml&quot;</span>));</span><br><span class="line">            List&lt;Player&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 第一步，获取根标签元素 &lt;players&gt;...&lt;/players&gt;</span></span><br><span class="line">            Element root = document.getRootElement();</span><br><span class="line">            <span class="comment">// 获取子标签&lt;player&gt;...&lt;/player&gt;中的内容</span></span><br><span class="line">            List&lt;Element&gt; elementList = root.elements(<span class="string">&quot;player&quot;</span>);</span><br><span class="line">            <span class="comment">// 遍历获取每个子标签&lt;player&gt;...&lt;/player&gt;中的内容</span></span><br><span class="line">            <span class="keyword">for</span> (Element e : elementList) &#123;</span><br><span class="line">                <span class="comment">// 将字符串转换为对应类型</span></span><br><span class="line">                <span class="keyword">int</span> id = Integer.parseInt(e.attribute(<span class="string">&quot;id&quot;</span>).getValue());</span><br><span class="line">                String name = e.elementText(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> number = Integer.parseInt(e.elementText(<span class="string">&quot;number&quot;</span>));</span><br><span class="line">                String gender = e.elementText(<span class="string">&quot;gender&quot;</span>);</span><br><span class="line">                <span class="keyword">long</span> salary = Long.parseLong(e.elementText(<span class="string">&quot;salary&quot;</span>));</span><br><span class="line">                list.add(<span class="keyword">new</span> Player(id, name, number, gender, salary));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到这里，说明解析过程错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Player&gt; players = parsePlayerXml();</span><br><span class="line">        <span class="keyword">for</span> (Player player : players) &#123;</span><br><span class="line">            System.out.println(player);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析结果</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Player&#123;<span class="attribute">id</span>=1, <span class="attribute">name</span>=<span class="string">&#x27;乔丹&#x27;</span>, <span class="attribute">number</span>=23, <span class="attribute">gender</span>=<span class="string">&#x27;男&#x27;</span>, <span class="attribute">salary</span>=30000000&#125;</span><br><span class="line">Player&#123;<span class="attribute">id</span>=2, <span class="attribute">name</span>=<span class="string">&#x27;科比&#x27;</span>, <span class="attribute">number</span>=24, <span class="attribute">gender</span>=<span class="string">&#x27;男&#x27;</span>, <span class="attribute">salary</span>=27000000&#125;</span><br><span class="line">Player&#123;<span class="attribute">id</span>=3, <span class="attribute">name</span>=<span class="string">&#x27;詹姆斯&#x27;</span>, <span class="attribute">number</span>=23, <span class="attribute">gender</span>=<span class="string">&#x27;男&#x27;</span>, <span class="attribute">salary</span>=27000000&#125;</span><br><span class="line">Player&#123;<span class="attribute">id</span>=4, <span class="attribute">name</span>=<span class="string">&#x27;库里&#x27;</span>, <span class="attribute">number</span>=30, <span class="attribute">gender</span>=<span class="string">&#x27;男&#x27;</span>, <span class="attribute">salary</span>=25000000&#125;</span><br><span class="line">Player&#123;<span class="attribute">id</span>=5, <span class="attribute">name</span>=<span class="string">&#x27;冬基奇&#x27;</span>, <span class="attribute">number</span>=77, <span class="attribute">gender</span>=<span class="string">&#x27;男&#x27;</span>, <span class="attribute">salary</span>=23000000&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dom4j生成xml文件大致步骤"><a href="#dom4j生成xml文件大致步骤" class="headerlink" title="dom4j生成xml文件大致步骤"></a>dom4j生成xml文件大致步骤</h2><ol>
<li>创建一个Document对象，表示生成一个xml文档</li>
<li>向Document中添加根标签元素</li>
<li>根据目标xml文档结构向根标签中添加子标签及内容，完成结构的创建</li>
<li>创建XMLWriter及输出流FileOutputStream</li>
<li>设置文件路径及文件名</li>
<li>使用XMLWriter将Document生成xml文档</li>
</ol>
<p>举例说明：</p>
<p><strong>生成XML文档类：CreateXmlFile</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateXmlFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createXmlFile</span><span class="params">(List&lt;Player&gt; playerList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建文件</span></span><br><span class="line">        Document document = DocumentHelper.createDocument();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 生成根标签元素</span></span><br><span class="line">            Element root = document.addElement(<span class="string">&quot;players&quot;</span>);</span><br><span class="line">            <span class="comment">// 添加子标签及其内容</span></span><br><span class="line">            <span class="keyword">for</span> (Player player : playerList) &#123;</span><br><span class="line">                Element element = root.addElement(<span class="string">&quot;player&quot;</span>);</span><br><span class="line">                <span class="comment">// 添加子子标签并设置内容</span></span><br><span class="line">                element.addAttribute(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;&quot;</span> + player.getId());</span><br><span class="line">                <span class="comment">// name</span></span><br><span class="line">                Element nameEle = element.addElement(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                nameEle.addText(player.getName());</span><br><span class="line">                <span class="comment">// number</span></span><br><span class="line">                Element numberEle = element.addElement(<span class="string">&quot;number&quot;</span>);</span><br><span class="line">                numberEle.addText(player.getNumber() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                <span class="comment">// gender</span></span><br><span class="line">                Element genderEle = element.addElement(<span class="string">&quot;gender&quot;</span>);</span><br><span class="line">                genderEle.addText(player.getGender());</span><br><span class="line">                <span class="comment">// salary</span></span><br><span class="line">                Element salaryEle = element.addElement(<span class="string">&quot;salary&quot;</span>);</span><br><span class="line">                salaryEle.addText(player.getSalary() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 输出</span></span><br><span class="line">            XMLWriter writer = <span class="keyword">new</span> XMLWriter(OutputFormat.createPrettyPrint());</span><br><span class="line">            FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;F:/GitTool/repository/DougCoding/pratice/src/com/doug/wilson/dom4j/myPlayer.xml&quot;</span>);</span><br><span class="line">            writer.setOutputStream(outputStream);</span><br><span class="line">            writer.write(document);</span><br><span class="line">            writer.flush();</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException | FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Player&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Player(<span class="number">1</span>, <span class="string">&quot;康利&quot;</span>, <span class="number">33</span>, <span class="string">&quot;男&quot;</span>, <span class="number">1000000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Player(<span class="number">2</span>, <span class="string">&quot;戴维斯&quot;</span>, <span class="number">9</span>, <span class="string">&quot;男&quot;</span>, <span class="number">2000000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Player(<span class="number">3</span>, <span class="string">&quot;汤神&quot;</span>, <span class="number">11</span>, <span class="string">&quot;男&quot;</span>, <span class="number">3000000</span>));</span><br><span class="line"></span><br><span class="line">        createXmlFile(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：myPlayer.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">players</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">player</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>康利<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">number</span>&gt;</span>33<span class="tag">&lt;/<span class="name">number</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">salary</span>&gt;</span>1000000<span class="tag">&lt;/<span class="name">salary</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">player</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">player</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>戴维斯<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">number</span>&gt;</span>9<span class="tag">&lt;/<span class="name">number</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">salary</span>&gt;</span>2000000<span class="tag">&lt;/<span class="name">salary</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">player</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">player</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>汤神<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">number</span>&gt;</span>11<span class="tag">&lt;/<span class="name">number</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">salary</span>&gt;</span>3000000<span class="tag">&lt;/<span class="name">salary</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">player</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">players</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dom4j</tag>
      </tags>
  </entry>
  <entry>
    <title>内容分布网络CDN</title>
    <url>/2020/02/05/%E5%86%85%E5%AE%B9%E5%88%86%E5%B8%83%E7%BD%91%E7%BB%9CCDN/</url>
    <content><![CDATA[<p>CDN，全称Content Delivery Network，内容分布网络，构筑在现有Internet上的一种流量分配网络。主要过程为：<strong>通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到离用户最近的的网络“边缘”，使用户可以就近取得所需内容，提高用户访问网站的响应速度</strong>。</p>
<span id="more"></span>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>CDN有别于镜像，它可以明显提高网络中信息流动的效率。相当于如下公式：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">CDN</span>=镜像+缓存+负载均衡</span><br></pre></td></tr></table></figure>

<p>目前CDN均以缓存网站中的静态数据为主，比如CSS/JS/图片/静态页面等数据。用户在从主站服务器请求到动态内容后，再从CDN上下载这些静态数据，从而加速网页数据内容的下载速度。</p>
<p>请求流程如下：</p>
<ol>
<li><p>基本的DNS解析流程完成后，LDNS向CND域名解析服务器发起请求</p>
</li>
<li><p>CND域名解析服务器将解析请求解析到另外一个域名，这个域名会最终指向CDN全局中的DNS负载均衡服务器，由该GTM(Global Traffic Manager全局流量管理)将离用户最近的CDN节点返回给LDNS，LDNS再将该CDN节点返回给用户主机</p>
</li>
<li><p>用户主机拿到该CDN节点后，就可以去这个CDN节点访问静态文件，如果用户请求的静态文件该CDN节点不存在，则会再到源站去获取这个文件，然后再返回给用户。</p>
<p><img src="/images/CDN%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B.png"></p>
</li>
</ol>
</blockquote>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><blockquote>
<p><strong>负载均衡(Load Balance)就是对工作任务进行平衡、分摊到多个操作单元上指向，如图片服务器、应用服务器等共同完成任务。</strong> <em>负载均衡可以提高服务器响应速度及利用效率，避免软件或硬件出现单点失效，解决网络拥塞问题。</em></p>
</blockquote>
<h3 id="链路负载均衡、集群负载均衡、操作系统负载均衡"><a href="#链路负载均衡、集群负载均衡、操作系统负载均衡" class="headerlink" title="链路负载均衡、集群负载均衡、操作系统负载均衡"></a>链路负载均衡、集群负载均衡、操作系统负载均衡</h3><h4 id="链路负载均衡"><a href="#链路负载均衡" class="headerlink" title="链路负载均衡"></a>链路负载均衡</h4><blockquote>
<p>链路负载均衡通过DNS解析成不同的IP，然后用户根据IP来访问不同的目标服务器。</p>
<p><img src="/images/%E9%93%BE%E8%B7%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png"></p>
<p>链路负载均衡其核心依然是DNS，在图中，该DNS服务器就是Global DNS Server。DNS解析的优点是用户可以直接访问目标服务器，而不需要经过其它代理服务器，一般而言，访问速度还不错。缺点是，当目标服务器挂掉，而用户的浏览器缓存或操作系统缓存还缓存有目标服务器的IP地址，那么在缓存时间内，用户将无法访问目标服务器的资源，即使挂掉的目标服务器在挂掉后更换了IP地址。</p>
</blockquote>
<h4 id="集群负载均衡"><a href="#集群负载均衡" class="headerlink" title="集群负载均衡"></a>集群负载均衡</h4><blockquote>
<p>目前最为常用的负载均衡手段。集群负载均衡一般还分为硬件负载均衡和软件负载均衡。</p>
<p>硬件负载均衡一般会有一台专门的硬件来转发请求。</p>
<p><img src="/images/%E7%A1%AC%E4%BB%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png"></p>
<p>软件负载均衡是通过软件处理，一次访问通过多次代理服务器，虽然成本比较低，但是网络时延是增加的。</p>
<p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png"></p>
<p>LVS Linux Virtual Server 通过在网络层进行IP地址转发</p>
<p>HAProxy 用C语言编写的软件，根据访问用户的HTTP请求头来进行负载均衡，比如可以根据不同的URL来将请求转发到特定机器</p>
</blockquote>
<h4 id="操作系统负载均衡"><a href="#操作系统负载均衡" class="headerlink" title="操作系统负载均衡"></a>操作系统负载均衡</h4><blockquote>
<p>利用操作系统基本的软中断或者硬件中断来达到负载均衡</p>
</blockquote>
<h2 id="CDN动态加速"><a href="#CDN动态加速" class="headerlink" title="CDN动态加速"></a>CDN动态加速</h2><blockquote>
<p>在CDN的DNS解析中，动态地进行链路探测来寻找回源最好的一条路径，然后通过DNS调度将所有请求调度到选定的这条路径上进行回源，从而加速用户访问的效率。</p>
<p><img src="/images/CDN%E5%8A%A8%E6%80%81%E5%8A%A0%E9%80%9F.png"></p>
</blockquote>
]]></content>
      <tags>
        <tag>CND</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划探究及例题分析</title>
    <url>/2020/01/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%8E%A2%E7%A9%B6%E5%8F%8A%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>分治算法是将问题划分成一些独立的子问题，递归求解各子问题，然后合并子问题的解而得到原问题的解。这种情况很多，如自顶向下的归并排序，图的深度遍历等等。</p>
<p>动态规划与此不同，适用于子问题不是独立的情况，即子问题包含公共子问题。如果在这种情况下采用分治算法，则分治算法会做许多不必要的工作——重复求解公共子问题。而动态规划算法只对每个子子问题求解一次，将其结果存放到一张表中，避免每次遇到各个子问题时重新计算答案。</p>
<span id="more"></span>

<h2 id="动态规划算法的设计步骤总结"><a href="#动态规划算法的设计步骤总结" class="headerlink" title="动态规划算法的设计步骤总结"></a>动态规划算法的设计步骤总结</h2><blockquote>
<ol>
<li>描述最优解的结构</li>
<li>递归定义最优解的值</li>
<li>按自底向上的方式计算最优解的值(非递归，通常为循环)</li>
<li>由计算出的结果构造一个最优解</li>
</ol>
</blockquote>
<h4 id="参考例题：算法导论——装配最短时间计算"><a href="#参考例题：算法导论——装配最短时间计算" class="headerlink" title="参考例题：算法导论——装配最短时间计算"></a>参考例题：算法导论——装配最短时间计算</h4><blockquote>
<p>问题描述：</p>
<p>某工厂内有两条装配产品的流水线：</p>
<p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%97%AE%E9%A2%98.png"></p>
<p>如果产品只在一条流水线上工作，则装配时间为：<br>$$<br>\sum_{i=1}^{n}a_{1i}+e_{1}+x_{1} 或 \sum_{i=1}^{n}a_{2i}+e_{2}+x_{2}<br>$$<br>如果从一条装配线的一个装配站<strong>i</strong>移动到另一个装配线<strong>i+1</strong>则需要加上额外的移动时间：<br>$$<br>t_{1i} 或t_{2i}<br>$$<br> 求产品装配的最短时间</p>
</blockquote>
<h4 id="按照求解步骤求解："><a href="#按照求解步骤求解：" class="headerlink" title="按照求解步骤求解："></a>按照求解步骤求解：</h4><h5 id="1-描述最优解的结构"><a href="#1-描述最优解的结构" class="headerlink" title="1 描述最优解的结构"></a>1 描述最优解的结构</h5><blockquote>
<p><img src="/images/%E6%8F%8F%E8%BF%B0%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%9C%80%E4%BC%98%E8%A7%A3%E7%BB%93%E6%9E%84.png"></p>
<p>假设目前要通过的装配站为S1j ，那么最快的路线只能是以下情况：</p>
<ol>
<li>通过了S1j-1装配站，然后直接到S1j装配站</li>
<li>通过了S2j-1装配站，然后花费t2j-1时间到S1j</li>
</ol>
<p>同理，如果通过的装配站为S2j，那么最快的路线只能是以下情况：</p>
<ol>
<li>通过了S2j-1装配站，然后直接到S2j装配站</li>
<li>通过了S1j-1装配站，然后花费时间t1j-1时间到S2j</li>
</ol>
</blockquote>
<h5 id="2-递归定义最优解的值"><a href="#2-递归定义最优解的值" class="headerlink" title="2 递归定义最优解的值"></a>2 递归定义最优解的值</h5><blockquote>
<p>由第一步可知，最优解可以由如下公式代替：<br>$$<br>f_{1}(n)=min(f_{1}(n-1), {f_{2}(n-1)+t_{2}(n-1)})+a_{1n} \<br>f_{2}(n)=min(f_{2}(n-1), {f_{1}(n-1)+t_{1}(n-1)})+a_{2n} \<br>f_{min}=min(f_{1}(n)+x_{1},f_{2}(n)+x_{2})\<br>考虑条件后，可以得到：\<br>f_{1}(j)=\left{\begin{matrix}<br>e_{1}+a_{11} \quad\quad  j=1\<br>min(f_{1}(j-1)+a_{1j},\quad f_{2}(j-1)+t_{2j-1}+a_{1j}) \quad j&gt;=2<br>\end{matrix}\right.  \<br>f_{2}(j)=\left{\begin{matrix}<br>e_{2}+a_{21} \quad\quad  j=1\<br>min(f_{2}(j-1)+a_{2j},\quad f_{1}(j-1)+t_{1j-1}+a_{2j}) \quad j&gt;=2<br>\end{matrix}\right. \<br>f_{min}=min(f_{1}(n)+x_{1},\quad f_{2}(n)+x_{2}) \quad 即最优解方程组<br>$$</p>
</blockquote>
<h5 id="3-将递归定义转化为从自底向上计算最优解的值"><a href="#3-将递归定义转化为从自底向上计算最优解的值" class="headerlink" title="3 将递归定义转化为从自底向上计算最优解的值"></a>3 将递归定义转化为从自底向上计算最优解的值</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算e1+a11和e2+a21的值，将值存入fmin，并记录</span></span><br><span class="line"><span class="comment">//定义标识符flag，flag为true时表示当前装配在流水线1，flag为false表示当前装配在流水线2  </span></span><br><span class="line"><span class="comment">//循环直到最后一个装配站</span></span><br><span class="line"><span class="comment">//当前装配站为i，</span></span><br><span class="line"><span class="comment">//计算fmin+ati和fmin+tti-1+afi的大小并比较哪一个时间较少</span></span><br><span class="line"><span class="comment">//记录并将值存入fmin</span></span><br><span class="line"><span class="comment">//如此，直到循环结束</span></span><br></pre></td></tr></table></figure>

<h5 id="4-计算最优解"><a href="#4-计算最优解" class="headerlink" title="4 计算最优解"></a>4 计算最优解</h5><blockquote>
<p>将第三步的伪代码转化成代码运行，并测试</p>
</blockquote>
]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>在js中对后台传送的时间进行格式化</title>
    <url>/2021/05/25/%E5%9C%A8js%E4%B8%AD%E5%AF%B9%E5%90%8E%E5%8F%B0%E4%BC%A0%E9%80%81%E7%9A%84%E6%97%B6%E9%97%B4%E8%BF%9B%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<span id="more"></span>

<p>最近在前端显示时间的时候，发现后台传送的时间格式要么是：1861447200000，或者是：Tue Apr 18 2020 10:39:23 。但是这往往不是想要的时间格式，js中也没有类似于java的SimpleDareFormat()函数，因此，自己写了一个js的function进行时间格式的转换：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">调用方式：</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().Format(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Date</span>.prototype.Format = <span class="function"><span class="keyword">function</span>(<span class="params">fmt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dateVar = &#123;</span><br><span class="line">        <span class="string">&quot;M+&quot;</span>: <span class="built_in">this</span>.getMonth() + <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;d+&quot;</span>: <span class="built_in">this</span>.getDate(),</span><br><span class="line">        <span class="string">&quot;h+&quot;</span>: <span class="built_in">this</span>.getHours(),</span><br><span class="line">        <span class="string">&quot;m+&quot;</span>: <span class="built_in">this</span>.getMinutes(),</span><br><span class="line">        <span class="string">&quot;s+&quot;</span>: <span class="built_in">this</span>.getSeconds(),</span><br><span class="line">        <span class="string">&quot;q+&quot;</span>: <span class="built_in">Math</span>.floor((<span class="built_in">this</span>.getMonth() + <span class="number">3</span>) / <span class="number">3</span>),</span><br><span class="line">        <span class="string">&quot;S&quot;</span>： <span class="built_in">this</span>.getMilliseconds()</span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="keyword">if</span> (<span class="regexp">/(y+)/</span>.test(fmt)) &#123;</span><br><span class="line">        fmt = fmt.replace(<span class="built_in">RegExp</span>.$1, (<span class="built_in">this</span>.getFullYear() + <span class="string">&quot;&quot;</span>)</span><br><span class="line">                          .substr(<span class="number">4</span> - <span class="built_in">RegExp</span>.$1.length));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> dateVar)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;(&quot;</span> + k + <span class="string">&quot;)&quot;</span>).test(fmt))&#123;</span><br><span class="line">            fmt = fmt.replace(<span class="built_in">RegExp</span>.$1, (<span class="built_in">RegExp</span>.$1.length == <span class="number">1</span>) ?</span><br><span class="line">             (dateVar[k]) : ((<span class="string">&quot;00&quot;</span> + dateVar[k]).substr((<span class="string">&quot;&quot;</span> + dateVar[k]).length)));</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>时间格式化</tag>
      </tags>
  </entry>
  <entry>
    <title>对java文件File类的操作</title>
    <url>/2020/04/25/%E5%AF%B9java%E6%96%87%E4%BB%B6File%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><code>java.io.File</code> 的每一个实例用于表示硬盘上的一个文件或者目录，通过File，我们可以进行如下操作：</p>
<ol>
<li>访问一个文件或目录的属性信息，文件名，大小，修改日期，访问权限</li>
<li>创建文件，删除文件，创建目录，删除目录</li>
<li>访问目录中的文件或者子目录</li>
<li>不可以访问文件的数据，这点要特别注意。只能通过IO来访问文件数据</li>
</ol>
<span id="more"></span>

<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">baseFileOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     File file = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>+File.separator+<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//获取文件名</span></span><br><span class="line">        String name = file.getName();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取文件大小。返回值为一个long值，表示占用的字节量</span></span><br><span class="line"><span class="comment">         * 中文以及中文状态下的标点符号都占用两个字节</span></span><br><span class="line"><span class="comment">         * 英文及英文状态下的标点符号占用一个字节</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> length = file.length();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取文件最后修改时间</span></span><br><span class="line">        <span class="keyword">long</span> time = file.lastModified();</span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 查看文件是否具有可运行，可读，可写的权限</span></span><br><span class="line">        file.canExecute();</span><br><span class="line">        file.canRead();</span><br><span class="line">        file.canWrite();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断当前File对象表示的是否为一个文件</span></span><br><span class="line">        <span class="keyword">boolean</span> isFile = file.isFile();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断当前File对象表示的是否为一个目录</span></span><br><span class="line">        <span class="keyword">boolean</span> isDir = file.isDirectory();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//是否为一个隐藏文件</span></span><br><span class="line">        <span class="keyword">boolean</span> isHidden = file.isHidden());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 在当前目录下创建一个文件demo.txt </span></span><br><span class="line">     File file = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>+File.separator+<span class="string">&quot;demo.txt&quot;</span>);</span><br><span class="line">   	 <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">         file.createNewFile();</span><br><span class="line">         System.out.println(<span class="string">&quot;创建完毕!&quot;</span>);	</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     File file = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>+File.separator+<span class="string">&quot;demo.txt&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">         file.delete();</span><br><span class="line">         System.out.println(<span class="string">&quot;删除完毕!&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 当前目录下创建一个目录demo</span></span><br><span class="line">     File dir = <span class="keyword">new</span> File(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span>(!dir.exists())&#123;</span><br><span class="line">         <span class="comment">// 创建目录</span></span><br><span class="line">         dir.mkdir();</span><br><span class="line">         System.out.println(<span class="string">&quot;创建完毕!&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建多级目录"><a href="#创建多级目录" class="headerlink" title="创建多级目录"></a>创建多级目录</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createMultipleDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在当前目录下创建目录a/b/c/d/e/f</span></span><br><span class="line">    File dir = <span class="keyword">new</span> File(</span><br><span class="line">    	<span class="string">&quot;a&quot;</span>+File.separator +</span><br><span class="line">    	<span class="string">&quot;b&quot;</span>+File.separator +</span><br><span class="line">    	<span class="string">&quot;c&quot;</span>+File.separator +</span><br><span class="line">    	<span class="string">&quot;d&quot;</span>+File.separator +</span><br><span class="line">    	<span class="string">&quot;e&quot;</span>+File.separator +</span><br><span class="line">    	<span class="string">&quot;f&quot;</span></span><br><span class="line">    );	</span><br><span class="line">    <span class="keyword">if</span>(!dir.exists())&#123;</span><br><span class="line">    	 <span class="comment">// mkdirs方法在创建当前目录的同时会将所有不存在的父目录</span></span><br><span class="line">    	 <span class="comment">// 自动创建出来。</span></span><br><span class="line">    	dir.mkdirs();</span><br><span class="line">    	System.out.println(<span class="string">&quot;创建完毕！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除目录（只能删除空目录）"><a href="#删除目录（只能删除空目录）" class="headerlink" title="删除目录（只能删除空目录）"></a>删除目录（只能删除空目录）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File dir = <span class="keyword">new</span> File(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(dir.exists())&#123;</span><br><span class="line">        <span class="comment">// 删除目录，只能删除空目录，即: 目录中不能含有任何子项。</span></span><br><span class="line">        dir.delete();</span><br><span class="line">        System.out.println(<span class="string">&quot;删除完毕!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取一个目录下的所有子项"><a href="#获取一个目录下的所有子项" class="headerlink" title="获取一个目录下的所有子项"></a>获取一个目录下的所有子项</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getSubitem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     File dir = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">     File[] subs = dir.listFiles();</span><br><span class="line">     <span class="keyword">for</span>(File sub : subs)&#123;</span><br><span class="line">        System.out.println((sub.isFile() ? <span class="string">&quot;文件:&quot;</span> : <span class="string">&quot;目录:&quot;</span>) + sub.getName());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取一个目录下符合条件的子项（文件过滤器）"><a href="#获取一个目录下符合条件的子项（文件过滤器）" class="headerlink" title="获取一个目录下符合条件的子项（文件过滤器）"></a>获取一个目录下符合条件的子项（文件过滤器）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getSubitemOnCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取当前目录下所有名字是以&quot;.&quot;开头的子项</span></span><br><span class="line"><span class="comment">         * 使用匿名内部类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        FileFilter filter = <span class="keyword">new</span> FileFilter()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">                String name = file.getName();</span><br><span class="line">                System.out.println(<span class="string">&quot;正在过滤:&quot;</span>+name);</span><br><span class="line">                <span class="keyword">return</span> name.startsWith(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 该重载的listFiles方法会将当前目录中的每</span></span><br><span class="line"><span class="comment">         * 一个子项都交给过滤器，然后只保留满足过滤器</span></span><br><span class="line"><span class="comment">         * 要求(为true)的子项</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        File[] subs = dir.listFiles(filter);</span><br><span class="line">        <span class="keyword">for</span>(File sub : subs)&#123;</span><br><span class="line">            System.out.println(sub.getName());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">正在过滤:.classpath</span></span><br><span class="line"><span class="section">正在过滤:.project</span></span><br><span class="line"><span class="section">正在过滤:.settings</span></span><br><span class="line"><span class="section">正在过滤:a</span></span><br><span class="line"><span class="section">正在过滤:build</span></span><br><span class="line"><span class="section">正在过滤:src</span></span><br><span class="line"><span class="section">正在过滤:test.txt</span></span><br><span class="line"><span class="section">正在过滤:WebContent</span></span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br></pre></td></tr></table></figure>

<h3 id="删除含有子项的目录"><a href="#删除含有子项的目录" class="headerlink" title="删除含有子项的目录"></a>删除含有子项的目录</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteDirHasSubitem</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">         <span class="comment">//先将其所有子项删除</span></span><br><span class="line">         File[] subs = file.listFiles();</span><br><span class="line">         <span class="keyword">for</span>(File sub:subs)&#123;</span><br><span class="line">             <span class="comment">//递归</span></span><br><span class="line">             deleteFile(sub);</span><br><span class="line">         &#125;			</span><br><span class="line">     &#125;</span><br><span class="line">     file.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   	 RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;demo.dat&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * int read()</span></span><br><span class="line"><span class="comment">      * 读取一个字节，并以int(低八位)形式返回</span></span><br><span class="line"><span class="comment">      * 若读取到文件末尾则返回值为-1</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">int</span> d = raf.read();</span><br><span class="line">     System.out.println(d); <span class="comment">// 27</span></span><br><span class="line">     raf.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   	 <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * RandomAccessFile创建支持很多模式</span></span><br><span class="line"><span class="comment">     * 常用的有:</span></span><br><span class="line"><span class="comment">     * &quot;r&quot;:只读</span></span><br><span class="line"><span class="comment">     * &quot;rw&quot;:读写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     RandomAccessFile raf= <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;demo.dat&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * void write(int d)</span></span><br><span class="line"><span class="comment">     * 向文件中写入一个字节，写的是该int值对应的2进制内容中的&quot;低八位&quot;,</span></span><br><span class="line"><span class="comment">     * 范围255</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     raf.write(<span class="number">27</span>);</span><br><span class="line">     raf.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="批量读写文件"><a href="#批量读写文件" class="headerlink" title="批量读写文件"></a>批量读写文件</h3><p>批量读取： <code>int read(byte[] data)</code> 一次性读取给定字节数组长度的字节量，并存入数组中，返回值为实际读取到的字节数，如果返回值为-1，则表示没有读到任何数据，到文件末尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readBath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;demo.dat&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> len = raf.read(data);<span class="comment">//每次read的长度，不写默认为1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;读到了&quot;</span>+len+<span class="string">&quot;个字节&quot;</span>);<span class="comment">//读到了22个字节</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 该构造方法允许我们将给定的字节数组</span></span><br><span class="line"><span class="comment">    * 中指定范围内的字节转换为对应的字符串</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    String str = <span class="keyword">new</span> String(data,<span class="number">0</span>,len,<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    System.out.println(str);<span class="comment">//摩擦摩擦，是魔鬼的步伐</span></span><br><span class="line">    raf.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>批量写入： <code>void write(byte[] data)</code> 批量写出字节，一次性将给定字节数组中的所有字节写出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeBatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;demo.dat&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">     String str = <span class="string">&quot;摩擦摩擦，是魔鬼的步伐&quot;</span>;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * byte[] getBytes()</span></span><br><span class="line"><span class="comment">      * String提供的该方法可以将当前字符串</span></span><br><span class="line"><span class="comment">      * 按照系统默认的字符集转换为对应的一组字节</span></span><br><span class="line"><span class="comment">      * </span></span><br><span class="line"><span class="comment">      * byte[] getBytes(String charset)</span></span><br><span class="line"><span class="comment">      * 按照给定的字符集将字符串转换为一组字节</span></span><br><span class="line"><span class="comment">      * 字符集名称:</span></span><br><span class="line"><span class="comment">      * GBK:国标编码  中文2字节</span></span><br><span class="line"><span class="comment">      * UTF-8:变长编码集，1-4个字节，中文3字节</span></span><br><span class="line"><span class="comment">      * ISO8859-1:欧洲编码，不支持中文</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">byte</span>[] data = str.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">     raf.write(data);</span><br><span class="line">     System.out.println(<span class="string">&quot;写出完毕&quot;</span>);</span><br><span class="line">     raf.close();	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>File类</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习CAS</title>
    <url>/2020/08/26/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0CAS/</url>
    <content><![CDATA[<p>CAS是Compare-And-Swap的缩写，意思为比较并交换。以AtomicInteger为例，其提供了<code>compareAndSet(int expect, int update)</code>方法，<code>expect</code>为期望值（被修改的值在主内存中的期望值），<code>update</code>为修改后的值。<code>compareAndSet</code>方法返回值类型为布尔类型，修改成功则返回true，修改失败返回false。</p>
<span id="more"></span>

<p>举个<code>compareAndSet</code>方法的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomticIntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> result = atomicInteger.compareAndSet(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中，通过<code>AtomicInteger(int initialValue)</code>构造方法指定了<code>AtomicInteger</code>类成员变量<code>value</code>的初始值为0：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicInteger with the given initial value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">(<span class="keyword">int</span> initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着执行<code>compareAndSet</code>方法，main线程从主内存中拷贝了<code>value</code>的副本到工作线程，值为0，并将这个值修改为1。如果此时主内存中value的值还是为0的话（言外之意就是没有被其他线程修改过），则将修改后的副本值刷回主内存更新value的值。所以上面的例子运行结果应该是true和1：</p>
<p><img src="/images/AtomicInteger%E7%BB%93%E6%9E%9C.png"></p>
<p>将上面的例子修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomticIntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> firstResult = atomicInteger.compareAndSet(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">boolean</span> secondResult = atomicInteger.compareAndSet(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(firstResult);</span><br><span class="line">        System.out.println(secondResult);</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中，main线程第二次调用<code>compareAndSet</code>方法的时候，value的值已经被修改为1了，不符合其expect的值，所以修改将失败。上面例子输出如下：</p>
<p><img src="/images/AtomicInteger%E7%BB%93%E6%9E%9C1.png"></p>
<h2 id="CAS底层原理"><a href="#CAS底层原理" class="headerlink" title="CAS底层原理"></a>CAS底层原理</h2><p>查看<code>compareAndSet</code>方法源码：</p>
<p><img src="/images/compareAndSet%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81.png"></p>
<ol>
<li><p><code>this</code>，当前对象；</p>
</li>
<li><p><code>valueOffset</code>，<code>value</code>成员变量的内存偏移量（也就是内存地址）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>expect</code>，期待值；</p>
</li>
<li><p><code>update</code>，更新值。</p>
</li>
</ol>
<p>所以这个方法的含义为：获取当前对象<code>value</code>成员变量在主内存中的值，和传入的期待值相比，如果相等则说明这个值没有被别的线程修改过，然后将其修改为更新值。</p>
<p>那么<code>unsafe</code>又是什么？它的<code>compareAndSwapInt</code>方法是原子性的么？查看该方法的源码：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法并没有具体Java代码实现，方法通过<code>native</code>关键字修饰。由于Java方法无法直接访问底层系统，<code>Unsafe</code>类相当于一个后门，可以通过该类的方法直接操作特定内存的数据。<code>Unsafe</code>类存在于<code>sun.msic</code>包中，JVM会帮我们实现出相应的<strong>汇编指令</strong>。<code>Unsafe</code>类中的CAS方法是一条CPU并发原语，由若干条指令组成，用于完成某个功能的一个过程。<strong>原语的执行必须是连续的，在执行过程中不允许被中断，不会存在数据不一致的问题</strong>。</p>
<h2 id="getAndIncrement方法剖析"><a href="#getAndIncrement方法剖析" class="headerlink" title="getAndIncrement方法剖析"></a>getAndIncrement方法剖析</h2><p>了解了CAS原理后，我们回头看下<code>AtomicInteger</code>的<code>getAndIncrement</code>方法源码：</p>
<p><img src="/images/getAndIncrement%E6%BA%90%E7%A0%811.png"></p>
<p>该方法通过调用<code>unsafe</code>类的<code>getAndAddInt</code>方法实现相关功能。继续查看<code>getAndAddInt</code>方法的源码：</p>
<p><img src="/images/getAndIncrement%E6%BA%90%E7%A0%812.png"></p>
<p>结合这两张图，我们便可以很直观地看出为什么<code>AtomicInteger</code>的<code>getAndIncrement</code>方法是线程安全的了：</p>
<p>上图中，<code>var1</code>是<code>AtomicInteger</code>对象本身；<code>var2</code>是<code>AtomicInteger</code>对象的成员变量<code>value</code>的内存地址；<code>var4</code>是需要变更的数量；<code>var5</code>是通过<code>unsafe</code>的<code>getIntVolatile</code>方法获得<code>AtomicInteger</code>对象的成员变量<code>value</code>在主内存中的值。do while循环中的逻辑为：用当前对象的值和<code>var5</code>比较，如果相同，说明该值没有被别的线程修改过，更新为<code>var5+var4</code>，并返回true（CAS）；否则继续获取值并比较，直到更新完成。</p>
<h2 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h2><p>CAS并不是完美的，其存在以下这些缺点：</p>
<ol>
<li>如果刚好while里的CAS操作一直不成功，那么对CPU的开销大；</li>
<li>只能确保一个共享变量的原子操作；</li>
<li>存在ABA问题。</li>
</ol>
<p>CAS实现的一个重要前提是需要取出某一时刻的数据并在当下时刻比较交换，这之间的时间差会导致数据的变化。比如：thread1线程从主内存中取出了变量a的值为A，thread2页从主内存中取出了变量a的值为A。由于线程调度的不确定性，这时候thread1可能被短暂挂起了，thread2进行了一些操作将值修改为了B，然后又进行了一些操作将值修改回了A，这时候当thread1重新获取CPU时间片重新执行CAS操作时，会发现变量a在主内存中的值仍然是A，所以CAS操作成功。</p>
<h2 id="解决CAS的ABA问题"><a href="#解决CAS的ABA问题" class="headerlink" title="解决CAS的ABA问题"></a>解决CAS的ABA问题</h2><p>那么如何解决CAS的ABA问题呢？由上面的阐述课件，光通过判断值是否相等并不能确保在一定时间差内值没有变更过，所以我们需要一个额外的指标来辅助判断，类似于时间戳，版本号等。</p>
<p>JUC为我们提供了一个<code>AtomicStampedReference</code>类，通过查看它的构造方法就可以看出，除了指定初始值外，还需指定一个版本号（戳）：</p>
<p><img src="/images/ABA%E9%97%AE%E9%A2%98%E7%89%88%E6%9C%AC%E5%8F%B7.png"></p>
<p>我们就用这个类来解决ABA问题，首先模拟一个ABA问题场景：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomticIntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AtomicReference&lt;String&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟一次ABA操作</span></span><br><span class="line">            atomicReference.compareAndSet(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程完成了一次ABA操作&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 让thread2先睡眠2秒钟，确保thread1的ABA操作完成</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> result = atomicReference.compareAndSet(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程修改值成功，当前值为：&quot;</span> + atomicReference.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，输出如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">thread1线程完成了一次ABA操作</span><br><span class="line">thread2线程修改值成功，当前值为：<span class="selector-tag">B</span></span><br></pre></td></tr></table></figure>

<p>使用<code>AtomicStampedReference</code>解决ABA问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomticIntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始值为A，版本号为1</span></span><br><span class="line">        AtomicStampedReference&lt;String&gt; reference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="string">&quot;A&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = reference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;当前版本号为：&quot;</span> + stamp);</span><br><span class="line">            <span class="comment">// 休眠1秒，让thread2也拿到初始的版本号</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟一次ABA操作</span></span><br><span class="line">            reference.compareAndSet(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, reference.getStamp(), reference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            reference.compareAndSet(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>, reference.getStamp(), reference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程完成了一次ABA操作&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = reference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;当前版本号为：&quot;</span> + stamp);</span><br><span class="line">            <span class="comment">// 让thread2先睡眠2秒钟，确保thread1的ABA操作完成</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> result = reference.compareAndSet(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程修改值成功，当前值为：&quot;</span> + reference.getReference());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程修改值失败，当前值为：&quot;</span> + reference.getReference() + <span class="string">&quot;，版本号为：&quot;</span> + reference.getStamp());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下：</p>
<p><img src="/images/ABA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%952.png"></p>
]]></content>
      <tags>
        <tag>cas</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习Spring Bean的生命周期</title>
    <url>/2020/05/19/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>前面有稍微了解一下Spring Bean的生命周期的大致流程，知道Spring Bean的生命周期是指Bean从创建到初始化再到销毁的过程，这个过程由IOC容器管理。</p>
<span id="more"></span>

<h2 id="Bean的初始化和销毁"><a href="#Bean的初始化和销毁" class="headerlink" title="Bean的初始化和销毁"></a>Bean的初始化和销毁</h2><p>在整个生命周期过程中，我们可以自定义Bean的初始化和销毁钩子函数，当Bean的生命周期到达相应的阶段的时候，Spring会调用我们自定义的Bean的初始化和销毁方法。自定义Bean初始化和销毁方法有多种方式，下面逐一介绍。</p>
<h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><p>在配置类中通过<code>@Bean</code>注解来注册Bean，我们也可以通过它来指定Bean的初始化和方法。下面举个例子说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用无参构造器创建User&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化User&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;销毁User&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>initMethod = &quot;init&quot;</code>和<code>destroyMethod = &quot;destory&quot;</code>与User类里的<code>init</code>，<code>destory</code>方法相对应。测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 IOC 容器，使用注解配置，传入配置类</span></span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">System.out.println(<span class="string">&quot;容器创建完毕&quot;</span>);</span><br><span class="line">User user = context.getBean(User.class);</span><br><span class="line"><span class="comment">// 关闭 IOC 容器</span></span><br><span class="line">context.close();</span><br></pre></td></tr></table></figure>

<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">控制台输出：</span><br><span class="line">调用无参构造器创建<span class="keyword">User</span></span><br><span class="line"><span class="title">初始化User</span></span><br><span class="line">容器创建完毕</span><br><span class="line">销毁User</span><br></pre></td></tr></table></figure>

<p>从上面的输出我们看出在容器启动之前，先调用对象的无参构造器创建对象，然后调用初始化方法，在容器关闭的时候调用销毁方法。</p>
<p>上面的情况是对于单例而言的，如果组件是多例模式又是什么情况呢？我们把上面的组件注册配置改为多例，然后再次启动项目，观察控制台：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">容器创建完毕</span><br><span class="line">调用无参构造器创建<span class="keyword">User</span></span><br><span class="line"><span class="title">初始化User</span></span><br></pre></td></tr></table></figure>

<p>可见，在多例模式下，IOC容器启动的时候并不会去创建对象，而是在每次获取的时候才会去调用方法创建对象，创建完对象后再调用初始化方法。但在容器关闭后，Spring并没有调用相应的销毁方法，这是因为在多例模式下，容器不会管理这个组件（只负责在你需要的时候创建这个组件），所以容器在关闭的时候并不会调用相应的销毁方法。</p>
<h3 id="InitializingBean-amp-DisposableBean"><a href="#InitializingBean-amp-DisposableBean" class="headerlink" title="InitializingBean&amp;DisposableBean"></a>InitializingBean&amp;DisposableBean</h3><p>除了上面这种方式指定初始化和销毁方法外，Spring还为我们提供了和初始化，销毁相对应的接口：</p>
<ul>
<li><code>InitializingBean</code>接口包含一个<code>afterPropertiesSet</code>方法，我们可以通过实现该接口，然后在这个方法中编写初始化逻辑。</li>
<li><code>DisposableBean</code>接口包含一个<code>destory</code>方法，我们可以通过实现该接口，然后再这个方法中编写销毁逻辑。</li>
</ul>
<p>重写之前的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用无参构造器创建User&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;销毁User&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化User&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 IOC 容器，使用注解配置，传入配置类</span></span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">System.out.println(<span class="string">&quot;容器创建完毕&quot;</span>);</span><br><span class="line">User user = context.getBean(User.class);</span><br><span class="line"><span class="comment">// 关闭 IOC 容器</span></span><br><span class="line">context.close();</span><br></pre></td></tr></table></figure>

<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">调用无参构造器创建Use</span><br><span class="line">初始化<span class="keyword">User</span></span><br><span class="line"><span class="title">容器创建完毕</span></span><br><span class="line"><span class="title">销毁User</span></span><br></pre></td></tr></table></figure>

<h3 id="PostConstrict-amp-PreDestroy"><a href="#PostConstrict-amp-PreDestroy" class="headerlink" title="@PostConstrict&amp;@PreDestroy"></a>@PostConstrict&amp;@PreDestroy</h3><p>除了上面两种指定初始化和销毁方法的方式外，我们还可以使用<code>@PostConstruct</code>和<code>@PreDestroy</code>注解修饰方法来指定相应的初始化和销毁方法。</p>
<p>依然重写之前的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用无参构造器创建User&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化User&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;销毁User&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 IOC 容器，使用注解配置，传入配置类</span></span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">System.out.println(<span class="string">&quot;容器创建完毕&quot;</span>);</span><br><span class="line">User user = context.getBean(User.class);</span><br><span class="line"><span class="comment">// 关闭 IOC 容器</span></span><br><span class="line">context.close();</span><br></pre></td></tr></table></figure>

<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">调用无参构造器创建Use</span><br><span class="line">初始化<span class="keyword">User</span></span><br><span class="line"><span class="title">容器创建完毕</span></span><br><span class="line"><span class="title">销毁User</span></span><br></pre></td></tr></table></figure>

<p>和之前的结果一致</p>
<h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>Spring提供了一个<code>BeanPostProcessor</code>接口，俗称<strong>Bean后置通知处理器</strong>，它提供了两个方法<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>。其中<code>postProcessBeforeInitialization</code>在组件的初始化方法调用之前执行，<code>postProcessAfterInitialization</code>在组件的初始化方法调用之后执行。它们都包含两个方法参数：</p>
<ol>
<li>bean：当前组件对象</li>
<li>beanName：当前组件在容器中的名称</li>
</ol>
<p>两个方法都返回一个Object类型，我们可以直接返回当前组件对象，或者包装后返回。</p>
<p>定义一个<code>BeanPostProcessor</code>接口的实现类<code>MyBeanPostProcessor</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(beanName + <span class="string">&quot; 初始化之前调用&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(beanName + <span class="string">&quot; 初始化之后调用&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在配置类中注册组件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyBeanPostProcessor <span class="title">myBeanPostProcessor</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyBeanPostProcessor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<p><img src="/images/%E8%87%AA%E5%AE%9A%E4%B9%89BeanPostProcessor.png"></p>
]]></content>
      <tags>
        <tag>spring, bean, 生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习Spring Bean组件注册</title>
    <url>/2020/05/20/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Spring-Bean%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<p>在传统的Java编程中，当需要用到某个对象的时候，我们都是主动显式创建一个对象实例（new）。使用Spring后就不需要这样做了，因为Spring会帮我们在需要用到某些对象的地方自动注入该对象，而无须我们自己去创建。这种模式俗称控制反转，即IOC（Inversion of Control）。那么Spring是从什么地方获取到我们所需要的对象呢？其实Spring给我们提供了一个IOC容器，里面管理着所有我们需要的对象，组件注册就是我们去告诉Spring哪些类需要交给IOC容器管理。</p>
<span id="more"></span>

<h2 id="通过-Bean注册组件"><a href="#通过-Bean注册组件" class="headerlink" title="通过@Bean注册组件"></a>通过@Bean注册组件</h2><p>创建一个User类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">// 省略构造器和getter, setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个配置类，通过@Bean注册User类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;DougWilson&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>@Bean</code>注解，我们向IOC容器注册了一个名称为<code>user</code>（Bean名称默认为方法名，我们也可以通过<code>@Bean(&quot;myUser&quot;)</code>方式来将组件名称指定为<code>myUser</code>）。下面进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 IOC 容器，使用注解配置，传入配置类</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">User user = context.getBean(User.class);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">User(<span class="attribute">name</span>=DougWilson, <span class="attribute">age</span>=18)</span><br></pre></td></tr></table></figure>

<h2 id="使用-ComponentScan扫描"><a href="#使用-ComponentScan扫描" class="headerlink" title="使用@ComponentScan扫描"></a>使用@ComponentScan扫描</h2><p>在使用XML配置组件扫描的时候，我们都是这样配置的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中<code>base-package</code>指定了扫描的路径。路径下所有被<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>和<code>@Component</code>注解标注的类都会被纳入IOC容器中。</p>
<p>现在我们脱离XML配置后，可以使用<code>@ComponentScan</code>注解来扫描组件并注册。通过举例子来说明：创建一个Controller，一个Service，一个Dao，并标注上相应的注解，然后创建一个配置类，配置类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.dougWilson.demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line"><span class="comment">// 查看基于注解的 IOC容器中所有组件名称</span></span><br><span class="line">String[] beanNames = context.getBeanDefinitionNames();</span><br><span class="line">Arrays.stream(beanNames).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">WebConfig</span><br><span class="line"><span class="keyword">user</span>Controller</span><br><span class="line"><span class="keyword">user</span>Mapper</span><br><span class="line"><span class="keyword">user</span></span><br><span class="line"><span class="keyword">user</span>Service</span><br></pre></td></tr></table></figure>

<p>可见，组件已经成功被扫描进去了，并且名称默认为类名首字母小写。</p>
<h3 id="指定扫描策略"><a href="#指定扫描策略" class="headerlink" title="指定扫描策略"></a>指定扫描策略</h3><p><code>@ComponentScan</code>注解允许我们指定扫描策略，即指定哪些被扫描，哪些不被扫描，查看其源码可发现这两个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specifies which types are eligible for component scanning.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Further narrows the set of candidate components from everything in &#123;<span class="doctag">@link</span> #basePackages&#125;</span></span><br><span class="line"><span class="comment"> * to everything in the base packages that matches the given filter or filters.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that these filters will be applied in addition to the default filters, if specified.</span></span><br><span class="line"><span class="comment"> * Any type under the specified base packages which matches a given filter will be included,</span></span><br><span class="line"><span class="comment"> * even if it does not match the default filters (i.e. is not annotated with &#123;<span class="doctag">@code</span> <span class="doctag">@Component</span>&#125;).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #resourcePattern()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #useDefaultFilters()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Filter[] includeFilters() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specifies which types are not eligible for component scanning.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #resourcePattern</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Filter[] excludeFilters() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>而Filter则是一个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> Filter &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">FilterType <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> FilterType.ANNOTATION</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;classes&quot;)</span></span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    Class&lt;?&gt;[] classes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] pattern() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据名称的含义可知：excludeFilters是用于指定排除扫描的规则，includeFilters则是用于定义扫描的规则。</p>
<p>常用的排除扫描规则有两种：</p>
<ol>
<li>根据注解来排除（<code>type = FilterType.ANNOTATION</code>）。比如，注解的类型为<code>classes = &#123;Controller.class, Repository.class&#125;</code>。即<code>Controller</code>和<code>Repository</code>注解标注的类不再被纳入到IOC容器中。</li>
<li>根据指定类型类排除（<code>type = FilterType.ASSIGNABLE_TYPE</code>），排除类型为对应类、其子类，实现类都会被排除。</li>
</ol>
<p>比如将这些排除规则加入前面例子的扫描策略中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;cc.mrbird.demo&quot;,</span></span><br><span class="line"><span class="meta">        excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">                @Filter(type = FilterType.ANNOTATION,</span></span><br><span class="line"><span class="meta">                        classes = &#123;Controller.class, Repository.class&#125;),</span></span><br><span class="line"><span class="meta">                @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = User.class)</span></span><br><span class="line"><span class="meta">        &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义扫描策略配置"><a href="#自定义扫描策略配置" class="headerlink" title="自定义扫描策略配置"></a>自定义扫描策略配置</h3><p>自定义扫描策略需要我们实现<code>org.springframework.core.type.filter.TypeFilter</code>接口，创建<code>MyTypeFilter</code>实现该接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口包含<code>match</code>方法，其两个入参<code>MetadataReader</code>和<code>MetadataReaderFactory</code>含义如下：</p>
<ol>
<li><code>MetadataReader</code>：当前正在扫描的类的信息；</li>
<li><code>MetadataReaderFactory</code>：可以通过它来获取其他类的信息。</li>
</ol>
<p>当<code>match</code>方法返回true时说明匹配成功，false则说明匹配失败。继续完善这个过滤规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前正在扫描的类的注解信息</span></span><br><span class="line">        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">        <span class="comment">// 获取当前正在扫描的类的类信息</span></span><br><span class="line">        ClassMetadata classMetadata = metadataReader.getClassMetadata();</span><br><span class="line">        <span class="comment">// 获取当前正在扫描的类的路径等信息</span></span><br><span class="line">        Resource resource = metadataReader.getResource();</span><br><span class="line"></span><br><span class="line">        String className = classMetadata.getClassName();</span><br><span class="line">        <span class="keyword">return</span> StringUtils.hasText(<span class="string">&quot;er&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面指定了当被扫描的类名包含<code>er</code>时候，匹配成功，配合<code>excludeFilters</code>使用意指当被扫描的类名包含<code>er</code>时，该类不被纳入IOC容器中。我们在<code>@ComponentScan</code>中使用这个自定义的过滤策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.dougWilson.demo&quot;,</span></span><br><span class="line"><span class="meta">        excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">            @Filter(type = FilterType.CUSTOM, classes = MyTypeFilter.class)</span></span><br><span class="line"><span class="meta">        &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">控制台输出：</span><br><span class="line">webConfig</span><br></pre></td></tr></table></figure>

<p>因为<code>User</code>，<code>UserMapper</code>，<code>UserService</code>和<code>UserController</code>等类的类名都包含<code>er</code>，所以它们都没有被纳入到IOC容器中。</p>
<h2 id="组件作用域-Scope"><a href="#组件作用域-Scope" class="headerlink" title="组件作用域@Scope"></a>组件作用域@Scope</h2><p>默认情况下，在Spring的IOC容器中每个组件都是单例的，即无论在任何地方注入多少次，这些对象都是同一个。在Spring中我们可以使用<code>@Scope</code>注解来改变组件的作用域：</p>
<ol>
<li><code>singleton</code>：单实例（默认）,在Spring IOC容器启动的时候会调用方法创建对象然后纳入到IOC容器中，以后每次获取都是直接从IOC容器中获取（<code>map.get()</code>）；</li>
<li><code>prototype</code>：多实例，IOC容器启动的时候并不会去创建对象，而是在每次获取的时候才会去调用方法创建对象；</li>
<li><code>request</code>：一个请求对应一个实例；</li>
<li><code>session</code>：同一个session对应一个实例</li>
</ol>
<h2 id="懒加载-Lazy"><a href="#懒加载-Lazy" class="headerlink" title="懒加载@Lazy"></a>懒加载@Lazy</h2><p>懒加载是针对单例模式而言的，正如前面所说，IOC容器中的组件默认是单例的，容器启动的时候会调用方法创建对象然后纳入到IOC容器中。在User Bean注册的地方加入一句话以观察：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;往IOC容器中注册user bean&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;dougWilson&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">System.out.println(<span class="string">&quot;容器创建完毕&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">往IOC容器中注册<span class="keyword">user</span> <span class="title">bean</span></span><br><span class="line">容器创建完毕</span><br></pre></td></tr></table></figure>

<p>可以看到，在IOC容器创建完毕之前，组件已经添加到容器中了。将User Bean改为懒加载的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;往IOC容器中注册user bean&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;dougWilson&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">容器创建完毕</span><br></pre></td></tr></table></figure>

<p>可看到，容器创建完的时候，User Bean这个组件并未添加到容器中。所以懒加载的功能是，在单例模式中，IOC容器创建的时候不会马上去调用方法创建对象并注册，只有当组件<strong>第一次</strong>被使用的时候才会调用方法创建对象并加入到容器中。</p>
<p>尝试调用一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">System.out.println(<span class="string">&quot;容器创建完毕&quot;</span>);</span><br><span class="line">Object user1 = context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">Object user2 = context.getBean(<span class="string">&quot;user&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">容器创建完毕</span><br><span class="line">往IOC容器中注册<span class="keyword">user</span> <span class="title">bean</span></span><br></pre></td></tr></table></figure>

<h2 id="条件注册-Conditional"><a href="#条件注册-Conditional" class="headerlink" title="条件注册@Conditional"></a>条件注册@Conditional</h2><p>使用<code>@Conditional</code>注解我们可以指定组件注册的条件，即满足特定条件才将组件纳入到IOC容器中。使用该注解之前，我们需要创建一个类，实现<code>Condition</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口包含一个<code>matches</code>方法，包含两个入参:</p>
<ol>
<li><code>ConditionContext</code>：上下文信息；</li>
<li><code>AnnotatedTypeMetadata</code>：注解信息。</li>
</ol>
<p>简单做个测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        String osName = context.getEnvironment().getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> osName != <span class="keyword">null</span> &amp;&amp; osName.contains(<span class="string">&quot;Windows&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着将这个条件添加到User Bean注册的地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Conditional(MyCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;往IOC容器中注册user bean&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;dougWilson&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果为：在Windows环境下，User这个组件将被成功注册，如果是别的操作系统，这个组件将不会被注册到IOC容器中。</p>
<h2 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h2><p><code>@Profile</code>可以根据不同的环境变量来注册不同的组件</p>
<h2 id="导入组件"><a href="#导入组件" class="headerlink" title="导入组件"></a>导入组件</h2><h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><p>到目前为止，可以使用包扫描和<code>@Bean</code>来实现组件注册。除此之外，还可以使用<code>@Import</code>来快速地往IOC容器中添加组件。创建一个新的类<code>Hello</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在配置类中导入这个组件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;Hello.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看IOC容器中所有组件的名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">String[] beanNames = context.getBeanDefinitionNames();</span><br><span class="line">Arrays.stream(beanNames).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">webConfig</span><br><span class="line">com<span class="selector-class">.dougWilson</span><span class="selector-class">.demo</span><span class="selector-class">.Hello</span></span><br><span class="line">user</span><br></pre></td></tr></table></figure>

<p>从测试结果可知，通过<code>@Import</code>可以快速地往IOC容器中添加组件，id默认为全类名。</p>
<h3 id="ImportSelector"><a href="#ImportSelector" class="headerlink" title="@ImportSelector"></a>@ImportSelector</h3><p>通过<code>@Import</code>已经实现了组件的导入，如果需要一次性导入较多组件，我们可以使用<code>ImportSelector</code>来实现。查看<code>ImportSelector</code>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Select and return the names of which class(es) should be imported based on</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125; of the importing @&#123;<span class="doctag">@link</span> Configuration&#125; class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ImportSelector</code>是一个接口，包含一个<code>selectImports</code>方法，方法返回类的全类名数组（即需要导入到IOC容器中组件的全类名数组），包含一个<code>AnnotationMetadata</code>类型入参，通过这个参数我们可以获取到使用<code>ImportSelector</code>的类的全部注解信息。</p>
<p>新增三个类<code>Apple</code>，<code>Banana</code>和<code>Watermelon</code>，代码略，并新建一个<code>ImportSelector</code>实现类<code>MyImportSelector</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;</span><br><span class="line">                <span class="string">&quot;com.dougWilson.demo.Apple&quot;</span>,</span><br><span class="line">                <span class="string">&quot;com.dougWilson.demo.Banana&quot;</span>,</span><br><span class="line">                <span class="string">&quot;com.dougWilson.demo.Watermelon&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法返回了新增的三个类的全类名数组，接着我们在配置类的<code>@Import</code>注解上使用<code>MyImportSelector</code>来把这三个组件快速地导入到IOC容器中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;MyImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看容器中是否已经有这三个组件:</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">String[] beanNames = context.getBeanDefinitionNames();</span><br><span class="line">Arrays.stream(beanNames).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">com<span class="selector-class">.dougWilson</span><span class="selector-class">.demo</span><span class="selector-class">.Apple</span></span><br><span class="line">com<span class="selector-class">.dougWilson</span><span class="selector-class">.demo</span><span class="selector-class">.Banana</span></span><br><span class="line">com<span class="selector-class">.dougWilson</span><span class="selector-class">.demo</span><span class="selector-class">.Watermelon</span></span><br><span class="line"><span class="comment">// 组件已成功导入</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>spring, bean, 注册</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Spring事件发布与监听</title>
    <url>/2020/05/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E4%B8%8E%E7%9B%91%E5%90%AC/</url>
    <content><![CDATA[<p>在使用Spring构建的应用程序中，适当使用事件发布与监听的机制可以使我们的代码灵活度更高，降低耦合度。Spring提供了完整的事件发布与监听模型，在该模型中，事件发布方只需将事件发布出去，无需关心有多少个对应的事件监听器；监听器无需关心是谁发布了事件，并且可以同时监听来自多个事件发布方发布的事件，通过这种机制，事件发布与监听是解耦的。本文将举例事件发布与监听的使用，并介绍内部实现原理。</p>
<span id="more"></span>

<h2 id="事件发布监听实例"><a href="#事件发布监听实例" class="headerlink" title="事件发布监听实例"></a>事件发布监听实例</h2><p>Spring中使用ApplicationEvent接口来表示一个事件，所以我们自定义事件MyEvent需要实现该接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 构造器source参数表示当前事件的事件源，一般传入Spring的context上下文对象即可。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事件发布通过事件发布器ApplicationEventPublisher完成，我们自定义一个事件发布器MyEventPublisher：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventPublisher</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;开始发布自定义事件MyEvent&quot;</span>);</span><br><span class="line">        MyEvent myEvent = <span class="keyword">new</span> MyEvent(applicationContext);</span><br><span class="line">        applicationEventPublisher.publishEvent(myEvent);</span><br><span class="line">        logger.info(<span class="string">&quot;发布自定义事件MyEvent结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在自定义事件发布器MyEventPublisher中，需要通过ApplicationEventPublisher来发布事件，所以需要实现ApplicationEventPublisherAware接口，通过回调方法setApplicationEventPublisher为MyEventPublisher的ApplicationEventPublisher属性赋值；同样的，自定义的事件MyEvent构造函数需要传入Spring上下文，所以MyEventPublisher还实现了ApplicationContextAware接口，注入了上下文对象ApplicationContext。</p>
<p>publishEvent方法发布了一个自定义事件MyEvent，当事件发布出去后，则需要编写相应的事件监听器：</p>
<p>通过@EventListener注解实现事件监听</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnotationEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMyEventPublished</span><span class="params">(MyEvent myEvent)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;收到自定义事件MyEvent -- MyAnnotationEventListener&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被@EventListener注解标注的方法入参为MyEvent类型，所以只要MyEvent事件被发布了，该监听器就会起作用，即该方法会被回调。</p>
<p>除了使用@EventListener注解实现事件的监听外，我们也可以手动实现ApplicationListener接口来实现事件的监听（泛型为监听的事件类型）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyEvent event)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;收到自定义事件MyEvent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(MyApplication.class, args);</span><br><span class="line">        MyEventPublisher publisher = context.getBean(MyEventPublisher.class);</span><br><span class="line">        publisher.publishEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"><span class="number">2020-06-22</span> <span class="number">16</span>:<span class="number">31:46.667</span>  INFO <span class="number">83600</span> --- [main] MyEventPublisher: 开始发布自定义事件MyEvent</span><br><span class="line"><span class="number">2020-06-22</span> <span class="number">16</span>:<span class="number">31:46.668</span>  INFO <span class="number">83600</span> --- [main] MyEventListener: 收到自定义事件MyEvent</span><br><span class="line"><span class="number">2020-06-22</span> <span class="number">16</span>:<span class="number">31:46.668</span>  INFO <span class="number">83600</span> --- [main] MyAnnotationEventListener: 收到自定义事件MyEvent -- MyAnnotationEventListener</span><br><span class="line"><span class="number">2020-06-22</span> <span class="number">16</span>:<span class="number">31:46.668</span>  INFO <span class="number">83600</span> --- [main] MyEventPublisher: 发布自定义事件MyEvent结束</span><br></pre></td></tr></table></figure>

<p>可以看到，两个监听器都监听到了事件的发布。此外还发现事件发布和事件监听是同一个线程完成的，过程为同步操作，只有当所有对应事件监听器的逻辑执行完毕后，事件发布方法才能出栈。后面进阶使用会介绍如何使用异步的方式进行事件监听。</p>
<h2 id="事件发布监听原理"><a href="#事件发布监听原理" class="headerlink" title="事件发布监听原理"></a>事件发布监听原理</h2><p>在事件发布方法上打个断点：</p>
<p><img src="/images/%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E6%96%B9%E6%B3%95%E4%B8%8A%E6%89%93%E4%B8%AA%E6%96%AD%E7%82%B9.png"></p>
<p>以debug的方式启动程序，程序执行到该断点后点击Step Into按钮，程序跳转到AbstractApplicationContext的publishEvent(ApplicationEvent event)方法：</p>
<p><img src="/images/publishEvent%E6%96%B9%E6%B3%95.png"></p>
<p>继续点击Step Into，程序跳转到AbstractApplicationContext的publishEvent(Object event, @Nullable ResolvableType eventType)方法：</p>
<p><img src="/images/AbstractApplicationContext%E7%9A%84publishEvent%E6%96%B9%E6%B3%95.png"></p>
<p>两个步骤解析如下：</p>
<ol>
<li><p>getApplicationEventMulticaster方法用于获取广播事件用的多播器，源码如下所示：</p>
<p><img src="/images/getApplicationEventMulticaster%E6%96%B9%E6%B3%95.png"></p>
</li>
<li><p>获取到事件多播器后，调用其multicastEvent方法广播事件，点击Step Into进入该方法内部查看具体逻辑：</p>
<p><img src="/images/multicastEvent%E6%96%B9%E6%B3%95.png"></p>
<p>查看invokeListener方法源码：</p>
<p><img src="/images/invokeListener%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%EF%BC%9A.png"></p>
<p>继续查看doInvokeListener方法源码：</p>
<p><img src="/images/doInvokeListener%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png"></p>
</li>
</ol>
<p>上述过程就是整个事件发布与监听的过程。</p>
<h3 id="多播器创建过程"><a href="#多播器创建过程" class="headerlink" title="多播器创建过程"></a>多播器创建过程</h3><p>为了弄清楚AbstractApplicationContext的applicationEventMulticaster属性是何时赋值的（即事件多播器是何时创建的），在AbstractApplicationContext的applicationEventMulticaster属性上打个断点：</p>
<p><img src="/images/applicationEventMulticaster%E5%B1%9E%E6%80%A7%E4%B8%8A%E6%89%93%E4%B8%AA%E6%96%AD%E7%82%B9.png"></p>
<p>以debug的方式启动程序，程序跳转到了AbstractApplicationContext的initApplicationEventMulticaster方法中：</p>
<p><img src="/images/AbstractApplicationContext%E7%9A%84initApplicationEventMulticaster%E6%96%B9%E6%B3%95.png"></p>
<p>通过跟踪方法调用栈，可以总结出程序执行到上述截图的过程：</p>
<ol>
<li><p>SpringBoot入口类的main方法执行SpringApplication.run(MyApplication.class, args)启动应用</p>
<p><img src="/images/%E8%B7%9F%E8%B8%AA%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%A0%881.png"></p>
</li>
<li><p>run方法内部包含refreshContext方法（刷新上下文）</p>
<p><img src="/images/%E8%B7%9F%E8%B8%AA%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%A0%882.png"></p>
</li>
<li><p>refresh方法内部包含initApplicationEventMulticaster方法</p>
<p><img src="/images/%E8%B7%9F%E8%B8%AA%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%A0%883.png"></p>
</li>
<li><p>initApplicationEventMulticaster方法创建多播器</p>
</li>
</ol>
<h3 id="监听器获取过程"><a href="#监听器获取过程" class="headerlink" title="监听器获取过程"></a>监听器获取过程</h3><p>在追踪事件发布与监听的过程中，我们知道事件对应的监听器是通过getApplicationListeners方法获取的：</p>
<p><img src="/images/%E7%9B%91%E5%90%AC%E5%99%A8%E9%80%9A%E8%BF%87getApplicationListeners%E6%96%B9%E6%B3%95%E8%8E%B7%E5%8F%96.png"></p>
<p>方法返回三个MyEvent事件对应的监听器，索引为0的监听器为DelegatingApplicationListener，它没有实质性的处理某事件，忽略；索引为1的监听器为通过实现ApplicationEventListener接口的监听器；索引为2的监听器为通过@EventListener实现的监听器。</p>
<h2 id="编程实现监听器注册过程"><a href="#编程实现监听器注册过程" class="headerlink" title="编程实现监听器注册过程"></a>编程实现监听器注册过程</h2><p>查看getApplicationListeners源码：</p>
<p><img src="/images/getApplicationListeners%E6%BA%90%E7%A0%81.png"></p>
<p>其中retrieverCache的定义为<code>final Map&lt;ListenerCacheKey, CachedListenerRetriever&gt; retrieverCache = new ConcurrentHashMap&lt;&gt;(64)</code>。</p>
<p>接着查看retrieveApplicationListeners方法（方法见名知意，程序第一次获取事件对应的监听器时，缓存中是空的，所以继续检索获取事件对应的监听器）：</p>
<p><img src="/images/retrieveApplicationListeners%E6%96%B9%E6%B3%95.png"></p>
<p>从上面这段代码知道，用于遍历的监听器集合对象listeners和listenerBeans的值是从this.defaultRetriever的applicationListeners和applicationListenerBeans属性获取的，所以需要关注这些属性是何时被赋值的。defaultRetriever的类型为DefaultListenerRetriever：</p>
<p><img src="/images/DefaultListenerRetriever%E6%BA%90%E7%A0%81.png"></p>
<p>在applicationListeners属性上右键选择Find Usages查看赋值相关操作：</p>
<p>![](/images/Find Usages查看赋值相关操作.png)</p>
<p>可以看到，赋值操作发生在AbstractApplicationEventMulticaster的addApplicationListener方法中，</p>
<p>继续在addApplicationListener方法上右键选择Find Usages查看调用源：</p>
<p><img src="/images/addApplicationListener%E6%96%B9%E6%B3%95%E6%9F%A5%E7%9C%8B%E8%B0%83%E7%94%A8%E6%BA%90.png"></p>
<p>在registerListeners方法上打个断点，重新启动程序，查看方法调用栈：</p>
<p><img src="/images/registerListeners%E6%96%B9%E6%B3%95%E6%9F%A5%E7%9C%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%A0%88.png"></p>
<p>从方法调用栈我们可以总结出this.defaultRetriever的applicationListeners和applicationListenerBeans属性值赋值的过程：</p>
<ol>
<li><p><code>SpringApplication.run(MyApplication.class, args)</code>启动Boot程序；</p>
</li>
<li><p><code>run</code>方法内部调用<code>refreshContext</code>刷新容器方法：</p>
<p><img src="/images/refreshContext%E5%88%B7%E6%96%B0%E5%AE%B9%E5%99%A8%E6%96%B9%E6%B3%95.png"></p>
</li>
<li><p><code>refresh</code>方法内部调用了<code>registerListener</code>方法注册监听器：</p>
<p><img src="/images/registerListener%E6%96%B9%E6%B3%95%E6%B3%A8%E5%86%8C%E7%9B%91%E5%90%AC%E5%99%A8.png"></p>
</li>
<li><p><code>registerListeners</code>方法内部从IOC容器获取所有ApplicationListener类型Bean，然后赋值给this.defaultRetriever的applicationListeners和applicationListenerBeans属性。</p>
</li>
</ol>
<h2 id="注解监听器注册过程"><a href="#注解监听器注册过程" class="headerlink" title="注解监听器注册过程"></a>注解监听器注册过程</h2><p>查看<code>@EventListener</code>注解源码：</p>
<p><img src="/images/%E6%9F%A5%E7%9C%8B@EventListener%E6%B3%A8%E8%A7%A3%E6%BA%90%E7%A0%81.png"></p>
<p>查看EventListenerMethodProcessor源码：</p>
<p><img src="/images/%E6%9F%A5%E7%9C%8BEventListenerMethodProcessor%E6%BA%90%E7%A0%81.png"></p>
<p>其实现了SmartInitializingSingleton接口，该接口包含afterSingletonsInstantiated方法：</p>
<p><img src="/images/afterSingletonsInstantiated%E6%96%B9%E6%B3%95.png"></p>
<p>通过注释可以看到这个方法的调用时机为：单实例Bean实例化后被调用，此时Bean已经被创建出来。</p>
<p>我们查看EventListenerMethodProcessor是如何实现该方法的：</p>
<p><img src="/images/EventListenerMethodProcessor%E5%AE%9E%E7%8E%B0.png"></p>
<p>继续查看processBean方法源码：</p>
<p><img src="/images/processBean%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png"></p>
<p>至此，两种方式注册监听器的原理都搞清楚了。</p>
<h2 id="事件监听异步化"><a href="#事件监听异步化" class="headerlink" title="事件监听异步化"></a>事件监听异步化</h2><p>通过前面的分析，我们知道事件广播和监听是一个线程完成的同步操作，有时候为了让广播更有效率，我们可以考虑将事件监听过程异步化</p>
<h3 id="单个异步"><a href="#单个异步" class="headerlink" title="单个异步"></a>单个异步</h3><p>首先需要在springboot入口类上通过<code>@EnableAsync</code>注解开启异步，然后在需要异步执行的监听器方法上使用<code>@Async</code>注解标注，以MyAnnotationEventListener为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnotationEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span> <span class="comment">// 异步</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMyEventPublished</span><span class="params">(MyEvent myEvent)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;收到自定义事件MyEvent -- MyAnnotationEventListener&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">INFO</span> 98747 --- [	  main] MyEventPublisher			: 开始发布自定义事件MyEvent</span><br><span class="line"><span class="builtin-name">INFO</span> 98747 --- [	  main] MyEventListener				: 收到自定义事件MyEvent</span><br><span class="line"><span class="builtin-name">INFO</span> 98747 --- [	  main] ThreadPoolTaskExecutor		: Initializing ExecutorService <span class="string">&#x27;applicationTaskExecutor&#x27;</span></span><br><span class="line"><span class="builtin-name">INFO</span> 98747 --- [	  main] MyEventPublisher			: 发布自定义事件MyEvent结束</span><br><span class="line"><span class="builtin-name">INFO</span> 98747 --- [	task-1] MyEventPublisher			: 收到自定义事件MyEvent -- MyAnnotationEventListener</span><br></pre></td></tr></table></figure>

<p>通过日志可以看出来，该监听器方法已经异步化，执行线程为task-1。</p>
<h3 id="整体异步"><a href="#整体异步" class="headerlink" title="整体异步"></a>整体异步</h3><p>通过前面源码分析，我们知道多播器在广播事件时，会先判断是否有指定executor，有的话通过executor执行监听器逻辑。所以我们可以通过指定executor的方式来让所有的监听方法都异步执行：</p>
<p><img src="/images/%E7%9B%91%E5%90%AC%E6%96%B9%E6%B3%95%E9%83%BD%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C.png"></p>
<p>新建一个配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncEventConfigure</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationEventMulticaster <span class="title">simpleApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleApplicationEventMulticaster eventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster();</span><br><span class="line">        eventMulticaster.setTaskExecutor(<span class="keyword">new</span> SimpleAsyncTaskExecutor());</span><br><span class="line">        <span class="keyword">return</span> eventMulticaster;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在配置类中，我们注册了一个名称为AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME（即applicationEventMulticaster）的Bean，用于覆盖默认的事件多播器，然后指定了TaskExecutor，SimpleAsyncTaskExecutor为Spring提供的异步任务executor。</p>
<p>在启动项目前，先把之前在springboot入口类添加的<code>@EnableAsync</code>注解去掉，然后启动项目，输出如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INFO</span> <span class="number">99778</span> <span class="comment">--- [	  	   main] MyEventPublisher			: 开始发布自定义事件MyEvent</span></span><br><span class="line"><span class="keyword">INFO</span> <span class="number">99778</span> <span class="comment">--- [	       main] MyEventPublisher			: 发布自定义事件MyEvent结束</span></span><br><span class="line"><span class="keyword">INFO</span> <span class="number">99778</span> <span class="comment">--- [TaskExecutor-15] MyEventListener			: 收到自定义事件MyEvent</span></span><br><span class="line"><span class="keyword">INFO</span> <span class="number">99778</span> <span class="comment">--- [TaskExecutor-15] MyAnnotationEventPublisher	: 收到自定义事件MyEvent -- MyAnnotationEventListener</span></span><br></pre></td></tr></table></figure>

<p>可以看到，监听器事件都异步化了。</p>
]]></content>
      <tags>
        <tag>spring, 事件, 监听</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解volatile关键字</title>
    <url>/2020/08/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>volatile关键字修饰的成员变量具有两大特性：保证了该成员变量在不同线程之间的可见性；禁止对该成员变量进行重排序，也就保证了其有序性。但是volatile修饰的成员变量并不具有原子性，在并发下对它的修改是线程不安全的。下面分别举例来演示这两个特性，并且分析为什么volatile不是线程安全的。</p>
<span id="more"></span>

<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>线程对主内存中共享变量的修改首先会从主内存获取值的拷贝，然后保存到线程的工作内存中。接着在工作内存中对值进行修改，最终刷回主内存。由于不同线程拥有各自的工作内存，所以它们对某个共享变量值的修改在没有刷回主内存的时候只对自己可见。</p>
<p>举个例子，假如有两个线程，其中一个线程用于修改共享变量value，另一个线程用于获取修改后的value：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> INIT_VALUE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> LIMIT = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> value = INIT_VALUE;</span><br><span class="line">            <span class="keyword">while</span> (value &lt; LIMIT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (value != INIT_VALUE) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;获取更新后的值：&quot;</span> + INIT_VALUE);</span><br><span class="line">                    value = INIT_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;reader&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> value = INIT_VALUE;</span><br><span class="line">            <span class="keyword">while</span> (INIT_VALUE &lt; LIMIT) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;将值更新为：&quot;</span> + ++value);</span><br><span class="line">                INIT_VALUE = value;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;writer&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>writer线程每隔0.5秒将INIT_VALUE值递增，直到INIT_VALUE大于等于5。而reader线程则是不停的去获取INIT_VALUE的值，直到INIT_VALUE的值大于等于5。程序执行结果如下：</p>
<p><img src="/images/volatile%E6%B5%8B%E8%AF%951.png"></p>
<p><img src="/images/volatile%E6%B5%8B%E8%AF%952.png"></p>
<p>多执行几次可能每次结果都不一样，但是可以确定的是，writer对值的修改reader并不能感知到（如果能感知到的话，reader线程就不会停不下来了）。</p>
<p>为什么会出现上面的结果呢？因为writer线程在工作内存中修改了INIT_VALUE的值，即使它刷回主内存了，但是reader线程在此之前已经从主内存获取了INIT_VALUE的值（因为线程获取CPU时间片不确定性，这个值可能是0，也可能是被writer修改后的值，但writer线程是每隔0.5毫秒才会去修改值，所以reader获取到的INIT_VALUE的值一般不会是writer修改的最终值5），并保存到了reader线程的工作内存中。reader线程通过while不断的轮询判断value和INIT_VALUE的值是否相等，但是由于reader线程工作内存中已经有INIT_VALUE的值的拷贝了，所以reader并不会重新从主内存中获取被writer修改后的INIT_VALUE的值，reader线程里while条件一直成立，这就是为什么reader线程不会正常停止并且没有输出修改后的值的原因。</p>
<p>修改上面的例子，将INIT_VALUE成员变量使用volatile关键字修饰：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> INIT_VALUE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> LIMIT = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> value = INIT_VALUE;</span><br><span class="line">            <span class="keyword">while</span> (value &lt; LIMIT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (value != INIT_VALUE) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;获取更新后的值：&quot;</span> + INIT_VALUE);</span><br><span class="line">                    value = INIT_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;reader&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> value = INIT_VALUE;</span><br><span class="line">            <span class="keyword">while</span> (INIT_VALUE &lt; LIMIT) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;将值更新为：&quot;</span> + ++value);</span><br><span class="line">                INIT_VALUE = value;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MICROSECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;writer&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/volatile%E6%B5%8B%E8%AF%953.png"></p>
<p>可以看到，reader线程已经可以正常停止了，因为最终INIT_VALUE的值肯定是5，并且reader可以感知到这个值被修改为5了。</p>
<p>为什么volatile修饰的成员变量在线程间具有可见性呢？因为通过volatile修饰，对此变量进行写操作时，汇编指令中会有一个LOCK前缀指令，加了这个指令后，会引发两件事情：</p>
<ol>
<li>将当前处理器缓存行的内容写回到系统内存，也就是强制将工作内存中的值刷回主内存；</li>
<li>这个写回到内存的操作会使得在其他CPU里缓存了该内存地址的数据失效。其他CPU缓存数据失效，则会重新去内存中读取值，也就是被修改的数据。</li>
</ol>
<p>通过上面这两个特性，我们可以确定的是，writer对值进行修改并刷回主内存后，reader里INIT_VALUE值的拷贝就失效了，所以reader线程会再次从主内存中获取INIT_VALUE的值，这时候这个值已经是被writer线程修改刷新后的值了。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>来看一个线程不安全的单例实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有化构造函数，让外部没办法直接通过new来创建</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonTest instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonTest <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双重检测</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonTest.class) &#123; <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonTest();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子虽然加了同步锁，但是在多线程下并不是线程安全的。第12行<code>instance = new SingletonTest()</code>在实际执行的时候会被拆分为以下三个步骤:</p>
<ol>
<li>分配存储SingletonTest对象的内存空间；</li>
<li>初始化SingletonTest对象；</li>
<li>将instance指向刚刚分配的内存空间。</li>
</ol>
<p>通过JMM的学习我们都知道，在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序，因为第2步和第3步并没有依赖关系，所以可能发生重排序，排序后的步骤为：</p>
<ol>
<li>分配存储SingletonTest对象的内存空间；</li>
<li>将instance指向刚刚分配的内存空间；</li>
<li>初始化SingletonTest对象。</li>
</ol>
<p>经过重排序后，上面的例子在多线程下就会出现问题。假如现在有两个线程A和B同时调用SingletonTest#getInstance，线程A执行到了代码的第12行<code>instance = new SingletonTest()</code>，已经完成了对象内存空间的分配并将instance指向了该内存空间，线程B执行到了第9行，发现instance并不是null（因为已经指向了内存空间），所以就直接返回instance了。但是线程A并还没有执行初始化SingletonTest操作，所以实际线程B拿到的SingletonTest实例是空的，那么线程B后续对SingletonTest操控将抛出空指针异常。</p>
<p>要让上面的例子是线程安全的，只需要用volatile修饰单例对象即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有化构造函数，让外部没办法直接通过new来创建</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonTest instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonTest <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双重检测</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonTest.class) &#123; <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonTest();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为通过volatile修饰的成员变量会添加内存屏障来阻止JVM进行指令重排优化。</p>
<h2 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h2><p>举个递增的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; IntStream.range(<span class="number">0</span>, <span class="number">500</span>).forEach(i -&gt; value += <span class="number">1</span>));</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; IntStream.range(<span class="number">0</span>, <span class="number">500</span>).forEach(i -&gt; value += <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多次运行上面的例子：</p>
<p><img src="/images/volatile%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8.gif"></p>
<p>可以看到最终的值有可能小于1000。</p>
<p>volatile可以保证修改的值能够马上更新到主内存，其他线程也会捕捉到被修改后的值，那么为什么不能保证原子性呢？</p>
<p>因为在Java中，只有对基本类型的赋值和修改才是原子性的，而对共享变量的修改并不是原子性的。通过<a href="https://mrbird.cc/Java-Memory-model.html">JMM</a>内存交互协议可以知道，一个线程修改共享变量的值需要经过下面这些步骤：</p>
<ol>
<li>线程从主内存中读取（read）共享变量的值，然后载入（load）到线程的工作内存中的变量；</li>
<li>使用（use）工作内存变量的值，执行加减操作，然后将修改后的值赋值（assign）给工作内存中的变量；</li>
<li>将工作内存中修改后的变量的值存储（store）到主内存中，并执行写入（write）操作。</li>
</ol>
<p>所以上面的例子中，可能出现下面这种情况：</p>
<p>thread1和thread2同时获取了value的值，比如为100。thread1执行了+1操作，然后写回主内存，这个时候thread2刚好执行完use操作（+1），准备执行assign（将+1后的值写回工作内存对应的变量中）操作。虽然这时候thread2工作内存中value值的拷贝无效了（因为volatile的特性），但是thread2已经执行完+1操作了，它并不需要再从主内存中获取value的值，所以thread2可以顺利地将+1后的值赋值给工作内存中的变量，然后刷回主存。这就是为什么上面的累加结果可能会小于1000的原因。</p>
<p>要让上面的例子是线程安全的话可以加同步锁，或者使用atomic类。</p>
]]></content>
      <tags>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>理解BeanFactoryPostProcessor&amp;BeanDefinitionRegistryPostProcessor</title>
    <url>/2020/05/20/%E7%90%86%E8%A7%A3BeanFactoryPostProcessor&amp;BeanDefinitionRegistryPostProcessor/</url>
    <content><![CDATA[<p>主要记录BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor的方法执行时机以及简单原理分析。</p>
<span id="more"></span>

<h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>查看BeanFactoryPostProcessor源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Modify the application context&#x27;s internal bean factory after its standard</span></span><br><span class="line"><span class="comment">	 * initialization. All bean definitions will have been loaded, but no beans</span></span><br><span class="line"><span class="comment">	 * will have been instantiated yet. This allows for overriding or adding</span></span><br><span class="line"><span class="comment">	 * properties even to eager-initializing beans.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据注释了解到postProcessBeanFactory方法的执行时机为：BeanFactory标准初始化之后，所有的Bean定义已经被加载，但Bean的实例还没被创建（不包括BeanFactoryPostProcessor类型）。该方法通常用于修改bean的定义，Bean的属性值等，甚至可以在此快速初始化Bean。</p>
<p>测试一下是否是这样：</p>
<p>新建MyBeanFactoryPostProcessor，实现BeanFactoryPostProcessor接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyBeanFactoryPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBeanFactoryPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;实例化MyBeanFactoryPostProcessor Bean&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> beanDefinitionCount = beanFactory.getBeanDefinitionCount();</span><br><span class="line">        logger.info(<span class="string">&quot;Bean定义个数: &quot;</span> + beanDefinitionCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TestBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;实例化TestBean&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在postProcessBeanFactory方法内，我们打印了当前已加载Bean定义的个数，并且在MyBeanFactoryPostProcessor类中，注册了TestBean。MyBeanFactoryPostProcessor和TestBean的构造函数输出的日志用于观察Bean实例化时机。</p>
<p>控制台输出结果如下：</p>
<p><img src="/images/BeanFactoryPostProcessor%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></p>
<p>上面的日志证实了方法的执行时机的确是在BeanFactory标准初始化之后，所有的Bean定义已经被加载，但Bean的实例还没被创建（此时TestBean还未被实例化，日志还没有输出”实例化TestBean”，但这不包括BeanFactoryPostProcessor类型Bean，该方法执行之前，日志就已经输出了”实例化MyBeanFactoryPostProcessor Bean”）。</p>
<p>在postProcessBeanFactory方法上打个断点，通过追踪方法调用栈，可以总结出BeanFactoryPostProcessor的postProcessBeanFactory方法执行时机和原理：</p>
<p><img src="/images/BeanFactory%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%951.png"></p>
<h4 id="1-run方法内部调用refreshContext方法刷新上下文"><a href="#1-run方法内部调用refreshContext方法刷新上下文" class="headerlink" title="1. run方法内部调用refreshContext方法刷新上下文"></a>1. <code>run</code>方法内部调用<code>refreshContext</code>方法刷新上下文</h4><p><img src="/images/BeanFactory%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%952.png"></p>
<h4 id="2-refresh方法内部调用invokeBeanFactoryPostProcessors方法："><a href="#2-refresh方法内部调用invokeBeanFactoryPostProcessors方法：" class="headerlink" title="2. refresh方法内部调用invokeBeanFactoryPostProcessors方法："></a>2. <code>refresh</code>方法内部调用<code>invokeBeanFactoryPostProcessors</code>方法：</h4><p><img src="/images/BeanFactory%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%953.png"></p>
<h4 id="3-PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法内部："><a href="#3-PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法内部：" class="headerlink" title="3. PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法内部："></a>3. PostProcessorRegistrationDelegate的<code>invokeBeanFactoryPostProcessors</code>方法内部：</h4><p><img src="/images/BeanFactory%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%954.png"></p>
<h3 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h3><p>BeanDefinitionRegistryPostProcessor继承自BeanFactoryPostProcessor，新增了一个postProcessBeanDefinitionRegistry方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Modify the application context&#x27;s internal bean definition registry after its</span></span><br><span class="line"><span class="comment">	 * standard initialization. All regular bean definitions will have been loaded,</span></span><br><span class="line"><span class="comment">	 * but no beans will have been instantiated yet. This allows for adding further</span></span><br><span class="line"><span class="comment">	 * bean definitions before the next post-processing phase kicks in.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registry the bean definition registry used by the application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过注释了解到postProcessBeanDefinitionRegistry方法的执行时机为：所有的Bean定义即将被加载，但Bean的实例还没被创建时。也就是说，BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法执行时机先于BeanFactoryPostProcessor的postProcessBeanFactory方法。这个方法通常用于给IOC容器添加额外的组件。</p>
<p>测试一下是否是这样，新建BeanDefinitionRegistryPostProcessor的实现类MyBeanDefinitionRegistryPostProcessor：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyBeanDefinitionRegistryPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> beanDefinitionCount = registry.getBeanDefinitionCount();</span><br><span class="line">        logger.info(<span class="string">&quot;Bean定义个数: &quot;</span> + beanDefinitionCount);</span><br><span class="line">        <span class="comment">// 添加一个新的Bean定义</span></span><br><span class="line">        RootBeanDefinition definition = <span class="keyword">new</span> RootBeanDefinition(Object.class);</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;hello&quot;</span>, definition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出如下：</p>
<p><img src="/images/BeanDefinitionRegistryPostProcessor%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></p>
<p>可以看到，BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法执行时机的确先于BeanFactoryPostProcessor的postProcessBeanFactory方法。</p>
<p>通过源码，这一点也可以看出：</p>
<p><img src="/images/BeanDefinitionRegistryPostProcessor%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89.png"></p>
]]></content>
      <tags>
        <tag>spring, BeanFactoryPostProcessor, BeanDefinitionRegistryPostProcessor</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Spring BeanPostProcessor &amp; InstantiationAwareBeanPostProcessor</title>
    <url>/2020/05/21/%E7%90%86%E8%A7%A3Spring-BeanPostProcessor-&amp;-InstantiationAwareBeanPostProcessor/</url>
    <content><![CDATA[<p>在前天写的文章《深入学习Spring Bean的生命周期》中，学习了Bean后置处理器BeanPostProcessor，用于在Bean初始化前后插入自己的逻辑（Bean增强，Bean代理等）。而BeanPostProcessor的子类InstantiationAwareBeanPostProcessor，用于Bean实例化前后处理，本文记录两者的区别以及简单原理分析</p>
<span id="more"></span>

<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>Initialization为初始化的意思，Instantiation为实例化的意思。在Spring Bean生命周期中，实例化指的是创建Bean的过程，初始化指的是Bean创建后，对其属性进行赋值（populate bean）、后置处理等操作的过程，所以Instantiation执行时机先于Initialization。</p>
<h4 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h4><p>BeanPostProcessor类结构图：</p>
<p><img src="/images/BeanPostProcessor%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<p>InstantiationAwareBeanPostProcessor为BeanPostProcessor的子类，新增了三个额外的方法：</p>
<p><img src="/images/BeanPostProcessor%E7%9A%84%E5%AD%90%E7%B1%BB.png"></p>
<p><img src="/images/BeanPostProcessor%E7%9A%84%E9%A2%9D%E5%A4%96%E6%96%B9%E6%B3%95.png"></p>
<h4 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h4><ol>
<li>BeanPostProcessor<ul>
<li><code>postProcessBeforeInitialization(Object bean, String beanName)</code>：bean：Bean实例；beanName：Bean名称。方法将在Bean实例的afterPropertiesSet方法或者自定义的init方法被调用前调用，此时Bean属性已经被赋值。方法返回原始Bean实例或者包装后的Bean实例，如果返回null，则后续的后置处理方法不再被调用。</li>
<li><code>postProcessAfterInitialization(Object bean, String beanName)</code>：bean：Bean实例；beanName：Bean名称。方法将在Bean实例的afterPropertiesSet方法或者自定义的init方法被调用后调用，此时Bean属性已经被赋值。方法返回原始Bean实例或者包装后的Bean实例，如果返回null，则后续的后置处理方法不再被调用。</li>
</ul>
</li>
<li>InstantiationAwareBeanPostProcessor<ul>
<li><code>postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)</code>：beanClass：待实例化的Bean类型；beanName：待实例化的Bean名称。方法作用为：在Bean实例化前调用该方法，返回值可以为代理后的Bean，以此代替Bean默认的实例化过程。返回值不为null时，后续只会调用BeanPostProcessor的 postProcessAfterInitialization方法，而不会调用别的后续后置处理方法（如postProcessAfterInitialization、postProcessBeforeInstantiation等方法）；返回值也可以为null，这时候Bean将按默认方式初始化。</li>
<li><code>postProcessAfterInstantiation(Object bean, String beanName)</code>：bean：实例化后的Bean，此时属性还没有被赋值；beanName：Bean名称。方法作用为：当Bean通过构造器或者工厂方法被实例化后，当属性还未被赋值前，该方法会被调用，一般用于自定义属性赋值。方法返回值为布尔类型，返回true时，表示Bean属性需要被赋值；返回false表示跳过Bean属性赋值，并且InstantiationAwareBeanPostProcessor的postProcessProperties方法不会被调用。</li>
</ul>
</li>
</ol>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>新建<code>MyBeanPostProcessor</code>实现BeanPostProcessor接口，因为对所有的Bean生效，所以为了方便观察输出，这里仅当Bean名称为<code>demoApplication</code>时才打印输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;demoApplication&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;post processor before &quot;</span> + beanName + <span class="string">&quot; initialization&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;demoApplication&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;post processor after &quot;</span> + beanName + <span class="string">&quot; initialization&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建<code>MyBeanInstantiationPostProcessor</code>实现InstantiationAwareBeanPostProcessor接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanInstantiationPostProcessor</span> <span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;demoApplication&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;post process before &quot;</span> + beanName + <span class="string">&quot; instantiation&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;demoApplication&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;post process after &quot;</span> + beanName + <span class="string">&quot; instantiation&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;demoApplication&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;post process &quot;</span> + beanName + <span class="string">&quot; properties&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="built_in">post</span> <span class="built_in">process</span> <span class="keyword">before</span> demoApplication instantiation</span><br><span class="line"><span class="built_in">post</span> <span class="built_in">process</span> <span class="keyword">after</span> demoApplication instantiation</span><br><span class="line"><span class="built_in">post</span> <span class="built_in">process</span> demoApplication properties</span><br><span class="line"><span class="built_in">post</span> processor <span class="keyword">before</span> demoApplication initialization</span><br><span class="line"><span class="built_in">post</span> processor <span class="keyword">after</span> demoApplication initialization</span><br></pre></td></tr></table></figure>

<p>如果将MyBeanInstantiationPostProcessor的postProcessAfterInstantiation方法返回值改为false，程序输出如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="built_in">post</span> <span class="built_in">process</span> <span class="keyword">before</span> demoApplication instantiation</span><br><span class="line"><span class="built_in">post</span> <span class="built_in">process</span> <span class="keyword">after</span> demoApplication instantiation</span><br><span class="line"><span class="built_in">post</span> processor <span class="keyword">before</span> demoApplication initialization</span><br><span class="line"><span class="built_in">post</span> processor <span class="keyword">after</span> demoApplication initialization</span><br></pre></td></tr></table></figure>

<h3 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h3><p>postProcessAfterInitialization和InstantiationAwareBeanPostProcessor的方法都和Bean生命周期有关，要分析它们的实现原理要从Bean的创建过程入手。Bean创建的入口为<code>AbstractAutowireCapableBeanFactory</code>的createBean方法，查看其源码：</p>
<p><img src="/images/postProcess%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901.png"></p>
<p><strong>resolveBeforeInstantiation方法源码如下所示：</strong></p>
<p><img src="/images/postProcess%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%902.png"></p>
<p><strong>上面方法返回的bean如果为空的话，<code>AbstractAutowireCapableBeanFactory</code>的createBean方法将继续往下执行doCreateBean方法：</strong></p>
<p><img src="/images/postProcess%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%903.png"></p>
<p><strong>查看doCreateBean方法源码：</strong></p>
<p><img src="/images/postProcess%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%904.png"></p>
<p><strong>重点关注populateBean和initializeBean方法。查看populateBean方法源码：</strong></p>
<p><img src="/images/postProcess%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%905.png"></p>
<p><strong>接着查看initializeBean方法源码：</strong></p>
<p><img src="/images/postProcess%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%906.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/postProcess%E6%80%BB%E7%BB%93.png"></p>
]]></content>
      <tags>
        <tag>Spring, BeanPostProcessor, InstantiationAwareBeanPostProcessor</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机程序运行基本知识</title>
    <url>/2020/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>这两天空闲时间比较多一些，打算把计算机一些基本知识再看一看，写一些总结，也当作复习。以下内容参考自书籍 ：</p>
<blockquote>
<p>《程序是怎样跑起来的》</p>
</blockquote>
<span id="more"></span>

<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>什么是程序？<strong>程序是指示计算机运行的一组指令</strong>。程序由什么组成？<strong>指令和数据</strong>？CPU能直接执行指令吗？不能，<strong>必须将指令解释成机器语言，CPU才能解释和执行</strong>。正在运行的程序存储在什么位置？<strong>内存，但是不绝对，需要运行的部分是在内存中，这一点确定</strong>。什么是内存地址？<strong>指令和数据在内存中存储位置的数值。</strong>程序执行的流程？<strong>高级语言编写的程序——&gt;编译后转换成机器语言文件——&gt;程序运行在内存中生成的机器语言文件副本——&gt;CPU解释和运行转换成机器语言的程序内容。一般而言，程序启动后，控制器就会根据时钟信号从内存中读取指令和数据，通过对这些指令加以解释和运行，运算器就会对数据进行运算，控制器根据运算结果来控制计算机</strong></p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><blockquote>
<p><strong>CPU作用：负责解释和运行转换成机器语言的程序内容</strong></p>
<p><strong>CPU硬件组成：CPU和内存都是由若干晶体管组成的电子部件，通常称为IC (Integrated Circuit)集成电路</strong></p>
<p><strong>CPU构成：寄存器、控制器、运算器、时钟。各部分间由电信号相互连通</strong></p>
</blockquote>
<h4 id="CPU构成"><a href="#CPU构成" class="headerlink" title="CPU构成"></a>CPU构成</h4><p><img src="/images/CPU%E6%9E%84%E6%88%90.png"></p>
<blockquote>
<p>控制器：将内存中的指令，数据读入寄存器，并根据指令的执行结果控制整个计算机</p>
</blockquote>
<blockquote>
<p>运算器：运算寄存器中的数据</p>
</blockquote>
<blockquote>
<p>时钟：负责CPU开始计时的时钟信号，一般CPU的时钟单位为GHz，比如2GHz表示时钟信号的频率为2GHz(1GHz=10亿次/秒)，也就是说时钟的频率越高，CPU运行速度越快</p>
</blockquote>
<blockquote>
<p>寄存器：暂存指令，数据等处理对象。因此，程序常常将寄存器当作对象进行描述，比如汇编语言：mov eax, dword ptr[ebp-8];  含义就是把寄存器ebp地址8的内容复制到eax寄存器中。而寄存器根据其保存的对象不同，将寄存器分成了以下几类：</p>
<p><img src="/images/%E5%AF%84%E5%AD%98%E5%99%A8.png"></p>
<p><strong>其中，基址寄存器、变址寄存器、通用寄存器可以有多个，其它寄存器只有一个</strong></p>
<p>标志寄存器：这是一个比较有意思的寄存器。条件分支和循环中的跳转指令都会参照当前标志寄存器中的数值来判断是否进行跳转。而标志寄存器中的数值由3个位表示，负位，零位，正位。如下图：</p>
<p><img src="/images/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%E7%8A%B6%E6%80%81.png"></p>
<p>当运算结果为负值，负位就会置为1；当运算结果为0，零位就会置为1；当运算结果为正值，正位就会置为1.</p>
<p>运算结果的计算过程：比如要比较累加寄存器中XXX值和通用寄存器中YYY值，执行比较指令后，CPU的运算会在内部进行XXX-YYY减法运算。而无论剑法运算的结果为正数，负数，还是零，都会保存到标志寄存器中。结果为正，表示XXX比YYY大，标志寄存器的正位置为1；结果为0，表示XXX和YYY相等，标志寄存器的零位置为1；结果为负值，表示XXX比YYY小，标志寄存器的负位置为1.</p>
<blockquote>
<p>基址寄存器和变址寄存器则定义程序指令在内存中的地址，其中，基址寄存器保存程序的起始地址，变址寄存器保存程序的指令地址。也正因这两类的寄存器的存在，程序的才能得到正确地执行。</p>
</blockquote>
</blockquote>
<h3 id="计算机的二进制"><a href="#计算机的二进制" class="headerlink" title="计算机的二进制"></a>计算机的二进制</h3><blockquote>
<p>前面说过，CPU是由IC集成电路组成的，而IC通常如下：</p>
<p><img src="/images/IC%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF.png"></p>
<p>所有引脚只有直流电压0V或5V两个状态，也就说一个引脚只能表示两个状态。IC的这个特性，决定了计算机的信息，只能通过二进制数来处理。</p>
<h4 id="二进制表示的数和运算"><a href="#二进制表示的数和运算" class="headerlink" title="二进制表示的数和运算"></a>二进制表示的数和运算</h4><p>正数用原码表示；负数用补码表示。这样做的原因是将计算机中的减法运算，转化成加法运算。比如1-1实际上为1+(-1) ：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">的二进制数：</span> <span class="number">0000 </span><span class="number">0001</span></span><br><span class="line"><span class="number">-1</span><span class="string">的二进制数：1111</span> <span class="number">1111   </span><span class="number">1000 </span><span class="number">0001</span><span class="string">取反加1</span></span><br><span class="line"><span class="number">1</span><span class="number">-1</span> <span class="string">变为</span> <span class="number">1</span><span class="string">+(-1):</span>   <span class="number">0000 </span><span class="number">0001</span></span><br><span class="line">                 <span class="string">+1111</span> <span class="number">1111</span></span><br><span class="line">                  <span class="number">0000 </span><span class="number">0000</span> <span class="string">等于0</span></span><br><span class="line"><span class="string">例2：2的二进制数</span>  <span class="number">0000 </span><span class="number">0010</span></span><br><span class="line">    <span class="number">-3</span><span class="string">的二进制数</span> <span class="number">1111 </span><span class="number">1101   </span><span class="number">1000 </span><span class="number">0011</span><span class="string">取反加1</span></span><br><span class="line"><span class="number">2</span><span class="number">-3</span> <span class="string">变为</span> <span class="number">2</span><span class="string">+(-3)：</span> <span class="number">0000 </span><span class="number">0010</span></span><br><span class="line">				<span class="string">+1111</span> <span class="number">1101</span></span><br><span class="line">				 <span class="number">1111 </span><span class="number">1111</span> <span class="string">等于-1</span></span><br></pre></td></tr></table></figure>

<h4 id="浮点数表示"><a href="#浮点数表示" class="headerlink" title="浮点数表示"></a>浮点数表示</h4><p>有些浮点数在计算机中是无法表示的，只能近似表示：比如十进制0.1无法用二进制表示，只能近似表示。如何规避浮点数错误？<strong>无视错误，或将小数转换成整数后计算</strong></p>
<p>那如何用二进制表示浮点数？</p>
<p><img src="/images/%E6%B5%AE%E7%82%B9%E6%95%B0.png"></p>
<img src="/F:/HexoBlog\blog\source\images\浮点数表示.png" style="zoom:75%;">
$$

<p>$$<br><strong>其中正负号为符号位，m为尾数，2为基数，e为指数</strong></p>
<p>举个例子进行求解，以单精度的浮点数为例，11.1875</p>
<blockquote>
<p>符号位求法：正数为0，负数为1 。因此11.1875 符号位为 0</p>
</blockquote>
<blockquote>
<p>尾数求法：11.1875用二进制数表示为 1011.0011 我们需要<strong>让其整数部分只有1</strong>，因此需要将其无符号位右移3位，变成1.011 0011，并确保小数点后长度为23位，变成 1.011 0011 0000 0000 0000 0000</p>
<p>那么尾数就确定了：011 0011 0000 0000 0000 0000</p>
</blockquote>
<blockquote>
<p>基数求法：不需要求，为2</p>
</blockquote>
<blockquote>
<p>指数求法：采用EXCESS系统进行求解。因为指数部分有正有负，因此采用中间基准来规避符号位。比如单精度的指数位数为8位，无符号数最大表示为1111 1111 = 255  因此采用中间基准 255 / 2 = 127  </p>
<p>0111 1111 作为中间基准。如果指数部分为 1111 1111 那么需要减去 0111 1111 表示为128 ，如果指数部分为0000 0000 那么需要减去0111 1111 表示为-127</p>
<p>比如上面的11.1875为了得到整数部分只有1，无符号向右移动了3位，那么其指数部分为 3 + 127 =</p>
<p>​       0000 0011</p>
<p>+     0111 1111 </p>
<p>​       1000 0010</p>
</blockquote>
<blockquote>
<p>综上，11.1875用二进制数表示为 <u>0</u> <u>1000 0010</u> <u>011 0011 0000 0000 0000 0000</u></p>
</blockquote>
</blockquote>
<h2 id="常用机器语言指令"><a href="#常用机器语言指令" class="headerlink" title="常用机器语言指令"></a>常用机器语言指令</h2><blockquote>
<table>
<thead>
<tr>
<th>MOV 复制</th>
<th>ADD 加法</th>
<th>ANL 与</th>
<th>JMP 跳转指令</th>
</tr>
</thead>
<tbody><tr>
<td>PUSH 压入</td>
<td>SUBB 减法</td>
<td>ORL 或</td>
<td>ACALL 短调用</td>
</tr>
<tr>
<td>POP 弹出</td>
<td>MUL 乘法</td>
<td>XRL 异或</td>
<td>LCALL 长调用</td>
</tr>
<tr>
<td>XCH 交换</td>
<td>DIV 除法</td>
<td></td>
<td>RET 返回</td>
</tr>
<tr>
<td>INC 加1</td>
<td></td>
<td></td>
<td>CALL 调用</td>
</tr>
<tr>
<td>DEC 减1</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>指令的跳转调用的是jump指令，一旦跳转后就不需要返回了，而函数的跳转调用的是CALL指令和RET指令的组合。当函数被调用时，调用CALL指令跳转到函数执行的起始地址，当函数执行完毕，需要调用RET指令返回到原来的调用点，执行调用点的下一条指令。</p>
<p><img src="/images/CALL%E5%92%8CRET%E6%8C%87%E4%BB%A4.png"></p>
</blockquote>
<h2 id="求余"><a href="#求余" class="headerlink" title="求余"></a>求余</h2><blockquote>
<p>这部分经常遇到，也经常忘记。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于同号的的，没有什么好说的： <span class="number">10</span> % <span class="number">3</span> = <span class="number">1</span>   -<span class="number">10</span> % (-<span class="number">3</span>) = -<span class="number">1</span></span><br><span class="line">而对于异号的，如 -<span class="number">10</span> % <span class="number">3</span>   <span class="number">10</span> % -<span class="number">3</span>  求余过程为：</span><br><span class="line">    两个操作取绝对值进行求余计算，如果能整除，则结果为<span class="number">0</span></span><br><span class="line">    如果不能整除，则要进行如下计算：a % b = (|a|/|b| + <span class="number">1</span>) × b + a 计算得到结果</span><br><span class="line">    比如 -<span class="number">10</span> % <span class="number">3</span> = (<span class="number">10</span> / <span class="number">3</span> + <span class="number">1</span>) × <span class="number">3</span> + (-<span class="number">10</span>) = <span class="number">2</span></span><br><span class="line">    <span class="number">10</span> % -<span class="number">3</span> = (<span class="number">10</span> / <span class="number">3</span> + <span class="number">1</span>)×(-<span class="number">3</span>) + <span class="number">10</span> = -<span class="number">2</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="内存，或者称为主存"><a href="#内存，或者称为主存" class="headerlink" title="内存，或者称为主存"></a>内存，或者称为主存</h2><blockquote>
<p>主存通过控制芯片等与CPU相连，主要负责存储指令和数据。在主存中，每个字节都有一个地址编号，CPU可以通过该地址读取主存中的指令和数据，或者写入数据。</p>
<p>前面说过，CPU和主存都是通过IC构成的，通常主存的IC引脚可以分为如下几部分：电源、地址引脚、数据引脚、控制引脚。</p>
<p><img src="/images/%E5%86%85%E5%AD%98IC.png"></p>
<p>VCC和GND为电源引脚：为内存IC提供电源</p>
<p>A0~A9为地址引脚(Address)：指定数据存储的场所</p>
<p>D0~D7为数据引脚：写入数据或读取数据</p>
<p>RD和WR为控制引脚：WR为写入信号，WR=1时有效；RD为读取信号，RD=1时有效；WR=0且RD=0时，读取和写入无法进行；WR=1且RD=1时，意味着可读可写。</p>
<p>内存存储的数据量计算：（数据信号引脚数量 / 8）× (地址信号引脚表示的地址数量)</p>
<p>例如上图的内存能存储的数据量：(8 / 8) × (2^10) = 1024B = 1KB </p>
<p>​                                                          (D0<del>D7)  (A0</del>A9)</p>
<p>因此要增大内存可存储数据量，可以增多引脚或者使用多个内存IC。</p>
<p><strong>通常而言，我们从内存中读取的为数据类型。比如byte, short, int, long, float, double等。数据类型是一个抽象的概念，其实内存并不知道数据类型，它只知道读取字节。而数据类型出现的原因是，程序中我们需要不同范围大小和不同类型的数据，因此，需要数据类型来满足需求。但也只是每次读取的字节数不同，byte每次读取1字节，int每次读取4字节，double每次读8字节。</strong></p>
<p><strong>指针也是一种变量，为4字节，保存内存的地址，我们可以通过内存地址读取出内存中该地址中的数据。为了区分数据类型和指针，需要再指针加一个*，变成这样：*pointer  然后还需要指定读取的数据类型，你是要取出内存地址中4个字节的数据还是1个字节的数据，你得指明，因此指针的最终写法为 ：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">数据类型 *p</span><br></pre></td></tr></table></figure>

<h4 id="内存与数组"><a href="#内存与数组" class="headerlink" title="内存与数组"></a>内存与数组</h4><p>如果数组为1字节的数据类型，它的构造和内存的物理构造完全一致。但为了方便读写内存，只能逐个读取字节，程序会变得比较繁琐。因此可以指定任意数据类型定义数组。</p>
</blockquote>
<h2 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h2><blockquote>
<p>磁盘的物理结构：磁盘是通过其物理表明划分成多个空间来使用。划分的方式有扇区方式和可变长方式两种。扇区方式将磁盘划分成固定长度的空间，而可变长方式则将磁盘划分成长度可变的空间。</p>
<p>大部分磁盘采用的是扇区的方式划分磁盘。扇区划分方式中，把磁盘表面分成若干个同心圆的空间就是磁道，而把磁道按照固定大小长度划分成的空间就是扇区。</p>
<p><img src="/images/%E7%A3%81%E7%9B%98%E5%88%92%E5%88%86.png"></p>
<p>一般而言，一个扇区大小为512字节，也就是说无论文件多小，只要文件有内容，且不超过512字节，那么它就会占据512字节的磁盘空间。</p>
<p>而且通过图我们可以很容易看出，外圈磁道拥有更多的扇区。</p>
</blockquote>
<h2 id="哈夫曼压缩算法"><a href="#哈夫曼压缩算法" class="headerlink" title="哈夫曼压缩算法"></a>哈夫曼压缩算法</h2><blockquote>
<p>压缩：压缩后的数据能复原的是可逆压缩，无法复原的是非可逆压缩</p>
<p>RLE(Run Length Encoding行程长度编码)压缩算法：数据 × 重复次数 。比如：</p>
<p>AAAAAA BB C DD EEEEE F 17个字符，经过RLE压缩后为：A6B2C1D2E5F1 12字符</p>
<p>压缩比为：12 / 17 × 100% = 70%</p>
<p>RLE压缩算法常用于压缩传真的图像，缺点是：当文件连续的重复字符较少时，压缩率不高，甚至可能增大文件大小，达成负的压缩率。</p>
<blockquote>
<p>哈夫曼压缩算法为：先将文件中字符出现的频率由高到低进行排序，然后从低频率的字符开始拼接成二叉树，位于左枝的边为0，位于右枝的边为1。</p>
<p>比如：AAAAAA BB C DD EEEEE F</p>
<p>统计后：A(6) E(5) B(2) D(2) C(1) F(1)，然后有如下过程：</p>
<p><img src="/images/%E5%93%88%E5%A4%AB%E6%9B%BC%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B.png"></p>
<p>从而得到字符的编码：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>E</td>
<td>01</td>
</tr>
<tr>
<td>B</td>
<td>100</td>
</tr>
<tr>
<td>D</td>
<td>101</td>
</tr>
<tr>
<td>C</td>
<td>110</td>
</tr>
<tr>
<td>F</td>
<td>111</td>
</tr>
</tbody></table>
<p>从而 AAAAAA BB C DD EEEEE F变为 000000 100100 110 101101 0101010101 111  34bit 5字节</p>
<p>假设一个字符为1字节，那么压缩率为：5 / 17 = 29.41% 贼小</p>
</blockquote>
</blockquote>
]]></content>
      <tags>
        <tag>计算机, 程序</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络之基本概述</title>
    <url>/2020/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>网络协议类似于人类协议，除了交换报文和采取动作的实体是通过设备的硬件或软件组件。在因特网中，凡是涉及到两个及两个以上远程通信实体的活动都要受到协议的制约。</p>
<p>比如，在两台物理上连接的计算机中，硬件实现的协议控制了两块网络接口卡间的比特流；在计算机端系统中，拥塞控制协议控制了发送方和接受方之间传输的分组发送的速率；在web应用中，HTTP协议控制了请求报文格式，响应报文格式，当客户端向web服务器发送一条连接请求报文，等待回答，而web服务器在收到连接请求报文后，要返回一条连接响应报文。</p>
<p>从上述例子可知，网络协议可定义成如下语句：</p>
<p><em>协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送或接收一条报文或其他事件所采取的动作。</em></p>
<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p>和因特网相连的计算机和其他设备都位于因特网中的“端点”，即因特网的边缘，所以也通常被称为端系统。因特网的端系统包括桌面计算机和移动计算机，以及越来越多的其他类型设备，比如共享单车等。</p>
<p>端系统也称为主机，因为它们容纳应用程序。所以，主机和端系统是两个相等的概念。而主机有时会被进一步划分成两类：<strong>客户(client)</strong> 和 <strong>服务器(server)</strong> 。客户大约等同于桌面PC、移动PC和智能手机等，而服务器则大约等同于强大的及其，用于存储和发布web页面、流视频等。</p>
<h2 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h2><p>接入网则是将端系统连接到<strong>边路由器</strong>的物理链路。边路由器是端系统到任何其他远程端系统路径上的第一台路由器。</p>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>网络核心，即由互联网端系统分组交换机和链路构成的网状网络。</p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83.png"></p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>在各种网络应用中，端系统彼此间交换**报文(message)**。报文能够包含协议设计者需要的任何东西。</p>
<p>为了从源端系统向目的端系统发送一个报文，源端系统会将报文划分成较小的数据块，称之为<strong>分组(packet)<strong>。在源端系统和目的端系统间，每个分组都会通过通信链路和</strong>分组交换机(packet switch) 主要包括路由器和链路层交换机</strong>进行传输。</p>
<p>因此，分组的传输速率和通信链路的传输速率有关，比如一个分组有 L 比特，链路的传输速率为 R比特/秒 ，则传输该分组的理论时间为 L/R 秒。</p>
<h4 id="存储转发"><a href="#存储转发" class="headerlink" title="存储转发"></a>存储转发</h4><p>多数分组交换机在链路的输入端使用**存储转发传输(store and forward transmission)**机制。存储转发机制是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。  </p>
<p><img src="/images/%E4%BC%A0%E8%BE%93%E7%AD%89%E5%BE%85%E6%9C%BA%E5%88%B6.png"></p>
<p>比如上述这个例子，源端系统要发送4个分组，该路由器（交换机）的任务就是将一个分组交换到一条出链路。当在某个时刻，源端系统传输了分组1的一部分（假设为分组1），分组1的前沿部分已经到达了路由器，但是因为该路由器应用了存储转发机制，所以这时候它还不能传输已经接收的比特，而是必须先缓存分组1已经达到路由器的比特，只有当路由器接收完分组1的所有比特，它才会向出链路传输该分组，目的端系统才能接收到分组数据。</p>
<p>由于存储转发机制的存在，该机制也会产生一定的时延，称该时延为存储转发时延。</p>
<h4 id="排队时延和分组丢失"><a href="#排队时延和分组丢失" class="headerlink" title="排队时延和分组丢失"></a>排队时延和分组丢失</h4><p>每个分组交换机有多条链路与之相连，而对于每条相连的链路，分组交换机具有一个**输出缓存(output buffer)**（也称为 **输出队列(output queue)**），用于存储路由器出链路的分组。</p>
<p>输出缓存在分组交换中有着重要的作用。如果到达的分组需要传输到某条链路，但是发现该链路正忙于传输其他分组，那么该到达的分组必须在该输出缓存中等待。因此，除了存储转发时延外，分组还会有输出缓存的**排队时延(queue delay)**。</p>
<p>因为缓存空间的大小是有限的，因此，一个分组到达路由器时，有可能缓存已经被其他等待传输的分组占满了。此情况下，就会出现**分组丢失(packet lost)**，到达的分组或者排队的分组之一就会被丢弃。</p>
<h4 id="转发表和路由选择协议"><a href="#转发表和路由选择协议" class="headerlink" title="转发表和路由选择协议"></a>转发表和路由选择协议</h4><p>路由器从与它相连的一条通信链路得到分组，向另一条与它相连的通信链路转发。路由器如何选择转发分组的链路？</p>
<p>分组的首部都会包含目的端系统的IP地址。当一个分组到达网络中的路由器时，路由器检查该分组的目的地址，根据该目的地址（或者目的地址一部分）搜索**转发表(forwarding table)**，以发现合适的出链路，然后将该分组导向该出链路。</p>
<p>而转发表的设置则是由**路由选择协议(routing protocol)**来完成。路由选择协议可以决定从每台路由器到每个目的地的最短路径，并使用这些最短路径结果来配置路由器的转发表。</p>
<h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><p>主要包括：**节点处理时延(nodal procession delay)、排队时延(queuing delay)、传输时延(transmission delay)、传播时延(propagation delay)**。</p>
<ol>
<li>处理时延。检查分组首部和决定将分组导向相应链路所需要的时间。</li>
<li>排队时延。分组在链路上等待传输时所需要的时间。该时延大小取决于正在排队等待向链路传输的分组数量。</li>
<li>传输时延。将分组所有的比特发送到链路所需要的时间。</li>
<li>传播时延。分组数据从链路起点到达下一个节点传播所需要的时间。</li>
</ol>
<h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>**电路交换(circuit switching)**在电路交换网络中，会预留端系统会话期间通信沿路径所需要的资源（缓存，链路传输速率）。在分组交换网络中，这些资源是不预留的。</p>
<p>传统的电话网络是电路交换网络的例子。考虑当一个人通过电话网向另一个人发送信息所发生的情况。在发送方能够发送信息之前，该网络必须在发送方和接收方间建立一条连接，并且沿着发送方和接收方上的交换机都会为该连接维护连接状态。用电话的术语来说，该连接被称为一条**电路(circuit)*<em>。当网络创建这种电路时，也会在连接期间在该网络链路上预留恒定的传输速率，因此，发送方能够以</em>确保*的恒定速率向接收方传送数据。</p>
<h4 id="电路交换网络中的复用"><a href="#电路交换网络中的复用" class="headerlink" title="电路交换网络中的复用"></a>电路交换网络中的复用</h4><p>链路中的电路通过<strong>频分复用(Frequency-Division Multiplexing FDM)</strong> 或 <strong>时分复用(Time-Division Multiplexing TDM)</strong> 实现。对于频分复用FDM，链路的频谱由跨越链路创建的所有连接所共享。特别是，在连接期间链路为每条连接专用一个频段，该频段的宽度称为**带宽(bandwidth)**。</p>
<p>对于时分复用TDM，链路的时间被划分为固定区间的帧，并且每帧又被划分成固定数量的间隙。当网络跨越一条链路创建一条连接时，网络在每个帧中为该连接指定一个时隙。这些时隙专门由该连接单独使用，连接在一个时隙（在每个帧内）可用于传输该连接的数据。</p>
<p><img src="/images/FDM%E5%92%8CTDM.png"></p>
<blockquote>
<p>假设从主机A到主机B经过一个电路交换网络发送一个64000比特的文件。加入在该网络中链路使用24时隙的TDM，具有1.536Mbps的比特速率。同时假定主机A在开始传输该文件时，需要500ms去创建一条端到端电路。那么传输文件的时间可以进行如下计算：</p>
<p>每条链路具有的传输速率是：1.536Mbps/24 = 64kbps</p>
<p>传输文件时间：640kb / 64kbps = 10s 再加上电路创建的时间，时间就变为10.5秒</p>
<p>该传输时间和链路数量无关：不管端到端的电路是一条链路还是100条链路，传输时间都是10秒</p>
</blockquote>
<h4 id="分组交换和电路交换的对比"><a href="#分组交换和电路交换的对比" class="headerlink" title="分组交换和电路交换的对比"></a>分组交换和电路交换的对比</h4><p>举一个例子：</p>
<p>假定多个用户共享一条1Mbps链路，用户时而以100kbps恒定速率产生数据，时而不产生数据，并且用户只有10%时间活跃。因此，对于电路交换而言，在所有时间内，必须为每个用户预留100kbps，比如对于TDM类型的电路交换，如果一个1s的帧被划分成10个时隙，每个时隙100ms，则每帧将为每个用户分配一个时隙。那么，该电路交换链路仅能支持10（1Mbps/100kbps）个并发用户。而对于分组交换而言，有11个或更多并发活跃用户的概率大概是0.0004，有10个或更少并发用户的概率是0.9996。因此，当有10个或更少活跃用户时，到达的聚合数据率小于等于该链路的输出速率1Mbps。当同时活跃用户超过10个时，分组的聚合到达率超过该链路的输出容量，输出队列将会开始变长，但是这个概率极小，所以，某种程度上，分组交换差不多提供了和电路交换相同的性能。</p>
<p>现考虑第二个简单例子。假定就只有10个用户，某个用户突然产生了1000个1000比特分组，而其他用户保持沉默，不产生分组。那么在每帧具有10个时隙并且每个时隙包含1000比特的TDM电路交换情况下，活跃用户仅能使用每帧中的一个时隙来传输数据，而剩余的9个时隙保持空闲。该活跃用户传输完10万个比特的数据需要10s的时间。而在分组交换情况下，活跃用户能够连续地以1Mbps的全部链路速率发送其分组，因为没有其他用户产生分组域该活跃用户的分组进行复用。在此情况下，该活跃用户的所有数据将在1s内发送完毕。</p>
<h2 id="网络协议层次"><a href="#网络协议层次" class="headerlink" title="网络协议层次"></a>网络协议层次</h2><p><img src="/images/%E5%8D%8F%E8%AE%AE%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.png"></p>
<ol>
<li><p>应用层。应用层是网络应用程序及它们的应用层协议存留的地方。应用层包括许多协议，如HTTP协议（提供web文档的请求和传送）、SMTP协议（提供电子邮件报文的传输）、FTP协议（提供端系统间的文件传送）</p>
<p>一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息的分组，我们称之为<strong>报文(message)</strong></p>
</li>
<li><p>传输层。传输层在应用程序断点之间传送应用层报文。非常重要的两个协议TCP和UDP协议都能够完成应用层报文的传输。TCP提供面向连接的服务，能够确保应用层报文向目的端系统的传递和流量控制，并且将长报文划分成短报文，提供拥塞控制机制，当网络拥塞时，控制器传输速率。UDP则提供无连接服务，没有可靠性，没有流量控制，也没有拥塞控制。传输层的分组一般称为<strong>报文段(segment)</strong></p>
</li>
<li><p>网络层。网络层的分组称为**数据报(datagram)**。网络层负责将数据报从一台主机移动到另一台主机。极其重要的一个网络层协议就是IP协议，该协议定义了数据报各个字段的含义，让端系统和路由器知道如何读取这些字段。</p>
</li>
<li><p>链路层。网络层通过源端系统和目的端系统之间的路由器将分组从一个节点移动到下一个节点，而这必须依靠链路层的服务。特别是在每个节点，网络层将数据报下传给链路层，链路层沿着庐江将数据报传递给下个节点。而在下个节点中，链路层又会将数据报上传给网络层。链路层的分组我们称之为<strong>帧(frame)</strong></p>
</li>
<li><p>物理层。物理层的任务就是将帧的一个一个比特从一个节点移动到另一个节点，和实际的链路有关（双绞铜线、光纤等）。</p>
</li>
</ol>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><img src="/images/%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png"></p>
]]></content>
      <tags>
        <tag>计算机网络, 基本概述</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络之网络层</title>
    <url>/2020/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<h2 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h2><h3 id="客户-服务器"><a href="#客户-服务器" class="headerlink" title="客户-服务器"></a>客户-服务器</h3><p>在<strong>客户-服务器体系结构(client-server architecture)<strong>中，有一个总是打开的主机称为</strong>服务器</strong>，它服务于数量庞大的称为<strong>客户</strong>的主机的请求。比如web服务器，当web服务器接收到来自某客户对某个资源的请求时，它就向该客户发送所请求的资源作为响应。</p>
<p>在客户-服务器体系结构中，有两个显著的特征：</p>
<ol>
<li>客户相互之间不直接通信</li>
<li>服务器具有固定的、为人所知的IP地址</li>
</ol>
<p>并且，服务器总是打开的，因此，客户总能通过向该服务器的IP地址发送分组来与其联系。</p>
<p>客户-服务器体系结构的另一个特点就是服务供应商需要支付带宽费用。通常服务器的体系结构通过会配备大量主机的数据中心，用于创建强大的虚拟服务器。一个数据中心需要有数十万台服务器，这些服务器必须要供电以及维护，还要有大量的带宽来发送和接收来自数据中心的数据。</p>
<h3 id="客户-客户"><a href="#客户-客户" class="headerlink" title="客户-客户"></a>客户-客户</h3><p><strong>客户-客户体系结构</strong>也称为**P2P(P2P architecture)*<em>。在P2P体系结构中，没有服务器依赖，应用程序在间断连接的主机对之间直接通信，这些主机对称为</em>对等方*。许多目前流行的、流量密集型的应用都是P2P体系结构，比如：对等方协助下载加速器（迅雷）、因特网电话（Skype）、IPTV（迅雷看看）等。需要注意的是，某些应用具有混合体系结构，结合了客户-服务器和P2P的元素。比如对于许多即时通讯应用而言，服务器被用于跟踪用户的IP地址，但用户到用户的报文在用户主机之间直接发送，没有经过服务器。</p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>网络层中，进行通信的实际上是**进程(process)**而不是程序。一个进程可以被认为是运行在端系统中的一个程序。当进程运行在相同的端系统上时，使用进程间的通信机制相互通信，通信的规则由端系统上的操作系统确定，这不是这里讨论的重点。这里只关注不同端系统上的进程间的通信。</p>
<p>在两个不同端系统上的进程，通过计算机网络交换报文而相互通信。发送进程生成并向网络中发送报文；接收进程接收这些报文并通过将报文发送回去进行响应。</p>
<h3 id="进程与计算机网络间的接口"><a href="#进程与计算机网络间的接口" class="headerlink" title="进程与计算机网络间的接口"></a>进程与计算机网络间的接口</h3><p>多数应用程序是由通信进程对组成，每对进程相互发送报文。从一个进程向另一个进程发送的报文必须通过底层的网络体系。进程通过一个称为**套接字(socket)**的软件接口向网络发送报文和从网络接收报文。</p>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6.png"></p>
<p>如图所示，由于套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络间的**应用程序编程接口(Application Programming Interface)**。应用程序开发者可以控制套接字在应用层中的表现，但是对该套接字的传输层端几乎没有控制权。应用程序开发者对传输层的控制仅限于：</p>
<ol>
<li>选择传输层协议</li>
<li>设定几个传输层参数，如最大缓存和最大报文段长度等</li>
</ol>
<h3 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h3><p>在一台主机上运行的进程为了向另一台主机上运行的进程发送分组，接收进程需要有一个地址，为了标识该接收进程，需要定义两种信息：</p>
<ol>
<li>主机的地址</li>
<li>定义在目的主机中的接收进程的标识符(端口号)</li>
</ol>
<h2 id="选择应用程序的传输服务"><a href="#选择应用程序的传输服务" class="headerlink" title="选择应用程序的传输服务"></a>选择应用程序的传输服务</h2><p>很多网络提供了不止一种的传输层协议。当开发一个应用时，必须选择一种可用的传输层协议。如何选择？这需要根据传输层协议提供的服务以及应用程序的功能来进行综合考虑。</p>
<h3 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h3><p>TCP服务模型包括面向连接服务和可靠数据传输服务。当某个应用程序调用TCP作为其传输层协议时，该应用程序就能获得来自TCP的这两种服务。</p>
<ol>
<li>面向连接的服务。在应用层数据报文开始流动之前，TCP让客户和服务器互相交换传输层控制信息。通过握手过程提示客户和服务器，使他们为分组的到来做好准备。握手阶段过后，一个TCP连接就在两个进程的套接字间建立了。这条连接是全双工的，即连接双方的进程可以在此连接上同时进行报文收发。当应用程序结束报文发送时，必须拆除该连接。</li>
<li>可靠的数据传送服务。通信进程能够依靠TCP，无差错、按顺序交付所有发送的数据，没有字节的丢失和冗余。</li>
</ol>
<p>TCP还拥有拥塞控制机制，这种服务不一定能为通信进程带来直接好吃，但能为整体互联网络带来整体好处。</p>
<h3 id="UDP服务"><a href="#UDP服务" class="headerlink" title="UDP服务"></a>UDP服务</h3><p>UDP是一种不提供不必要服务的轻量级传输协议，它仅提供最小服务。UDP是无连接的，因此在两个进程通信前没有握手过程；UDP提供尽最大努力交付的服务，不能够保证将报文按序、完整地传送到接收进程。</p>
<h2 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h2><p>**超文本传输协议(HyperText Transfer Protocol, HTTP)**协议，是web的核心。HTTP协议定义了客户与服务器间会话的报文结构以及进行报文交换的方式。</p>
<p><img src="/images/%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8.png"></p>
<p>HTTP使用TCP作为其传输层协议支持。HTTP客户首先发起一个与服务器的TCP连接，一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问TCP。客户向它的套接字接口发送HTTP请求报文，并从它的套接字接口接收HTTP响应报文。类似地，服务器从它的套接字接口接收HTTP请求报文和向它的套接字接口发送HTTP响应报文。一旦客户向它的套接字接口发送了一个请求报文，该报文就脱离了客户控制，并进入TCP的控制。而TCP提供可靠的数据传输服务，这意味着客户进程发送的每个HTTP请求报文都能最终完整地到达服务器。</p>
<p>需要注意的HTTP一个重要特点就是：**HTTP是一个无状态协议(stateless protocol)**。服务器向客户发送被请求的文件，而不会存储任何关于该客户的状态信息。</p>
<h3 id="非持续连接和持续连接的HTTP协议"><a href="#非持续连接和持续连接的HTTP协议" class="headerlink" title="非持续连接和持续连接的HTTP协议"></a>非持续连接和持续连接的HTTP协议</h3><p>**非持续连接(non-persistent connection)**：每个请求/响应对经过一个单独的TCP连接发送</p>
<p>**持续连接(persistent connection)**：所有请求/响应都经过相同的TCP连接发送</p>
]]></content>
      <tags>
        <tag>网络层, 计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList &amp; LinkedList源码解析</title>
    <url>/2020/08/31/ArrayList&amp;LinkedList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>ArrayList &amp; LinkedList源码解析，基于JDK1.8</p>
<span id="more"></span>

<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList实现了List接口的所有方法，可以看成是“长度可调节的数组”，可以包含任何类型数据（包括null，可重复）。ArrayList大体和Vector一致，唯一区别是ArrayList非线程安全，Vector线程安全，但Vector线程安全的代价较大，推荐使用CopyOnWriteArrayList，后面文章再做记录。</p>
<h3 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h3><p>ArrayList类层级关系如下图所示：</p>
<p><img src="/images/ArrayList%E7%B1%BB%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.png"></p>
<p>ArrayList额外实现了RandomAccess接口，关于RandomAccess接口的作用下面再做讨论。</p>
<p>ArrayList类主要包含如下两个成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>elementData为Object类型数组，用于存放ArrayList数据；size表示数组元素个数（并非数组容量）。</p>
<p>ArrayList类还包含了一些常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 数组默认初始化容量为10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 表示空数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 也是空数组，和EMPTY_ELEMENTDATA区分开</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h3><p>Arrays类的<code>copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType)</code>方法用于复制指定数组original到新数组，新数组的长度为newLength，新数组元素类型为newType。</p>
<ol>
<li>如果新数组的长度大于旧数组，那么多出的那部分用null填充；</li>
<li>如果新数组的长度小于旧数组，那么少的那部分直接截取掉。</li>
</ol>
<p>举两个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Long[] array1 = <span class="keyword">new</span> Long[]&#123;<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>&#125;;</span><br><span class="line">Object[] array2 = Arrays.copyOf(array1, <span class="number">5</span>, Object[].class);</span><br><span class="line">System.out.println(Arrays.toString(array2)); <span class="comment">// [1, 2, 3, null, null]</span></span><br><span class="line"></span><br><span class="line">Object[] array3 = Arrays.copyOf(array1, <span class="number">1</span>, Object[].class);</span><br><span class="line">System.out.println(Arrays.toString(array3)); <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>

<p>重载方法<code>copyOf(T[] original, int newLength)</code>用于复制指定数组original到新数组，新数组的长度为newLength，新数组元素类型和旧数组一致。</p>
<p><code>copyOf</code>方法内部调用System类的native方法<code>arraycopy(Object src, int srcPos,Object dest, int destPos, int length)</code>：</p>
<ol>
<li><code>src</code>：需要被拷贝的旧数组；</li>
<li><code>srcPos</code>：旧数组开始拷贝的起始位置；</li>
<li><code>dest</code>：拷贝目标数组；</li>
<li><code>destPos</code>：目标数组的起始拷贝位置；</li>
<li><code>length</code>：拷贝的长度。</li>
</ol>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Long[] array1 = <span class="keyword">new</span> Long[]&#123;<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>&#125;;</span><br><span class="line">Object[] array2 = <span class="keyword">new</span> Object[<span class="number">5</span>];</span><br><span class="line">System.arraycopy(array1, <span class="number">0</span>, array2, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(Arrays.toString(array2)); <span class="comment">// [1, 2, 3, null, null]</span></span><br></pre></td></tr></table></figure>

<p>指定位置插入元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Long[] array1 = <span class="keyword">new</span> Long[]&#123;<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">System.arraycopy(array1, index, array1, index + <span class="number">1</span>, <span class="number">3</span> - index);</span><br><span class="line">array1[index] = <span class="number">0L</span>;</span><br><span class="line">System.out.println(Arrays.toString(array1)); <span class="comment">// [1, 0, 2, 3, null, null]</span></span><br></pre></td></tr></table></figure>

<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><code>public ArrayList(int initialCapacity)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建容量大小为initialCapacity的ArrayList，如果initialCapacity小于0，则抛出IllegalArgumentException异常；如果initialCapacity为0，则elementData为EMPTY_ELEMENTDATA。</p>
<p><code>public ArrayList()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空参构造函数，elementData为DEFAULTCAPACITY_EMPTY_ELEMENTDATA。</p>
<p><code>public ArrayList(Collection&lt;? extends E&gt; c)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个包含指定集合c数据的ArrayList。上面为什么要多此一举使用<code>Arrays.copyOf(elementData, size, Object[].class)</code>复制一遍数组呢？这是因为在某些情况下调用集合的toArray()方法返回的类型并不是Object[].class，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Long[] array1 = &#123;<span class="number">1L</span>, <span class="number">2L</span>&#125;;</span><br><span class="line">List&lt;Long&gt; list1 = Arrays.asList(array1);</span><br><span class="line">Object[] array2 = list1.toArray();</span><br><span class="line">System.out.println(array2.getClass() == Object[].class); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">List&lt;Long&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">System.out.println(list2.toArray().getClass() == Object[].class); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h4><p><code>add(E e)</code>用于尾部添加元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于确定数组容量</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如现在我们通过如下代码创建了一个ArrayList实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>内部过程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于确定数组容量，e=hello，size=0</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 末尾添加元素，然后size递增1</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123; <span class="comment">// minCapacity=1,elementData=&#123;&#125;</span></span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">// DEFAULT_CAPACITY=10，minCapacity=1，故返回10</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123; <span class="comment">// minCapacity=10</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// minCapacity=10，elementData.length=0，所以调用grow方法扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123; <span class="comment">//minCapacity=10</span></span><br><span class="line">    <span class="comment">// oldCapacity=0</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// newCapacity为oldCapacity的1.5倍，这里为0</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// newCapacity=0，minCapacity=10，所以该条件成立</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// newCapacity=10</span></span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 复制到新数组，数组容量为10</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">// MAX_ARRAY_SIZE常量值为Integer.MAX_VALUE - 8，通过</span></span><br><span class="line">    <span class="comment">// 这段逻辑我们可以知道，ArrayList最大容量为Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面源码分析我们可以知道：</p>
<ol>
<li>任何一个空的ArrayList在添加第一个元素时，内部数组容量将被扩容为10；</li>
<li>扩容时，newCapacity为oldCapacity的1.5倍；</li>
<li>数组容量最大为Integer.MAX_VALUE；</li>
<li>尾部添加元素不用移动任何元素，所以速度快。</li>
</ol>
<h4 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h4><p><code>add(int index, E element)</code>用于在指定位置添加元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下标检查</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 确定数组容量，和上面add(E e)方法介绍的一致</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将原来index后面的所有元素往后面移动一个位置</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    <span class="comment">// index处放入新元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// size递增</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下标比size大或者下标小于0，都会抛出下标越界异常</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及到元素移动，所以速度较慢。</p>
<h4 id="get-int-index"><a href="#get-int-index" class="headerlink" title="get(int index)"></a>get(int index)</h4><p><code>get(int index)</code>获取指定位置元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下标合法性检查</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 直接返回数组指定位置元素</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>get</code>方法直接返回数组指定下标元素，速度非常快。</p>
<h4 id="set-int-index-E-element"><a href="#set-int-index-E-element" class="headerlink" title="set(int index, E element)"></a>set(int index, E element)</h4><p><code>set(int index, E element)</code>设置指定位置元素为指定值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下标合法性检查</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 根据下标获取旧值</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">// 设置新值</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 返回旧值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>set</code>方法不涉及元素移动和遍历，所以速度快。</p>
<h4 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h4><p><code>remove(int index)</code>删除指定位置元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 获取指定位置元素（需要被删除的元素）</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 直接将index后面的元素往前移动一位，覆盖index处的元素</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="comment">// 返回被删除的元</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法涉及到元素移动，所以效率也不高。</p>
<h4 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h4><p><code>remove(Object o)</code>删除指定元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历数组，找到第一个目标元素，然后删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 逻辑和remove一致，都是将index后面的元素往前移动一位，覆盖index处的元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法涉及到数组遍历和元素移动，效率也不高。</p>
<h4 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize()"></a>trimToSize()</h4><p><code>trimToSize()</code>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">          ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法用于将数组容量调整为实际元素个数大小，当一个ArrayList元素个数不会发生改变时，可以调用该方法减少内存占用。</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="类结构-1"><a href="#类结构-1" class="headerlink" title="类结构"></a>类结构</h3><p>LinkedList底层采用双向链表结构存储数据，允许重复数据和null值，长度没有限制：</p>
<p><img src="/images/LinkedList%E7%B1%BB%E7%BB%93%E6%9E%84.png"></p>
<p>每个节点用内部类Node表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Node节点包含item（存储数据），next（后继节点）和prev（前继节点）。数组内存地址必须连续，而链表就没有这个限制了，Node可以分布于各个内存地址，它们之间的关系通过prev和next维护。</p>
<h3 id="LinkedList类关系图："><a href="#LinkedList类关系图：" class="headerlink" title="LinkedList类关系图："></a>LinkedList类关系图：</h3><p><img src="/images/LinkedList%E7%B1%BB%E5%85%B3%E7%B3%BB.png"></p>
<p>可以看到LinkedList类并没有实现RandomAccess接口，额外实现了Deque接口，所以包含一些队列方法。</p>
<p>LinkedList包含如下成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素个数，默认为0</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示第一个节点，第一个节点必须满足(first == null &amp;&amp; last == null) || (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示最后一个节点，最后一个节点必须满足(first == null &amp;&amp; last == null) || (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>

<h3 id="方法解析-1"><a href="#方法解析-1" class="headerlink" title="方法解析"></a>方法解析</h3><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><p><code>LinkedList()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空参构造函数，默认size为0，每次添加新元素都要创建Node节点。</p>
<p><code>LinkedList(Collection&lt;? extends E&gt; c)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环创建节点，设置prev，next指向</span></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该构造函数用于创建LinkedList，并往里添加指定集合元素。</p>
<h4 id="add-int-index-E-element-1"><a href="#add-int-index-E-element-1" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h4><p><code>add(int index, E element)</code>指定下标插入元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下标合法性检查</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        <span class="comment">// 如果插入下标等于size，说明是在尾部插入，执行尾部插入操作</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果不是尾插入，则在指定下标节点前插入</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取最后一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 创建一个新节点，prev为原链表最后一个节点，next为null</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 更新last为新节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果原链表最后一个节点为null，说明原链表没有节点，将新节点赋给first</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则更新原链表最后一个节点的next为新节点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">// size递增</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 模数递增，用于快速失败</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// succ为原链表指定index位置的节点，获取其prev节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">// 创建新节点，prev为原链表指定index位置的节点的prev节点，next为原链表指定index位置的节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">// 将原链表指定index位置的节点的prev更新为新节点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果链表指定index位置的节点的prev为null，说明原链表没有节点，将新节点赋给first</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则更新原链表指定index位置的节点的prev的next节点为新节点</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    <span class="comment">// size递增</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 模数递增，用于快速失败</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用二分法遍历每个Node节点，直到找到index位置的节点</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码较为简单，无非就是设置节点的prev和next关系。可以看到，除了头插和尾插外，在链表别的位置插入新节点，涉及到节点遍历操作，所以我们常说的链表插入速度快，指的是插入节点改变前后节点的引用过程很快。</p>
<h4 id="get-int-index-1"><a href="#get-int-index-1" class="headerlink" title="get(int index)"></a>get(int index)</h4><p><code>get(int index)</code>获取指定下标元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用二分法遍历每个Node节点，直到找到index位置的节点</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码较为简单，就是通过node函数查找指定index下标Node，然后获取其item属性值，节点查找需要遍历。</p>
<h4 id="set-int-index-E-element-1"><a href="#set-int-index-E-element-1" class="headerlink" title="set(int index, E element)"></a>set(int index, E element)</h4><p><code>set(int index, E element)</code>设置指定下标节点的item为指定值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下标合法性检查</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 获取index下标节点</span></span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    <span class="comment">// 获取旧值</span></span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    <span class="comment">// 设置新值</span></span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="comment">// 返回旧值</span></span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用二分法遍历每个Node节点，直到找到index位置的节点</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，set方法也需要通过遍历查找目标节点。</p>
<h4 id="remove-int-index-1"><a href="#remove-int-index-1" class="headerlink" title="remove(int index)"></a>remove(int index)</h4><p><code>remove(int index)</code>删除指定下标节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>remove(int index)</code>通过node方法找到需要删除的节点，然后调用unlink方法改变删除节点的prev和next节点的前继和后继节点。</p>
<h2 id="RandomAccess接口"><a href="#RandomAccess接口" class="headerlink" title="RandomAccess接口"></a>RandomAccess接口</h2><p>RandomAccess接口是一个空接口，不包含任何方法，只是作为一个标识：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现该接口的类说明其支持快速随机访问，比如ArrayList实现了该接口，说明ArrayList支持快速随机访问。所谓快速随机访问指的是通过元素的下标即可快速获取元素对象，无需遍历，而LinkedList则没有这个特性，元素获取必须遍历链表。</p>
<p>在Collections类的<code>binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)</code>方法中，可以看到RandomAccess的应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当list实现了RandomAccess接口时，调用indexedBinarySearch方法，否则调用iteratorBinarySearch。所以当我们遍历集合时，如果集合实现了RandomAccess接口，优先选择普通for循环，其次foreach；遍历未实现RandomAccess的接口，优先选择iterator遍历。</p>
]]></content>
      <tags>
        <tag>ArrayList, LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Concurrency Lock</title>
    <url>/2020/08/24/Java-Concurrency-Lock/</url>
    <content><![CDATA[<p>Lock锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。</p>
<span id="more"></span>

<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock字面上意思就是可重入锁（又称为递归锁），表示该锁能够支持一个线程对资源的重复加锁。定义一个ReentrantLock：</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock()<span class="comment">;</span></span><br></pre></td></tr></table></figure>



<p>默认无参构造函数创建的是非公平锁，构造函数重载方法<code>ReentrantLock(boolean fair)</code>支持传入<code>true</code>创建公平锁。公平锁的意思是多线程在获取锁的时候是公平的，也就是等待时间最长的线程最优先获取锁，类似FIFO。</p>
<p>使用ReentrantLock可以实现和synchronized一样的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">2</span>).forEach(i -&gt; <span class="keyword">new</span> Thread(ReentrantLockTest::needLock).start());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">needLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始工作&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：确保在finally里释放锁，否则容易造成死锁</strong></p>
<p>上面例子同一时刻只能有一个线程可以获得锁<code>lock</code>，别的线程必须等待锁被释放（<code>unlock</code>）才能开始竞争获取锁。程序运行结果如下所示：</p>
<p><img src="/images/lock%E9%94%81.gif"></p>
<p><code>needLock</code>方法和下面通过synchronized关键字实现锁方法效果是一样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">needLockBySync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (ReentrantLockTest.class) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始工作&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么<code>ReentrantLock</code>又称为递归锁呢？这是因为：一个线程如果获取了某个方法的锁，这个方法内部即使调用了别的需要获取锁的方法，那么这个线程不需要再次等待获取锁，可以直接进去。说着可能有点抽象，下面举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream.rangeClosed(<span class="number">0</span>,<span class="number">1</span>).forEach(i-&gt; <span class="keyword">new</span> Thread(Test::method1, String.valueOf(i)).start());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; invoked method1&quot;</span>);</span><br><span class="line">            method2();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; invoked method2&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span>invoked method1</span><br><span class="line"><span class="symbol">0 </span>invoked method2</span><br><span class="line"><span class="symbol">1 </span>invoked method1</span><br><span class="line"><span class="symbol">1 </span>invoked method2</span><br></pre></td></tr></table></figure>

<p>上面例子中，method1和method2都加了锁，线程0获取到了method1的锁后，内部可以直接调用method2，无需重新获取锁对象。<code>synchronized</code>也具有相同的特性。</p>
<p><code>ReentrantLock</code>可以对一个方法不限次的重复加锁，但解锁次数必须和加锁次数一致，否则锁永远不会被释放，别的线程将无法获取该方法的锁，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream.rangeClosed(<span class="number">0</span>,<span class="number">1</span>).forEach(i-&gt; <span class="keyword">new</span> Thread(Test::method1, String.valueOf(i)).start());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加锁4次</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        lock.lock();</span><br><span class="line">        lock.lock();</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; invoked method1&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 解锁3次</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">            lock.unlock();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85.png"></p>
<p>线程1一直处于WAITING状态，因为线程0加锁了4次，但只释放了3次锁，所以线程1一直无法获取到锁。</p>
<p><code>lock</code>方法是不可被打断的，即调用线程的<code>interrupt</code>方法不起作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(ReentrantLockTest::testLockUnInterruptibly);</span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(ReentrantLockTest::testLockUnInterruptibly);</span><br><span class="line">        thread2.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testLockUnInterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 不可以被打断</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始工作&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p><img src="/images/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%8F%AF%E8%A2%AB%E6%89%93%E6%96%AD.png"></p>
<p>thread2(Thread-1)依旧在继续等待获取锁，没有被打断。</p>
<p>ReentrantLock提供了可打断获取锁的方法<code>lockInterruptibly</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(ReentrantLockTest::testLockInterruptibly);</span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(ReentrantLockTest::testLockInterruptibly);</span><br><span class="line">        thread2.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testLockInterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lockInterruptibly(); <span class="comment">// 可以被打断</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始工作&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%A2%AB%E6%89%93%E6%96%AD.png"></p>
<p>thread2在等待获取锁时被打断，抛出<code>InterruptedException</code>异常。</p>
<p>ReentrantLock的<code>tryLock</code>方法用于尝试获取锁，返回boolean类型，表示获取锁成功与否：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(ReentrantLockTest::testTryLock, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(ReentrantLockTest::testTryLock, <span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始工作&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;没有获取到锁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">thread1开始工作</span><br><span class="line">thread2没有获取到锁</span><br></pre></td></tr></table></figure>

<p>thread1抢到锁后进入死循环，一直不释放锁。thread2尝试获取锁失败后直接放弃。</p>
<p><code>tryLock</code>的重载方法<code>tryLock(long timeout, TimeUnit unit)</code>可以设置尝试获取锁的时间范围，超过这个时间没有获取到锁则返回false。</p>
<p>ReentrantLock一些别的方法：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>getQueueLength()</code></td>
<td align="left">等待获取锁线程数量</td>
</tr>
<tr>
<td align="left"><code>hasQueuedThreads()</code></td>
<td align="left">是否有在等待获取锁的线程</td>
</tr>
<tr>
<td align="left"><code>hasQueuedThread(Thread thread)</code></td>
<td align="left">等待获取锁的线程队列里是包含指定的线程</td>
</tr>
<tr>
<td align="left"><code>isLocked</code></td>
<td align="left">当前锁是否被任意一个线程获取到了</td>
</tr>
</tbody></table>
<h2 id="Spin-Lock"><a href="#Spin-Lock" class="headerlink" title="Spin Lock"></a>Spin Lock</h2><p>JUC中并没有自旋锁对应的类，而所谓的自旋锁就是：尝试获取锁的线程不会马上阻塞，而是采用循环的方式去尝试获取锁。这种方式的好处是可以减少线程上下文切换的消耗，缺点是循环会消耗CPU资源。</p>
<p>我们可以利用CAS实现一个自旋锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AtomicReference&lt;Thread&gt; reference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot;尝试获取锁&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!reference.compareAndSet(<span class="keyword">null</span>, thread)) &#123;</span><br><span class="line">            <span class="comment">// 自旋锁就是利用CAS思想制造循环，block住代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot;获取到了锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        reference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpinLock lock = <span class="keyword">new</span> SpinLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;做某事...&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;做某事...&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出结果：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">线程<span class="number">1</span>尝试获取锁</span><br><span class="line">线程<span class="number">1</span>获取到了锁</span><br><span class="line">线程<span class="number">1</span>做某事...</span><br><span class="line">线程<span class="number">2</span>尝试获取锁</span><br><span class="line">线程<span class="number">1</span>释放锁</span><br><span class="line">线程<span class="number">2</span>获取到了锁</span><br><span class="line">线程<span class="number">2</span>做某事...</span><br><span class="line">线程<span class="number">2</span>释放锁</span><br></pre></td></tr></table></figure>

<h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p>ReadWriteLock为读写锁。ReentrantLock为排他锁，同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p>
<p>简而言之，ReadWriteLock包含读写锁，遵循以下规则：</p>
<ul>
<li>写的时候不能读</li>
<li>写的时候不能写</li>
<li>读的时候不能写</li>
<li>读的时候可以读</li>
</ul>
<p>ReadWriteLock为接口，我们使用它的实现类ReentrantReadWriteLock创建读写锁实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock(<span class="keyword">true</span>);</span><br><span class="line">ReentrantReadWriteLock.ReadLock readLock = lock.readLock();</span><br><span class="line">ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();</span><br></pre></td></tr></table></figure>

<p>使用读写锁创建一个读写的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 读锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.ReadLock readLock = lock.readLock();</span><br><span class="line">    <span class="comment">// 写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();</span><br><span class="line">    <span class="comment">// 存放数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Long&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;writer&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;reader&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeLock.lock(); <span class="comment">// 写锁</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">long</span> value = System.currentTimeMillis();</span><br><span class="line">            data.add(value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入value: &quot;</span> + value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            readLock.lock(); <span class="comment">// 获取读锁</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            String value = data.stream().map(String::valueOf).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读取data: &quot;</span> + value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<p><img src="/images/%E8%AF%BB%E5%86%99%E9%94%81%E6%B5%8B%E8%AF%95.gif"></p>
<p>ReentrantReadWriteLock还包含了一些别的实用方法：</p>
<p><img src="/images/ReentrantReadWriteLock%E5%88%AB%E7%9A%84%E6%96%B9%E6%B3%95.png"></p>
<h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p>JDK8 新增了一个锁StampedLock，它是对ReadWriteLock的改进。</p>
<p>使用ReadWriteLock的时候，当读线程数量远大于写线程数量的时候就会出现“写饥饿”现象。因为锁大概率都被读线程抢走了，写线程很难抢到锁，这将使得读写效率非常低下。</p>
<p>JDK8的StampedLock就是为了解决这个问题而设计的，StampedLock包含<strong>乐观锁</strong>和<strong>悲观锁</strong>：</p>
<ul>
<li>乐观锁：每次去拿数据的时候，并不获取锁对象，而是判断标记位（stamp）是否有被修改，如果有修改就再去读一次。</li>
<li>悲观锁：每次拿数据的时候都去获取锁。</li>
</ul>
<p>通过乐观锁，当写线程没有写数据的时候，标志位stamp并没有改变，所以即使有再多的读线程在读取数据，它们都可以直接去读数据，而无需获取锁，这就不会使得写线程抢不到锁了。</p>
<p>简而言之，stamp类似一个时间戳的作用，每次写的时候对其+1来改变被操作对象的stamp值。</p>
<p>下面通过一个例子来模拟写饥饿的情况：创建20个线程，其中19个线程用于读数据，1个线程用于写数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StampedLock lock = <span class="keyword">new</span> StampedLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Long&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Runnable read = StampedLockTest::read;</span><br><span class="line">        Runnable write = StampedLockTest::write;</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">19</span>).forEach(i -&gt; executorService.submit(read));</span><br><span class="line">        executorService.submit(write);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped = lock.readLock(); <span class="comment">// 获取悲观锁，阻塞写线程</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            String collect = data.stream().map(String::valueOf).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; read value: &quot;</span> + collect);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockRead(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped = lock.writeLock();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">long</span> value = System.currentTimeMillis();</span><br><span class="line">            data.add(value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; write value: &quot;</span> + value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockWrite(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子通过StampedLock调用<code>writeLock</code>、<code>unlockWrite</code>、<code>readLock</code>和<code>unlockRead</code>的时候都会导致StampedLock的stamp值的变化，即每次+1，直到加到最大值，然后从0重新开始。</p>
<p>上面程序运行结果如下：</p>
<p><img src="/images/StampLock%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>
<p>可以看到写线程最后才抢到锁并写入数据。</p>
<p>我们通过乐观锁来改善这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StampedLock lock = <span class="keyword">new</span> StampedLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Long&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Runnable read = StampedLockTest2::read;</span><br><span class="line">        Runnable write = StampedLockTest2::write;</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">19</span>).forEach(i -&gt; executorService.submit(read));</span><br><span class="line">        executorService.submit(write);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped = lock.tryOptimisticRead(); <span class="comment">// 获取乐观锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接读取值</span></span><br><span class="line">        String collect = data.stream().map(String::valueOf).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果戳被改变，方法返回false，说明stamped被修改过了（被write方法修改过了，有新的数据写入），</span></span><br><span class="line">        <span class="comment">// 那么重新获取锁并去读取值，否则直接使用上面读取的值。</span></span><br><span class="line">        <span class="keyword">if</span> (!lock.validate(stamped)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stamped = lock.readLock();</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                collect = data.stream().map(String::valueOf).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlockRead(stamped);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; read value: &quot;</span> + collect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped = lock.writeLock();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">long</span> value = System.currentTimeMillis();</span><br><span class="line">            data.add(value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; write value: &quot;</span> + value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockWrite(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们重点关注<code>read</code>方法。<code>read</code>方法一开始通过调用StampedLock的<code>tryOptimisticRead</code>方法来获取标志位stamp，获取乐观锁并不会真正的去获取锁（所以不会阻塞写操作），然后直接去读数据。接着通过StampedLock的<code>validate</code>方法判断标志位stamp是否被修改了（<code>write</code>方法里会修改标志位的值），如果方法返回true，则说明数据没有被修改过，直接使用前面读取的数据即可；否则需要去获取锁重新去读数据，阻止写操作。</p>
<p>上面例子运行结果如下：</p>
<p><img src="/images/StampLock%E4%B9%90%E8%A7%82%E9%94%81.png"></p>
<p>可以看到，写操作一开始就抢到了锁，并写入了数据。</p>
<p><strong>简而言之，StampedLock解决了在没有新数据写入时，由于过多读操作抢夺锁而使得写操作一直获取不到锁无法写入新数据的问题。</strong></p>
<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>Condition接口提供了类似Object的<code>wait</code>、<code>notify</code>和<code>notifyAll</code>方法，与Lock配合可以实现生产/消费模式，但是这两者在使用方式以及功能特性上还是有差别的。</p>
<p>使用Codition实现一个生产消费的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="comment">// 初始数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 是否被消费</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> consumed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                produceData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;producer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                consumeData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;consumer&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">produceData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">            <span class="keyword">while</span> (!consumed) &#123; <span class="comment">// 判断数据是否被消费</span></span><br><span class="line">                condition.await(); <span class="comment">// 如果没有被消费则进入等待</span></span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            data++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; produce data = &quot;</span> + data);</span><br><span class="line">            consumed = <span class="keyword">false</span>; <span class="comment">// 生产完数据将消费标识置为false</span></span><br><span class="line">            condition.signal(); <span class="comment">// 解除await，用于通知消费者可以开始消费了</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumeData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">            <span class="keyword">while</span> (consumed) &#123; <span class="comment">// 判断数据是否被消费</span></span><br><span class="line">                condition.await(); <span class="comment">// 如果被消费了则进入等待</span></span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.MICROSECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; consume data = &quot;</span> + data);</span><br><span class="line">            consumed = <span class="keyword">true</span>; <span class="comment">// 消费完将消费标识置为true</span></span><br><span class="line">            condition.signal(); <span class="comment">// 解除await，用于通知生产者可以开始生产了</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中，通过<code>consumed</code>判断数据是否被消费。<code>produceData</code>方法在获取锁后，判断数据是否被消费，如果没有被消费，则调用Condition的<code>await</code>方法进入等待，直到Condition对象的<code>signal</code>方法被调用；<code>consumeData</code>方法逻辑和<code>produceData</code>一致。</p>
<p>Condition核心用法就是通过<code>await</code>方法让线程进入阻塞等待状态，通过<code>signal</code>解除阻塞状态。上面的例子运行效果如下所示：</p>
<p><img src="/images/Condition%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.gif"></p>
<p>对应上面的例子可以思考下面三个问题：</p>
<ol>
<li>是否可以只使用Lock而不使用Condition？</li>
<li>生产者抢到了锁进入await，并没有释放锁，为什么消费者可以获得锁？</li>
<li>是否可以只使用Condition不使用Lock？</li>
</ol>
<p>对于第一个问题：<strong>是否可以只使用Lock而不使用Condition？</strong></p>
<p>虽然可以定义公平的ReentrantLock，但是实际上并不能确保100%公平，只是尽可能的公平。生产消费模型必须为生产者生成完了数据通知消费者消费，消费者消费完了通知生产者生产，这是环环相扣的，不允许出现别的情况。</p>
<p>对于第二个问题：<strong>生产者抢到了锁进入await，并没有释放锁，为什么消费者可以获得锁？</strong></p>
<p>假如一开始<code>produceData</code>方法先通过<code>lock.lock()</code>获取到了锁，consumed初始值为false，所以接着方法会调用<code>condition.await()</code>进入阻塞等待。<code>await</code>方法会使得当前线程<strong>释放锁对象</strong>，然后进入休眠状态，直到发生下面三种情况之一才会被解除休眠：</p>
<ol>
<li>Condition的<code>signal</code>方法被调用；</li>
<li>Condition的<code>signalAll</code>方法被调用；</li>
<li>其他线程调用了当前线程的<code>interrupt</code>方法</li>
</ol>
<p>对于第三个问题：<strong>是否可以只使用Condition不使用Lock？</strong></p>
<p>既然<code>await</code>会使得线程进入阻塞等待状态，那么是否可以直接使用<code>await</code>，而不使用Lock呢？改造上面的例子，去掉获取和释放锁的相关代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 公平锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="comment">// 初始数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 是否被消费</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> consumed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                produceData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                consumeData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">produceData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!consumed) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            data++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; produce data = &quot;</span> + data);</span><br><span class="line">            consumed = <span class="keyword">false</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumeData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (consumed) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.MICROSECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; consume data = &quot;</span> + data);</span><br><span class="line">            consumed = <span class="keyword">true</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E4%B8%8D%E4%BD%BF%E7%94%A8Lock%E7%9A%84Condition.png"></p>
<p>可以看到，程序抛出<code>IllegalMonitorStateException</code>异常，所以Condition必须配合Lock使用。</p>
<p>正如前面说的，Condition的功能类似于Object对象的<code>wait</code>和<code>notify</code>方法，下面我们使用Object对象的<code>wait</code>和<code>notify</code>方法实现一个类似上面生产消费的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> used = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Object MONITOR = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                produceData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                consumeData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">produceData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (MONITOR) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!used) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    MONITOR.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            data++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 生产data = &quot;</span> + data);</span><br><span class="line">            used = <span class="keyword">false</span>;</span><br><span class="line">            MONITOR.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumeData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (MONITOR) &#123;</span><br><span class="line">            <span class="keyword">while</span> (used) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    MONITOR.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 消费data = &quot;</span> + data);</span><br><span class="line">            used = <span class="keyword">true</span>;</span><br><span class="line">            MONITOR.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下所示：</p>
<p><img src="/images/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85.gif"></p>
<p><code>Condition</code>还可以绑定多个条件，并唤醒指定的线程，举个三个线程循环干活的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Loop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String value = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 条件1</span></span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="comment">// 条件2</span></span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="comment">// 条件3</span></span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (!value.equals(<span class="string">&quot;a&quot;</span>)) &#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; print a&quot;</span>);</span><br><span class="line">            value = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (!value.equals(<span class="string">&quot;b&quot;</span>)) &#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; print b&quot;</span>);</span><br><span class="line">            value = <span class="string">&quot;c&quot;</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (!value.equals(<span class="string">&quot;c&quot;</span>)) &#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; print c&quot;</span>);</span><br><span class="line">            value = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Loop loop = <span class="keyword">new</span> Loop();</span><br><span class="line">        IntStream.rangeClosed(<span class="number">0</span>, <span class="number">2</span>).forEach(i -&gt; <span class="keyword">new</span> Thread(loop::printA, <span class="string">&quot;线程A&quot;</span>).start());</span><br><span class="line">        IntStream.rangeClosed(<span class="number">0</span>, <span class="number">2</span>).forEach(i -&gt; <span class="keyword">new</span> Thread(loop::printB, <span class="string">&quot;线程B&quot;</span>).start());</span><br><span class="line">        IntStream.rangeClosed(<span class="number">0</span>, <span class="number">2</span>).forEach(i -&gt; <span class="keyword">new</span> Thread(loop::printC, <span class="string">&quot;线程C&quot;</span>).start());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">线程A <span class="builtin-name">print</span> a</span><br><span class="line">线程B <span class="builtin-name">print</span> b</span><br><span class="line">线程C <span class="builtin-name">print</span> c</span><br><span class="line">线程A <span class="builtin-name">print</span> a</span><br><span class="line">线程B <span class="builtin-name">print</span> b</span><br><span class="line">线程C <span class="builtin-name">print</span> c</span><br><span class="line">线程A <span class="builtin-name">print</span> a</span><br><span class="line">线程B <span class="builtin-name">print</span> b</span><br><span class="line">线程C <span class="builtin-name">print</span> c</span><br></pre></td></tr></table></figure>

<h2 id="synchronized和Lock区别"><a href="#synchronized和Lock区别" class="headerlink" title="synchronized和Lock区别"></a>synchronized和Lock区别</h2><p><strong>1. 构成不一样</strong></p>
<p><code>synchronized</code>是Java关键字，属于JVM层面，底层是由monitorenter和monitorexit指令完成（查看字节码证实）：</p>
<p><img src="/images/synchronized%E5%BA%95%E5%B1%82.png"></p>
<p><strong>2.使用方式不同</strong></p>
<p><code>synchronized</code>不需要我们手动释放锁，当<code>synchronized</code>代码执行完后，当前线程会自动释放锁；</p>
<p><code>ReentrantLock</code>需要手动释放锁，不然会造成死锁。</p>
<p><strong>3.可中断性</strong></p>
<p><code>synchronized</code>是不可中断的，除非同步方法内抛出异常或者程序正常运行完成； <code>ReentrantLock</code>是可以中断的，比如<code>lockInterruptibly()</code>方法。</p>
<p><strong>4.公平否</strong></p>
<p><code>synchronized</code>是非公平锁；</p>
<p><code>ReentrantLock</code>可以通过构造方法<code>ReentrantLock(boolean fair)</code>设置公平与否。</p>
<p><strong>5.灵活性</strong></p>
<p><code>synchronized</code>不可以设置条件；</p>
<p><code>ReentrantLock</code>可以通过condition绑定多条件，精确唤醒指定线程。</p>
]]></content>
      <tags>
        <tag>concurrency, lock</tag>
      </tags>
  </entry>
  <entry>
    <title>Java HashMap底层实现原理</title>
    <url>/2020/09/04/Java-HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>Java HashMap底层数据结构、方法实现原理等，基于JDK 1.8</p>
<span id="more"></span>

<h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><p>Java HashMap底层采用哈希表结构（数组+链表、JDK1.8后为数组+链表或红黑树）实现，结合了数组和链表的优点：</p>
<ol>
<li>数组优点：通过数组下标可以快速实现对数组元素的访问，效率极高；</li>
<li>链表优点：插入或删除数据不需要移动元素，只需修改节点引用，效率极高。</li>
</ol>
<p>HashMap图示如下所示：</p>
<p><img src="/images/HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p>
<p>HashMap内部使用数组存储数据，数组中的每个元素类型为<code>Node&lt;K,V&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Node包含了四个字段：hash、key、value、next，其中next表示链表的下一个节点。</p>
<p>HashMap通过<code>hash</code>方法计算key的哈希码，然后通过<code>(n-1)&amp;hash</code>公式（n为数组长度）得到key在数组中存放的下标。当两个key在数组中存放的下标一致时，数据将以链表的方式存储（哈希冲突，哈希碰撞）。我们知道，在链表中查找数据必须从第一个元素开始一层一层往下找，直到找到为止，时间复杂度为O(N)，所以当链表长度越来越长时，HashMap的效率越来越低。</p>
<p>为了解决这个问题，JDK1.8开始采用数组+链表+红黑树的结构来实现HashMap。当链表中的元素超过8个（<strong>TREEIFY_THRESHOLD</strong>）并且数组长度大于64（<strong>MIN_TREEIFY_CAPACITY</strong>）时，会将链表转换为红黑树，转换后数据查询时间复杂度为O(logN)。</p>
<p>红黑树的节点使用TreeNode表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap包含几个重要的变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组默认的初始化长度16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组最大容量，2的30次幂，即1073741824</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认加载因子值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表转换为红黑树的长度阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树转换为链表的长度阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表转换为红黑树时，数组容量必须大于等于64</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap里键值对个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容阈值，计算方法为 数组容量*加载因子</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap使用数组存放数据，数组元素类型为Node&lt;K,V&gt;</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），直接抛出ConcurrentModificationException异常</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>

<p>上面这些字段在下面源码解析的时候尤为重要，其中需要着重讨论的是加载因子是什么，为什么默认值为0.75f。</p>
<p>加载因子也叫扩容因子，用于决定HashMap数组何时进行扩容。比如数组容量为16，加载因子为0.75，那么扩容阈值为<code>16*0.75=12</code>，即HashMap数据量大于等于12时，数组就会进行扩容。我们都知道，数组容量的大小在创建的时候就确定了，所谓的扩容指的是重新创建一个指定容量的数组，然后将旧值复制到新的数组里。扩容这个过程非常耗时，会影响程序性能。所以加载因子是基于容量和性能之间平衡的结果：</p>
<ul>
<li>当加载因子过大时，扩容阈值也变大，也就是说扩容的门槛提高了，这样容量的占用就会降低。但这时哈希碰撞的几率就会增加，效率下降；</li>
<li>当加载因子过小时，扩容阈值变小，扩容门槛降低，容量占用变大。这时候哈希碰撞的几率下降，效率提高。</li>
</ul>
<p>可以看到容量占用和性能是此消彼长的关系，它们的平衡点由加载因子决定，0.75是一个即兼顾容量又兼顾性能的经验值。</p>
<p>此外用于存储数据的table字段使用transient修饰，通过transient修饰的字段在序列化的时候将被排除在外，那么HashMap在序列化后进行反序列化时，是如何恢复数据的呢？HashMap通过自定义的readObject/writeObject方法自定义序列化和反序列化操作。这样做主要是出于以下两点考虑：</p>
<ol>
<li>table一般不会存满，即容量大于实际键值对个数，序列化table未使用的部分不仅浪费时间也浪费空间；</li>
<li>key对应的类型如果没有重写hashCode方法，那么它将调用Object的hashCode方法，该方法为native方法，在不同JVM下实现可能不同；换句话说，同一个键值对在不同的JVM环境下，在table中存储的位置可能不同，那么在反序列化table操作时可能会出错。</li>
</ol>
<h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><p>put方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put方法通过hash函数计算key对应的哈希值，hash函数源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果key为null，返回0，不为null，则通过<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>公式计算得到哈希值。该公式通过hashCode的高16位异或低16位得到哈希值，主要从性能、哈希碰撞角度考虑，减少系统开销，不会造成因为高位没有参与下标计算从而引起的碰撞。</p>
<p>得到key对应的哈希值后，再调用<code>putVal(hash(key), key, value, false, true)</code>方法插入元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果数组(哈希表)为null或者长度为0，则进行数组初始化操作</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 根据key的哈希值计算出数据插入数组的下标位置，公式为(n-1)&amp;hash</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果该下标位置还没有元素，则直接创建Node对象，并插入</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果目标位置key已经存在，则直接覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果目标位置key不存在，并且节点为红黑树，则插入红黑树中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则为链表结构，遍历链表，尾部插入</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果链表长度大于等于TREEIFY_THRESHOLD，则考虑转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash); <span class="comment">// 转换为红黑树操作，内部还会判断数组长度是否小于MIN_TREEIFY_CAPACITY，如果是的话不转换</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果链表中已经存在该key的话，直接覆盖替换</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">// 返回被替换的值</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模数递增</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 当键值对个数大于等于扩容阈值的时候，进行扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put操作过程总结：</p>
<ol>
<li><p>判断HashMap数组是否为空，是的话初始化数组（由此可见，在创建HashMap对象的时候并不会直接初始化数组）；</p>
</li>
<li><p>通过<code>(n-1) &amp; hash</code>计算key在数组中的存放索引；</p>
</li>
<li><p>目标索引位置为空的话，直接创建Node存储；</p>
</li>
<li><p>目标索引位置不为空的话，分下面三种情况：</p>
<p>4.1. key相同，覆盖旧值；</p>
<p>4.2. 该节点类型是红黑树的话，执行红黑树插入操作；</p>
<p>4.3. 该节点类型是链表的话，遍历到最后一个元素尾插入，如果期间有遇到key相同的，则直接覆盖。如果链表长度大于等于TREEIFY_THRESHOLD，并且数组容量大于等于MIN_TREEIFY_CAPACITY，则将链表转换为红黑树结构；</p>
</li>
<li><p>判断HashMap元素个数是否大于等于threshold，是的话，进行扩容操作。</p>
</li>
</ol>
<h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><p>get和put相比，就简单多了，下面是get操作源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 判断数组是否为空，数组长度是否大于0，目标索引位置下元素是否为空，是的话直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果目标索引位置元素就是要找的元素，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 如果目标索引位置元素的下一个节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果类型是红黑树，则从红黑树中查找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 否则就是链表，遍历链表查找目标元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h2><p>由前面的put源码分析知道，数组的初始化和扩容都是通过调用resize方法完成的，所以现在来关注下resize方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 扩容前的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 扩容前的数组的大小和阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 预定义新数组的大小和阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩容了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩大容量为当前容量的两倍，但不能超过 MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前数组没有数据，使用初始化的值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 如果初始化的值为 0，则使用默认的初始化容量，默认值为16</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新的容量等于 0</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; </span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">// 开始扩容，将新的容量赋值给 table</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 原数据不为空，将原数据复制到新 table 中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据容量循环数组，复制非空元素到新 table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果链表只有一个，则进行直接赋值</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 红黑树相关的操作</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 链表复制，JDK 1.8 扩容优化部分</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引 + oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 将原索引放到哈希桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将原索引 + oldCap 放到哈希桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.8在扩容时通过高位运算<code>e.hash &amp; oldCap</code>结果是否为0来确定元素是否需要移动，主要有如下两种情况：</p>
<p>情况一：</p>
<p>扩容前oldCap=16，hash=5，<code>(n-1)&amp;hash=15&amp;5=5</code>，<code>hash&amp;oldCap=5&amp;16=0</code>；</p>
<p>扩容后newCap=32，hash=5，<code>(n-1)&amp;hash=31&amp;5=5</code>，<code>hash&amp;oldCap=5&amp;16=0</code>。</p>
<p>这种情况下，扩容后元素索引位置不变，并且hash&amp;oldCap==0。</p>
<p>情况二：</p>
<p>扩容前oldCap=16，hash=18，<code>(n-1)&amp;hash=15&amp;18=2</code>，<code>hash&amp;oldCap=18&amp;16=16</code>；</p>
<p>扩容后newCap=32，hash=18，<code>(n-1)&amp;hash=31&amp;18=18</code>，<code>hash&amp;oldCap=18&amp;16=16</code>。</p>
<p>这种情况下，扩容后元素索引位置为18，即旧索引2加16(oldCap)，并且hash&amp;oldCap!=0。</p>
<h2 id="遍历原理"><a href="#遍历原理" class="headerlink" title="遍历原理"></a>遍历原理</h2><p>通常使用下面两种方式遍历HashMap：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;9&quot;</span>, <span class="string">&quot;i&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;Map.Entry&lt;String, Object&gt;&gt; entries = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : entries) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-------&quot;</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line"><span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">    System.out.println(key + <span class="string">&quot;: &quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight ldif"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>: a</span><br><span class="line"><span class="attribute">2</span>: b</span><br><span class="line"><span class="attribute">3</span>: c</span><br><span class="line"><span class="attribute">4</span>: d</span><br><span class="line"><span class="attribute">9</span>: i</span><br><span class="line"><span class="literal">-------</span></span><br><span class="line"><span class="attribute">1</span>: a</span><br><span class="line"><span class="attribute">2</span>: b</span><br><span class="line"><span class="attribute">3</span>: c</span><br><span class="line"><span class="attribute">4</span>: d</span><br><span class="line"><span class="attribute">9</span>: i</span><br></pre></td></tr></table></figure>

<p>通过前面对put源码的分析，可知HashMap是无序的，输出元素顺序和插入元素顺序一般都不一样。但是多次运行上面的程序你会发现，每次遍历的顺序都是一样的。那么遍历的原理是什么，内部是如何操作的？</p>
<p>通过entrySet或者keySet遍历，它们的内部原理是一样的，这里以entrySet为例。</p>
<p>通过查看代码对应的class文件，会发现下面这段代码实际会被转换为iterator遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String, Object&gt;&gt; entries = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : entries) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增强for循环会被编译为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Entry&lt;String, Object&gt;&gt; entries = map.entrySet();</span><br><span class="line">Iterator var3 = entries.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">    Entry&lt;String, Object&gt; entry = (Entry)var3.next();</span><br><span class="line">    System.out.println((String)entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看entrySet，iterator，hasNext，next方法的源码就可以清楚的了解到HashMap遍历原理:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="comment">// entrySet一开始为null，通过new EntrySet()创建</span></span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="comment">// EntrySet内部包含迭代器方法，方法内部通过new EntryIterator()创建Entry迭代器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    ...... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EntryIterator继承自HashIterator，调用EntryIterator的hasNext方法实际调用的是</span></span><br><span class="line"><span class="comment">// 父类HashIterator的hashNext方法，调用EntryIterator的next方法，方法内部调用的是父类HashIterator</span></span><br><span class="line"><span class="comment">// 的nextNode方法，所以我们主要关注HashIterator的源码</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// 下一个节点</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// 当前节点</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;  <span class="comment">// 期待的模数值，用于快速失败</span></span><br><span class="line">    <span class="keyword">int</span> index;             <span class="comment">// 当前遍历的table index</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        <span class="comment">// 将当前模数值赋值给期待的模数值，所以在遍历的时候，别的线程调用了当前hashMap实例的</span></span><br><span class="line">        <span class="comment">// 增删改方法，模数值会改变，那么expectedModCount和modCount就不相等了，遍历操作直接</span></span><br><span class="line">        <span class="comment">// 抛出ConcurrentModificationException</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从hashMap数组头部开始遍历</span></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="comment">// 从数组头部开始找，index递增，当index位置的节点不为空时，将其赋值给next</span></span><br><span class="line">            <span class="comment">// 也就是说，在创建hashMap迭代器的时候，内部就已经找到了hashMap数组中第一个非空节点了</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 逻辑很简单，就是判断next是否为空</span></span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="comment">// 模数判断</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 如果next为空了，还调用nextNode方法的话，将抛出NoSuchElementException异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="comment">// 这段逻辑也很简单，主要包含如下两种情况：</span></span><br><span class="line">        <span class="comment">// 1. 如果当前节点的next节点为空的话，说明该节点无需进行链表遍历了（就一个节点或者已经到了链表的末尾），那么进行do while循环，直到找到hashMap数组中下一个不为空的节点</span></span><br><span class="line">        <span class="comment">// 2. 如果当前节点的next节点不为空的话，说明该位置存在链表，那么外界在循环调用iterator的next方法时，实际就是不断调用nextNode方法遍历链表操作</span></span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，遍历HashMap的过程就是从头查找HashMap数组中的不为空的结点，如果该结点下存在链表，则遍历该链表，遍历完链表后再找HashMap数组中下一个不为空的结点，以此进行下去直到遍历结束。</p>
<p>那么，如果某个结点下是红黑树结构的话，怎么遍历？其实当链表转换为红黑树时，链表节点里包含的next字段信息是保留的，所以依旧可以通过红黑树节点中的next字段找到下一个节点。</p>
<h2 id="和JDK1-7的区别"><a href="#和JDK1-7的区别" class="headerlink" title="和JDK1.7的区别"></a>和JDK1.7的区别</h2><h3 id="hash计算规则不同"><a href="#hash计算规则不同" class="headerlink" title="hash计算规则不同"></a>hash计算规则不同</h3><p>JDK1.7 hash计算规则为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于JDK1.8的hash方法，JDK1.7的hash方法的性能会稍差一点</p>
<h3 id="put操作不同"><a href="#put操作不同" class="headerlink" title="put操作不同"></a>put操作不同</h3><p>JDK1.7并没有使用红黑树，如果哈希冲突后，都用链表解决。区别于JDK1.8的尾部插入，JDK1.7采用头部插入的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;   </span><br><span class="line">    <span class="comment">// 键为null，将元素放置到table数组的0下标处</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value); </span><br><span class="line">    <span class="comment">// 计算hash和数组下标索引位置</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());  </span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);  </span><br><span class="line">    <span class="comment">// 遍历链表，当key一致时，说明该key已经存在，使用新值替换旧值并返回</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;  </span><br><span class="line">        Object k;  </span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </span><br><span class="line">            V oldValue = e.value;  </span><br><span class="line">            e.value = value;  </span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);  </span><br><span class="line">            <span class="keyword">return</span> oldValue;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 插入链表</span></span><br><span class="line">    addEntry(hash, key, value, i);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 一样的，新旧值替换</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            V oldValue = e.value;  </span><br><span class="line">            e.value = value;  </span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);  </span><br><span class="line">            <span class="keyword">return</span> oldValue;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    modCount++;  </span><br><span class="line">    <span class="comment">// 插入到数组下标为0位置</span></span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新值头部插入，原先头部变成新的头部元素的next</span></span><br><span class="line">    Entry&lt;K, V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K, V&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">// 计数，扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容操作不同"><a href="#扩容操作不同" class="headerlink" title="扩容操作不同"></a>扩容操作不同</h3><p>JDK1.8在扩容时通过高位运算<code>e.hash &amp; oldCap</code>结果是否为0来确定元素是否需要移动，JDK1.7重新计算了每个元素的哈希值，按旧链表的正序遍历链表、在新链表的头部依次插入，即在转移数据、扩容后，容易出现链表逆序的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时若多线程并发执行resize操作，容易出现环形链表，从而在获取数据、遍历链表时造成死循环</p>
]]></content>
      <tags>
        <tag>HashMap, 原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对称加密算法</title>
    <url>/2020/08/04/Java%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>对称加密算法加密和解密使用的是同一份秘钥，解密是加密的逆运算。对称加密算法加密速度快，密文可逆，一旦秘钥文件泄露，就会导致原始数据暴露。对称加密的结果一般使用Base64算法编码，便于阅读和传输。JDK8支持的对称加密算法主要有DES、DESede、AES、Blowfish，以及RC2和RC4等。不同的算法秘钥长度不同，秘钥长度越长，加密安全性越高。</p>
<span id="more"></span>

<h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><p>DES（Data Encryption Standard，数据加密标准）算法是对称加密算法领域中的典型算法，DES算法秘钥较短，以现在计算机的计算能力，DES算法加密的数据在24小时内可能被破解。所以DES算法已经被淘汰，建议使用AES算法，不过这里还是简单了解下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String value = <span class="string">&quot;Doug Wilson&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;待加密值：&quot;</span> + value);</span><br><span class="line">        <span class="comment">// 加密算法</span></span><br><span class="line">        String algorithm = <span class="string">&quot;DES&quot;</span>;</span><br><span class="line">        <span class="comment">// 转换模式</span></span><br><span class="line">        String transformation = <span class="string">&quot;DES&quot;</span>;</span><br><span class="line">        <span class="comment">// --- 生成秘钥 ---</span></span><br><span class="line">        <span class="comment">// 实例化秘钥生成器</span></span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化秘钥长度</span></span><br><span class="line">        keyGenerator.init(<span class="number">56</span>);</span><br><span class="line">        <span class="comment">// 生成秘钥</span></span><br><span class="line">        SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">        <span class="comment">// 实例化DES秘钥材料</span></span><br><span class="line">        DESKeySpec desKeySpec = <span class="keyword">new</span> DESKeySpec(secretKey.getEncoded());</span><br><span class="line">        <span class="comment">// 实例化秘钥工厂</span></span><br><span class="line">        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 生成DES秘钥</span></span><br><span class="line">        SecretKey desSecretKey = secretKeyFactory.generateSecret(desKeySpec);</span><br><span class="line">        System.out.println(<span class="string">&quot;DES秘钥：&quot;</span> + Base64.getEncoder().encodeToString(desSecretKey.getEncoded()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化密码对象</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(transformation);</span><br><span class="line">        <span class="comment">// 设置模式（ENCRYPT_MODE：加密模式；DECRYPT_MODE：解密模式）和指定秘钥</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, desSecretKey);</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] encrypt = cipher.doFinal(value.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;DES加密结果：&quot;</span> + Base64.getEncoder().encodeToString(encrypt));</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        <span class="comment">// 设置为解密模式</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, desSecretKey);</span><br><span class="line">        <span class="keyword">byte</span>[] decrypt = cipher.doFinal(encrypt);</span><br><span class="line">        System.out.println(<span class="string">&quot;DES解密结果：&quot;</span> + <span class="keyword">new</span> String(decrypt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面步骤看着挺多，其实可以总结为如下几步：</p>
<ol>
<li><p>生成加密秘钥；</p>
<p>1.1. 通过KeyGenerator生成一个指定位数的秘钥；</p>
<p>1.2. 通过上面生成的秘钥实例化算法对应的秘钥材料KeySpec；</p>
<p>1.3. 使用秘钥材料通过秘钥工厂SecretKeyFactory生成算法秘钥SecretKey。</p>
</li>
<li><p>通过转换模式实例化Cipher；</p>
</li>
<li><p>指定Cipher模式和秘钥，进行加解密操作。</p>
</li>
</ol>
<p>运行结果如下：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">待加密值：Doug Wilson</span><br><span class="line"><span class="keyword">DES</span>秘钥：LO/CCEC8y8E=</span><br><span class="line"><span class="keyword">DES</span>加密结果：hRZdN6f+6yj/lhPWUPsayA==</span><br><span class="line"><span class="keyword">DES</span>解密结果：Doug Wilson</span><br></pre></td></tr></table></figure>

<p>特别注意：<strong>如果在生成秘钥的时候，不指定为56位，则会抛出java.security.InvalidParameterException: Wrong keysize: must be equal to 56异常</strong></p>
<h2 id="DESede"><a href="#DESede" class="headerlink" title="DESede"></a>DESede</h2><p>作为DES算法的一种改良，DESede算法（也称为3DES，三重DES）针对其秘钥长度偏短和迭代次数偏少等问题做了相应改进，提高了安全强度，但同时也造成处理速度较慢、秘钥计算时间加长、加密效率不高的问题。所以这里还是简单了解下，实际还是推荐用AES。</p>
<p>JDK8支持112位或168位长度的DESede秘钥：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String value = <span class="string">&quot;Doug Wilson&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;待加密值：&quot;</span> + value);</span><br><span class="line">        <span class="comment">// 加密算法</span></span><br><span class="line">        String algorithm = <span class="string">&quot;DESede&quot;</span>;</span><br><span class="line">        <span class="comment">// 转换模式</span></span><br><span class="line">        String transformation = <span class="string">&quot;DESede&quot;</span>;</span><br><span class="line">        <span class="comment">// --- 生成秘钥 ---</span></span><br><span class="line">        <span class="comment">// 实例化秘钥生成器</span></span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化秘钥长度</span></span><br><span class="line">        keyGenerator.init(<span class="number">112</span>);</span><br><span class="line">        <span class="comment">// 生成秘钥</span></span><br><span class="line">        SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">        <span class="comment">// 实例化DESede秘钥材料</span></span><br><span class="line">        DESedeKeySpec desKeySpec = <span class="keyword">new</span> DESedeKeySpec(secretKey.getEncoded());</span><br><span class="line">        <span class="comment">// 实例化秘钥工厂</span></span><br><span class="line">        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 生成DES秘钥</span></span><br><span class="line">        SecretKey desSecretKey = secretKeyFactory.generateSecret(desKeySpec);</span><br><span class="line">        System.out.println(<span class="string">&quot;DESede秘钥：&quot;</span> + Base64.getEncoder().encodeToString(desSecretKey.getEncoded()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化密码对象</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(transformation);</span><br><span class="line">        <span class="comment">// 设置模式（ENCRYPT_MODE：加密模式；DECRYPT_MODE：解密模式）和指定秘钥</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, desSecretKey);</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] encrypt = cipher.doFinal(value.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;DESede加密结果：&quot;</span> + Base64.getEncoder().encodeToString(encrypt));</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        <span class="comment">// 设置为解密模式</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, desSecretKey);</span><br><span class="line">        <span class="keyword">byte</span>[] decrypt = cipher.doFinal(encrypt);</span><br><span class="line">        System.out.println(<span class="string">&quot;DESede解密结果：&quot;</span> + <span class="keyword">new</span> String(decrypt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过程和DES一致，区别仅在于使用的加密算法为DESede，秘钥长度指定为112，秘钥材料对象为DESedeKeySpec类。</p>
<p>上面程序输出如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">待加密值：Doug Wilson</span><br><span class="line">DESede秘钥：1fFb+F1wboVGGTSPNIBJ+9XxW/hdcG6F</span><br><span class="line">DESede加密结果：WVg9w6exyRREqY1vNyRI+<span class="attribute">Q</span>==</span><br><span class="line">DESede解密结果：Doug Wilson</span><br></pre></td></tr></table></figure>

<p>特别注意：<strong>如果指定不合法的秘钥长度，程序将抛出java.security.InvalidParameterException: Wrong keysize: must be equal to 112 or 168异常</strong></p>
<h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><p>AES（AdvancedEncryption Standard，高级数据加密标准）算法支持128位、192位和256位的秘钥长度，加密速度比DES和DESede都快，至今还没有被破解的报道。经过验证，目前采用的AES算法能够有效抵御已知的针对DES算法的所有攻击方法，如部分差分攻击、相关秘钥攻击等。AES算法因秘钥建立时间短、灵敏性好、内存需求低等优点，在各个领域得到广泛的研究与应用。</p>
<p>JDK8支持128位、192位和256位长度的AES秘钥：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String value = <span class="string">&quot;Doug Wilson&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;待加密值：&quot;</span> + value);</span><br><span class="line">        <span class="comment">// 加密算法</span></span><br><span class="line">        String algorithm = <span class="string">&quot;AES&quot;</span>;</span><br><span class="line">        <span class="comment">// 转换模式</span></span><br><span class="line">        String transformation = <span class="string">&quot;AES&quot;</span>;</span><br><span class="line">        <span class="comment">// --- 生成秘钥 ---</span></span><br><span class="line">        <span class="comment">// 实例化秘钥生成器</span></span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化秘钥长度</span></span><br><span class="line">        keyGenerator.init(<span class="number">256</span>);</span><br><span class="line">        <span class="comment">// 生成秘钥</span></span><br><span class="line">        SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">        <span class="comment">// 生成秘钥材料</span></span><br><span class="line">        SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), algorithm);</span><br><span class="line">        System.out.println(<span class="string">&quot;AES秘钥：&quot;</span> + Base64.getEncoder().encodeToString(secretKey.getEncoded()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化密码对象</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(transformation);</span><br><span class="line">        <span class="comment">// 设置模式（ENCRYPT_MODE：加密模式；DECRYPT_MODE：解密模式）和指定秘钥</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] encrypt = cipher.doFinal(value.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;AES加密结果：&quot;</span> + Base64.getEncoder().encodeToString(encrypt));</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        <span class="comment">// 设置为解密模式</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);</span><br><span class="line">        <span class="keyword">byte</span>[] decrypt = cipher.doFinal(encrypt);</span><br><span class="line">        System.out.println(<span class="string">&quot;AES解密结果：&quot;</span> + <span class="keyword">new</span> String(decrypt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过程和上面例子大体一致，唯一区别是使用AES算法无需指定特定类型的秘钥材料，直接用SecretKeySpec对象即可。</p>
<p>程序输出如下：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">待加密值：Doug Wilson</span><br><span class="line">AES秘钥：vMj1fnhYdIGpTfxpEeKaynG879ARZ5r2AcfBpf+<span class="attr">yoRs=</span></span><br><span class="line">AES加密结果：GCmIlqEJIBlBRw/<span class="number">474</span><span class="attr">OanQ==</span></span><br><span class="line">AES解密结果：Doug Wilson</span><br></pre></td></tr></table></figure>

<p>特别注意：<strong>如果指定不合法的秘钥长度，程序将抛出java.security.InvalidParameterException: Wrong keysize: must be equal to 128, 192 or 256异常</strong></p>
<h2 id="RC2、RC4"><a href="#RC2、RC4" class="headerlink" title="RC2、RC4"></a>RC2、RC4</h2><p>RC2和RC4算法也可以用于替换DES算法，特点是秘钥长度较为灵活，RC2和RC4的秘钥长度范围为40到1024位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String value = <span class="string">&quot;Doug Wilson&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;待加密值：&quot;</span> + value);</span><br><span class="line">        <span class="comment">// 加密算法</span></span><br><span class="line">        String algorithm = <span class="string">&quot;RC2&quot;</span>;</span><br><span class="line">        <span class="comment">// 转换模式</span></span><br><span class="line">        String transformation = <span class="string">&quot;RC2&quot;</span>;</span><br><span class="line">        <span class="comment">// --- 生成秘钥 ---</span></span><br><span class="line">        <span class="comment">// 实例化秘钥生成器</span></span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化秘钥长度</span></span><br><span class="line">        keyGenerator.init(<span class="number">666</span>);</span><br><span class="line">        <span class="comment">// 生成秘钥</span></span><br><span class="line">        SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">        <span class="comment">// 生成秘钥材料</span></span><br><span class="line">        SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), algorithm);</span><br><span class="line">        System.out.println(<span class="string">&quot;RC2秘钥：&quot;</span> + Base64.getEncoder().encodeToString(secretKey.getEncoded()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化密码对象</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(transformation);</span><br><span class="line">        <span class="comment">// 设置模式（ENCRYPT_MODE：加密模式；DECRYPT_MODE：解密模式）和指定秘钥</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] encrypt = cipher.doFinal(value.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;RC2加密结果：&quot;</span> + Base64.getEncoder().encodeToString(encrypt));</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        <span class="comment">// 设置为解密模式</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);</span><br><span class="line">        <span class="keyword">byte</span>[] decrypt = cipher.doFinal(encrypt);</span><br><span class="line">        System.out.println(<span class="string">&quot;RC2解密结果：&quot;</span> + <span class="keyword">new</span> String(decrypt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">待加密值：Doug Wilson</span><br><span class="line">RC2秘钥：<span class="regexp">//</span>wHmkfa<span class="regexp">/TpQqeard5RD8h6Gdd1YJQZbFT4pUsssRfitpz1YkhJfCN/</span>J<span class="regexp">/hjR0Q1HmVReJaSPCNDqP+GUBlvnWi7zsoKW35O6R5W/</span>R0Bgnjh/qVsu</span><br><span class="line">RC2加密结果：+XL70sqXz/myi1JRiLVbCw==</span><br><span class="line">RC2解密结果：Doug Wilson</span><br></pre></td></tr></table></figure>

<p><strong>如果指定不合法的秘钥长度，程序将抛出java.security.InvalidParameterException: Key length for RC2 must be between 40 and 1024 bits异常</strong></p>
<h2 id="Blowfish"><a href="#Blowfish" class="headerlink" title="Blowfish"></a>Blowfish</h2><p>Blowfish算法也可以用于替换DES，Blowfish算法的秘钥长度范围为32到448位，并且必须为8的倍数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String value = <span class="string">&quot;Doug Wilson&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;待加密值：&quot;</span> + value);</span><br><span class="line">        <span class="comment">// 加密算法</span></span><br><span class="line">        String algorithm = <span class="string">&quot;Blowfish&quot;</span>;</span><br><span class="line">        <span class="comment">// 转换模式</span></span><br><span class="line">        String transformation = <span class="string">&quot;Blowfish&quot;</span>;</span><br><span class="line">        <span class="comment">// --- 生成秘钥 ---</span></span><br><span class="line">        <span class="comment">// 实例化秘钥生成器</span></span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化秘钥长度</span></span><br><span class="line">        keyGenerator.init(<span class="number">128</span>);</span><br><span class="line">        <span class="comment">// 生成秘钥</span></span><br><span class="line">        SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">        <span class="comment">// 生成秘钥材料</span></span><br><span class="line">        SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), algorithm);</span><br><span class="line">        System.out.println(<span class="string">&quot;Blowfish秘钥：&quot;</span> + Base64.getEncoder().encodeToString(secretKey.getEncoded()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化密码对象</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(transformation);</span><br><span class="line">        <span class="comment">// 设置模式（ENCRYPT_MODE：加密模式；DECRYPT_MODE：解密模式）和指定秘钥</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] encrypt = cipher.doFinal(value.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;Blowfish加密结果：&quot;</span> + Base64.getEncoder().encodeToString(encrypt));</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        <span class="comment">// 设置为解密模式</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);</span><br><span class="line">        <span class="keyword">byte</span>[] decrypt = cipher.doFinal(encrypt);</span><br><span class="line">        System.out.println(<span class="string">&quot;Blowfish解密结果：&quot;</span> + <span class="keyword">new</span> String(decrypt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">待加密值：Doug Wilson</span><br><span class="line">Blowfish秘钥：<span class="attribute">d3ReFylxI2OI7n3qgPFViQ</span>==</span><br><span class="line">Blowfish加密结果：<span class="attribute">nnH2mqVZhhhegBwAuqecLw</span>==</span><br><span class="line">Blowfish解密结果：Doug Wilson</span><br></pre></td></tr></table></figure>

<p><strong>如果指定不合法的秘钥长度，程序将抛出java.security.InvalidParameterException: Keysize must be multiple of 8, and can only range from 32 to 448 (inclusive)异常</strong></p>
<h2 id="加密模式"><a href="#加密模式" class="headerlink" title="加密模式"></a>加密模式</h2><p>对称加密算法分为：序列密码(流密码)加密，分组密码(块密码)加密两种。流密码是对信息流中的每一个元素（一个字母或一个比特）作为基本的处理单元进行加密，块密码是先对信息流分块，再对每一块分别加密。</p>
<p>上面介绍的这些都属于块密码加密。不同的算法侧重点不同，有的强调效率，有的强调安全，有的强调容错性。根据数据加密时每个加密区块间的关联方式来区分，可以分为4种加密模式：电子密码本模式（Electronic Code Book，ECB）、密文链接模式（Cipher Book Chaining，CBC）、密文反馈模式（Cipher Feed Back，CFB）、输出反馈模式（Output Feed Back，OFB）。AES标准除了推荐上述4种工作模式外，还推荐了一种新的工作模式—计数器模式（Counter，CTR）。这些工作模式可适用于各种分组密码算法。</p>
<h3 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h3><p>ECB模式加解密过程如下图所示：</p>
<p><img src="/images/ECB%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86.png"></p>
<p>明文分为若干块，每次加密均产生独立的密文分组，每组的加密结果不会对其他分组产生影响，相同的明文加密后对应产生相同的密文。</p>
<ul>
<li><strong>优点</strong>：可并行操作，没有误差传递（因为每个密文都是独立加密来的）；</li>
<li><strong>缺点</strong>：如果明文重复，则对应的密文也会重复，对明文进行主动攻击的可能性较高；</li>
<li><strong>用途</strong>：适合加密秘钥、随机数等短数据。例如，安全地传递DES秘钥，ECB是最合适的模式。</li>
</ul>
<h3 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h3><p>CBC模式加解密过程如下图所示：</p>
<p><img src="/images/CBC%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86.png"></p>
<p>明文分为若干块，每次加密前，明文块都和前一个明文块加密后的内容进行异或处理，然后再用秘钥加密。因为第一个明文块没有可以用来异或处理的密文块，所以我们需要提供一个初始化向量来替代。</p>
<ul>
<li><strong>优点</strong>：密文链接模式加密后的密文上下文关联，对明文的主动攻击的可能性较低；</li>
<li><strong>缺点</strong>：不能并行加密，如果在加密过程中发生错误，则错误将被无限放大，导致加密失败。并且需要提供初始化向量；</li>
<li><strong>用途</strong>：可加密任意长度的数据；适用于计算产生检测数据完整性的消息认证码Mac。</li>
</ul>
<h3 id="CFB"><a href="#CFB" class="headerlink" title="CFB"></a>CFB</h3><p>CFB模式加解密过程如下图所示：</p>
<p><img src="/images/CFB%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86.png"></p>
<p>明文分为若干块，每次加密前，先将前一个密文块使用秘钥加密，加密结果和当前明文块异或处理得到密文块。同样的，需要为第一个明文块加密提供初始化向量。</p>
<ul>
<li><strong>优点</strong>：和CBC类似；</li>
<li><strong>缺点</strong>：和CBC类似；</li>
<li><strong>用途</strong>：因错误传播无界，可用于检查发现明文密文的篡改。</li>
</ul>
<h3 id="OFB"><a href="#OFB" class="headerlink" title="OFB"></a>OFB</h3><p>OFB模式加解密过程如下图所示：</p>
<p><img src="/images/OFB%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86.png"></p>
<p>过程和CFB类似，区别在于OFB第一次使用秘钥对初始化向量进行加密（结果为A），加密结果和明文块异或处理得到密文块，下一次操作时候，不是使用秘钥加密前一个密文块，而是使用秘钥加密A的结果再和明文块异或处理，得到当前密文块。</p>
<ul>
<li><strong>优点</strong>：和CFB类似；</li>
<li><strong>缺点</strong>：不利于并行计算；对明文的主动攻击是可能的，安全性较CFB差；</li>
<li><strong>用途</strong>：适用于加密冗余性较大的数据，比如语音和图像数据。</li>
</ul>
<h3 id="CTR"><a href="#CTR" class="headerlink" title="CTR"></a>CTR</h3><p>CTR模式加解密过程如下图所示：</p>
<p><img src="/images/CTR%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86.png"></p>
<p>CTR含义是计数器模式，所以它维护了一个递增的计数器。秘钥加密计数器，结果和明文块异或得到密文块，依次类推。</p>
<ul>
<li><strong>优点</strong>：可以并行操作，安全性和CBC一样好；</li>
<li><strong>缺点</strong>：没有错误传播，因此不易确保数据完整性；</li>
<li><strong>用途</strong>：适用于各种加密应用。</li>
</ul>
<h2 id="填充模式"><a href="#填充模式" class="headerlink" title="填充模式"></a>填充模式</h2><p>当需要按块处理的数据, 数据长度不符合块处理需求时, 按照一定的方法填充满块长的规则。如果不填充，待加密的数据块长度不符合要求时程序会抛出异常。</p>
<p>JDK8中主要支持NoPadding和PKCS5Padding填充模式。</p>
<ol>
<li>NoPadding：不填充；</li>
<li>PKCS5Padding：数据块的大小为8位, 不够就补足。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th align="left">算法</th>
<th align="left">秘钥长度（位）</th>
<th align="left">工作模式</th>
<th align="left">填充模式</th>
<th align="left">初始化向量秘钥长度（字节）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DES</td>
<td align="left">56</td>
<td align="left">ECB、CBC、CFB、OFB、CTR等</td>
<td align="left">NoPadding、 PKCS5Padding、 ISO10126Padding</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">DESede</td>
<td align="left">112、168</td>
<td align="left">ECB、CBC、CFB、OFB、CTR等</td>
<td align="left">NoPadding、 PKCS5Padding、 ISO10126Padding</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">AES</td>
<td align="left">128、192、256</td>
<td align="left">ECB、CBC、CFB、OFB、CTR等</td>
<td align="left">NoPadding、 PKCS5Padding、 ISO10126Padding</td>
<td align="left">16</td>
</tr>
<tr>
<td align="left">RC2</td>
<td align="left">40~1024</td>
<td align="left">ECB、CBC、CFB、OFB、CTR等</td>
<td align="left">NoPadding、 PKCS5Padding、 ISO10126Padding</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">RC4</td>
<td align="left">40~1024</td>
<td align="left">ECB</td>
<td align="left">NoPadding</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">Blowfish</td>
<td align="left">32~448，8的倍数</td>
<td align="left">ECB、CBC、CFB、OFB、CTR等</td>
<td align="left">NoPadding、 PKCS5Padding、 ISO10126Padding</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">PBE</td>
<td align="left">无</td>
<td align="left">CBC</td>
<td align="left">PKCS5Padding</td>
<td align="left">16（带Hmac）</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>对称加密算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java非对称加密算法</title>
    <url>/2020/08/03/Java%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>非对称加密和对称加密算法相比，多了一把秘钥，为双秘钥模式，一个公开称为公钥，一个保密称为私钥。遵循公钥加密私钥解密，或者私钥加密公钥解密。非对称加密算法源于DH算法，后又有基于椭圆曲线加密算法的密钥交换算法ECDH，不过目前最为流行的非对称加密算法是RSA，本文简单记录下RSA的使用。</p>
<span id="more"></span>

<h2 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h2><p>RSA算法是最为典型的非对称加密算法，该算法由美国麻省理工学院（MIT）的Ron Rivest、Adi Shamir和Leonard Adleman三位学者提出，并以这三位学者的姓氏开头字母命名，称为RSA算法。</p>
<p>RSA算法的数据交换过程分为如下几步：</p>
<ol>
<li>A构建RSA秘钥对；</li>
<li>A向B发布公钥；</li>
<li>A用私钥加密数据发给B；</li>
<li>B用公钥解密数据；</li>
<li>B用公钥加密数据发给A；</li>
<li>A用私钥解密数据。</li>
</ol>
<p>JDK8支持RSA算法：</p>
<table>
<thead>
<tr>
<th align="left">算法</th>
<th align="left">秘钥长度</th>
<th align="left">加密模式</th>
<th align="left">填充模式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">RSA</td>
<td align="left">512~16384位，64倍数</td>
<td align="left">ECB</td>
<td align="left">NoPadding   PKCS1Padding OAEPWithMD5AndMGF1Padding OAEPWithSHA1AndMGF1Padding    OAEPWithSHA-1AndMGF1Padding OAEPWithSHA-224AndMGF1Padding      OAEPWithSHA-256AndMGF1Padding     OAEPWithSHA-384AndMGF1Padding OAEPWithSHA-512AndMGF1Padding   OAEPWithSHA-512/224AndMGF1Padding    OAEPWithSHA-512/2256ndMGF1Padding</td>
</tr>
</tbody></table>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String value = <span class="string">&quot;Doug Wilson&quot;</span>;</span><br><span class="line">        <span class="comment">// 加密算法</span></span><br><span class="line">        String algorithm = <span class="string">&quot;RSA&quot;</span>;</span><br><span class="line">        <span class="comment">// 转换模式</span></span><br><span class="line">        String transform = <span class="string">&quot;RSA/ECB/PKCS1Padding&quot;</span>;</span><br><span class="line">        <span class="comment">// 实例化秘钥对生成器</span></span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化，秘钥长度512~16384位，64倍数</span></span><br><span class="line">        keyPairGenerator.initialize(<span class="number">512</span>);</span><br><span class="line">        <span class="comment">// 生成秘钥对</span></span><br><span class="line">        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        <span class="comment">// 公钥</span></span><br><span class="line">        PublicKey publicKey = keyPair.getPublic();</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA公钥: &quot;</span> + Base64.getEncoder().encodeToString(publicKey.getEncoded()));</span><br><span class="line">        <span class="comment">// 私钥</span></span><br><span class="line">        PrivateKey privateKey = keyPair.getPrivate();</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA私钥: &quot;</span> + Base64.getEncoder().encodeToString(privateKey.getEncoded()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------ 测试公钥加密，私钥解密 ------</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(transform);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">byte</span>[] pubEncryptBytes = cipher.doFinal(value.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA公钥加密后数据: &quot;</span> + Base64.getEncoder().encodeToString(pubEncryptBytes));</span><br><span class="line"></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">byte</span>[] priDecryptBytes = cipher.doFinal(pubEncryptBytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA私钥解密后数据: &quot;</span> + <span class="keyword">new</span> String(priDecryptBytes));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------ 测试私钥加密，公钥解密 ------</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">byte</span>[] priEncryptBytes = cipher.doFinal(value.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA私钥加密后数据: &quot;</span> + Base64.getEncoder().encodeToString(priEncryptBytes));</span><br><span class="line"></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">byte</span>[] pubDecryptBytes = cipher.doFinal(priEncryptBytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA公钥解密后数据: &quot;</span> + <span class="keyword">new</span> String(pubDecryptBytes));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">RSA</span>公钥: MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAL<span class="number">2</span>Zq<span class="number">7</span>TVzBpN<span class="number">4</span>LBegajgh<span class="number">6</span>cOp<span class="number">6</span>mU<span class="number">1</span>FeNBu<span class="number">6</span>pePDaAOaxW<span class="number">13</span>JsoR<span class="number">3</span>+<span class="number">6</span>gPFg<span class="number">8</span>OIEpnOjl<span class="number">3</span>AvM<span class="number">6</span>DZbs+<span class="number">3</span>ec<span class="number">3</span>Gb<span class="number">5</span>cWUCAwEAAQ==</span><br><span class="line"><span class="attribute">RSA</span>私钥: MIIBVgIBADANBgkqhkiG<span class="number">9</span>w<span class="number">0</span>BAQEFAASCAUAwggE<span class="number">8</span>AgEAAkEAvZmrtNXMGk<span class="number">3</span>gsF<span class="number">6</span>BqOCHpw<span class="number">6</span>nqZTUV<span class="number">40</span>G<span class="number">7</span>ql<span class="number">48</span>NoA<span class="number">5</span>rFbXcmyhHf<span class="number">7</span>qA<span class="number">8</span>WDw<span class="number">4</span>gSmc<span class="number">6</span>OXcC<span class="number">8</span>zoNluz<span class="number">7</span>d<span class="number">5</span>zcZvlxZQIDAQABAkEAqOdQBs<span class="number">37</span>gGdmRdg<span class="number">7</span>K<span class="number">8</span>WyMwmkJTdXnxMcXNqOygl<span class="number">7</span>igZmK<span class="number">3</span>VQENAasGVaxAzs+<span class="number">5</span>kBGn<span class="number">0</span>q<span class="number">5</span>xRiu<span class="number">4</span>zPokUn/Ej<span class="number">3</span>wQIhAOzsuGEV<span class="number">2</span>mf<span class="number">2</span>JbT<span class="number">8</span>Q<span class="number">0</span>lrsZ<span class="number">7</span>DdI<span class="number">8</span>hDGS<span class="number">6</span>/vLXQ<span class="number">2</span>aPKtLRAiEAzN<span class="number">2</span>Kwz<span class="number">1</span>xdphRMISwms<span class="number">3</span>c<span class="number">586</span>/ratJuBDlcodTe<span class="number">5</span>Ay<span class="number">0</span>lUCIQCE<span class="number">4</span>Zvj<span class="number">79</span>LIXjj<span class="number">10</span>kqW<span class="number">4</span>k<span class="number">0</span>Dw<span class="number">5</span>IbOKjv<span class="number">0</span>iVt<span class="number">5</span>CgMXJ<span class="number">3</span>jEQIgSMNDHtc<span class="number">67</span>oFpDM+EHmeR<span class="number">129</span>yWw+kblDp/cSc<span class="number">3</span>R<span class="number">05</span>P<span class="number">8</span>UCIQCbzKKLVj<span class="number">7</span>wXIyOcLQTsDrz<span class="number">6</span>n<span class="number">6</span>Hbpy<span class="number">9</span>BqTznO<span class="number">272</span>PPrEA==</span><br><span class="line"><span class="attribute">RSA</span>公钥加密后数据: CgQ<span class="number">9</span>rkRvb<span class="number">5</span>vzG<span class="number">6</span>R/vMnhWPfQLWlo<span class="number">2</span>igEr<span class="number">3</span>GRx<span class="number">4</span>zOf+oSh<span class="number">9</span>MdlfD<span class="number">6</span>n<span class="number">0</span>PRV<span class="number">5</span>jQFdtMbpQ<span class="number">3</span>qjDqqnD<span class="number">48</span>/<span class="number">3</span>VwskCrw==</span><br><span class="line"><span class="attribute">RSA</span>私钥解密后数据: Doug Wilson</span><br><span class="line"><span class="attribute">RSA</span>私钥加密后数据: grY<span class="number">7</span>iL<span class="number">5</span>tP<span class="number">7316</span>hC+OUbBa<span class="number">15</span>p<span class="number">7</span>sMfBXQ<span class="number">9</span>dRjdjtJIUHgPKL+VWwIlIZ<span class="number">64</span>VzMAFVaOIsZKsrg<span class="number">6</span>L<span class="number">0</span>lS<span class="number">7</span>Lk<span class="number">4</span>O<span class="number">4</span>ORKw==</span><br><span class="line"><span class="attribute">RSA</span>公钥解密后数据: Doug Wilson</span><br></pre></td></tr></table></figure>

<p>可以看到，公钥加密私钥解密和私钥加密公钥解密的模式都可行</p>
<h2 id="公钥获取"><a href="#公钥获取" class="headerlink" title="公钥获取"></a>公钥获取</h2><p>假如现在有RSA公钥：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAL2Zq7TVzBpN4LBegajgh6cOp6mU1FeNBu6pePDaAOaxW13JsoR3</span>+<span class="number">6</span>gPFg<span class="number">8</span>OIEpnOjl<span class="number">3</span>AvM<span class="number">6</span>DZbs+<span class="number">3</span>ec<span class="number">3</span>Gb<span class="number">5</span>cWUCAwEAAQ==</span><br></pre></td></tr></table></figure>

<p>RSA私钥：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">MIIBVgIBADANBgkqhkiG9w0BAQEFAASCAUAwggE8AgEAAkEAvZmrtNXMGk3gsF6BqOCHpw6nqZTUV40G7ql48NoA5rFbXcmyhHf7qA8WDw4gSmc6OXcC8zoNluz7d5zcZvlxZQIDAQABAkEAqOdQBs37gGdmRdg7K8WyMwmkJTdXnxMcXNqOygl7igZmK3VQENAasGVaxAzs</span>+<span class="number">5</span>kBGn<span class="number">0</span>q<span class="number">5</span>xRiu<span class="number">4</span>zPokUn/Ej<span class="number">3</span>wQIhAOzsuGEV<span class="number">2</span>mf<span class="number">2</span>JbT<span class="number">8</span>Q<span class="number">0</span>lrsZ<span class="number">7</span>DdI<span class="number">8</span>hDGS<span class="number">6</span>/vLXQ<span class="number">2</span>aPKtLRAiEAzN<span class="number">2</span>Kwz<span class="number">1</span>xdphRMISwms<span class="number">3</span>c<span class="number">586</span>/ratJuBDlcodTe<span class="number">5</span>Ay<span class="number">0</span>lUCIQCE<span class="number">4</span>Zvj<span class="number">79</span>LIXjj<span class="number">10</span>kqW<span class="number">4</span>k<span class="number">0</span>Dw<span class="number">5</span>IbOKjv<span class="number">0</span>iVt<span class="number">5</span>CgMXJ<span class="number">3</span>jEQIgSMNDHtc<span class="number">67</span>oFpDM+EHmeR<span class="number">129</span>yWw+kblDp/cSc<span class="number">3</span>R<span class="number">05</span>P<span class="number">8</span>UCIQCbzKKLVj<span class="number">7</span>wXIyOcLQTsDrz<span class="number">6</span>n<span class="number">6</span>Hbpy<span class="number">9</span>BqTznO<span class="number">272</span>PPrEA==</span><br></pre></td></tr></table></figure>

<p>将它们还原为PublicKey和PrivateKey对象，可以参考如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String value = <span class="string">&quot;Doug Wilson&quot;</span>;</span><br><span class="line">        <span class="comment">// 加密算法</span></span><br><span class="line">        String algorithm = <span class="string">&quot;RSA&quot;</span>;</span><br><span class="line">        <span class="comment">// 转换模式</span></span><br><span class="line">        String transform = <span class="string">&quot;RSA/ECB/PKCS1Padding&quot;</span>;</span><br><span class="line">        <span class="comment">// RSA公钥BASE64字符串</span></span><br><span class="line">        String rsaPublicKey = <span class="string">&quot;MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAKBvz9cma+hXNiv2yXg6e1PyZhHVZm3bJXDvTJP2LyXo4vs9grH36Q9kNgr6quHtuU6fEoUxUu2zbEB8dkEWB9UCAwEAAQ==&quot;</span>;</span><br><span class="line">        <span class="comment">// RSA私钥BASE64字符串</span></span><br><span class="line">        String rsaPrivateKey = <span class="string">&quot;MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEAoG/P1yZr6Fc2K/bJeDp7U/JmEdVmbdslcO9Mk/YvJeji+z2CsffpD2Q2Cvqq4e25Tp8ShTFS7bNsQHx2QRYH1QIDAQABAkEAjemZXORdesz52/WVzEVepai6ZHfw/Kdl/PmPMSoIFmz7mk55rprl2Akn2V0odSiHSnMWvDmOUIAvHaHF4Re4wQIhAN5GxVeF7ndyoWasxqIOVb6baNkUrapBM0nacPS4WA8JAiEAuMcvNM2Z1rW74JagoGlSIfRkNUqa+3LTCN/fK7VR2W0CICs/+gYduVjkpSMlW0ENKQH9m1kh/Oiz5xbnujLj676BAiBVGif7wdXgtcLaJYXFW7ygNtcQVFQdCz13EOTQVKpl4QIgY2YyH3vUYI2J68qCGtYjj5iNHUEwwze+Za1R7y0V43k=&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------- 还原公钥 --------</span></span><br><span class="line">        <span class="keyword">byte</span>[] publicKeyBytes = Base64.getDecoder().decode(rsaPublicKey);</span><br><span class="line">        X509EncodedKeySpec x509EncodedKeySpec = <span class="keyword">new</span> X509EncodedKeySpec(publicKeyBytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);</span><br><span class="line">        PublicKey publicKey = keyFactory.generatePublic(x509EncodedKeySpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------- 还原私钥 --------</span></span><br><span class="line">        <span class="keyword">byte</span>[] privateKeyBytes = Base64.getDecoder().decode(rsaPrivateKey);</span><br><span class="line">        PKCS8EncodedKeySpec pkcs8EncodedKeySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(privateKeyBytes);</span><br><span class="line">        PrivateKey privateKey = keyFactory.generatePrivate(pkcs8EncodedKeySpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------- 测试加解密 --------</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(transform);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">byte</span>[] pubEncryptBytes = cipher.doFinal(value.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA公钥加密数据: &quot;</span> + Base64.getEncoder().encodeToString(pubEncryptBytes));</span><br><span class="line"></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">byte</span>[] priDecryptBytes = cipher.doFinal(pubEncryptBytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA私钥解密数据: &quot;</span> + <span class="keyword">new</span> String(priDecryptBytes));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">RSA</span>公钥加密数据: clQ<span class="number">6</span>HuRVCWHm<span class="number">3</span>pCJ<span class="number">6</span>yTbj/mW<span class="number">7</span>clTwe/ZE<span class="number">7</span>IfMah<span class="number">3</span>aPzdHJMle<span class="number">6</span>AqD<span class="number">4</span>sPLkLwskn+<span class="number">4</span>nZ<span class="number">1</span>gYlvkoqceJiFm+IkIg==</span><br><span class="line"><span class="attribute">RSA</span>私钥解密数据: Doug Wilson</span><br></pre></td></tr></table></figure>

<h2 id="分段加解密"><a href="#分段加解密" class="headerlink" title="分段加解密"></a>分段加解密</h2><p>RSA加解密中必须考虑到的密钥长度、明文长度和密文长度问题。明文长度需要小于密钥长度，而密文长度则等于密钥长度。因此当加密内容长度大于密钥长度时，有效的RSA加解密就需要对内容进行分段。</p>
<p>这是因为，RSA算法本身要求加密内容也就是明文长度m必须满足<code>0&lt;m&lt;密钥长度n</code>。如果小于这个长度就需要进行padding，因为如果没有padding，就无法确定解密后内容的真实长度，字符串之类的内容问题还不大，以0作为结束符，但对二进制数据就很难，因为不确定后面的0是内容还是内容结束符。而只要用到padding，那么就要占用实际的明文长度，于是实际明文长度需要减去padding字节长度。我们一般使用的padding标准有NoPPadding、OAEPPadding、PKCS1Padding等，其中PKCS#1建议的padding就占用了11个字节。</p>
<p>以秘钥长度为1024bits为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       StringBuilder value = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">29</span>; i++) &#123;</span><br><span class="line">           value.append(<span class="string">&quot;18cm&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;待加密内容长度: &quot;</span> + value.toString().length());</span><br><span class="line">       <span class="comment">// 加密算法</span></span><br><span class="line">       String algorithm = <span class="string">&quot;RSA&quot;</span>;</span><br><span class="line">       <span class="comment">// 转换模式</span></span><br><span class="line">       String transform = <span class="string">&quot;RSA/ECB/PKCS1Padding&quot;</span>;</span><br><span class="line">       <span class="comment">// 实例化秘钥对生成器</span></span><br><span class="line">       KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm);</span><br><span class="line">       <span class="comment">// 初始化，秘钥长度512~16384位，64倍数</span></span><br><span class="line">       keyPairGenerator.initialize(<span class="number">1024</span>);</span><br><span class="line">       <span class="comment">// 生成秘钥对</span></span><br><span class="line">       KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">       <span class="comment">// 公钥</span></span><br><span class="line">       PublicKey publicKey = keyPair.getPublic();</span><br><span class="line">       System.out.println(<span class="string">&quot;RSA公钥: &quot;</span> + Base64.getEncoder().encodeToString(publicKey.getEncoded()));</span><br><span class="line">       <span class="comment">// 私钥</span></span><br><span class="line">       PrivateKey privateKey = keyPair.getPrivate();</span><br><span class="line">       System.out.println(<span class="string">&quot;RSA私钥: &quot;</span> + Base64.getEncoder().encodeToString(privateKey.getEncoded()));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// ------ 测试公钥加密，私钥解密 ------</span></span><br><span class="line">       Cipher cipher = Cipher.getInstance(transform);</span><br><span class="line">       cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">       <span class="keyword">byte</span>[] pubEncryptBytes = cipher.doFinal(value.toString().getBytes());</span><br><span class="line">       System.out.println(<span class="string">&quot;RSA公钥加密后数据: &quot;</span> + Base64.getEncoder().encodeToString(pubEncryptBytes));</span><br><span class="line"></span><br><span class="line">       cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">       <span class="keyword">byte</span>[] priDecryptBytes = cipher.doFinal(pubEncryptBytes);</span><br><span class="line">       System.out.println(<span class="string">&quot;RSA私钥解密后数据: &quot;</span> + <span class="keyword">new</span> String(priDecryptBytes));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// ------ 测试私钥加密，公钥解密 ------</span></span><br><span class="line">       cipher.init(Cipher.ENCRYPT_MODE, privateKey);</span><br><span class="line">       <span class="keyword">byte</span>[] priEncryptBytes = cipher.doFinal(value.toString().getBytes());</span><br><span class="line">       System.out.println(<span class="string">&quot;RSA私钥加密后数据: &quot;</span> + Base64.getEncoder().encodeToString(priEncryptBytes));</span><br><span class="line"></span><br><span class="line">       cipher.init(Cipher.DECRYPT_MODE, publicKey);</span><br><span class="line">       <span class="keyword">byte</span>[] pubDecryptBytes = cipher.doFinal(priEncryptBytes);</span><br><span class="line">       System.out.println(<span class="string">&quot;RSA公钥解密后数据: &quot;</span> + <span class="keyword">new</span> String(pubDecryptBytes));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">待加密内容长度: <span class="number">120</span></span><br><span class="line">RSA公钥: MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrYRsr7qLnZSv2SmDOjddnAc2K0SYVY4lg3o/l85mFCFEivkse0aKVBQ068E7P2HlHhBvDP97hlGUt8z4pH7XZqRBVsBPT+HlYJTXsYB2FZC+Vdm+bSq75JxHyVI0ov1jLUImFV6j/Des7KC/<span class="number">68</span>TZ4qmIMbwwlt8vAuTmy8MD3KQIDAQAB</span><br><span class="line">RSA私钥: MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAKthGyvuoudlK/ZKYM6N12cBzYrRJhVjiWDej+XzmYUIUSK+Sx7RopUFDTrwTs/YeUeEG8M/<span class="number">3</span>uGUZS3zPikftdmpEFWwE9P4eVglNexgHYVkL5V2b5tKrvknEfJUjSi/WMtQiYVXqP8N6zsoL/rxNniqYgxvDCW3y8C5ObLwwPcpAgMBAAECgYBE+dNezjAgo7aa7Pqjh7EfUzlv2pfSWfpr04flDDNIuL03F5HSeJtQEPVvOFLwEndVklU+M1G4RuqmINVu5cVhhrURkNNKvFC0LhjeEABXqdhiGmmIpPJ1SGq0bVcjtHXjP1Ee2R+JKmtbh6CYuBeKn5QTX2VQi+uyXJrAJnUndQJBAPy1JiPFCbZXPQ890zzxXtV9ymrCieudLrQNHHATwoiMhTUO3XbfhdEtwbEKcdxrgBV2duIg8NOSWnVUT/g/Y+<span class="number">8</span>CQQCtnLRUOzB6zIc8PLbIrNaNwygabA90aSWpft0EDNf5qGBW0ISgJ6R8Le6Fz29uzGaGC3UP1B4yq7oFJj2aUl5nAkBKdGDZVxtmcsuVqwSKxx7GzfoOfGTAW55ABEDlsJy3OJeiq0+Kz46Qs+eGbupfI/kn2bBrLYNnAo7OVNn+<span class="number">7</span>UZXAkAsrIY6poBzGO4zsevW96K+F9nZ8rSHYAcw9lQpFqT8uTcRH9cA3zKUQb1+<span class="number">8</span>UHbYP2AwLH+wLaEk2vqp0xyyX9BAkEAimpo/rQ+<span class="number">14</span>ydBHJK5gWrEstp7lIyyrF9GWLGcH7unGXIzezxCuoZZkoY2uO9c8RZ8jYlk6anYgrFCdugBXCnDg==</span><br><span class="line"></span><br><span class="line">javax<span class="selector-class">.crypto</span><span class="selector-class">.IllegalBlockSizeException</span>: Data must not be longer than <span class="number">117</span> bytes</span><br><span class="line"></span><br><span class="line">	at java.base/com<span class="selector-class">.sun</span><span class="selector-class">.crypto</span><span class="selector-class">.provider</span><span class="selector-class">.RSACipher</span><span class="selector-class">.doFinal</span>(RSACipher<span class="selector-class">.java</span>:<span class="number">347</span>)</span><br><span class="line">	at java.base/com<span class="selector-class">.sun</span><span class="selector-class">.crypto</span><span class="selector-class">.provider</span><span class="selector-class">.RSACipher</span><span class="selector-class">.engineDoFinal</span>(RSACipher<span class="selector-class">.java</span>:<span class="number">392</span>)</span><br><span class="line">	at java.base/javax<span class="selector-class">.crypto</span><span class="selector-class">.Cipher</span><span class="selector-class">.doFinal</span>(Cipher<span class="selector-class">.java</span>:<span class="number">2208</span>)</span><br><span class="line">	at com<span class="selector-class">.doug</span><span class="selector-class">.wilson</span><span class="selector-class">.rsa</span><span class="selector-class">.Demo</span><span class="selector-class">.test</span>(Demo<span class="selector-class">.java</span>:<span class="number">40</span>)</span><br><span class="line">	at java.base/jdk<span class="selector-class">.internal</span><span class="selector-class">.reflect</span><span class="selector-class">.NativeMethodAccessorImpl</span><span class="selector-class">.invoke0</span>(Native Method)</span><br><span class="line">	at java.base/jdk<span class="selector-class">.internal</span><span class="selector-class">.reflect</span><span class="selector-class">.NativeMethodAccessorImpl</span><span class="selector-class">.invoke</span>(NativeMethodAccessorImpl<span class="selector-class">.java</span>:<span class="number">62</span>)</span><br><span class="line">	at java.base/jdk<span class="selector-class">.internal</span><span class="selector-class">.reflect</span><span class="selector-class">.DelegatingMethodAccessorImpl</span><span class="selector-class">.invoke</span>(DelegatingMethodAccessorImpl<span class="selector-class">.java</span>:<span class="number">43</span>)</span><br><span class="line">	at java.base/java<span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.Method</span><span class="selector-class">.invoke</span>(Method<span class="selector-class">.java</span>:<span class="number">567</span>)</span><br><span class="line">	at org<span class="selector-class">.junit</span><span class="selector-class">.runners</span><span class="selector-class">.model</span>.FrameworkMethod$<span class="number">1</span><span class="selector-class">.runReflectiveCall</span>(FrameworkMethod<span class="selector-class">.java</span>:<span class="number">50</span>)</span><br><span class="line">	at </span><br><span class="line">	......</span><br></pre></td></tr></table></figure>

<p>对于1024长度的密钥。128字节（1024bits/8）减去PKCS#1建议的padding就占用了11个字节正好是117字节。所以加密的明文长度120字节大于117字节，程序抛出了异常。</p>
<p>要解决这个问题，可以采用分段加密的手段。编写一个分段加解密的工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RSA分段加解密</span></span><br><span class="line"><span class="comment"> * 针对秘钥长度为1024bits</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RsaUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大加密块长度 1024/8 - 11</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENCRYPT_BLOCK = <span class="number">117</span>;</span><br><span class="line">    <span class="comment">// 最大解密块长度 1024/8</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_DECRYPT_BLOCK = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRANSFORM = <span class="string">&quot;RSA/ECB/PKCS1Padding&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value     待加密值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(PublicKey publicKey, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">            Cipher cipher = Cipher.getInstance(TRANSFORM);</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = value.getBytes();</span><br><span class="line">            <span class="keyword">int</span> length = bytes.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> offSet = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] cache;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 对数据分段加密</span></span><br><span class="line">            <span class="keyword">while</span> (length - offSet &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (length - offSet &gt; MAX_ENCRYPT_BLOCK) &#123;</span><br><span class="line">                    cache = cipher.doFinal(bytes, offSet, MAX_ENCRYPT_BLOCK);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cache = cipher.doFinal(bytes, offSet, length - offSet);</span><br><span class="line">                &#125;</span><br><span class="line">                out.write(cache, <span class="number">0</span>, cache.length);</span><br><span class="line">                i++;</span><br><span class="line">                offSet = i * MAX_ENCRYPT_BLOCK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] encryptedData = out.toByteArray();</span><br><span class="line">            <span class="keyword">return</span> Base64.getEncoder().encodeToString(encryptedData);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encrypt    带解密值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解密值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(PrivateKey privateKey, String encrypt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">            Cipher cipher = Cipher.getInstance(TRANSFORM);</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = Base64.getDecoder().decode(encrypt);</span><br><span class="line">            <span class="keyword">int</span> length = bytes.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> offSet = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] cache;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 对数据分段解密</span></span><br><span class="line">            <span class="keyword">while</span> (length - offSet &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (length - offSet &gt; MAX_DECRYPT_BLOCK) &#123;</span><br><span class="line">                    cache = cipher.doFinal(bytes, offSet, MAX_DECRYPT_BLOCK);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cache = cipher.doFinal(bytes, offSet, length - offSet);</span><br><span class="line">                &#125;</span><br><span class="line">                out.write(cache, <span class="number">0</span>, cache.length);</span><br><span class="line">                i++;</span><br><span class="line">                offSet = i * MAX_DECRYPT_BLOCK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] decryptedData = out.toByteArray();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(decryptedData);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       StringBuilder value = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">29</span>; i++) &#123;</span><br><span class="line">           value.append(<span class="string">&quot;18cm&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;待加密内容长度: &quot;</span> + value.toString().length());</span><br><span class="line">       <span class="comment">// 加密算法</span></span><br><span class="line">       String algorithm = <span class="string">&quot;RSA&quot;</span>;</span><br><span class="line">       <span class="comment">// 实例化秘钥对生成器</span></span><br><span class="line">       KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm);</span><br><span class="line">       <span class="comment">// 初始化，秘钥长度512~16384位，64倍数</span></span><br><span class="line">       keyPairGenerator.initialize(<span class="number">1024</span>);</span><br><span class="line">       <span class="comment">// 生成秘钥对</span></span><br><span class="line">       KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">       <span class="comment">// 公钥</span></span><br><span class="line">       PublicKey publicKey = keyPair.getPublic();</span><br><span class="line">       System.out.println(<span class="string">&quot;RSA公钥: &quot;</span> + Base64.getEncoder().encodeToString(publicKey.getEncoded()));</span><br><span class="line">       <span class="comment">// 私钥</span></span><br><span class="line">       PrivateKey privateKey = keyPair.getPrivate();</span><br><span class="line">       System.out.println(<span class="string">&quot;RSA私钥: &quot;</span> + Base64.getEncoder().encodeToString(privateKey.getEncoded()));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// ------ 测试公钥加密，私钥解密 ------</span></span><br><span class="line">       String pubEncrypt= RsaUtil.encrypt(publicKey, value.toString());</span><br><span class="line">       System.out.println(<span class="string">&quot;RSA公钥加密后数据: &quot;</span> + pubEncrypt);</span><br><span class="line"></span><br><span class="line">       String priDecrypt = RsaUtil.decrypt(privateKey, pubEncrypt);</span><br><span class="line">       System.out.println(<span class="string">&quot;RSA私钥解密后数据: &quot;</span> + priDecrypt);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">待加密内容长度: <span class="number">120</span></span><br><span class="line">RSA公钥: MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDFO9e1imMmI73<span class="regexp">/nss+4Qy272mvePgKo6l5wKj8X2kYXc7LriJ3U4l9Rlggh+h59PhycbxSzeAPiJRLDuIHbh9XO1ETtMh3LkaqWlUHYqfUkwGBk6TnYDn7fF+nRuMrj0WkKo5cCKL9+Pqc/y</span>GCQxUo5TEALNNcqZh+VRrQc7vEiwIDAQAB</span><br><span class="line">RSA私钥: MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAMU717WKYyYjvf+eyz7hDLbvaa94+AqjqXnAqPxfaRhdzsuuIndTiX1GWCCH6Hn0+HJxvFLN4A+IlEsO4gduH1c7URO0yHcuRqpaVQdip9STAYGTpOdgOft8X6dG4yuPRaQqjlwIov34+pz<span class="regexp">/IYJDFSjlMQAs01ypmH5VGtBzu8SLAgMBAAECgYEAw4ASy/</span>bVWpu5HCSJb9VhZf8f8fflXZ5mQbHvjuD<span class="regexp">/6lApyAjeTws10EAm4G/</span><span class="number">2</span>xtREZCRKuIUrIBqQa2ngL98<span class="regexp">/HdlfsMpKsOFwoWYOTdbrg7v7GlfzoPIy4XnciIrtwCg24MFiHT2lY685aBcwRITFQtxqReZT3kWIH3yQAglc/</span>xkCQQDqzr57v0grxiCKYzHLW4Jggiq7wIv0I1b+pOt4DPqhThQuzcNBXuJoT1pXOPhk7w6K<span class="regexp">/Kd77yPkuyg5hC14TtF1AkEA1wjzbGMKqr3o0ab3iVGRU8xMYFPU6CBqxVeSrf8iz0meUbDAkN9N0e7B8jgW1r6xc+n1SwisCmARulCoM8d9/</span>wJADIaK0r8ZcnxXMAqqlVaEVfGbpfhXfuaDtYHGrdjDZedsXDLNv6b4HOhewVhgp8G43OEtbgcLux<span class="regexp">/gvXC3nDtYIQJAROP1OJAyZqkY4bHgM/</span>oR2QrmnSW+W++mxTpdH6lReZ9YPUunJcKkp9EaCYO2rW3CZCRcFYHdvCUzCMG2YYBT+QJBAIRGQhiWGwrI8dSqfx+Ays5qKc1zPfAF35O6OB3rE52CPx87hLTnkBxCh3PWaR62rrwwaNPsTHxiG3Isa6dj8QI=</span><br><span class="line">RSA公钥加密后数据: Bc8n04ImBwKbf+mTHBA92qrEK4OH+lzS1LDRm8rTSPn0snTfofM1iXMRiOxdaVIr1dDi0SLQHNCBMoSHJUJIXSg8JG1qrkMG684NimqdMVbSTuQZMowMpEHjdCrYfNScmJ2nKidHiW5En7Iz7uNDG20DCtGwBu49snPPj8vtgPoR1XY5fzIpS1QMNEjtwYcbriuF2D5iRUQM3x1klvHMFeIgNBXVFSHYeYt4SjmzHDaXp8hmGO7HhAaiUJhX1iNRkMO21JipBKQBDwG/D8yysdDYxS4ijeCLYgF8bhM2NC7kXCXA0rN2yINWy0PTCUnz7KlWBXaK3lZW0IrzI5WynQ==</span><br><span class="line">RSA私钥解密后数据: <span class="number">18</span>cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm</span><br></pre></td></tr></table></figure>

<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ol>
<li>公钥是通过A发送给B的，其在传递过程中很有可能被截获，也就是说窃听者很有可能获得公钥。如果窃听者获得了公钥，向A发送数据，A是无法辨别消息的真伪的。因此，虽然可以使用公钥对数据加密，但这种方式还是会有存在一定的安全隐患。如果要建立更安全的加密消息传递模型，就需要AB双方构建两套非对称加密算法密钥，仅遵循“私钥加密，公钥解密”的方式进行加密消息传递；</li>
<li>RSA不适合加密过长的数据，虽然可以通过分段加密手段解决，但过长的数据加解密耗时较长，在响应速度要求较高的情况下慎用。一般推荐使用非对称加密算法传输对称加密秘钥，双方数据加密用对称加密算法加解密。</li>
</ol>
]]></content>
      <tags>
        <tag>非对称加密</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis级联</title>
    <url>/2020/10/09/MyBatis%E7%BA%A7%E8%81%94/</url>
    <content><![CDATA[<p>MyBatis中的级联分为3种：association，collection和discriminator：</p>
<ol>
<li><p><code>association</code>：代表一对一关系，比如学生和学生证是一对一关系。</p>
</li>
<li><p><code>collection</code>：代表一对多关系，比如学生和课程是一对多关系，一个学生可以有多个课程。</p>
</li>
<li><p><code>discriminator</code>：鉴别器，它可以根据实际选择采用哪个类作为实例，允许你根据特定的条件去关联不同的结果集。</p>
</li>
</ol>
<span id="more"></span>

<p>设计一个模型关系：</p>
<p><img src="/images/%E5%AD%A6%E7%94%9F%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B.png"></p>
<p>根据模型新建库表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_lecture(</span><br><span class="line">    id <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">    lecture_name <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;课程名称&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">table</span> t_student(</span><br><span class="line">    id <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">    cnname <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;学生姓名&#x27;</span>,</span><br><span class="line">    sex TINYINT(<span class="number">4</span>) <span class="keyword">not</span> <span class="keyword">null</span> COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">    selfcard_no <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学生证号&#x27;</span>,</span><br><span class="line">    note <span class="type">VARCHAR</span>(<span class="number">1024</span>) COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">table</span> t_student_health_female(</span><br><span class="line">    id <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">    student_id <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;学生编号&#x27;</span>,</span><br><span class="line">    check_date <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;检查日期&#x27;</span>,</span><br><span class="line">    heart <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;心&#x27;</span>,</span><br><span class="line">    liver <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;肝&#x27;</span>,</span><br><span class="line">    spleen <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;脾&#x27;</span>,</span><br><span class="line">    lung <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;肺&#x27;</span>,</span><br><span class="line">    kidney <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;肾&#x27;</span>,</span><br><span class="line">    uterus <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;子宫&#x27;</span>,</span><br><span class="line">    note <span class="type">VARCHAR</span>(<span class="number">1024</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> comment <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">table</span> t_student_health_male(</span><br><span class="line">    id <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">    student_id <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;学生编号&#x27;</span>,</span><br><span class="line">    check_date <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;检查日期&#x27;</span>,</span><br><span class="line">    heart <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;心&#x27;</span>,</span><br><span class="line">    liver <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;肝&#x27;</span>,</span><br><span class="line">    spleen <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;脾&#x27;</span>,</span><br><span class="line">    lung <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;肺&#x27;</span>,</span><br><span class="line">    kidney <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;肾&#x27;</span>,</span><br><span class="line">    prostate <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;前列腺&#x27;</span>,</span><br><span class="line">    note <span class="type">VARCHAR</span>(<span class="number">1024</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> comment <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_student_lecture(</span><br><span class="line">    id <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">    student_id <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;学生编号&#x27;</span>,</span><br><span class="line">    lecture_id <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;课程编号&#x27;</span>,</span><br><span class="line">    grade <span class="type">DECIMAL</span>(<span class="number">16</span>,<span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;评分&#x27;</span>,</span><br><span class="line">    note <span class="type">VARCHAR</span>(<span class="number">1024</span>) comment <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_student_selfcard(</span><br><span class="line">    id <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">    student_id <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;学生编号&#x27;</span>,</span><br><span class="line">    native <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;籍贯&#x27;</span>,</span><br><span class="line">    issue_date <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> comment <span class="string">&#x27;发证日期&#x27;</span>,</span><br><span class="line">    end_date <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;结束日期&#x27;</span>,</span><br><span class="line">    note <span class="type">VARCHAR</span>(<span class="number">1024</span>) comment <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="association"><a href="#association" class="headerlink" title="association"></a>association</h2><p>用t_student和t_student_selfcard演示一对一级联。</p>
<p>新增Student POJO：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String cnName;</span><br><span class="line">    <span class="keyword">private</span> Sex sex;</span><br><span class="line">    <span class="keyword">private</span> Long selfCardNo;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    <span class="comment">//一对一关系</span></span><br><span class="line">    <span class="keyword">private</span> StudentSelfcard selfCard;</span><br><span class="line">    <span class="comment">// getter，setter略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StudentSelfcard POJO：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentSelfcard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Long studentId;</span><br><span class="line">    <span class="keyword">private</span> String natives;</span><br><span class="line">    <span class="keyword">private</span> Date issueDate;</span><br><span class="line">    <span class="keyword">private</span> Date endDate;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    <span class="comment">// getter，setter略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义接口StudentSelfcardMapper：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentSelfcardMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentSelfcard <span class="title">findStudentSelfcardByStudentId</span><span class="params">(Long id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertStudentSelfcard</span><span class="params">(StudentSelfcard selfCard)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建对应的映射文件StudentSelfcardMapper.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>    </span><br><span class="line">    <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>   </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentSelfcardMapper&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;studentSelfcard_column&quot;</span>&gt;</span></span><br><span class="line">        id,student_id as studentId,native as natives,issue_date as issueDate,</span><br><span class="line">        end_date as endDate,note</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findStudentSelfcardByStudentId&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">resultType</span>=<span class="string">&quot;studentSelfcard&quot;</span>&gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;studentSelfcard_column&quot;</span>/&gt;</span> </span><br><span class="line">        from t_student_selfcard where student_id = #&#123;studentId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertStudentSelfcard&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;studentSelfcard&quot;</span>&gt;</span></span><br><span class="line">        insert into t_student_selfcard (student_id,native,issue_date,end_date,</span><br><span class="line">        note) values (#&#123;studentId&#125;,#&#123;natives&#125;,#&#123;issueDate&#125;,#&#123;endDate&#125;,#&#123;note&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着定义接口StudentMapper：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">public interface StudentMapper &#123;</span><br><span class="line">    public Student findStudentById(Long id);</span><br><span class="line">    public int createStudent(Student s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其相对于的映射文件StudentMapper.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>    </span><br><span class="line">    <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>   </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentMapper&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;student&quot;</span> <span class="attr">id</span>=<span class="string">&quot;studentList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;cnname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;cnName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">typeHandler</span>=<span class="string">&quot;org.apache.ibatis.type.EnumTypeHandler&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;selfcard_no&quot;</span> <span class="attr">property</span>=<span class="string">&quot;selfCardNo&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;note&quot;</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 一对一关联，column指定用哪列的值作为select查询的条件，如果有多个值用</span></span><br><span class="line"><span class="comment">            逗号隔开，select指定查询方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;selfCard&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">select</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentSelfcardMapper.findStudentSelfcardByStudentId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;student_column&quot;</span>&gt;</span></span><br><span class="line">        id,cnname as cnName,sex,selfcard_no as selfCardNo,note </span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findStudentById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentList&quot;</span>&gt;</span></span><br><span class="line">        select </span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;student_column&quot;</span>/&gt;</span> </span><br><span class="line">        from t_student where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置主键回填，供t_student_selfcard的student_id字段使用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;createStudent&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;student&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        insert into t_student(cnname,sex,selfcard_no,note) values (#&#123;cnName&#125;,</span><br><span class="line">        #&#123;sex,typeHandler=org.apache.ibatis.type.EnumTypeHandler&#125;,</span><br><span class="line">        #&#123;selfCardNo&#125;,#&#123;note&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>设置别名，指定mapper略。</p>
<p>先往库表插入值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = SqlSessionFactoryUtil.openSqlSession();</span><br><span class="line">StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">StudentSelfcardMapper selfcardMapper = sqlSession.getMapper(StudentSelfcardMapper.class);</span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.setCnName(<span class="string">&quot;辛久奈&quot;</span>);</span><br><span class="line">student.setNote(<span class="string">&quot;旋涡辛久奈&quot;</span>);</span><br><span class="line">student.setSelfCardNo(<span class="number">10000L</span>);</span><br><span class="line">student.setSex(Sex.FEMALE);</span><br><span class="line"><span class="keyword">int</span> n = studentMapper.createStudent(student);</span><br><span class="line"><span class="keyword">if</span>( n == <span class="number">1</span>)&#123;</span><br><span class="line">    StudentSelfcard selfCard = <span class="keyword">new</span> StudentSelfcard();</span><br><span class="line">    selfCard.setStudentId(student.getId());</span><br><span class="line">    selfCard.setNatives(<span class="string">&quot;福州&quot;</span>);</span><br><span class="line">    selfCard.setIssueDate(<span class="keyword">new</span> Date());</span><br><span class="line">    selfCard.setEndDate(<span class="keyword">new</span> Date());</span><br><span class="line">    selfCard.setNote(<span class="string">&quot;旋涡辛久奈的学生证&quot;</span>);</span><br><span class="line">    selfcardMapper.insertStudentSelfcard(selfCard);</span><br><span class="line">&#125;</span><br><span class="line">sqlSession.commit();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>查询库表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_student;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+-------------+------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> cnname <span class="operator">|</span> sex    <span class="operator">|</span> selfcard_no <span class="operator">|</span> note       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+-------------+------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span> 辛久奈  <span class="operator">|</span> FEMALE <span class="operator">|</span>   <span class="number">10000</span>    <span class="operator">|</span> 旋涡辛久奈  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+-------------+------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_student_selfcard;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+--------+------------+------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> student_id <span class="operator">|</span> native <span class="operator">|</span> issue_date <span class="operator">|</span> end_date   <span class="operator">|</span> note               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+--------+------------+------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span>         <span class="number">10</span> <span class="operator">|</span> 福州   <span class="operator">|</span> <span class="number">2017</span><span class="number">-01</span><span class="number">-06</span> <span class="operator">|</span> <span class="number">2017</span><span class="number">-01</span><span class="number">-06</span> <span class="operator">|</span> 旋涡辛久奈的学生证   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+--------+------------+------------+--------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>插入成功，现测试级联获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = SqlSessionFactoryUtil.openSqlSession();</span><br><span class="line">StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">Student student = studentMapper.findStudentById(<span class="number">10L</span>);</span><br><span class="line">System.out.println(student.getSelfCard().getNote());</span><br><span class="line">sqlSession.commit();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">旋涡辛久奈的学生证</span><br></pre></td></tr></table></figure>

<p>success.</p>
<h2 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h2><p>学生和学生成绩是一对多的关系，所以用t_student和t_student_lecture表练习一对多级联。</p>
<p>修改Student POJO：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String cnName;</span><br><span class="line">    <span class="keyword">private</span> Sex sex;</span><br><span class="line">    <span class="keyword">private</span> Long selfCardNo;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    <span class="comment">//一对多关联</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;StudentLecture&gt; lectures;</span><br><span class="line">    <span class="comment">// getter，setter略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增StudentLecture POJO：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentLecture</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Long studentId;</span><br><span class="line">    <span class="keyword">private</span> Long lectureId;</span><br><span class="line">    <span class="keyword">private</span> Double grade;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    <span class="comment">// getter，setter略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建StudentLectureMapper接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentLectureMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;StudentLecture&gt; <span class="title">getLecturesByStudentId</span><span class="params">(Long studentId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertStudentLecture</span><span class="params">(StudentLecture lecture)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其对应的映射文件StudentLectureMapper.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>    </span><br><span class="line">    <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>   </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentLectureMapper&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;studentLecture&quot;</span> <span class="attr">id</span>=<span class="string">&quot;lectures&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;student_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;studentId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;lecture_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lectureId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;grade&quot;</span> <span class="attr">property</span>=<span class="string">&quot;grade&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;note&quot;</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;student_lecture_column&quot;</span>&gt;</span></span><br><span class="line">        id,student_id as studentId,lecture_id as lectureId,grade,note </span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getLecturesByStudentId&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">resultMap</span>=<span class="string">&quot;lectures&quot;</span>&gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;student_lecture_column&quot;</span>/&gt;</span> </span><br><span class="line">        from t_student_lecture where student_id = #&#123;studentId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertStudentLecture&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        &lt;![CDATA[</span><br><span class="line">            insert into t_student_lecture(student_id,lecture_id,grade,note) </span><br><span class="line">            values (#&#123;studentId&#125;,#&#123;lectureId&#125;,#&#123;grade&#125;,#&#123;note&#125;)</span><br><span class="line">        ]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改StudentMapper.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>    </span><br><span class="line">    <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>   </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentMapper&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;student&quot;</span> <span class="attr">id</span>=<span class="string">&quot;studentList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;cnname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;cnName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">typeHandler</span>=<span class="string">&quot;org.apache.ibatis.type.EnumTypeHandler&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;selfcard_no&quot;</span> <span class="attr">property</span>=<span class="string">&quot;selfCardNo&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;note&quot;</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 一对多关联，column指定用哪列的值作为select查询的条件，如果由多个值用</span></span><br><span class="line"><span class="comment">            逗号隔开，select指定查询方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;lectures&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">select</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentLectureMapper.getLecturesByStudentId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;student_column&quot;</span>&gt;</span></span><br><span class="line">        id,cnname as cnName,sex,selfcard_no as selfCardNo,note </span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findStudentById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentList&quot;</span>&gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;student_column&quot;</span>/&gt;</span> </span><br><span class="line">        from t_student where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置主键回填，供t_student_selfcard的student_id字段使用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;createStudent&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;student&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        insert into t_student(cnname,sex,selfcard_no,note) values (#&#123;cnName&#125;,</span><br><span class="line">        #&#123;sex,typeHandler=org.apache.ibatis.type.EnumTypeHandler&#125;,</span><br><span class="line">        #&#123;selfCardNo&#125;,#&#123;note&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>先插入一些测试数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = SqlSessionFactoryUtil.openSqlSession();</span><br><span class="line">StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">StudentLectureMapper lectureMapper = sqlSession.getMapper(StudentLectureMapper.class);</span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.setCnName(<span class="string">&quot;水门&quot;</span>);</span><br><span class="line">student.setSelfCardNo(<span class="number">11111L</span>);</span><br><span class="line">student.setNote(<span class="string">&quot;波风水门&quot;</span>);</span><br><span class="line">student.setSex(Sex.MALE);</span><br><span class="line"><span class="keyword">int</span> n = studentMapper.createStudent(student);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">    Long studentId = student.getId();</span><br><span class="line">    String[] noteArr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;语文成绩&quot;</span>,<span class="string">&quot;数学成绩&quot;</span>,<span class="string">&quot;英语成绩&quot;</span>&#125;;</span><br><span class="line">    Double[] gradeArr = <span class="keyword">new</span> Double[]&#123;<span class="number">99.0</span>,<span class="number">100.0</span>,<span class="number">98.0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;noteArr.length;i++)&#123;</span><br><span class="line">        StudentLecture lecture = <span class="keyword">new</span> StudentLecture();</span><br><span class="line">        lecture.setStudentId(studentId);</span><br><span class="line">        lecture.setLectureId(Long.valueOf(i));</span><br><span class="line">        lecture.setGrade(gradeArr[i]);</span><br><span class="line">        lecture.setNote(noteArr[i]);</span><br><span class="line">        lectureMapper.insertStudentLecture(lecture);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sqlSession.commit();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>查询数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_student;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+-------------+------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> cnname <span class="operator">|</span> sex    <span class="operator">|</span> selfcard_no <span class="operator">|</span> note       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+-------------+------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span> 辛久奈 <span class="operator">|</span> FEMALE <span class="operator">|</span>       <span class="number">10000</span> <span class="operator">|</span> 旋涡辛久奈  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12</span> <span class="operator">|</span> 水门   <span class="operator">|</span> MALE   <span class="operator">|</span>       <span class="number">11111</span> <span class="operator">|</span> 波风水门    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+-------------+------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_student_lecture;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+------------+--------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> student_id <span class="operator">|</span> lecture_id <span class="operator">|</span> grade  <span class="operator">|</span> note     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+------------+--------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span>         <span class="number">12</span> <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span>  <span class="number">99.00</span> <span class="operator">|</span> 语文成绩  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span>         <span class="number">12</span> <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> <span class="number">100.00</span> <span class="operator">|</span> 数学成绩  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span>         <span class="number">12</span> <span class="operator">|</span>          <span class="number">2</span> <span class="operator">|</span>  <span class="number">98.00</span> <span class="operator">|</span> 英语成绩  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+------------+--------+----------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>插入成功，现测试级联获取lectures：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = SqlSessionFactoryUtil.openSqlSession();</span><br><span class="line">StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">Student student = studentMapper.findStudentById(<span class="number">12L</span>);</span><br><span class="line">List&lt;StudentLecture&gt; lectures = student.getLectures();</span><br><span class="line"><span class="keyword">for</span>(StudentLecture l : lectures)&#123;</span><br><span class="line">    System.out.println(l.getNote()+<span class="string">&quot;：&quot;</span>+l.getGrade());</span><br><span class="line">&#125; </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">语文成绩：99.0</span><br><span class="line">数学成绩：100.0</span><br><span class="line">英语成绩：98.0</span><br></pre></td></tr></table></figure>

<p>success.</p>
<h2 id="discriminator"><a href="#discriminator" class="headerlink" title="discriminator"></a>discriminator</h2><p>鉴别器其实同其他级联一样，只不过是多了个鉴别的过程罢了。</p>
<p>为了学习鉴别器，我们向t_student_health_female和t_student_health_male中插入一组数据：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">INSERT INTO `t_student_health_female`</span><br><span class="line">VALUES(</span><br><span class="line">    1,</span><br><span class="line">    &#x27;10&#x27;,</span><br><span class="line">    &#x27;2017-1-6&#x27;,</span><br><span class="line">    &#x27;心正常&#x27;,</span><br><span class="line">    &#x27;肝正常&#x27;,</span><br><span class="line">    &#x27;脾正常&#x27;,</span><br><span class="line">    &#x27;肺正常&#x27;,</span><br><span class="line">    &#x27;肾正常&#x27;,</span><br><span class="line">    &#x27;子宫正常&#x27;,</span><br><span class="line">    &#x27;健康&#x27;);</span><br><span class="line"> </span><br><span class="line">INSERT INTO `t_student_health_male`</span><br><span class="line">VALUES(</span><br><span class="line">    1,</span><br><span class="line">    &#x27;12&#x27;,</span><br><span class="line">    &#x27;2017-1-6&#x27;,</span><br><span class="line">    &#x27;心脏良好&#x27;,</span><br><span class="line">    &#x27;肝良好&#x27;,</span><br><span class="line">    &#x27;脾良好&#x27;,</span><br><span class="line">    &#x27;肺良好&#x27;,</span><br><span class="line">    &#x27;肾良好&#x27;,</span><br><span class="line">    &#x27;前列腺良好&#x27;,</span><br><span class="line">    &#x27;健康&#x27;);</span><br></pre></td></tr></table></figure>

<p>其对应的实体类StudentHealthFemale和StudentHealthMale略。</p>
<p>新增两个POJO：MaleStudent和FemaleStudent均继承自Student：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaleStudent</span> <span class="keyword">extends</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;StudentHealthMale&gt; studentHealthMaleList;</span><br><span class="line">   <span class="comment">// getter，setter略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FemaleStudent</span> <span class="keyword">extends</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;StudentHealthFemale&gt; studentHealthFemaleList;</span><br><span class="line">    <span class="comment">// getter，setter略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着编写两个接口StudentHealthMaleMapper和StudentHealthFemaleMapper，包含一个根据studentId获取health的抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mrbird.leanote.pojo.StudentHealthMale;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentHealthMaleMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentHealthMale <span class="title">findStudentHealthMaleByStudentId</span><span class="params">(Long studentId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mrbird.leanote.pojo.StudentHealthFemale;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentHealthFemaleMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentHealthFemale <span class="title">findStudentHealthFemaleByStudentId</span><span class="params">(Long studentId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>各自对应的映射器：</p>
<p>StudentHealthMaleMapper.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>    </span><br><span class="line">    <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>   </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentHealthMaleMapper&quot;</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findStudentHealthMaleByStudentId&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">resultType</span>=<span class="string">&quot;studentHealthMale&quot;</span>&gt;</span></span><br><span class="line">        select * from t_student_health_male where student_id = #&#123;studentId&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为在MyBatis配置文件中配置了<code>&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</code>，并且数据库命名规范，所以这里可以用select * from…</p>
<p>studentHealthFemaleMapper.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>   </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentHealthFemaleMapper&quot;</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findStudentHealthFemaleByStudentId&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">resultType</span>=<span class="string">&quot;studentHealthFemale&quot;</span>&gt;</span></span><br><span class="line">        select * from t_student_health_female where student_id = #&#123;studentId&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接下来就是重点了，我们修改StudentMapper.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>    </span><br><span class="line">    <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>   </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentMapper&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 定义maleStudentList，类型为“maleStudent”。这是一个一对多关联，一个学生可以体检多次。</span></span><br><span class="line"><span class="comment">        调用的方法为findStudentHealthMaleByStudentId。</span></span><br><span class="line"><span class="comment">        正如其POJO继承Student那样，resultMap也同样继承自studentList--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;maleStudent&quot;</span> <span class="attr">id</span>=<span class="string">&quot;maleStudentList&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;studentList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;studentHealthMaleList&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">select</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentHealthMaleMapper</span></span></span><br><span class="line"><span class="string"><span class="tag">                .findStudentHealthMaleByStudentId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;femaleStudent&quot;</span> <span class="attr">id</span>=<span class="string">&quot;femaleStudentList&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;studentList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;studentHealthFemaleList&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">select</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentHealthFemaleMapper</span></span></span><br><span class="line"><span class="string"><span class="tag">                .findStudentHealthFemaleByStudentId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;student&quot;</span> <span class="attr">id</span>=<span class="string">&quot;studentList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;cnname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;cnName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;selfcard_no&quot;</span> <span class="attr">property</span>=<span class="string">&quot;selfCardNo&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;note&quot;</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置鉴别器，类似于switch，用于鉴别的列为“sex”，</span></span><br><span class="line"><span class="comment">            值为MALE时结果集为maleStudentList</span></span><br><span class="line"><span class="comment">            值为FEMALE时结果集为femaleStudentList --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;MALE&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;maleStudentList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;FEMALE&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;femaleStudentList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;student_column&quot;</span>&gt;</span></span><br><span class="line">        id,cnname as cnName,sex,selfcard_no as selfCardNo,note </span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findStudentById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentList&quot;</span>&gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;student_column&quot;</span>/&gt;</span> </span><br><span class="line">        from t_student where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = SqlSessionFactoryUtil.openSqlSession();</span><br><span class="line">StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">MaleStudent student = (MaleStudent) studentMapper.findStudentById(<span class="number">12L</span>);</span><br><span class="line">System.out.println(student.getCnName()+<span class="string">&quot;的&quot;</span>+</span><br><span class="line">    student.getStudentHealthMaleList().get(<span class="number">0</span>).getProstate());</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>页面输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">水门的前例腺良好</span><br></pre></td></tr></table></figure>

<h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><p>假如一次性将所有与Student有关的信息都加载出来，这必定会造成性能的问题，如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>    </span><br><span class="line">    <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>   </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentMapper&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;student&quot;</span> <span class="attr">id</span>=<span class="string">&quot;studentList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;cnname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;cnName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;selfcard_no&quot;</span> <span class="attr">property</span>=<span class="string">&quot;selfCardNo&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;note&quot;</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;selfCard&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">select</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentSelfcardMapper</span></span></span><br><span class="line"><span class="string"><span class="tag">                .findStudentSelfcardByStudentId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;lectures&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">select</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentLectureMapper</span></span></span><br><span class="line"><span class="string"><span class="tag">                .getLecturesByStudentId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;MALE&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;maleStudentList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;FEMALE&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;femaleStudentList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  ...  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>MyBatis的延迟加载策略可以很好的应对这种情况。只需在mybatis-config.xml中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">&lt;!-- 开启延迟加载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 关闭按层级加载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在级联标签上可以自由的配置fetchType=”lazy”或者fetchType=”eager”来改变加载策略。</p>
<h2 id="另外一种级联"><a href="#另外一种级联" class="headerlink" title="另外一种级联"></a>另外一种级联</h2><p>所谓的另外一种级联就是用一条sql查出所有学生的信息，没有性能问题。</p>
<p>在StudentMapper中定义一个查找所有学生信息的抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">finAllStudentMsg</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>其映射文件如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>    </span><br><span class="line">    <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>   </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentMapper&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;finAllStudentMsg&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;allStudentList&quot;</span>&gt;</span></span><br><span class="line">        select s.id,s.cnname,s.sex,s.selfcard_no,s.note as snote,</span><br><span class="line">        IF (s.sex = &#x27;MALE&#x27;,shm.id,shf.id) as hid,</span><br><span class="line">        IF (s.sex = &#x27;MALE&#x27;,shm.check_date,shf.check_date) as checkDate,</span><br><span class="line">        IF (s.sex = &#x27;MALE&#x27;,shm.heart,shf.heart) as heart,</span><br><span class="line">        IF (s.sex = &#x27;MALE&#x27;,shm.liver,shf.liver) as liver,</span><br><span class="line">        IF (s.sex = &#x27;MALE&#x27;,shm.spleen,shf.spleen) as spleen,</span><br><span class="line">        IF (s.sex = &#x27;MALE&#x27;,shm.lung,shf.lung) as lung,</span><br><span class="line">        IF (s.sex = &#x27;MALE&#x27;,shm.kidney,shf.kidney) as kidney,</span><br><span class="line">        IF (s.sex = &#x27;MALE&#x27;,shm.note,shf.note) as hnote,</span><br><span class="line">        shm.prostate,shf.uterus,</span><br><span class="line">        ss.id as ssid,ss.native as natives,</span><br><span class="line">        ss.issue_date as issueDate,ss.end_date as endDate,</span><br><span class="line">        ss.note as ssNote,</span><br><span class="line">        sl.id as slid,sl.lecture_id as lectureId,sl.grade,</span><br><span class="line">        sl.note as slNote </span><br><span class="line">        FROM t_student s </span><br><span class="line">        LEFT JOIN t_student_health_male shm on s.id = shm.student_id </span><br><span class="line">        LEFT JOIN t_student_health_female shf on s.id = shf.student_id </span><br><span class="line">        LEFT JOIN t_student_selfcard ss on s.id = ss.student_id </span><br><span class="line">        LEFT JOIN t_student_lecture sl on s.id = sl.student_id </span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;student&quot;</span> <span class="attr">id</span>=<span class="string">&quot;allStudentList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;cnname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;cnName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;selfcard_no&quot;</span> <span class="attr">property</span>=<span class="string">&quot;selfCardNo&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;snote&quot;</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- javaType属性告诉MyBtis用哪个类去映射这些字段 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;selfCard&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;studentSelfcard&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ssid&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;studentId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;natives&quot;</span> <span class="attr">column</span>=<span class="string">&quot;natives&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;issueDate&quot;</span> <span class="attr">column</span>=<span class="string">&quot;issueDate&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;endDate&quot;</span> <span class="attr">column</span>=<span class="string">&quot;endDate&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ssNote&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;lectures&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;studentLecture&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;slid&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;studentId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;lectureId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;lectureId&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;grade&quot;</span> <span class="attr">column</span>=<span class="string">&quot;grade&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span> <span class="attr">column</span>=<span class="string">&quot;slNote&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;MALE&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;maleStudentList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;FEMALE&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;femaleStudentList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;maleStudent&quot;</span> <span class="attr">id</span>=<span class="string">&quot;maleStudentList&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;allStudentList&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ofType属性指定了其泛型 --&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;studentHealthMaleList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;studentHealthMale&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;hid&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;studentId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;checkDate&quot;</span> <span class="attr">column</span>=<span class="string">&quot;checkDate&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;heart&quot;</span> <span class="attr">column</span>=<span class="string">&quot;heart&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;liver&quot;</span> <span class="attr">column</span>=<span class="string">&quot;liver&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;spleen&quot;</span> <span class="attr">column</span>=<span class="string">&quot;spleen&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;lung&quot;</span> <span class="attr">column</span>=<span class="string">&quot;lung&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;kidney&quot;</span> <span class="attr">column</span>=<span class="string">&quot;kidney&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;prostate&quot;</span> <span class="attr">column</span>=<span class="string">&quot;prostate&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span> <span class="attr">column</span>=<span class="string">&quot;hnote&quot;</span>/&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;femaleStudent&quot;</span> <span class="attr">id</span>=<span class="string">&quot;femaleStudentList&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;allStudentList&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;studentHealthFemaleList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;studentHealthFemale&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;hid&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;studentId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;checkDate&quot;</span> <span class="attr">column</span>=<span class="string">&quot;checkDate&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;heart&quot;</span> <span class="attr">column</span>=<span class="string">&quot;heart&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;liver&quot;</span> <span class="attr">column</span>=<span class="string">&quot;liver&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;spleen&quot;</span> <span class="attr">column</span>=<span class="string">&quot;spleen&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;lung&quot;</span> <span class="attr">column</span>=<span class="string">&quot;lung&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;kidney&quot;</span> <span class="attr">column</span>=<span class="string">&quot;kidney&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;uterus&quot;</span> <span class="attr">column</span>=<span class="string">&quot;uterus&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span> <span class="attr">column</span>=<span class="string">&quot;hnote&quot;</span>/&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试finAllStudentMsg方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = SqlSessionFactoryUtil.openSqlSession();</span><br><span class="line">StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">List&lt;Student&gt; students = studentMapper.finAllStudentMsg();</span><br><span class="line"><span class="keyword">for</span>(Student student : students)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;MALE&quot;</span>.equalsIgnoreCase(student.getSex().toString()))&#123;</span><br><span class="line">        MaleStudent male = (MaleStudent) student;</span><br><span class="line">        System.out.println(male.getCnName()+<span class="string">&quot;的卡号：&quot;</span>+male.getSelfCardNo());</span><br><span class="line">        StudentSelfcard selfcard = male.getSelfCard();</span><br><span class="line">        System.out.println(<span class="string">&quot;来自：&quot;</span>+selfcard.getNatives()+<span class="string">&quot;,&quot;</span>+selfcard.getNote());</span><br><span class="line">        List&lt;StudentLecture&gt; lectures = male.getLectures();</span><br><span class="line">        <span class="keyword">for</span>(StudentLecture le : lectures)&#123;</span><br><span class="line">            System.out.println(le.getNote()+<span class="string">&quot;：&quot;</span>+le.getGrade());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;StudentHealthMale&gt; healthMales = male.getStudentHealthMaleList();</span><br><span class="line">        <span class="keyword">for</span>(StudentHealthMale healthMale : healthMales)&#123;</span><br><span class="line">            System.out.println(healthMale.getCheckDate()+<span class="string">&quot;，&quot;</span>+healthMale.getProstate());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	FemaleStudent female = (FemaleStudent) student;</span><br><span class="line">    	System.out.println(female.getCnName()+<span class="string">&quot;的卡号：&quot;</span>+female.getSelfCardNo());</span><br><span class="line">    	StudentSelfcard selfcard = female.getSelfCard();</span><br><span class="line">    	System.out.println(<span class="string">&quot;来自：&quot;</span>+selfcard.getNatives()+<span class="string">&quot;,&quot;</span>+selfcard.getNote());</span><br><span class="line">    	List&lt;StudentLecture&gt; lectures = female.getLectures();</span><br><span class="line">    	<span class="keyword">for</span>(StudentLecture le : lectures)&#123;</span><br><span class="line">            System.out.println(le.getNote()+<span class="string">&quot;：&quot;</span>+le.getGrade());</span><br><span class="line">    	&#125;</span><br><span class="line">    	List&lt;StudentHealthFemale&gt; healthFemales = female.getStudentHealthFemaleList();</span><br><span class="line">    	<span class="keyword">for</span>(StudentHealthFemale healthfemale : healthFemales)&#123;</span><br><span class="line">            System.out.println(healthfemale.getCheckDate()+<span class="string">&quot;，&quot;</span>+healthfemale.getUterus());</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">辛久奈的卡号：10000</span><br><span class="line">来自：福州,旋涡辛久奈的学生证</span><br><span class="line">语文成绩：99.0</span><br><span class="line">数学成绩：99.0</span><br><span class="line">英语成绩：99.0</span><br><span class="line">2017<span class="string">-1</span><span class="string">-6</span>，子宫正常</span><br><span class="line">水门的卡号：11111</span><br><span class="line">来自：厦门,波风水门的学生证</span><br><span class="line">语文成绩：99.0</span><br><span class="line">数学成绩：100.0</span><br><span class="line">英语成绩：98.0</span><br><span class="line">2017<span class="string">-1</span><span class="string">-6</span>，前例腺良好</span><br></pre></td></tr></table></figure>

<p>这种方式比较直观明了，但是SQL编写起来较为繁琐。</p>
]]></content>
      <tags>
        <tag>MyBatis, 级联</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring框架</title>
    <url>/2020/02/23/Spring%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>Spring作为现在最优秀的框架之一，被广泛地使用并且其地位越来越重要。”Spring全家桶”这个词也逐渐流行于程序员间。但无论Spring家族如何变化，其最核心的永远是Spring中的骨架——Spring Bean/Spring Core/Spring Context，这三个jar包是所有Spring工具的使用基础，也是整个Spring框架的基础结构。</p>
<span id="more"></span>

<h2 id="Spring基础架构"><a href="#Spring基础架构" class="headerlink" title="Spring基础架构"></a>Spring基础架构</h2><blockquote>
<p>Spring框架的总体架构图：</p>
<p><img src="/images/Spring%E6%A1%86%E6%9E%B6.png"></p>
<p>Spring的核心组件只有3个：Core/Context/Bean，它们构建起了整个Spring的骨架。其中Bean更是核心中的核心。</p>
<p>其实Spring就是面向Bean的编程(Bean Oriented Programming BOP)，Bean在Spring中的作用就像Object对OOP面向对象编程的意义一样，没有Bean对象就没有Spring存在的意义。而Spring之所以这么流行，就在于Spring解决了一个关键的问题：<strong>将对象间的依赖关系转为配置文件进行管理(依赖注入机制)。Spring将根据配置信息创建对象并将对象包装成Bean对象，然后又提供一个IOC容器，对容器中的Bean对象进行管理，并管理Bean对象间的依赖注入关系。</strong></p>
<p>这个IOC容器就是由Context来提供。Context要发现每个Bean之间的关系，并为Bean建立和维护好这种关系。所以，从另一个角度来说，Context也是一个Bean关系的集合，只不过我们将这种集合称为容器，更具体地说是叫IOC容器。一旦建立好这个容器，Spring就可以开始工作。</p>
<p>Core，其实更应该称为Util。它提供了发现Bean，建立Bean，维护每个Bean间关系所需要的一系列工具，是一个工具组件。</p>
</blockquote>
<h3 id="核心组件Bean"><a href="#核心组件Bean" class="headerlink" title="核心组件Bean"></a>核心组件Bean</h3><p>Bean组件：<code>org.springframework.beans</code></p>
<p>这个包下的类主要解决3件事情：Bean的定义、Bean的创建、Bean的解析</p>
<p>对于开发者来说，只需要了解Bean的创建，而Bean的定义，Bean的解析由Spring在内部完成，对开发者是透明的。也正因如此，使用Spring十分简单，就像面对对象编程中创建对象一样，你只需要知道如何创建(new)，创建过程对你来说是透明的。</p>
<blockquote>
<p><img src="/images/Bean%E5%B7%A5%E5%8E%82%E7%9A%84%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<p>Spring Bean是典型的工厂模式，顶级接口为BeanFactory。</p>
<p>BeanFactory有3个子类：ListableBeanFactory/HierarchicalBeanFactory/AutowireCapableBeanFactory(这从图中可以看出，hierarchical含义为体系的，等级的)，最终的默认实现类为DefaultListableBeanFactory，实现了所有接口。</p>
<p>为什么要定义这么多接口层次？其实每个接口都有它的使用场景，并对对象的数据访问做限制。比如ListableBeanFactory接口表示Bean是可列表的；HierarchicalBeanFactory接口表示Bean是有继承关系的(Bean有父Bean)；AutowireCapableBeanFactory接口定义Bean的自动装配规则。这可以从代码得到一窥：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String var1, Class&lt;T&gt; var2)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String var1, Object... var2)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; var1, Object... var2)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(Class&lt;T&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(ResolvableType var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String var1)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String var1)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String var1, ResolvableType var2)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String var1, Class&lt;?&gt; var2)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getType(String var1) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getType(String var1, <span class="keyword">boolean</span> var2) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    String[] getAliases(String var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略一些方法</span></span><br><span class="line">    String[] getBeanDefinitionNames();</span><br><span class="line">    </span><br><span class="line">    String[] getBeanNamesForType(ResolvableType var1);</span><br><span class="line">    </span><br><span class="line">    String[] getBeanNamesForType(ResolvableType var1, <span class="keyword">boolean</span> var2, <span class="keyword">boolean</span> var3);</span><br><span class="line">    </span><br><span class="line">    String[] getBeanNamesForType(<span class="meta">@Nullable</span> Class&lt;?&gt; var1);</span><br><span class="line">    </span><br><span class="line">    String[] getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt; var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HierarchicalBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">BeanFactory <span class="title">getParentBeanFactory</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsLocalBean</span><span class="params">(String var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> AUTOWIRE_NO = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> AUTOWIRE_BY_NAME = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> AUTOWIRE_BY_TYPE = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> AUTOWIRE_CONSTRUCTOR = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//省略一些方法</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">createBean</span><span class="params">(Class&lt;T&gt; var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">autowireBean</span><span class="params">(Object var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Object <span class="title">configureBean</span><span class="params">(Object var1, String var2)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Object <span class="title">createBean</span><span class="params">(Class&lt;?&gt; var1, <span class="keyword">int</span> var2, <span class="keyword">boolean</span> var3)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Object <span class="title">autowire</span><span class="params">(Class&lt;?&gt; var1, <span class="keyword">int</span> var2, <span class="keyword">boolean</span> var3)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当Spring成功解析定义的一个&lt;bean/&gt;节点(@Component,@Bean)后，在Spring内部它就被转化成BeanDefinition对象，之后所有的操作都是对这个对象进行。</strong></p>
<p>Bean的解析过程比较复杂，主要就是对Spring配置文件的解析，之后再进行学习了解。</p>
</blockquote>
<h3 id="核心组件Context"><a href="#核心组件Context" class="headerlink" title="核心组件Context"></a>核心组件Context</h3><blockquote>
<p>Context组件类结构图：</p>
<p><img src="/images/Context%E7%BB%84%E4%BB%B6%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<p>从图中我们可知，ApplicationContext是Context的顶级父类，有两个子类：ConfigurableApplicationContext和WebApplicationContext。ApplicationContext继承了BeanFactory，说明Spring容器的主体是Bean对象。此外，ApplicationContext还继承了多个接口，这主要是用于扩展ApplicationContext的功能。比如ApplicationContext继承的ResourceLoader接口，可以使ApplicationContext访问到任何外部资源。</p>
<p>主要对ApplicationContext的子类做个简要说明：</p>
<ul>
<li>ConfigurableApplicationContext表示该Context是可修改的，也就是说在构建Context时，用户可以动态地添加或修改已有的配置信息。ConfigurableApplicationContext有多个子类，使用较多的是AbstractRefreshableApplicationContext类，为可更新Context。</li>
<li>WebApplicationContext顾名思义就是为Web准备的Context，可以直接访问ServletContext。这个接口用的比较少。</li>
</ul>
<p>总的来说，ApplicationContext必须要完成以下几件事：</p>
<ol>
<li>标识一个应用环境</li>
<li>利用BeanFactory创建Bean对象</li>
<li>保存对象间的关系表</li>
<li>捕获各种事件</li>
</ol>
</blockquote>
<h3 id="核心组件Core"><a href="#核心组件Core" class="headerlink" title="核心组件Core"></a>核心组件Core</h3><blockquote>
<p>Core组件包含了许多关键类，一个比较重要的部分就是定义了资源的访问方式。</p>
</blockquote>
<h3 id="IOC容器如何工作"><a href="#IOC容器如何工作" class="headerlink" title="IOC容器如何工作"></a>IOC容器如何工作</h3><blockquote>
<p>IOC容器实际上是Context组件和其他两个组件beans和core共同构建的一个Bean关系网。Bean关系网具体构建过程，在context包的AbstractApplicationContext类的refresh方法中。就其源码和注释，开始分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">			<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">            <span class="comment">// 准备用于刷新的context</span></span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 告诉子类刷新内部的BeanFactory并获取用于在context中创建Bean对象的BeanFactory，</span></span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 配置BeanFactory所需要的contex特征(环境)</span></span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">                <span class="comment">// 允许context的子类对BeanFactory进行后处理</span></span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">                <span class="comment">// 激活BeanFactory的PostProcessor并将其注册为context的bean对象，用于拦截bean</span></span><br><span class="line">                <span class="comment">//对象的创建</span></span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">				<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">                <span class="comment">// 初始化context的MessageSource</span></span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">                <span class="comment">// 初始化context的EventMulticaster</span></span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">                <span class="comment">// 初始化特定的context子类中的特定Bean对象</span></span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">                <span class="comment">// 检查并注册Listener监听器的Bean对象</span></span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">                <span class="comment">// 实例化所有non-lazy-init的单例Bean</span></span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">                <span class="comment">// 发布相应的事件</span></span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">					logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">							<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">				<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">				resetCommonCaches();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>refresh方法就是构建整个IOC容器过程的完整代码，要知道如何构建IOC容器的，就需要对上面的代码进行研究。大体步骤如下：</p>
<ol>
<li>构建BeanFactory，以便生产Bean对象</li>
<li>注册相关事件</li>
<li>创建Bean实例对象</li>
<li>触发被监听的事件</li>
</ol>
<h4 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh()"></a>prepareRefresh()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prepare this context for refreshing, setting its startup date and</span></span><br><span class="line"><span class="comment"> * active flag as well as performing any initialization of property sources.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 准备用于刷新的context，设定开始日期，活动标识，初始化属性源</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Switch to active.</span></span><br><span class="line">	<span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">	<span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Refreshing &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Refreshing &quot;</span> + getDisplayName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line">       <span class="comment">//由具体子类实现，父类中该方法默认为空方法</span></span><br><span class="line">	initPropertySources();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Validate that all properties marked as required are resolvable:</span></span><br><span class="line">	<span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">	getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">		<span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">		<span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">	<span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">	<span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory()"></a>obtainFreshBeanFactory()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the fresh BeanFactory instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	refreshBeanFactory();  <span class="comment">//父类方法没有实现，只有在子类 AbstractRefreshableApplicationContext中才有实现</span></span><br><span class="line">	<span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// refreshBeanFactory()方法实现</span></span><br><span class="line">	<span class="comment">// 刷新context用于生产Bean对象的BeanFactory，如果它已经存在则将其关闭，不存在则创建一个新的BeanFactory用于context生命周期的下一个阶段</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * This implementation performs an actual refresh of this context&#x27;s underlying</span></span><br><span class="line"><span class="comment">	 * bean factory, shutting down the previous bean factory (if any) and</span></span><br><span class="line"><span class="comment">	 * initializing a fresh bean factory for the next phase of the context&#x27;s lifecycle.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">//BeanFactory存在则关闭</span></span><br><span class="line">		<span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">			destroyBeans();</span><br><span class="line">			closeBeanFactory();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//不存在则创建</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里采用BeanFactory的默认子类DefaultListableBeanFactory作为context的BeanFactory</span></span><br><span class="line">			DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">			beanFactory.setSerializationId(getId());</span><br><span class="line">			customizeBeanFactory(beanFactory);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//这行代码最为关键，解析Bean的定义，将其加载到BeanFactory中。换句话说就是加载解析Bean的定义，将用户自定义的数据结构转化为IOC容器中的数据结构，这样一来，才能被BeanFactory构建成一个Bean对象</span></span><br><span class="line">			loadBeanDefinitions(beanFactory); </span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">				<span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="prepareBeanFactory-ConfigurableListableBeanFactory"><a href="#prepareBeanFactory-ConfigurableListableBeanFactory" class="headerlink" title="prepareBeanFactory(ConfigurableListableBeanFactory)"></a>prepareBeanFactory(ConfigurableListableBeanFactory)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置BeanFactory所需要的contex特征(环境)</span></span><br><span class="line"><span class="comment">// 如context的类加载器和后处理器</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configure the factory&#x27;s standard context characteristics,</span></span><br><span class="line"><span class="comment"> * such as the context&#x27;s ClassLoader and post-processors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the BeanFactory to configure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Tell the internal bean factory to use the context&#x27;s class loader etc.</span></span><br><span class="line">	beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">	beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">	beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">	beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">	<span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">	beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">	beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">	beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">	beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">		<span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">		beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register default environment beans.</span></span><br><span class="line">	<span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="postProcessBeanFactory、invokeBeanFactoryPostProcessors、registerBeanPostProcessors"><a href="#postProcessBeanFactory、invokeBeanFactoryPostProcessors、registerBeanPostProcessors" class="headerlink" title="postProcessBeanFactory、invokeBeanFactoryPostProcessors、registerBeanPostProcessors"></a>postProcessBeanFactory、invokeBeanFactoryPostProcessors、registerBeanPostProcessors</h4><p>三个方法主要用于Spring的功能扩展。postProcessBeanFactory用于对已经构建的BeanFactory的配置做修改，invokeBeanFactoryPostProcessors和registerBeanPostProcessors则是可以对创建的Bean对象添加一些自定义的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于在BeanFactory初始化后修改ApplicationContext内部BeanFactory。此时所有的Bean的定义</span></span><br><span class="line"><span class="comment">// 已经被加载，但是还未被实例化。因此，可以允许在特定的ApplicationContext中注册特殊的</span></span><br><span class="line"><span class="comment">// BeanPostProcessors等，扩展Spring功能。</span></span><br><span class="line"><span class="comment">// 在具体子类中实现，父类提供空方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Modify the application context&#x27;s internal bean factory after its standard</span></span><br><span class="line"><span class="comment"> * initialization. All bean definitions will have been loaded, but no beans</span></span><br><span class="line"><span class="comment"> * will have been instantiated yet. This allows for registering special</span></span><br><span class="line"><span class="comment"> * BeanPostProcessors etc in certain ApplicationContext implementations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当有明确的指令时，实例化和激活所有已注册的BeanFactoryPostProcessor的Bean对象</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and invoke all registered BeanFactoryPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before singleton instantiation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">	<span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">		beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Instantiate and register all BeanPostProcessor beans,</span></span><br><span class="line"><span class="comment">	 * respecting explicit order if given.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Must be called before any instantiation of application beans.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="initMessageSource-、initApplicationEventMulticaster-、onRefresh-、registerListeners"><a href="#initMessageSource-、initApplicationEventMulticaster-、onRefresh-、registerListeners" class="headerlink" title="initMessageSource()、initApplicationEventMulticaster()、onRefresh()、registerListeners()"></a>initMessageSource()、initApplicationEventMulticaster()、onRefresh()、registerListeners()</h4><p>这几个方法主要是初始化操作，以及初始化监听事件、对系统其他监听者的注册。</p>
<h4 id="finishBeanFactoryInitialization-beanFactory"><a href="#finishBeanFactoryInitialization-beanFactory" class="headerlink" title="finishBeanFactoryInitialization(beanFactory)"></a>finishBeanFactoryInitialization(beanFactory)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结束context的BeanFactory的初始化过程</span></span><br><span class="line"><span class="comment">// 并初始化non-lazy单例Bean对象</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the initialization of this context&#x27;s bean factory,</span></span><br><span class="line"><span class="comment"> * initializing all remaining singleton beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">			beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">		beanFactory.setConversionService(</span><br><span class="line">				beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">	<span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">	<span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">	<span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">		beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">	String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">		getBean(weaverAwareName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Bean的实例化代码，由3个方法完成</span></span><br><span class="line">       <span class="comment">// 不使用TempClassLoader类加载器</span></span><br><span class="line">	<span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">	beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 禁止修改当前Bean的配置信息</span></span><br><span class="line">	<span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">	beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 实例化non-lazy-init类型的单例Bean</span></span><br><span class="line">	<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">	beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Bean的实例化代码，我们也可看出，Bean的实例化都在BeanFactory完成。比较重要的方法就是preInstantiateSingletons方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.trace(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">        Iterator var2 = beanNames.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            String beanName;</span><br><span class="line">            Object bean;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    RootBeanDefinition bd;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="keyword">do</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (!var2.hasNext()) &#123;</span><br><span class="line">                                    var2 = beanNames.iterator();</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">                                        <span class="comment">//核心实现部分</span></span><br><span class="line">                                        beanName = (String)var2.next();</span><br><span class="line">                                        Object singletonInstance = <span class="keyword">this</span>.getSingleton(beanName);</span><br><span class="line">                                        <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">                                            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton)singletonInstance;</span><br><span class="line">                                            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                                AccessController.doPrivileged(() -&gt; &#123;</span><br><span class="line">                                                    smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                                                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                                                &#125;, <span class="keyword">this</span>.getAccessControlContext());</span><br><span class="line">                                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">return</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                beanName = (String)var2.next();</span><br><span class="line">                                bd = <span class="keyword">this</span>.getMergedLocalBeanDefinition(beanName);</span><br><span class="line">                            &#125; <span class="keyword">while</span>(bd.isAbstract());</span><br><span class="line">                        &#125; <span class="keyword">while</span>(!bd.isSingleton());</span><br><span class="line">                    &#125; <span class="keyword">while</span>(bd.isLazyInit());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.isFactoryBean(beanName)) &#123;</span><br><span class="line">                        bean = <span class="keyword">this</span>.getBean(<span class="string">&quot;&amp;&quot;</span> + beanName);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">this</span>.getBean(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span>(!(bean <span class="keyword">instanceof</span> FactoryBean));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//FactoryBean，一个重要的Bean对象，大部分扩展功能都与之相关</span></span><br><span class="line">            FactoryBean&lt;?&gt; factory = (FactoryBean)bean;</span><br><span class="line">            <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                SmartFactoryBean var10000 = (SmartFactoryBean)factory;</span><br><span class="line">                ((SmartFactoryBean)factory).getClass();</span><br><span class="line">                isEagerInit = (Boolean)AccessController.doPrivileged(var10000::isEagerInit, <span class="keyword">this</span>.getAccessControlContext());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isEagerInit = factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp; ((SmartFactoryBean)factory).isEagerInit();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在preInstantiateSingletons方法中出现了一个比较重要的Bean——FactoryBean。Spring多数的扩展功能都和该Bean有关。FactoryBean是一个工厂的Bean(将工厂包装成Bean对象)，是用于生产Bean实例对象的Bean。如果一个类继承FactoryBean，就可以自己定义生产Bean实例对象的方法，只需要继承它的getObject方法即可，然后在Spring内部，继承FactoryBean的类就会被实例化成FactoryBean的实例对象，再通过调用其getObject方法就能获取用户自定义的对象，从而为Spring提供良好的扩展性。</p>
<p>该方法的主要创建流程如下：</p>
<p><img src="/images/bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
</blockquote>
<h3 id="IOC容器的扩展"><a href="#IOC容器的扩展" class="headerlink" title="IOC容器的扩展"></a>IOC容器的扩展</h3><blockquote>
<p>Bean对象需要有一定的扩展性，前面也稍微提了一些用于扩展Bean对象功能的接口，主要有：BeanFactoryProcessor和BeanPostProcessor，它们分别在构建BeanFactory和构建Bean对象时调用。还有就是InitializingBean和DisposableBean，分别在Bean实例创建和销毁时被调用。可以实现这些接口中的方法，Spring在需要的时候会调用它们。另外一个比较重要的扩展就是FactoryBean，虽然它也是个Bean对象，但是是特殊的Bean对象，可以被用户更多地控制。</p>
<p>自己目前的水平，看这些东西是迷迷糊糊的，看部分内容可以看得懂，但是想要去学习更多，就显得吃力，困难。而Spring要掌握好内在机理，就看有没有掌握好Spring的扩展点，如何使用这些扩展点。很明显，写这篇博客的自己还没有达到这个水平。但我会加油，以后，希望自己能回来重新搞懂。</p>
</blockquote>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Linux命令第二版</title>
    <url>/2020/03/25/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4%E7%AC%AC%E4%BA%8C%E7%89%88/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><blockquote>
<h4 id="set和printenv"><a href="#set和printenv" class="headerlink" title="set和printenv"></a>set和printenv</h4><p>shell在环境中存储了两种变量，shell变量（bash存放的少量数据），环境变量（除shell变量外的其他所有变量）。此外，shell还存储了别名和shell函数。</p>
<p>set命令会同时显示shell变量和环境变量，printenv只会显示环境变量，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set | less   重定向到less便于查看</span><br><span class="line">printenv | less</span><br><span class="line">查看某个特定的变量：</span><br><span class="line">printenv USER</span><br></pre></td></tr></table></figure>

<p>常用变量：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SHELL</td>
<td>本机shell名称</td>
</tr>
<tr>
<td>HOME</td>
<td>本机主目录的路径</td>
</tr>
<tr>
<td>LANG</td>
<td>本机语言的字符集和排序规则</td>
</tr>
<tr>
<td>PATH</td>
<td>以冒号分割的一个目录列表</td>
</tr>
<tr>
<td>PWD</td>
<td>当前工作目录</td>
</tr>
<tr>
<td>USER</td>
<td>用户名</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ printenv SHELL</span><br><span class="line">/bin/bash</span><br><span class="line">dougwilson@doug:~$ printenv HOME</span><br><span class="line">/home/dougwilson</span><br><span class="line">dougwilson@doug:~$ printenv LANG</span><br><span class="line">en_US.UTF-8</span><br><span class="line">dougwilson@doug:~$ printenv PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">dougwilson@doug:~$ printenv PWD</span><br><span class="line">/home/dougwilson</span><br><span class="line">dougwilson@doug:~$ printenv USER</span><br><span class="line">dougwilson</span><br></pre></td></tr></table></figure>

<p>也可以通过 echo $变量名 获取变量对应的值</p>
</blockquote>
<h3 id="VI行编辑器"><a href="#VI行编辑器" class="headerlink" title="VI行编辑器"></a>VI行编辑器</h3><blockquote>
<h4 id="基本命令-vi-q-q-w"><a href="#基本命令-vi-q-q-w" class="headerlink" title="基本命令 vi :q :q!  :w"></a>基本命令 vi :q :q!  :w</h4><ul>
<li>vi 启动vi行编辑器</li>
<li>vi filename.txt 启动行编辑器编辑filename.txt内容</li>
<li>:q 退出</li>
<li>:q! 强制退出</li>
<li>:w 保存编辑内容</li>
</ul>
<p>启动后，vi行编辑器是命令模式。在命令模式中，<strong>键盘上的每一个键都代表一条命令</strong>。如果要进行文本编辑，需要切换到插入模式。如何切换？按下<kbd>I</kbd>键即可切换到插入模式。</p>
<p>进入插入模式后，可编辑文本内容。当编辑完成，需要切换回命令模式。如何切换？按下<kbd>Esc</kbd>键即可切换回命令模式。</p>
<p>切换回命令模式后，有两个选择。一个是放弃编辑的内容，则可以在命令模式中通过命令 :q! 强制退出。另一个选择就是通过命令 :w 保存编辑内容，然后才退出。</p>
<h4 id="取消命令u-命令模式下有效"><a href="#取消命令u-命令模式下有效" class="headerlink" title="取消命令u(命令模式下有效)"></a>取消命令u(命令模式下有效)</h4><p>取消上一个命令执行的结果，回退到之前的状态</p>
<h4 id="常用光标移动命令-命令模式下有效"><a href="#常用光标移动命令-命令模式下有效" class="headerlink" title="常用光标移动命令(命令模式下有效)"></a>常用光标移动命令(命令模式下有效)</h4><table>
<thead>
<tr>
<th>光标移动效果</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>上下左右</td>
<td>方向键上下左右</td>
</tr>
<tr>
<td>移至本行开头</td>
<td>数字0</td>
</tr>
<tr>
<td>移至本行末尾</td>
<td><kbd>Shift</kbd>+<kbd>$</kbd></td>
</tr>
<tr>
<td>移至上一单词开头</td>
<td>W</td>
</tr>
<tr>
<td>移至下一单词开头</td>
<td>B</td>
</tr>
<tr>
<td>移到文件最后一行</td>
<td><kbd>Shift</kbd>+<kbd>G</kbd></td>
</tr>
<tr>
<td>移到文件第n行</td>
<td>输入数字再<kbd>Shift</kbd>+<kbd>G</kbd></td>
</tr>
</tbody></table>
<h4 id="插入模式——插入文本"><a href="#插入模式——插入文本" class="headerlink" title="插入模式——插入文本"></a>插入模式——插入文本</h4><p>以下操作均在命令模式中操作，在插入模式中编辑：</p>
<ul>
<li><kbd>I</kbd> 从光标开始处编辑，并进入插入模式</li>
<li><kbd>a</kbd> 从光标开始的下一个字符开始编辑，并进入插入模式</li>
<li><kbd>A</kbd> 光标自动移动到行末，可以在行末进行编辑，并进入插入模式</li>
<li><kbd>o</kbd> 在当前行的下方创建一个新行，光标移动到新行开头，并进入插入模式</li>
<li><kbd>O</kbd> 在当前行的上方创建一个新行，光标移动到新行开头，并进入插入模式</li>
</ul>
<h4 id="插入模式——删除文本"><a href="#插入模式——删除文本" class="headerlink" title="插入模式——删除文本"></a>插入模式——删除文本</h4><p>以下命令均在命令模式中操作：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>删除内容</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>光标所在字符</td>
</tr>
<tr>
<td>3x</td>
<td>光标所在字符和之后2个字符</td>
</tr>
<tr>
<td>dd</td>
<td>当前行</td>
</tr>
<tr>
<td>5dd</td>
<td>当前行和之后4行</td>
</tr>
<tr>
<td>dW</td>
<td>光标所在字符到下一个单词开头之前</td>
</tr>
<tr>
<td>d$</td>
<td>光标所在字符到当前行末尾</td>
</tr>
<tr>
<td>d0</td>
<td>光标所在字符到当前行开头</td>
</tr>
<tr>
<td>d^</td>
<td>光标所在字符到当前行下一个非空字符</td>
</tr>
<tr>
<td>dG</td>
<td>当前行到文件末尾</td>
</tr>
<tr>
<td>d20G</td>
<td>当前行到文件第20行</td>
</tr>
</tbody></table>
<h4 id="插入模式——剪切、复制、粘贴"><a href="#插入模式——剪切、复制、粘贴" class="headerlink" title="插入模式——剪切、复制、粘贴"></a>插入模式——剪切、复制、粘贴</h4><p>和命令d相关的操作都是剪切文本。在每次使用d命令之后，都会复制删除的内容进缓存，然后可以使用<kbd>p</kbd>命令将缓存中的内容粘贴到光标之后，或使用<kbd>P</kbd>命令将内容粘贴到光标之前。</p>
<p>下面是关于复制的命令，和剪切命令d很相似:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>复制内容</th>
</tr>
</thead>
<tbody><tr>
<td>yy</td>
<td>当前行</td>
</tr>
<tr>
<td>5yy</td>
<td>当前行和之后4行</td>
</tr>
<tr>
<td>yW</td>
<td>光标所在字符到下一个单词起始字符之前</td>
</tr>
<tr>
<td>y$</td>
<td>光标所在字符到当前行的末尾</td>
</tr>
<tr>
<td>y0</td>
<td>光标所在字符到当前行的起始</td>
</tr>
<tr>
<td>y^</td>
<td>光标所在字符到当前行下一个非空字符</td>
</tr>
<tr>
<td>yG</td>
<td>当前行到文件末尾</td>
</tr>
<tr>
<td>y20G</td>
<td>当前行到文件第20行</td>
</tr>
</tbody></table>
<h4 id="插入模式——搜索整个文件"><a href="#插入模式——搜索整个文件" class="headerlink" title="插入模式——搜索整个文件"></a>插入模式——搜索整个文件</h4><p>按下<kbd>/</kbd>键，输入要搜索的单词或短语，按下Enter结束。光标会移动到被搜索字符串的地方。按下n键，光标可以移动到下一个匹配的字符串，直到文件末尾。</p>
</blockquote>
<h3 id="挂载和卸载设备"><a href="#挂载和卸载设备" class="headerlink" title="挂载和卸载设备"></a>挂载和卸载设备</h3><blockquote>
<p>/etc/fstab文件内容列出了系统启动时挂载的设备（通常是硬盘分区）。部分文件内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LABEL=/12      /        ext3    defaults    1    1</span><br><span class="line">LABEL=/home    /home    ext3    defaults    1    2</span><br><span class="line">LABEL=/boot    /boot    ext3    defaults    1    2</span><br></pre></td></tr></table></figure>

<p>文件中6个字段（列）的含义：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>内容</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>设备</td>
<td>由于热拔插设备的存在（如USB驱动器），所以许多Linux发行版采用文本标签来关联设备。当设备与系统连接后，该标签就会被操作系统识别。</td>
</tr>
<tr>
<td>2</td>
<td>挂载节点</td>
<td>设备挂载到文件系统上目录的目录名称</td>
</tr>
<tr>
<td>3</td>
<td>文件系统类型</td>
<td>Linux能挂载许多文件类型，常见的有ext3，FAT32，NTFS，iso</td>
</tr>
<tr>
<td>4</td>
<td>选项</td>
<td>文件系统挂载时的选项参数</td>
</tr>
<tr>
<td>5</td>
<td>频率</td>
<td>该数值被dump命令用来决定是否对该文件系统进行备份以及多久备份一次</td>
</tr>
<tr>
<td>6</td>
<td>优先级</td>
<td>此数值被fsck命令决定在启动时需要被扫描的文件系统的顺序</td>
</tr>
</tbody></table>
<h4 id="mount-unmount"><a href="#mount-unmount" class="headerlink" title="mount/unmount"></a>mount/unmount</h4><p>mount命令可用于查看已经挂载的文件系统列表，或者用于挂载文件系统。</p>
<p>unmount命令可用于卸载设备。</p>
<p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount | less   查看已经挂载的文件系统列表，通常重定向到less查看</span><br><span class="line">显示的列表格式为：</span><br><span class="line">设备 on 挂载节点 type 文件系统类型 (选项参数)  </span><br><span class="line">如：</span><br><span class="line">sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">/dev/sr0 on /media/dougwilson/Ubuntu 20.10 amd64 type iso9660 (ro,nosuid,nodev,relatime,nojoliet,check=s,map=n,blocksize=2048,uid=1000,gid=1000,dmode=500,fmode=400,uhelper=udisks2)</span><br><span class="line"></span><br><span class="line">挂载设备格式：</span><br><span class="line">mount [设备名称] [设备挂载的文件系统的目录的目录名称]</span><br><span class="line">卸载设备格式：</span><br><span class="line">unmount [设备名称]</span><br><span class="line">如：</span><br><span class="line">mount -t iso9660 /dev/hdc /mnt/cdrom  /dev/hdc是设备名称，/mnt/cdrom是挂载文件系统，该操作含义为挂载光盘设备/deb/hdc到新的节点cdrom目录，并使用-t指定了文件系统的类型</span><br><span class="line">unmount /dev/hdc  卸载光盘设备</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><blockquote>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>find命令通过给定一个或若干个目录名作为其搜索范围。如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find ~ | less  列出当前系统主目录下的文件列表</span><br><span class="line">统计系统主目录下文件个数：</span><br><span class="line">dougwilson@doug:~$ find ~ | wc -l</span><br><span class="line">518</span><br></pre></td></tr></table></figure>

<p>find命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find 查找目录 [test选项] [action选项] [option选项]</span><br></pre></td></tr></table></figure>

<h5 id="test选项"><a href="#test选项" class="headerlink" title="test选项"></a>test选项</h5><p>常用test选项参数：</p>
<table>
<thead>
<tr>
<th>test参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-perm mode</td>
<td>寻找访问权限与既定模式匹配的文件或目录。既定模式可以以八进制或符号的形式表示</td>
</tr>
<tr>
<td>-size n</td>
<td>匹配n大小的文件</td>
</tr>
<tr>
<td>-type c</td>
<td>匹配c类型的文件</td>
</tr>
<tr>
<td>-empty</td>
<td>匹配空文件和空目录</td>
</tr>
<tr>
<td>-name pattern</td>
<td>匹配特定通配符模式的文件或目录</td>
</tr>
</tbody></table>
<p>-type支持搜索的文件类型：</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-type b</td>
<td>块设备文件</td>
</tr>
<tr>
<td>-type c</td>
<td>字符设备文件</td>
</tr>
<tr>
<td>-type d</td>
<td>目录</td>
</tr>
<tr>
<td>-type f</td>
<td>普通文件</td>
</tr>
<tr>
<td>-type l</td>
<td>符号链接</td>
</tr>
</tbody></table>
<p>-size支持的计量单位：</p>
<table>
<thead>
<tr>
<th>字母</th>
<th>单位</th>
</tr>
</thead>
<tbody><tr>
<td>-size b</td>
<td>512字节的块</td>
</tr>
<tr>
<td>-size c</td>
<td>字节</td>
</tr>
<tr>
<td>-size w</td>
<td>两个字节的字</td>
</tr>
<tr>
<td>-size k</td>
<td>KB</td>
</tr>
<tr>
<td>-size M</td>
<td>MB</td>
</tr>
<tr>
<td>-size G</td>
<td>GB</td>
</tr>
</tbody></table>
<p><strong>test选项操作符</strong></p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>-and</td>
<td>与</td>
</tr>
<tr>
<td>-or</td>
<td>或</td>
</tr>
<tr>
<td>-not</td>
<td>非</td>
</tr>
<tr>
<td>()</td>
<td>括号操作。注意在命令行中使用需要进行转义，它是特殊字符。</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find ~ -type d | wc -l    统计主目录下目录数量</span><br><span class="line">find ~ -type f | wc -l    统计主目录下普通文件数量</span><br><span class="line">find ~ -type f -name &quot;*.JPG&quot; -size +1M | wc -l  统计大于1M的JPG文件</span><br><span class="line">find ~ -type f -name &quot;*.JPG&quot; -size -1M | wc -l  统计小于1M的JPG文件</span><br><span class="line">find ~ -type f -name &quot;*.JPG&quot; -size 1M | wc -l   统计等于1M的JPG文件</span><br><span class="line">find ~ \(-type f -not -perm 0600\) -or \(-type f -not -perm 0700\) 确定主目录下是否所有文件和子目录都有安全的访问权限</span><br></pre></td></tr></table></figure>

<h5 id="action选项"><a href="#action选项" class="headerlink" title="action选项"></a>action选项</h5><p>常用选项参数：</p>
<table>
<thead>
<tr>
<th>动作</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>-delete</td>
<td>删除匹配文件</td>
</tr>
<tr>
<td>-ls</td>
<td>对匹配文件执行ls操作，输出文件信息</td>
</tr>
<tr>
<td>-print</td>
<td>将匹配的文件的全路径以标准形式输出。该操作是默认操作</td>
</tr>
<tr>
<td>-quit</td>
<td>一旦匹配便成功退出</td>
</tr>
</tbody></table>
<p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find ~ -print</span><br><span class="line">find ~ -type f -name &quot;*.BAK&quot; -delete</span><br></pre></td></tr></table></figure>

<h5 id="option选项"><a href="#option选项" class="headerlink" title="option选项"></a>option选项</h5><p>option选项用于控制find命令的搜索范围。暂且搁置。</p>
</blockquote>
<h3 id="打包压缩命令"><a href="#打包压缩命令" class="headerlink" title="打包压缩命令"></a>打包压缩命令</h3><blockquote>
<h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>tar命令用于对文件进行打包压缩或解压，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar [选项] [文件]</span><br></pre></td></tr></table></figure>

<p>常用选项：</p>
<table>
<thead>
<tr>
<th>选项参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>创建压缩文件</td>
</tr>
<tr>
<td>-C</td>
<td>解压到指定目录</td>
</tr>
<tr>
<td>-f</td>
<td>目标文件名</td>
</tr>
<tr>
<td>-p</td>
<td>保留原始权限与属性</td>
</tr>
<tr>
<td>-P</td>
<td>使用绝对路径进行压缩</td>
</tr>
<tr>
<td>-v</td>
<td>显示解压过程</td>
</tr>
<tr>
<td>-x</td>
<td>解压</td>
</tr>
<tr>
<td>-z</td>
<td>用Gzip压缩或解压</td>
</tr>
<tr>
<td>-j</td>
<td>用Bzip2压缩或解压</td>
</tr>
<tr>
<td>-t</td>
<td>查看压缩包内容</td>
</tr>
</tbody></table>
<p>常用选项组合：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">压缩文件：</span><br><span class="line">tar -czvf 压缩包名称 打包目录</span><br><span class="line">解压文件：</span><br><span class="line">tar -xzvf 压缩包名称 -C 解压文件存放的目录</span><br></pre></td></tr></table></figure>

<h4 id="gzip-gunzip文件压缩与解压"><a href="#gzip-gunzip文件压缩与解压" class="headerlink" title="gzip/gunzip文件压缩与解压"></a>gzip/gunzip文件压缩与解压</h4><p>gzip命令用于压缩一个或多个文件，执行后，原文件会被其压缩文件取代。</p>
<p>gunzip命令则将压缩文件还原为原文件。格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gzip filename...</span><br><span class="line">gunzip filename...</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ ls -l ls-output.txt</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 81043  5月 19 15:07 ls-output.txt</span><br><span class="line">dougwilson@doug:~$ ls -l ls-error.txt</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 56  5月 19 14:32 ls-error.txt</span><br><span class="line"></span><br><span class="line">dougwilson@doug:~$ gzip ls-output.txt ls-error.txt</span><br><span class="line"></span><br><span class="line">dougwilson@doug:~$ ls -l ls-error.txt.gz</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 89  5月 19 14:32 ls-error.txt.gz</span><br><span class="line">dougwilson@doug:~$ ls -l ls-output.txt.gz</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 14652  5月 19 15:07 ls-output.txt.gz</span><br><span class="line"></span><br><span class="line">dougwilson@doug:~$ gunzip ls-error.txt.gz ls-output.txt.gz</span><br><span class="line"></span><br><span class="line">dougwilson@doug:~$ ls -l ls-error.txt</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 56  5月 19 14:32 ls-error.txt</span><br><span class="line">dougwilson@doug:~$ ls -l ls-output.txt</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 81043  5月 19 15:07 ls-output.txt</span><br></pre></td></tr></table></figure>

<h4 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h4><p>bzip2与gzip命令功能相似，但使用不同的压缩算法。该算法具有高质量的数据压缩能力，但牺牲了压缩速度。</p>
</blockquote>
<h3 id="文本搜索"><a href="#文本搜索" class="headerlink" title="文本搜索"></a>文本搜索</h3><blockquote>
<h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>grep命令用于在文本中执行关键词搜索，并显示匹配结果。格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep [options] regex [file...]</span><br></pre></td></tr></table></figure>

<p>regex是正则表达式，这里就不进行扩展，之前学过一些。</p>
<p>grep命令常用选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>-i</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>-v</td>
<td>正常情况下，grep命令会输出匹配行，而该选项可使grep输出不包含匹配项所有行</td>
</tr>
<tr>
<td>-c</td>
<td>输出匹配项数目</td>
</tr>
<tr>
<td>-l</td>
<td>输出匹配项文件名而不是直接输出匹配行自身</td>
</tr>
<tr>
<td>-n</td>
<td>在每个匹配行前加上该行在文件内的行号</td>
</tr>
<tr>
<td>-h</td>
<td>进行多文件搜索时，抑制文件名输出</td>
</tr>
<tr>
<td>-L</td>
<td>和-l选项类似，但输出的是不包含匹配项的文件名</td>
</tr>
</tbody></table>
<p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ ls /bin &gt; dirlist-bin.txt</span><br><span class="line">dougwilson@doug:~$ ls /usr/bin &gt; dirlist-usr-bin.txt</span><br><span class="line">dougwilson@doug:~$ ls /sbin &gt; dirlist-sbin.txt</span><br><span class="line">dougwilson@doug:~$ ls /usr/sbin &gt; dirlist-usr-sbin.txt</span><br><span class="line">dougwilson@doug:~$ ls dirlist*.txt</span><br><span class="line">dirlist-bin.txt  dirlist-sbin.txt  dirlist-usr-bin.txt  dirlist-usr-sbin.txt</span><br><span class="line">dougwilson@doug:~$ grep bzip dirlist*.txt</span><br><span class="line">dirlist-bin.txt:bzip2</span><br><span class="line">dirlist-bin.txt:bzip2recover</span><br><span class="line">dirlist-usr-bin.txt:bzip2</span><br><span class="line">dirlist-usr-bin.txt:bzip2recover</span><br><span class="line">dougwilson@doug:~$ grep -l bzip dirlist*.txt</span><br><span class="line">dirlist-bin.txt</span><br><span class="line">dirlist-usr-bin.txt</span><br><span class="line">dougwilson@doug:~$ grep -L bzip dirlist*.txt</span><br><span class="line">dirlist-sbin.txt</span><br><span class="line">dirlist-usr-sbin.txt</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><blockquote>
<p>文本处理常用命令：</p>
<ul>
<li>cat：连接多个文件并复制到标准输出</li>
<li>sort：对文本进行排序</li>
<li>uniq：省略重复行</li>
<li>cut：从每一行中移除文本区域</li>
<li>paste：合并文件文本行</li>
<li>join：基于某个共享字段来联合两个文件的文本行</li>
<li>common：逐行比较两个已经排序好的文件</li>
<li>diff：逐行比较文件</li>
<li>patch：对原文件打补丁</li>
<li>tr：转换或删除字符</li>
<li>sed：用于过滤和转换文本的流编辑器</li>
<li>aspel：交互式拼写检查器</li>
</ul>
<p>这里先列出命令，用到时再查。</p>
<h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat [options] [filename...]</span><br></pre></td></tr></table></figure>

<p>cat命令用于将多个文件的文本内容复制到标准输出中进行显示。当然，也可以重定向到文件中。</p>
<p>当没有文件参数时，默认为键盘输入。如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ cat &gt; foo.txt</span><br><span class="line">I never give up because I have faith.</span><br><span class="line">dougwilson@doug:~$ cat -A foo.txt</span><br><span class="line">I never give up because I have faith.$</span><br></pre></td></tr></table></figure>

<p>cat也有很多参数选项，比较常用的有两个：-n 对文本行进行编号 以及 -s 禁止输出多个空白行 。如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ cat &gt; foo.txt</span><br><span class="line">The first line</span><br><span class="line"></span><br><span class="line">The second line</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">blank two line. The third line</span><br><span class="line">dougwilson@doug:~$ cat -n foo.txt</span><br><span class="line">     1	The first line</span><br><span class="line">     2	</span><br><span class="line">     3	The second line</span><br><span class="line">     4	</span><br><span class="line">     5	</span><br><span class="line">     6	blank two line. The third line</span><br><span class="line">dougwilson@doug:~$ cat -s foo.txt</span><br><span class="line">The first line</span><br><span class="line"></span><br><span class="line">The second line</span><br><span class="line"></span><br><span class="line">blank two line. The third line</span><br><span class="line">dougwilson@doug:~$ cat -ns foo.txt</span><br><span class="line">     1	The first line</span><br><span class="line">     2	</span><br><span class="line">     3	The second line</span><br><span class="line">     4	</span><br><span class="line">     5	blank two line. The third line</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><blockquote>
<h4 id="Shell脚本格式"><a href="#Shell脚本格式" class="headerlink" title="Shell脚本格式"></a>Shell脚本格式</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is our first script</span></span><br><span class="line">echo &#x27;Hello World!&#x27;</span><br></pre></td></tr></table></figure>

<p>第一行 <strong>#!</strong> 字符是一种特殊的结构，称之为shebang。shebang用来告知操作系统，执行后的脚本应该使用的解释器名字。每个shell脚本都务必将其作为第一行</p>
<p>第二行 <strong>#</strong> 是注释行，虽然它不会被编译，但是对开发人员起到一个解释说明的作用，也是十分重要的</p>
<p>第三行 脚本行，用于执行脚本的代码</p>
<h4 id="设置脚本可执行权限"><a href="#设置脚本可执行权限" class="headerlink" title="设置脚本可执行权限"></a>设置脚本可执行权限</h4><p>对于脚本，有两种常见的权限设置：权限为755的脚本，每个人都可以执行；权限为700的脚本，只有脚本所有人才能执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 755 脚本名称</span><br><span class="line">chmod 700 脚本名称</span><br></pre></td></tr></table></figure>

<h4 id="脚本文件的位置"><a href="#脚本文件的位置" class="headerlink" title="脚本文件的位置"></a>脚本文件的位置</h4><p>为了使脚本能够运行，必须显示指定脚本文件的路径，如果不这么做，脚本可能无法被执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ ./hello_world</span><br><span class="line">Hello World</span><br><span class="line">dougwilson@doug:~$ hello_world</span><br><span class="line">hello_word: command not found</span><br></pre></td></tr></table></figure>

<p>这和一个环境变量PATH有关。如果没有显式指定路径，则系统查找一个可执行程序时，需要搜索一系列路径下的目录，这些目录就保存在环境变量PATH中。这也是为什么我们输入命令ls时，就能执行/bin/ls的原因。</p>
<p>所以，如果你想创建一个自己的脚本目录，并且不想显式地指定路径，那么你就应该将目录存入PATH环境变量中。这之前，先了解PATH变量是如何存储目录的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br></pre></td></tr></table></figure>

<p>发现，目录间是以冒号 <strong>:</strong> 作为区分的，而且最后一个目录后面没有带冒号。所以，设置自己的脚本目录时，应该以冒号开头，否则是设置失败的。比如你在家目录下创建了一个bin目录作为脚本文件目录，那么你可以在 <strong>.bashrc</strong> 文件中增加下面的行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=~/bin:&quot;$PATH&quot;</span><br></pre></td></tr></table></figure>

<p>修改完毕后，它会在每个新的终端会话中生效。</p>
<p>一个更加推荐的方法是，在PATH环境变量中的目录列表中的目录存储脚本，比如在/usr/local/bin中存放你的脚本</p>
<h4 id="脚本的变量与常量"><a href="#脚本的变量与常量" class="headerlink" title="脚本的变量与常量"></a>脚本的变量与常量</h4><p>需要注意的点：</p>
<ol>
<li>变量或常量名一定不能拼写错误。因为你拼写错误，并不会提示错误，反而会得到一个空值。</li>
<li>格式为：<strong>variable=value</strong></li>
<li>赋值时变量名、等号、值之间不能有空格</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is a simple page</span></span><br><span class="line"></span><br><span class="line">title=&quot;This is a variable&quot;</span><br><span class="line">TITLE=&quot;This is a constant variable&quot;</span><br><span class="line">echo &quot;&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;title&gt;$title&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;h1&gt;$TITLE&lt;/h1&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;	</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<h4 id="here文档"><a href="#here文档" class="headerlink" title="here文档"></a>here文档</h4><p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command &lt;&lt; token</span><br><span class="line">text body</span><br><span class="line">token</span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># Program to output a system information page</span></span><br><span class="line"></span><br><span class="line">TITLE=<span class="string">&quot;System information report for <span class="variable">$HOSTNAME</span>&quot;</span></span><br><span class="line">CURRENT_TIME=$(date + <span class="string">&quot;%x %r %z&quot;</span>)</span><br><span class="line">TIME_STAMP=<span class="string">&quot;Generated <span class="variable">$CURRENT_TIME</span>, by <span class="variable">$USER</span>&quot;</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt; <span class="string">_EOF_</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">	&lt;head&gt;</span></span><br><span class="line"><span class="string">		&lt;title&gt;$TITLE&lt;/title&gt;</span></span><br><span class="line"><span class="string">	&lt;/head&gt;</span></span><br><span class="line"><span class="string">	&lt;body&gt;</span></span><br><span class="line"><span class="string">		&lt;h1&gt;$TITLE&lt;/h1&gt;</span></span><br><span class="line"><span class="string">		&lt;p&gt;$TIME_STAMP&lt;/p&gt;</span></span><br><span class="line"><span class="string">	&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">_EOF_</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~/bin$ foo=&quot;some text&quot;</span><br><span class="line">dougwilson@doug:~/bin$ cat &lt;&lt; _EOF_</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="variable">$foo</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> \<span class="variable">$foo</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="string">&quot;<span class="variable">$foo</span>&quot;</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="string">&#x27;$foo&#x27;</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> _EOF_</span></span><br><span class="line">some text</span><br><span class="line"><span class="meta">$</span><span class="bash">foo</span></span><br><span class="line">&quot;some text&quot;</span><br><span class="line">&#x27;some text&#x27;</span><br></pre></td></tr></table></figure>

<p>here文档和echo命令很相似，但是在默认情况下，here文档内的单引号和双引号将失去它们在shell中的特殊含义，被当作普通字符。这意味着我们可以在here文档中随意嵌入引号。此外，here文档和echo文档没有什么特别的区别。</p>
<h4 id="shell脚本函数"><a href="#shell脚本函数" class="headerlink" title="shell脚本函数"></a>shell脚本函数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># function demo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一种格式</span></span><br><span class="line">funtion fun &#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;first function type&quot;</span></span><br><span class="line">	<span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种格式</span></span><br><span class="line"><span class="function"><span class="title">funTwo</span></span>() &#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;second function type&quot;</span></span><br><span class="line">	<span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;step1&quot;</span></span><br><span class="line">fun</span><br><span class="line">funTwo</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;step4&quot;</span></span><br></pre></td></tr></table></figure>

<p>return 是可以返回值的，比如下面的代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test_file() &#123;</span><br><span class="line">	FILE=~/.bash</span><br><span class="line">	if [ -e &quot;FILE&quot; ]; then</span><br><span class="line">		echo &quot;$FILE is exist&quot;</span><br><span class="line">		return 0</span><br><span class="line">	else </span><br><span class="line">		echo &quot;$FILE is not exist&quot;</span><br><span class="line">		return 1</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="if分支语句"><a href="#if分支语句" class="headerlink" title="if分支语句"></a>if分支语句</h4><p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if commands; then</span><br><span class="line">	commands</span><br><span class="line">elif commands; then</span><br><span class="line">	commands</span><br><span class="line">else </span><br><span class="line">	commands</span><br><span class="line">fi</span><br><span class="line">如：</span><br><span class="line">if true; then</span><br><span class="line">	echo &quot;It&#x27;s true&quot;</span><br><span class="line">else </span><br><span class="line">	echo &quot;It&#x27;s false&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p><strong>退出状态</strong></p>
<p>不同于高级语言编程会返回true或者false。在命令执行完毕后，会向操作系统发送一个值，称为退出状态。退出状态的值为0~255的整数，当退出状态的值为0时，表示命令执行成功。当退出状态的值不为0时，表示命令执行失败。shell提供了一个用于检测退出状态的参数**$?**</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ ls -d /usr/bin</span><br><span class="line">/usr/bin</span><br><span class="line">dougwilson@doug:~$ echo $?</span><br><span class="line">0</span><br><span class="line">dougwilson@doug:~$ ls -d /bin/ussr</span><br><span class="line">ls: cannot access &#x27;/bin/ussr&#x27;: No such file or directory</span><br><span class="line">dougwilson@doug:~$ echo $?</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h4 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h4><p>经常和if一起使用的命令是test，test命令有两种等价形式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test expression</span><br><span class="line">[ expression ]  常用形式</span><br></pre></td></tr></table></figure>

<p>这里的expression是一个表达式，其结果为true或者false。当表达式结果为true时，test命令返回一个为0的退出状态；当表达式结果为false时，test命令返回一个为1的退出状态</p>
<h5 id="test命令的文件表达式"><a href="#test命令的文件表达式" class="headerlink" title="test命令的文件表达式"></a>test命令的文件表达式</h5><p>常用文件表达式格式：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>达成true的条件</th>
</tr>
</thead>
<tbody><tr>
<td>file1 -ef file2</td>
<td>两个文件通过硬链接指向同一个文件</td>
</tr>
<tr>
<td>file1 -nt file2</td>
<td>文件1比文件2新</td>
</tr>
<tr>
<td>file1 -ot file2</td>
<td>文件1比文件2旧</td>
</tr>
<tr>
<td>-d file</td>
<td>文件存在并且是一个目录</td>
</tr>
<tr>
<td>-e file</td>
<td>文件存在</td>
</tr>
<tr>
<td>-f file</td>
<td>文件存在并且是一个普通文件</td>
</tr>
<tr>
<td>-L file</td>
<td>文件是一个符号链接</td>
</tr>
<tr>
<td>-r file</td>
<td>文件存在并且可读</td>
</tr>
<tr>
<td>-s file</td>
<td>文件存在并且其长度大于0</td>
</tr>
<tr>
<td>-w file</td>
<td>文件存在并且可写</td>
</tr>
<tr>
<td>-x file</td>
<td>文件存在并且可执行</td>
</tr>
</tbody></table>
<p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">FILE=~/.bashrc</span><br><span class="line"></span><br><span class="line">if [ -e &quot;$FILE&quot; ]; then</span><br><span class="line">	if [ -f &quot;$FILE&quot; ]; then</span><br><span class="line">		echo &quot;$FILE is a regular file.&quot;</span><br><span class="line">	fi</span><br><span class="line">	if [ -d &quot;$FILE&quot; ]; then</span><br><span class="line">		echo &quot;$FILE is a directory.&quot;</span><br><span class="line">	fi</span><br><span class="line">else </span><br><span class="line">	echo &quot;$FILE does not exists&quot;</span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h5 id="test命令的字符串表达式"><a href="#test命令的字符串表达式" class="headerlink" title="test命令的字符串表达式"></a>test命令的字符串表达式</h5><p>常用字符串表达式：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>达成true的条件</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>string不为空</td>
</tr>
<tr>
<td>-n string</td>
<td>string长度大于0</td>
</tr>
<tr>
<td>-z string</td>
<td>string长度等于0</td>
</tr>
<tr>
<td>string1=string2 或 string1==string2</td>
<td>string1和string2相等</td>
</tr>
<tr>
<td>string1!=string2</td>
<td>string1和string2不相等</td>
</tr>
<tr>
<td>string1&gt;string2</td>
<td>排序时，string1排在string2之后</td>
</tr>
<tr>
<td>string1&lt;string2</td>
<td>排序时，string1排在string2之前</td>
</tr>
</tbody></table>
<p>注意，使用test命令时，”&lt;”和”&gt;“运算符必须进行转义，或者用引号括起来。如果不这么做，则会被shell解释为重定向符。</p>
<p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">ANSWER=maybe</span><br><span class="line">if [ -z &quot;$ANSWER&quot; ]; then</span><br><span class="line">	echo &quot;There is no answer.&quot; &gt;&amp;2</span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$ANSWER&quot;=&quot;yes&quot;]; then</span><br><span class="line">	echo &quot;The answer is yes&quot;</span><br><span class="line">elif [ &quot;$ANSWER&quot;=&quot;no&quot; ]; then</span><br><span class="line">	echo &quot;The answer is no&quot;</span><br><span class="line">else </span><br><span class="line">	echo &quot;The answer is unknown&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h5 id="test命令的整数表达式"><a href="#test命令的整数表达式" class="headerlink" title="test命令的整数表达式"></a>test命令的整数表达式</h5><p>常用整数表达式为：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>达成true的条件</th>
</tr>
</thead>
<tbody><tr>
<td>integer1 -eq integer2</td>
<td>integer1和integer2相等</td>
</tr>
<tr>
<td>integer1 -ne integer2</td>
<td>integer1和integer2不相等</td>
</tr>
<tr>
<td>integer1 -le integer2</td>
<td>integer1 小于等于 integer2</td>
</tr>
<tr>
<td>integer1 -lt integer2</td>
<td>integer1 小于 integer2</td>
</tr>
<tr>
<td>integer1 -ge integer2</td>
<td>integer1 大于等于 integer2</td>
</tr>
<tr>
<td>integer1 -gt integer2</td>
<td>integer1 大于 integer2</td>
</tr>
</tbody></table>
<p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">INT=-5</span><br><span class="line">if [ -z &quot;$INT&quot; ]; then</span><br><span class="line">	echo &quot;INT is empty.&quot; &gt;&amp;2</span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br><span class="line">if [ $INT -eq 0 ]; then</span><br><span class="line">	echo &quot;INT is zero.&quot;</span><br><span class="line">else </span><br><span class="line">	if [ $INT -lt 0 ]; then</span><br><span class="line">		echo &quot;INT is negative.&quot;</span><br><span class="line">	else </span><br><span class="line">		echo &quot;INT is positive.&quot;</span><br><span class="line">	fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h4 id="增强test命令"><a href="#增强test命令" class="headerlink" title="增强test命令"></a>增强test命令</h4><p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ [ expression ] ]</span><br></pre></td></tr></table></figure>

<p>看起来多了一个方括号，但是不用担心，用法是一样的，只不过是增加了一个很重要的字符串表达式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ [ string1=~regex ] ]</span><br></pre></td></tr></table></figure>

<p>regex是一个正则表达式。如果string1和扩展的正则表达式regex相匹配，那么就会返回true。下面给一个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">INT=-5</span><br><span class="line">if [[ &quot;$INT&quot;=~^-?[0-9]+$ ]]; then</span><br><span class="line">	echo &quot;INT is an integer&quot;</span><br><span class="line">else </span><br><span class="line">	echo &quot;INT is not an integer.&quot; &gt;&amp;2</span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h4 id="增强整数设计"><a href="#增强整数设计" class="headerlink" title="增强整数设计"></a>增强整数设计</h4><p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(( expression ))</span><br></pre></td></tr></table></figure>

<p>当算术计算结果为非0值时，结果为true；算术结果为0值时，结果为false</p>
<p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">INT=-5</span><br><span class="line">if [[ &quot;$INT&quot;=~^-?[0-9]+$ ]]; then</span><br><span class="line">	if (( INT == 0 )); then</span><br><span class="line">		echo &quot;INT is zero.&quot;</span><br><span class="line">	else </span><br><span class="line">		if (( INT &lt; 0 )); then</span><br><span class="line">			echo &quot;INT is negative.&quot;</span><br><span class="line">		else</span><br><span class="line">			echo &quot;INT is positive.&quot;</span><br><span class="line">	fi</span><br><span class="line">else</span><br><span class="line">	echo &quot;INT is not an integer&quot; &gt;&amp;2 </span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h4 id="组合表达式"><a href="#组合表达式" class="headerlink" title="组合表达式"></a>组合表达式</h4><table>
<thead>
<tr>
<th>Operation</th>
<th>test</th>
<th>[[]]and(())</th>
</tr>
</thead>
<tbody><tr>
<td>AND</td>
<td>-a</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>OR</td>
<td>-o</td>
<td>||</td>
</tr>
<tr>
<td>NOT</td>
<td>!</td>
<td>!</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="从键盘读取输入"><a href="#从键盘读取输入" class="headerlink" title="从键盘读取输入"></a>从键盘读取输入</h3><blockquote>
<h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">echo -n &quot;please enter an integer -&gt; &quot;</span><br><span class="line">read inputNum</span><br><span class="line"></span><br><span class="line">if [[ &quot;$inputNum&quot;=~^?[0-9]+$ ]]; then</span><br><span class="line">	if [ $inputNum -eq 0 ]; then</span><br><span class="line">		echo &quot;$inputNum is zero.&quot;</span><br><span class="line">	else</span><br><span class="line">		if [ $inputNum -lt 0 ]; then</span><br><span class="line">			echo &quot;$inputNum is negative.&quot;</span><br><span class="line">		else</span><br><span class="line">			echo &quot;$inputNum is positive.&quot;</span><br><span class="line">		fi</span><br><span class="line">	fi</span><br><span class="line">else</span><br><span class="line">	echo &quot;Input value is not an integer.&quot;&gt;&amp;2</span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>在上述代码中，inputNum为键盘输入的赋值变量。如果read命令后面没有赋值变量，那么会将键盘的输入赋值给默认shell变量 <strong>REPLY</strong> 比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;Enter values &gt; &quot; </span><br><span class="line">read</span><br><span class="line"></span><br><span class="line">echo &quot;REPLY=&#x27;$REPLY&#x27;&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><blockquote>
<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while commands; do commands; done</span><br></pre></td></tr></table></figure>

<p>如同if命令一样，while会判断指令的退出状态。只要退出状态为0，它旧执行循环内的指令，直到退出状态不为0，退出循环。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">count = 1</span><br><span class="line">while [ $count -le 5 ]; do</span><br><span class="line">	echo $count</span><br><span class="line">	count=$(( count+1 ))</span><br><span class="line">done</span><br><span class="line">echo &quot;Finished.&quot;</span><br></pre></td></tr></table></figure>

<h4 id="continue-break"><a href="#continue-break" class="headerlink" title="continue/break"></a>continue/break</h4><p>和其他高级语言一样，shell中也有continue命令和break命令，用于执行下一个循环和跳出循环。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">DELAY=3</span><br><span class="line">while true; do</span><br><span class="line">	clear</span><br><span class="line">	cat &lt;&lt;-_EOF_</span><br><span class="line">		please Select:</span><br><span class="line">		1. Display System Information</span><br><span class="line">		2. Display Disk Space</span><br><span class="line">		3. Display Home Space Utilization</span><br><span class="line">		0. Quit</span><br><span class="line">	_EOF_</span><br><span class="line">	read -p &quot;Enter selection[0-3] &gt; &quot;</span><br><span class="line">	if [[ $REPLY=~^[0-3]$ ]]; then</span><br><span class="line">		if [[ $REPLY==1 ]]; then</span><br><span class="line">			echo &quot;Hostname: $HOSTNAME&quot;</span><br><span class="line">			uptime</span><br><span class="line">			sleep $DELAY</span><br><span class="line">			continue</span><br><span class="line">		fi</span><br><span class="line">		if [[ $REPLY==2 ]]; then</span><br><span class="line">			df -h</span><br><span class="line">			sleep $DELAY</span><br><span class="line">			continue</span><br><span class="line">		fi</span><br><span class="line">		if [[ $REPLY==3 ]]; then</span><br><span class="line">			if [[ $(id -u) -eq 0 ]]; then</span><br><span class="line">				echo &quot;Home Space Utilization (All Users)&quot;</span><br><span class="line">				du -sh /home/*</span><br><span class="line">			else </span><br><span class="line">				echo &quot;Home Space Utilization ($USER)&quot;</span><br><span class="line">				du -sh $HOME</span><br><span class="line">			fi</span><br><span class="line">			sleep $DELAY</span><br><span class="line">			continue</span><br><span class="line">		fi</span><br><span class="line">		if [[ $REPLY==0 ]]; then</span><br><span class="line">			break</span><br><span class="line">		fi</span><br><span class="line">	else </span><br><span class="line">		echo &quot;Invalid entry.&quot;</span><br><span class="line">		sleep $DELAY</span><br><span class="line">	fi</span><br><span class="line">done</span><br><span class="line">echo &quot;Program terminated&quot;</span><br></pre></td></tr></table></figure>

<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for variable [in words]; do</span><br><span class="line">	commands</span><br><span class="line">done</span><br><span class="line">variable是循环执行时会增值的变量名，words是一列按顺序赋值给variable的可选项，for循环的强大之处就在于可选项的多变性</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~/bin$ for num in A B C D; do echo $num; done</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">D</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">for num in A B C D; do</span><br><span class="line">	echo $num</span><br><span class="line">done</span><br><span class="line">或</span><br><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">for num in &#123;A..D&#125;; do</span><br><span class="line">	echo $num</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="c语言形式for循环"><a href="#c语言形式for循环" class="headerlink" title="c语言形式for循环"></a>c语言形式for循环</h4><p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for((expression1;expression2;expression3)); do</span><br><span class="line">	commands</span><br><span class="line">done</span><br><span class="line">如：</span><br><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">for((i=0;i&lt;5;i=i+1)); do</span><br><span class="line">	echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

</blockquote>
]]></content>
      <tags>
        <tag>linux, 命令</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习Spring Boot中的SpringApplication</title>
    <url>/2020/09/25/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Spring-Boot%E4%B8%AD%E7%9A%84SpringApplication/</url>
    <content><![CDATA[<p>在Spring Boot的入口类中，通常是通过调用<code>SpringApplication</code>的run方法来启动Spring Boot项目，本文来深入学习下SpringApplication的一些细节。</p>
<span id="more"></span>

<h2 id="自定义SpringApplication"><a href="#自定义SpringApplication" class="headerlink" title="自定义SpringApplication"></a>自定义SpringApplication</h2><p>默认情况下都是直接通过<code>SpringApplication</code>的run方法来直接启动Spring Boot，其实可以通过API来调整某些行为。</p>
<h3 id="通过SpringApplication-API调整"><a href="#通过SpringApplication-API调整" class="headerlink" title="通过SpringApplication API调整"></a>通过SpringApplication API调整</h3><p>我们新建一个SpringBoot项目，Spring Boot版本为2.1.0.RELEASE，<code>artifactId</code>为SpringApplication，并引入<code>spring-boot-starter-web</code>依赖。项目结构如下所示：</p>
<p>![](/images/Spring Boot项目结构.png)</p>
<p>我们将入口类的代码改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringApplication application = <span class="keyword">new</span> SpringApplication(DemoApplication.class);</span><br><span class="line">application.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">application.setWebApplicationType(WebApplicationType.NONE);</span><br><span class="line">application.setAdditionalProfiles(<span class="string">&quot;dev&quot;</span>);</span><br><span class="line">application.run(args);</span><br></pre></td></tr></table></figure>

<p>通过调用<code>SpringApplication</code>的方法，我们关闭了Banner的打印，设置应用环境为非WEB应用，profiles指定为dev。除此之外，<code>SpringApplication</code>还包含了许多别的方法，具体可以查看源码或者官方文档：</p>
<p><img src="/images/SpringApplication%E6%96%B9%E6%B3%95.png"></p>
<h3 id="通过SpringApplicationBuilder-API调整"><a href="#通过SpringApplicationBuilder-API调整" class="headerlink" title="通过SpringApplicationBuilder API调整"></a>通过SpringApplicationBuilder API调整</h3><p><code>SpringApplicationBuilder</code>提供了Fluent API，可以实现链式调用，下面的代码和上面的效果一致，但在编写上较为方便：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(DemoApplication.class)</span><br><span class="line">        .bannerMode(Banner.Mode.OFF)</span><br><span class="line">        .web(WebApplicationType.NONE)</span><br><span class="line">        .profiles(<span class="string">&quot;dev&quot;</span>)</span><br><span class="line">        .run(args);</span><br></pre></td></tr></table></figure>

<h2 id="SpringApplication准备阶段"><a href="#SpringApplication准备阶段" class="headerlink" title="SpringApplication准备阶段"></a>SpringApplication准备阶段</h2><p><code>SpringApplication</code>的生命周期阶段大致可以分为准备阶段和运行阶段。</p>
<p>我们通过源码来查看<code>SpringApplication</code>的有参构造器：</p>
<p><img src="/images/SpringApplication%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%99%A8.png"></p>
<p>通过有参构造器里的代码我们可以将<code>SpringApplication</code>的准备阶段分为以下几个步骤：</p>
<h3 id="配置源"><a href="#配置源" class="headerlink" title="配置源"></a>配置源</h3><p>构造器中<code>this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</code>这行代码用于加载我们配置的Spring Boot Bean源。通常我们使用<code>SpringApplication</code>或者<code>SpringApplicationBuilder</code>的构造器来直接指定源。</p>
<p>所谓的Spring Boot Bean源指的是某个被<code>@SpringBootApplication</code>注解标注的类，比如入口类：</p>
<p><img src="/images/%E5%85%A5%E5%8F%A3%E7%B1%BB.png"></p>
<p>我们也可以将上面的代码改为下面这种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication application = <span class="keyword">new</span> SpringApplication(ApplicationResource.class);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SpringBootApplication</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationResource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样也是可行的。查看<code>SpringApplication</code>的单个参数构造器：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="title">SpringApplication</span>(<span class="params">Class&lt;?&gt;... primarySources</span>)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(<span class="literal">null</span>, primarySources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明我们除了配置单个源外，还可以配置多个源</p>
<h3 id="推断应用类型"><a href="#推断应用类型" class="headerlink" title="推断应用类型"></a>推断应用类型</h3><p>构造器中这行<code>this.webApplicationType = WebApplicationType.deduceFromClasspath();</code>代码用于推断当前Spring Boot应用类型。</p>
<p>Spring Boot 2.0后，应用可以分为下面三种类型：</p>
<ol>
<li><code>WebApplicationType.NONE</code>：非WEB类型；</li>
<li><code>WebApplicationType.REACTIVE</code>：Web Reactive类型；</li>
<li><code>WebApplicationType.SERVLET</code>：Web Servlet类型。</li>
</ol>
<p><code>WebApplicationType.deduceFromClasspath()</code>方法根据当前应用ClassPath中是否存在相关的实现类来判断应用类型到底是哪个，<code>deduceFromClasspath</code>方法的源码如下所示:</p>
<p><img src="/images/deduceFromClasspath%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png"></p>
<p>我们也可以直接通过<code>SpringApplication</code>的<code>setWebApplicationType</code>方法或者<code>SpringApplicationBuilder</code>的<code>web</code>方法来指定当前应用的类型。</p>
<h3 id="加载应用上下文初始器"><a href="#加载应用上下文初始器" class="headerlink" title="加载应用上下文初始器"></a>加载应用上下文初始器</h3><p>接着下一行代码<code>setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</code>用于加载应用上下文初始器<code>ApplicationContextInitializer</code>。</p>
<p><code>getSpringFactoriesInstances</code>方法的源码如下所示：</p>
<p><img src="/images/getSpringFactoriesInstances%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png"></p>
<p>上面代码利用Spring工厂加载机制，实例化<code>ApplicationContextInitializer</code>实现类，并进行排序。</p>
<p>所以我们可以通过实现<code>ApplicationContextInitializer</code>接口用于在Spring Boot应用初始化之前执行一些自定义操作。</p>
<p>举个例子，在<code>com.example.demo</code>下新建<code>initializer</code>包，然后创建一个<code>HelloApplicationContextInitializer</code>类，实现<code>ApplicationContextInitializer</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationContextInitializer</span> <span class="keyword">implements</span> <span class="title">ApplicationContextInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConfigurableApplicationContext.id - &quot;</span> + applicationContext.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中实现了initialize方法，并且使用<code>@Order</code>注解指定优先级。其中<code>Ordered.HIGHEST_PRECEDENCE</code>等于<code>Integer.MIN_VALUE</code>，<code>Ordered.LOWEST_PRECEDENCE</code>等于<code>Integer.MAX_VALUE</code>。所以数值越小，优先级越高。</p>
<p>除了使用<code>@Order</code>注解来指定优先级外，我们也可以通过实现<code>org.springframework.core.Ordered</code>接口的<code>getOrder</code>方法来指定优先级。</p>
<p>接着我们来创建一个优先级比<code>HelloApplicationContextInitializer</code>低的Initializer —— <code>AfterHelloApplicationContextInitializer</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterHelloApplicationContextInitializer</span> <span class="keyword">implements</span> <span class="title">ApplicationContextInitializer</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AfterHelloApplicationContextInitializer: &quot;</span> + applicationContext.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面通过<code>getOrder</code>方法来指定了优先级为最低优先级。</p>
<p>创建好后，我们还需在工厂配置文件里配置这两个实现类。在resources目录下新建META-INF目录，并创建spring.factories文件：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.<span class="built_in">context</span>.ApplicationContextInitializer=\</span><br><span class="line">com.<span class="built_in">example</span>.<span class="built_in">demo</span>.initializer.HelloApplicationContextInitializer,\</span><br><span class="line">com.<span class="built_in">example</span>.<span class="built_in">demo</span>.initializer.AfterHelloApplicationContextInitializer</span><br></pre></td></tr></table></figure>

<p>这时候，启动Spring Boot项目，会发现控制台在打印Banner后就执行了这两个初始化器，并且<code>HelloApplicationContextInitializer</code>的<code>initialize</code>方法执行时机先于<code>AfterHelloApplicationContextInitializer</code>的<code>initialize</code>方法：</p>
<p><img src="/images/initialize%E6%96%B9%E6%B3%95.png"></p>
<h3 id="加载应用事件监听器"><a href="#加载应用事件监听器" class="headerlink" title="加载应用事件监听器"></a>加载应用事件监听器</h3><p>在加载完应用上下文初始器后，下一行的<code>setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</code>代码加载了应用事件监听器。与加载事件上下文初始器类似，Spring Boot也是通过Spring的工厂方法来实例化<code>ApplicationListener</code>的实现类，并进行排序。</p>
<p>既然是事件监听，那么其可以监听什么事件呢？其监听的是<code>ApplicationEvent</code>接口的实现类，我们查看一下都有哪些事件实现了这个接口：</p>
<p>![](/images/Spring Boot监听事件.png)</p>
<p>这里我们以<code>ContextClosedEvent</code>为例子来编写自定义的应用事件监听器，监听Spring上下文关闭事件。</p>
<p>在<code>com.example.demo</code>下新建<code>listener</code>包，然后创建一个<code>ContextClosedEventListener</code>类，实现<code>ApplicationListener</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextClosedEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextClosedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ContextClosedEvent: &quot;</span> + event.getApplicationContext().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码实现了对<code>ContextClosedEvent</code>事件的监听，并且分配了最高优先级。</p>
<p>接着创建一个优先级比<code>ContextClosedEventListener</code>低的监听器<code>AfterContextClosedEventListener</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterContextClosedEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextClosedEvent</span>&gt;, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AfterContextClosedEventr: &quot;</span> + event.getApplicationContext().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Ordered.HIGHEST_PRECEDENCE + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在Spring工厂配置文件里进行配置：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"># Application Listeners</span><br><span class="line">org.springframework.<span class="built_in">context</span>.ApplicationListener=\</span><br><span class="line">com.<span class="built_in">example</span>.<span class="built_in">demo</span>.listener.ContextClosedEventListener,\</span><br><span class="line">com.<span class="built_in">example</span>.<span class="built_in">demo</span>.listener.AfterContextClosedEventListener</span><br></pre></td></tr></table></figure>

<p>在Spring Boot入口类中将环境指定为非WEB环境（这样在启动后应用会马上关闭）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(DemoApplication.class)</span><br><span class="line">                .web(WebApplicationType.NONE)</span><br><span class="line">                .run(args);</span><br></pre></td></tr></table></figure>

<p>运行Spring Boot入口类，控制台输出如下：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">ContextClosedEvent：<span class="built_in">application</span></span><br><span class="line">AfterContextCloseEvent: <span class="built_in">application</span></span><br></pre></td></tr></table></figure>

<h3 id="推断入口类"><a href="#推断入口类" class="headerlink" title="推断入口类"></a>推断入口类</h3><p>接着构造器里的代码下一行<code>this.mainApplicationClass = deduceMainApplicationClass();</code>用于推断运行Spring Boot应用的入口类。查看<code>deduceMainApplicationClass</code>方法源码：</p>
<p><img src="/images/deduceMainApplicationClass%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png"></p>
<p>代码主要逻辑是根据Main线程执行堆栈判断实际的入口类。</p>
<p>准备阶段介绍完毕后，接下来开始介绍运行阶段。</p>
<h2 id="SpringApplication运行阶段"><a href="#SpringApplication运行阶段" class="headerlink" title="SpringApplication运行阶段"></a>SpringApplication运行阶段</h2><p>SpringApplication的运行阶段对应<code>SpringApplication</code>的<code>run</code>方法，我们查看其源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">    listeners.starting();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">                args);</span><br><span class="line">        ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">                applicationArguments);</span><br><span class="line">        configureIgnoreBeanInfo(environment);</span><br><span class="line">        Banner printedBanner = printBanner(environment);</span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">                SpringBootExceptionReporter.class,</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;ConfigurableApplicationContext.class&#125;, context);</span><br><span class="line">        prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">                printedBanner);</span><br><span class="line">        refreshContext(context);</span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">                    .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        listeners.started(context);</span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        listeners.running(context);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行阶段大致可以分为下面这几个过程：</p>
<h3 id="开启时间监听"><a href="#开启时间监听" class="headerlink" title="开启时间监听"></a>开启时间监听</h3><p><code>run</code>方法开头的这两行代码用于开启时间监听：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br></pre></td></tr></table></figure>

<p>上面代码用于开启Spring Boot应用启动时间监听，配合下面的<code>stopWatch.stop();</code>便可以计算出完整的启动时间。</p>
<h3 id="开启运行监听器"><a href="#开启运行监听器" class="headerlink" title="开启运行监听器"></a>开启运行监听器</h3><p><code>run</code>方法的这几行代码用于加载Spring应用运行监听器（SpringApplicationRunListener）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">listeners.started();</span><br></pre></td></tr></table></figure>

<p><code>getRunListeners</code>方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SpringApplicationRunListeners <span class="title">getRunListeners</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SpringApplicationRunListeners(logger, getSpringFactoriesInstances(</span><br><span class="line">        SpringApplicationRunListener.class, types, <span class="keyword">this</span>, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码通过<code>SpringFactoriesLoader</code>检索META-INF/spring.factories找到声明的所有<code>SpringApplicationRunListener</code>的实现类并将其实例化，然后装配到<code>List&lt;SpringApplicationRunListener&gt;</code>运行监听器集合中。</p>
<p><code>listeners.started();</code>用于遍历运行监听器集合中的所有<code>SpringApplicationRunListener</code>的实现类，并逐一调用它们的<code>starting</code>方法，广播Spring Boot应用要开始启动了。</p>
<p>在Spring Boot中<code>SpringApplicationRunListener</code>接口用于监听整个Spring Boot应用生命周期，其代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpringApplicationRunListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">started</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">running</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些方法对应着Spring Boot应用生命周期的各个阶段：</p>
<table>
<thead>
<tr>
<th align="left">方法名称</th>
<th align="left">对应生命周期</th>
<th align="left">Spring Boot起始版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left">starting()</td>
<td align="left">Spring 应用刚启动</td>
<td align="left">1.0</td>
</tr>
<tr>
<td align="left">environmentPrepared(ConfigurableEnvironment)</td>
<td align="left">ConfigurableEnvironment 准备完毕，允许将其调整</td>
<td align="left">1.0</td>
</tr>
<tr>
<td align="left">contextPrepared(ConfigurableApplicationContext)</td>
<td align="left">ConfigurableApplicationContext 准备完毕，允许将其调整</td>
<td align="left">1.0</td>
</tr>
<tr>
<td align="left">contextLoaded(ConfigurableApplicationContext)</td>
<td align="left">ConfigurableApplicationContext 已装载，但仍未启动</td>
<td align="left">1.0</td>
</tr>
<tr>
<td align="left">started(ConfigurableApplicationContext)</td>
<td align="left">ConfigurableApplicationContext 已启动，此时 Spring Bean 已初始化完成</td>
<td align="left">2.0</td>
</tr>
<tr>
<td align="left">running(ConfigurableApplicationContext)</td>
<td align="left">Spring 应用正在运行</td>
<td align="left">2.0</td>
</tr>
<tr>
<td align="left">failed(ConfigurableApplicationContext,Throwable)</td>
<td align="left">Spring 应用运行失败</td>
<td align="left">2.0</td>
</tr>
</tbody></table>
<p>在<code>com.example.demo.linstener</code>下自定义一个<code>SpringApplicationRunListener</code>接口实现类<code>HelloSpringApplicationRunListener</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationRunListener</span> <span class="keyword">implements</span> <span class="title">SpringApplicationRunListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloApplicationRunListener</span><span class="params">(SpringApplication application, String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloApplicationRunListener starting......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">started</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">running</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个实现类，我们可以在Spring Boot应用刚启动的时候在控制台输出<code>HelloApplicationRunListener starting......</code>。</p>
<p>因为其基于Spring的工厂方法来实现，所以我们需要在spring.factories文件里配置这个实现类:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Run Listeners</span></span><br><span class="line">org.springframework.boot.<span class="attribute">SpringApplicationRunListener</span>=\</span><br><span class="line">com.example.demo.run.HelloApplicationRunListener</span><br></pre></td></tr></table></figure>

<p>启动Spring Boot便可以在控制台看到如下输出了：</p>
<p>![](/images/Spring Boot输出显示.png)</p>
<h3 id="创建-Environment"><a href="#创建-Environment" class="headerlink" title="创建 Environment"></a>创建 Environment</h3><p><code>run</code>方法中的这行代码用于创建并配置当前SpringBoot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ConfigurableEnvironment environment = prepare<span class="constructor">Environment(<span class="params">listeners</span>, <span class="params">applicationArguments</span>)</span>;</span><br></pre></td></tr></table></figure>



<p>我们已经在准备阶段里推断出了应用类型，这里只要根据相应的应用类型来创建相应的应用环境即可，类型和环境对应关系如下：</p>
<ul>
<li>Web Reactive： StandardReactiveWebEnvironment</li>
<li>Web Servlet： StandardServletEnvironment</li>
<li>非 Web： StandardEnvironment</li>
</ul>
<p>在<code>prepareEnvironment</code>方法中会执行<code>listeners.environmentPrepared(environment);</code>，用于遍历调用所有<code>SpringApplicationRunListener</code>实现类的<code>environmentPrepared()</code>方法，广播Environment准备完毕。</p>
<h3 id="是否打印Banner"><a href="#是否打印Banner" class="headerlink" title="是否打印Banner"></a>是否打印Banner</h3><p><code>run</code>方法中的这行代码会根据我们的配置来决定是否打印Banner：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Banner printedBanner = printBanner(environment);</span><br></pre></td></tr></table></figure>

<h3 id="创建Context"><a href="#创建Context" class="headerlink" title="创建Context"></a>创建Context</h3><p><code>run</code>方法中的这行代码用于创建<code>ApplicationContext</code>：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">context</span> = createApplicationContext()<span class="comment">;</span></span><br></pre></td></tr></table></figure>



<p>不同的环境对应不同的<code>ApplicationContext</code>：</p>
<ul>
<li>Web Reactive： AnnotationConfigReactiveWebServerApplicationContext</li>
<li>Web Servlet： AnnotationConfigServletWebServerApplicationContext</li>
<li>非 Web： AnnotationConfigApplicationContext</li>
</ul>
<h3 id="装配Context"><a href="#装配Context" class="headerlink" title="装配Context"></a>装配Context</h3><p><code>run</code>方法中的这行代码用于装配Context：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">prepare<span class="constructor">Context(<span class="params">context</span>, <span class="params">environment</span>, <span class="params">listeners</span>, <span class="params">applicationArguments</span>, <span class="params">printedBanner</span>)</span>;</span><br></pre></td></tr></table></figure>



<p>方法<code>prepareContext</code>的源码如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="params"><span class="function">                            ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="params"><span class="function">                            ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">    context.setEnvironment(environment);</span><br><span class="line">    postProcessApplicationContext(context);</span><br><span class="line">    applyInitializers(context);</span><br><span class="line">    listeners.contextPrepared(context);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">        logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">        logStartupProfileInfo(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add boot specific singleton beans</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">    beanFactory.registerSingleton(<span class="string">&quot;springApplicationArguments&quot;</span>, applicationArguments);</span><br><span class="line">    <span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">&quot;springBootBanner&quot;</span>, printedBanner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">        ((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">                .setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Load the sources</span></span><br><span class="line">    Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">    Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line">    load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">    listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>prepareContext</code>方法开头为<code>ApplicationContext</code>加载了environment，之后通过<code>applyInitializers</code>方法逐个执行<code>ApplicationContextInitializer</code>的<code>initialize</code>方法来进一步封装<code>ApplicationContext</code>，并调用所有的<code>SpringApplicationRunListener</code>实现类的<code>contextPrepared</code>方法，广播ApplicationContext已经准备完毕了。</p>
<p>之后初始化IOC容器，并调用<code>SpringApplicationRunListener</code>实现类的<code>contextLoaded</code>方法，广播<code>ApplicationContext</code>加载完成，这里就包括通过<code>@EnableAutoConfiguration</code>导入的各种自动配置类。</p>
<h3 id="Refresh-Context"><a href="#Refresh-Context" class="headerlink" title="Refresh Context"></a>Refresh Context</h3><p><code>run</code>方法中的这行代码用于初始化所有自动配置类，并调用<code>ApplicationContext</code>的<code>refresh</code>方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">refresh<span class="constructor">Context(<span class="params">context</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="广播应用已启动"><a href="#广播应用已启动" class="headerlink" title="广播应用已启动"></a>广播应用已启动</h3><p><code>run</code>方法中的这行代码用于广播Spring Boot应用已启动：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">listeners.started(context)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p><code>started</code>方法会调用所有的<code>SpringApplicationRunListener</code>的<code>finished</code>方法，广播SpringBoot应用已经成功启动。</p>
<h3 id="执行Runner"><a href="#执行Runner" class="headerlink" title="执行Runner"></a>执行Runner</h3><p><code>run</code>方法中的这行代码<code>callRunners(context, applicationArguments);</code>遍历所有<code>ApplicationRunner</code>和<code>CommandLineRunner</code>的实现类，并执行其<code>run</code>方法。我们可以实现自己的<code>ApplicationRunner</code>或者<code>CommandLineRunner</code>，来对Spring Boot的启动过程进行扩展。</p>
<p>我们在<code>com.example.demo</code>下新建<code>runner</code>包，然后创建一个<code>ApplicationRunner</code>的实现类<code>HelloApplicationRunner</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloApplicationRunner: hello spring boot&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们需要将<code>HelloApplicationRunner</code>使用<code>@Component</code>注解标注，让其注册到IOC容器中。</p>
<p>然后再创建一个<code>CommandLineRunner</code>的实现类<code>HelloCommandLineRunner</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloCommandLineRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloCommandLineRunner: hello spring boot&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动Spring Boot应用，便可以在应用刚启动好后看到如下输出：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">HelloApplicationRunner:</span> hello spring boot</span><br><span class="line"><span class="symbol">HelloCommandLineRunner:</span> hello spring boot</span><br></pre></td></tr></table></figure>

<h3 id="广播应用运行中"><a href="#广播应用运行中" class="headerlink" title="广播应用运行中"></a>广播应用运行中</h3><p><code>run</code>方法中的这行代码<code>listeners.running(context);</code>用于调用<code>SpringApplicationRunListener</code>的<code>running</code>方法，广播Spring Boot应用正在运行中。</p>
<p>当<code>run</code>方法运行出现异常时，便会调用<code>handleRunFailure</code>方法来处理异常，该方法里会通过<code>listeners.failed(context, exception);</code>来调用<code>SpringApplicationRunListener</code>的<code>failed</code>方法，广播应用启动失败，并将异常扩散出去。</p>
]]></content>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Spring AOP原理</title>
    <url>/2020/05/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring-AOP%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>AOP底层为动态代理，AOP指的是：在程序运行期间动态地将某段代码切入到指定方法指定位置进行运行的编程方式，相关设计模式为代理模式。</p>
<span id="more"></span>

<h2 id="AOP的使用"><a href="#AOP的使用" class="headerlink" title="AOP的使用"></a>AOP的使用</h2><p>创建一个目标类TatgetClass，包含需要被AOP代理增强的方法test：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;目标方法test被执行&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasLength(value)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;value不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写切面类MyAspect：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * cc.mrbird..*.TargetClass.test(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;onBefore：&quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot;方法开始执行，参数：&quot;</span></span><br><span class="line">                + Arrays.asList(joinPoint.getArgs()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAfter</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;onAfter：&quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot;方法执行结束，参数：&quot;</span></span><br><span class="line">                + Arrays.asList(joinPoint.getArgs()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;pointcut()&quot;, returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(JoinPoint joinPoint, Object result)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning：&quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot;方法执行结束返回，参数：&quot;</span></span><br><span class="line">                + Arrays.asList(joinPoint.getArgs()) + <span class="string">&quot;，返回值：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;pointcut()&quot;, throwing = &quot;exception&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(JoinPoint joinPoint, Exception exception)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing：&quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot;方法执行出错，参数：&quot;</span></span><br><span class="line">                + Arrays.asList(joinPoint.getArgs()) + <span class="string">&quot;，异常：&quot;</span> + exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该切面包含了4个通知方法：</p>
<ul>
<li>前置通知（@Before）：在目标方法被调用之前调用通知功能；</li>
<li>后置通知（@After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li>
<li>返回通知（@AfterReturning）：在目标方法成功执行之后调用通知；</li>
<li>异常通知（@AfterThrowing）：在目标方法抛出异常后调用通知。</li>
</ul>
<p>测试AOP结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(AopApplication.class, args);</span><br><span class="line">        TargetClass targetClass = context.getBean(TargetClass.class);</span><br><span class="line">        targetClass.test(<span class="string">&quot;aop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序测试结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">onBefore：<span class="built_in">test</span>方法开始执行，参数：[aop]</span><br><span class="line">目标方法<span class="built_in">test</span>被执行</span><br><span class="line">afterReturning：<span class="built_in">test</span>方法执行结束返回，参数：[aop]，返回值：aop</span><br><span class="line">onAfter：<span class="built_in">test</span>方法执行结束，参数：[aop]</span><br></pre></td></tr></table></figure>

<p><code>test</code>方法参数为空时，程序运行结果如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">onBefore：test方法开始执行，参数：<span class="selector-attr">[]</span></span><br><span class="line">目标方法test被执行</span><br><span class="line">afterThrowing：test方法执行出错，参数：<span class="selector-attr">[]</span>，异常：java<span class="selector-class">.lang</span><span class="selector-class">.RuntimeException</span>: value不能为空</span><br><span class="line">onAfter：test方法执行结束，参数：<span class="selector-attr">[]</span></span><br></pre></td></tr></table></figure>

<p>回顾了AOP使用后，下面就深入探究Spring AOP的实现原理</p>
<h3 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h3><p>@EnableAspectJAutoProxy用于开启AspectJ自动代理，源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123;AspectJAutoProxyRegistrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该注解类上通过@Import导入了<code>AspectJAutoProxyRegistrar</code>AspectJ自动代理注册器，查看<code>AspectJAutoProxyRegistrar</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span></span><br><span class="line"><span class="comment">	 * of the @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">			AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">		AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line">				AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">		<span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>)) &#123;</span><br><span class="line">				AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;exposeProxy&quot;</span>)) &#123;</span><br><span class="line">				AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过注释我们大体可以知道，该注册器的作用是往IOC容器里注册了一个类型为<code>AnnotationAwareAspectJAutoProxyCreator</code>（注解驱动的AspectJ自动代理创建器）的Bean。该类的<code>registerBeanDefinitions</code>方法主要关注：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br></pre></td></tr></table></figure>

<p>查看其源码：</p>
<p><img src="/images/AopConfigUtils%E6%BA%90%E7%A0%81.png"></p>
<p>可以看到，核心逻辑为通过<code>RootBeanDefinition</code>往IOC注册了名称为<code>AUTO_PROXY_CREATOR_BEAN_NAME</code>（常量，值为org.springframework.aop.config.internalAutoProxyCreator），类型为AnnotationAwareAspectJAutoProxyCreator的Bean</p>
<p>综上，可以知道：<code>@EnableAspectJAutoProxy</code>模块驱动注解往IOC容器中注册了类型为AnnotationAwareAspectJAutoProxyCreator的Bean，Bean名称为org.springframework.aop.config.internalAutoProxyCreator。</p>
<h3 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h3><p>通过前面的分析，主要目标就是<code>AnnotationAwareAspectJAutoProxyCreator</code>类，为了搞清楚这个类的作用，先捋清类的层级关系：</p>
<p><img src="/images/AnnotationAwareAspectJAutoProxyCreator%E7%B1%BB%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.png"></p>
<p>可以看到AnnotationAwareAspectJAutoProxyCreator的父类AbstractAutoProxyCreator实现了SmartInstantiationAwareBeanPostProcessor和BeanFactoryAware接口。实现BeanFactoryAware用于在Bean初始化时注入BeanFactory，而SmartInstantiationAwareBeanPostProcessor接口的父类为InstantiationAwareBeanPostProcessor接口，该接口继承自BeanPostProcessor接口。</p>
<p>通过查看AnnotationAwareAspectJAutoProxyCreator及其各个层级父类源码可以发现，AbstractAutoProxyCreator类实现了InstantiationAwareBeanPostProcessor接口的postProcessBeforeInstantiation方法（自定义Bean实例化前操作逻辑），实现了BeanPostProcessor的postProcessAfterInitialization方法（自定义Bean初始化后操作逻辑）。所以后续就是分析这两个方法：</p>
<p><img src="/images/postProcessBeforeInstantiation%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95.png"></p>
<h3 id="AOP代理创建过程"><a href="#AOP代理创建过程" class="headerlink" title="AOP代理创建过程"></a>AOP代理创建过程</h3><p>以debug的方式启动前面的AOP例子，因为后置处理器对所有Bean都生效，所以每个Bean创建时都会进入我们刚刚打断点的那两个方法中。但我们只关心Spring AOP是怎样增强我们定义的目标类TargetClass的，所以如果Bean类型不是TargetClass，我们都直接点击Resume Program按钮跳过，直到Bean类型是TargetClass：</p>
<p>postProcessBeforeInstantiation方法主要包含以下几个核心步骤：</p>
<p><img src="/images/postProcessBeforeInstantiation%E6%96%B9%E6%B3%95%E6%A0%B8%E5%BF%83%E6%AD%A5%E9%AA%A4.png"></p>
<p><strong>分析上面的步骤</strong></p>
<ol>
<li><p>通过Bean名称和Bean类型获取该Bean的唯一缓存键名，getCacheKey方法源码如下所示：</p>
<p><img src="/images/getCacheKey%E6%96%B9%E6%B3%95.png"></p>
</li>
<li><p>判断当前Bean（TargetClass）是否包含在advisedBeans集合中（AbstractAutoProxyCreator的成员变量<code>private final Map&lt;Object, Boolean&gt; advisedBeans = new ConcurrentHashMap&lt;&gt;(256)</code>，用于存放所有Bean是否需要增强标识，键为每个Bean的cacheKey，值为布尔类型，true表示需要增强，false表示不需要增强），此时TargetClass还未实例化，所以不在该集合中。</p>
</li>
<li><p>判断当前Bean（TargetClass）是否是基础类，查看isInfrastructureClass方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isInfrastructureClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.isInfrastructureClass(beanClass) || (<span class="keyword">this</span>.aspectJAdvisorFactory != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.aspectJAdvisorFactory.isAspect(beanClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了父类的 <code>isInfrastructureClass</code> 方法 以及 this.aspectJAdvisorFactory.isAspect方法</p>
<p>两个方法源码如下所示：</p>
<p><img src="/images/isInfrastructureClass%E6%BA%90%E7%A0%81.png"></p>
<p><img src="/images/isAspect%E6%BA%90%E7%A0%81.png"></p>
<p>所以这一步逻辑为：判断当前Bean（TargetClass）是否是Advice，Pointcut，Advisor，AopInfrastructureBean的子类或者是否为切面类（@Aspect注解标注）</p>
</li>
<li><p>判断是否需要跳过。通过Bean名称判断是否以AutowireCapableBeanFactory.ORIGINAL_INSTANCE_SUFFIX（.ORIGINAL）结尾，是的话返回true表示跳过代理。</p>
</li>
<li><p>如果自定义了TargetSource，则在此处创建Bean代理，以取代目标Bean的后续默认实例化方式。但是代码中并没有自定义TargetSource，所以直接跳过。</p>
</li>
</ol>
<p>经过以上这些步骤，就TargetClass这个Bean而言，postProcessBeforeInstantiation方法最终返回null。Bean实例化前置处理到此完毕，点击Resume Program，继续Bean的后续生命周期处理逻辑，程序跳转到Bean初始化后置处理方法postProcessAfterInitialization：</p>
<p><img src="/images/postProcessAfterInitialization%E5%BC%80%E5%A7%8B%E8%B0%83%E8%AF%95.png"></p>
<p>该方法重点关注wrapIfNecessary方法，查看wrapIfNecessary方法源码：</p>
<p><img src="/images/wrapIfNecessary%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png"></p>
<ol>
<li><p>getAdvicesAndAdvisorsForBean方法内部主要包含以下这些逻辑：</p>
<ul>
<li>获取所有的通知方法（切面里定义的各个方法）；</li>
<li>通过切点表达式判断这些通知方法是否可为当前Bean所用；</li>
<li>如果有符合的通知方法，则对它们进行排序（排序规则不同版本Spring有所不同，上面已经提及过）。</li>
</ul>
<p>在前面的AOP例子中，切面MyAspect里的通知方法就是为了增强TargetClass所设的（根据切点表达式），所以getAdvicesAndAdvisorsForBean方法返回值如下所示：</p>
<p><img src="/images/getAdvicesAndAdvisorsForBean%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC.png"></p>
<p>这些通知方法就是我们在MyAspect切面里定义的通知方法：</p>
<p><img src="/images/aop%E9%80%9A%E7%9F%A5%E6%96%B9%E6%B3%95.png"></p>
</li>
<li><p>如果该Bean的通知方法集合不为空的话，则创建该Bean的代理对象，具体查看createProxy方法源码：</p>
<p><img src="/images/createProxy%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png"></p>
<p>继续跟踪proxyFactory.getProxy(getProxyClassLoader())源码：</p>
<p><img src="/images/getProxy%E6%BA%90%E7%A0%811.png"></p>
<p><img src="/images/getProxy%E6%BA%90%E7%A0%812.png"></p>
<p>Spring会判断当前使用哪种代理对象（一般来说当Bean有实现接口时，使用JDK动态代理，当Bean没有实现接口时，使用cglib代理，在Boot中，我们可以通过<code>spring.aop.proxy-target-class=true</code>配置来强制使用cglib代理）。</p>
</li>
</ol>
<p>通过Bean初始化后置代理方法postProcessBeforeInstantiation处理后，TargetClass被包装为了cglib代理的增强Bean，注册到IOC容器中：</p>
<p><img src="/images/TargetClass%E8%A2%AB%E5%8C%85%E8%A3%85.png"></p>
<p>后续从IOC容器中获得的TargetClass就是被代理后的对象，执行代理对象的目标方法的时候，代理对象会执行相应的通知方法链。</p>
<h3 id="生成拦截器链MethodInterceptor"><a href="#生成拦截器链MethodInterceptor" class="headerlink" title="生成拦截器链MethodInterceptor"></a>生成拦截器链MethodInterceptor</h3><p>AOP代理对象生成后，需要关注代理对象的目标方法执行时，通知方法是怎么被执行的。</p>
<p>先将前面打的断点都去掉，然后在SpringBoot的入口类AopApplication的如下位置打个断点：</p>
<p><img src="/images/AopApplication%E6%89%93%E6%96%AD%E7%82%B9.png"></p>
<p>以debug方式启动程序，可以看到获取到的TargetClass Bean就是前面cglib代理后的Bean（TargetClass$$EnhanceBySpringCGLIB）</p>
<p><img src="/images/TargetClass%E7%9A%84Bean%E5%AF%B9%E8%B1%A1.png"></p>
<p>点击Step Into进入test方法内部调用逻辑，会发现程序跳转到了CglibAopProxy的intercept方法中，也就是说我们的目标对象的目标方法被CglibAopProxy的intercept方法拦截了，该拦截方法主要逻辑如下：</p>
<p><img src="/images/CglibAopProxy%E6%8B%A6%E6%88%AA%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.png"></p>
<p>getInterceptorsAndDynamicInterceptionAdvice方法，其源码如下所示:</p>
<p><img src="/images/getInterceptorsAndDynamicInterceptionAdvice%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png"></p>
<p>继续查看this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice源码：</p>
<p><img src="/images/this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice%E6%BA%90%E7%A0%81.png"></p>
<p>通过debug我们可以看到，当前代理对象的test方法的拦截器链不为空，并且元素个数为5：</p>
<p><img src="/images/%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE%E4%B8%AA%E6%95%B0.png"></p>
<p>拦截器链5个元素：拦截器链第一个元素类型为ExposeInvocationInterceptor，是默认的拦截器，后面会介绍到它的作用。剩下四个依次为：MethodBeforeAdviceInterceptor、AspectJAfterAdvice、AfterReturningAdviceInterceptor和AspectJAfterThrowingAdvice，它们都是MethodInterceptor的实现类：</p>
<p><img src="/images/%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE%E7%B1%BB%E7%BB%93%E6%9E%84.png"></p>
<h3 id="链式调用通知方法"><a href="#链式调用通知方法" class="headerlink" title="链式调用通知方法"></a>链式调用通知方法</h3><p>获取到了代理对象目标方法的拦截器链后，当获取拦截器链并且拦截器链不为空时，CglibAopProxy的intercept方法创建CglibMethodInvocation对象，并调用它的proceed方法：</p>
<p><img src="/images/proceed%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%9C.png"></p>
<p>查看CglibMethodInvocation源码：</p>
<p><img src="/images/CglibMethodInvocation%E6%BA%90%E7%A0%81.png"></p>
<p>查看CglibMethodInvocation父类ReflectiveMethodInvocation proceed方法源码：</p>
<p><img src="/images/ReflectiveMethodInvocation%E7%9A%84proceed%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png"></p>
<p>清除掉之前打的断点，在该方法上第一行打个端点，重新以debug方式启动Boot应用：</p>
<p><img src="/images/%E9%87%8D%E5%90%AFBoot%E5%BA%94%E7%94%A8.png"></p>
<p>程序第一次进该方法时currentInterceptorIndex值为-1，this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex)取出拦截器链第一个拦截器ExposeInvocationInterceptor，方法最后调用该拦截器的invoke方法，Step Into进入该方法：</p>
<p>![](/images/Step Into进入该方法.png)</p>
<p>mi就是我们传入的ReflectiveMethodInvocation对象，程序执行到mi.proceed方法时，Step Into进入该方法：</p>
<p><img src="/images/mi.proceed%E6%96%B9%E6%B3%95.png"></p>
<p>可以看到，此时程序第二次执行ReflectiveMethodInvocation的poceed方法，currentInterceptorIndex值为0，this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex)取出拦截器链第二个拦截器MethodBeforeAdviceInterceptor，方法最后调用该拦截器的invoke方法，Step Into进入该方法：</p>
<p><img src="/images/%E8%B0%83%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84invoke%E6%96%B9%E6%B3%95.png"></p>
<p>可以看到MethodBeforeAdviceInterceptor的invoke方法第一行调用了通知方法before，此时控制台打印内容为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">onBefore：<span class="built_in">test</span>方法开始执行，参数：[hello]</span><br></pre></td></tr></table></figure>

<p>接着又通过mi.proceed再次调用ReflectiveMethodInvocation的poceed方法。就这样，随着invokeJoinpoint()方法执行结束返回出栈，程序回到AspectJAfterThrowingAdvice的invoke方法：</p>
<p><img src="/images/AspectJAfterThrowingAdvice%E7%9A%84invoke%E6%96%B9%E6%B3%95.png"></p>
<p>就这个例子来说，目标方法test并没有抛出异常，所以AspectJAfterThrowingAdvice的invoke方法执行结束出栈，程序回到AfterReturningAdviceInteceptor的invoke方法：</p>
<p><img src="/images/AfterReturningAdviceInteceptor%E7%9A%84invoke%E6%96%B9%E6%B3%95.png"></p>
<p>this.advice.afterReturning执行afterReturning通知方法，控制台打印内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">onBefore：<span class="built_in">test</span>方法开始执行，参数：[hello]</span><br><span class="line">目标方法<span class="built_in">test</span>被执行</span><br><span class="line">afterReturning：<span class="built_in">test</span>方法执行结束返回，参数：[hello]，返回值：hello</span><br></pre></td></tr></table></figure>

<p>AfterReturningAdviceInteceptor的invoke方法执行结束出栈，程序回到AspectJAfterAdvice的invoke方法：</p>
<p><img src="/images/AspectJAfterAdvice%E7%9A%84invoke%E6%96%B9%E6%B3%95.png"></p>
<p>AspectJAfterAdvice的invoke方法最终执行finally after逻辑，控制台打印内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">onBefore：<span class="built_in">test</span>方法开始执行，参数：[hello]</span><br><span class="line">目标方法<span class="built_in">test</span>被执行</span><br><span class="line">afterReturning：<span class="built_in">test</span>方法执行结束返回，参数：[hello]，返回值：hello</span><br><span class="line">onAfter：<span class="built_in">test</span>方法执行结束，参数：[hello]</span><br></pre></td></tr></table></figure>

<p>AspectJAfterAdvice的invoke方法执行结束出栈，程序回到MethodBeforeAdviceInterceptor的invoke方法：</p>
<p><img src="/images/MethodBeforeAdviceInterceptor%E7%9A%84invoke%E6%96%B9%E6%B3%95.png"></p>
<p>MethodBeforeAdviceInterceptor的invoke方法正常执行结束，出栈，程序回到ExposeInvocationInterceptor的invoke方法：</p>
<p><img src="/images/ExposeInvocationInterceptor%E7%9A%84invoke%E6%96%B9%E6%B3%95.png"></p>
<p>ExposeInvocationInterceptor的invoke方法执行结束出栈，程序回到CglibAopProxy的intercept方法。当CglibAopProxy的intercept方法执行结束出栈后，整个AOP的拦截器链调用也随之结束了：</p>
<p><img src="/images/CglibAopProxy%E7%9A%84intercept%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9D%9F.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/aop%E6%80%BB%E7%BB%93.png"></p>
]]></content>
      <tags>
        <tag>spring, aop</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2020/04/07/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>前段时间考试周，没有很多时间看书。这两天比较闲，不如把背包问题好好解决一番，供以后复习。</p>
<p>之前讨论过动态规划的问题，动态规划最终的结果是通过解决小问题来解决大问题。同样的道理，解决背包问题也是如此，先解决小背包问题，再解决大背包问题。</p>
<p>下面由浅入深，条件由简单到复杂地讨论背包问题的动态规划解决方案。</p>
<p>还是老办法，参照4个步骤：</p>
<ol>
<li>描述最优解的结构</li>
<li>递归定义最优解的值</li>
<li>按自底向上的方式计算最优解的值(非递归，通常为循环)</li>
<li>由计算出的结果构造一个最优解</li>
</ol>
<p>Tip:</p>
<ol>
<li>每种动态规划解决方案都涉及网格(数组)</li>
<li>单元格(数组项)中的值通常为要优化的值</li>
<li>每个单元格都是一个子问题最优解，因此，应该考虑如何将问题分成子问题，这有助于找出网格的坐标轴(行和列号对应含义)</li>
</ol>
<span id="more"></span>

<h2 id="背包问题1——基本背包"><a href="#背包问题1——基本背包" class="headerlink" title="背包问题1——基本背包"></a>背包问题1——基本背包</h2><blockquote>
<p>问题描述：</p>
<p>有N种物品和一个容量为V的背包，每种物品仅有1件，放入第i件物品耗费的空间为Ci，得到的价值为Vi。问，如何组合才能使背包里物品的价值最大。</p>
<p><strong>实际问题描述：</strong></p>
<p><em>假设你是一个小偷，背着一个可装4kg东西的背包，可盗窃的商品如下：</em></p>
<table>
<thead>
<tr>
<th>商品</th>
<th>价值（美元）</th>
<th>重量（kg）</th>
</tr>
</thead>
<tbody><tr>
<td>音响</td>
<td>3000</td>
<td>4</td>
</tr>
<tr>
<td>笔记本电脑</td>
<td>2000</td>
<td>3</td>
</tr>
<tr>
<td>吉他</td>
<td>1500</td>
<td>1</td>
</tr>
<tr>
<td>iphone</td>
<td>2000</td>
<td>1</td>
</tr>
<tr>
<td>项链</td>
<td>1000</td>
<td>0.5</td>
</tr>
<tr>
<td>戒指</td>
<td>1500</td>
<td>0.5</td>
</tr>
</tbody></table>
<p><em>每样商品数量只有一个，你该如何窃取，窃取财务的价值才能最大？</em></p>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li> 描述最优解结构</li>
</ol>
<p>   <img src="/images/%E5%B0%8F%E5%81%B7%E8%83%8C%E5%8C%85%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0.png"></p>
<ol start="2">
<li><p>递归定义最优解值</p>
<p>假设当前商品属于最大价值的商品的一部分，那么当前子背包容量扣去当前商品重量后的剩余重量所产生的商品价值应该为最大，否则假设不成立。</p>
<p>$$<br>为了方便讨论，定义如下变量： \<br>假设当前放入物品的索引为i，当前背包容量的索引为j。那么对应物品重量则为W_{i}，\ 对应的物品价值则为V_{i}，对应的背包容量为C_{j}，扣去当前物理重量，剩余背包容量对应的索引为k。\<br>再定义一个变量F_{i,j}表示放入一个容量为C_{j}的背包，可以获得的最大价值。那么会有如下方程：<br>$$</p>
<p>$$<br>F_{i,j}=\left{\begin{matrix}<br>V_{i} \quad\quad  i=0&amp;&amp;W_{i}&lt;=C_{j} \<br>0 \quad\quad i=0&amp;&amp;W_{i}&gt;C_{j} \<br>F_{i-1,j} \quad\quad i&gt;=1&amp;&amp;W_{i}&gt;C_{j} \<br>max{ F_{i-1,j}\quad , F_{i-1,k}+V_{i} } \quad\quad i&gt;=1&amp;&amp;W_{i}&lt;=C_{j} \</p>
<p>\end{matrix}\right.  \<br>$$</p>
</li>
</ol>
<ol start="3">
<li><p>按自底向上方式求解最优值</p>
<p>根据描述，需要定义一个双层循环，外层循环控制行——物品项。内层循环控制列——背包重量。</p>
<p>通过求解子背包的最大价值，进而求得当前背包的最大价值。伪代码描述如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外层循环，索引为i，最大值为物品数量-<span class="number">1</span></span><br><span class="line">	内层循环，索引为j，最大值为定义的子背包数量-<span class="number">1</span></span><br><span class="line">		获取当前物品的重量Wi，当前物品的价值Vi，当前背包容量Cj</span><br><span class="line">		判断Wi和Cj大小，Wi&gt;Cj，如果i!=<span class="number">0</span>，则Fij=Fi-1j，如果i=<span class="number">0</span>，则Fij=<span class="number">0</span></span><br><span class="line">    	Wi&lt;=Cj，如果i=<span class="number">0</span>，则Fij=Vi，如果i!=<span class="number">0</span>，则需要找出剩余背包容量最大价值Fi-1k</span><br><span class="line">    	找到后进行Fi-1k+Vi和Fi-1j的比较，较大的为当前项Fij的值</span><br></pre></td></tr></table></figure></li>
<li><p>用代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Goods</span>&gt; </span>&#123;</span><br><span class="line">   </span><br><span class="line"> <span class="keyword">private</span> String name;  <span class="comment">// 商品名称</span></span><br><span class="line"> <span class="keyword">private</span> Integer value;  <span class="comment">// 商品价值</span></span><br><span class="line"> <span class="keyword">private</span> Double weight;  <span class="comment">// 商品重量</span></span><br><span class="line">   </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String name, Integer value, Double weight)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.name = name;</span><br><span class="line">     <span class="keyword">this</span>.value = value;</span><br><span class="line">     <span class="keyword">this</span>.weight = weight;</span><br><span class="line"> &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Goods goods)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 按照商品重量进行比较</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.weight &lt; goods.weight) &#123;</span><br><span class="line">         <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.weight &gt; goods.weight) &#123;</span><br><span class="line">         <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//省略getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThiefWithGoodsProblem</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> bagCapacity;  <span class="comment">// 背包容量</span></span><br><span class="line"> <span class="keyword">private</span> Goods[] goodsList;  <span class="comment">// 商品列表</span></span><br><span class="line"> <span class="keyword">private</span> Double[] weightList; <span class="comment">//重量列表</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span>[][] valueCalculate;  <span class="comment">//偷走商品价值计算</span></span><br><span class="line"> <span class="keyword">private</span> ArrayList&lt;Goods&gt;[][] valueRecord;  <span class="comment">//偷走商品记录</span></span><br><span class="line">   </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThiefWithGoodsProblem</span><span class="params">(Goods[] goodsList, <span class="keyword">int</span> bagCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.bagCapacity = bagCapacity;</span><br><span class="line">     <span class="keyword">this</span>.goodsList = goodsList;</span><br><span class="line">     <span class="comment">// 根据重量从小到大排序</span></span><br><span class="line">     Arrays.sort(goodsList);</span><br><span class="line">     TreeSet&lt;Double&gt; weightTempList = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span> (Goods g : goodsList) &#123;</span><br><span class="line">         weightTempList.add(g.getWeight());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">this</span>.weightList = weightTempList.toArray(<span class="keyword">new</span> Double[<span class="number">0</span>]);</span><br><span class="line">   </span><br><span class="line">     <span class="comment">//初始化</span></span><br><span class="line">     valueCalculate = <span class="keyword">new</span> <span class="keyword">int</span>[goodsList.length][weightList.length];</span><br><span class="line">     valueRecord = <span class="keyword">new</span> ArrayList[goodsList.length][weightList.length];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueRecord.length; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; valueRecord[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">             valueRecord[i][j] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">     <span class="comment">//开始计算并记录小偷能偷走的最大价值商品</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueRecord.length; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; valueRecord[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">             <span class="comment">// 获取当前商品</span></span><br><span class="line">             Goods currentGoods = goodsList[i];</span><br><span class="line">             <span class="comment">// 获取当前子背包重量</span></span><br><span class="line">             <span class="keyword">double</span> currentBagCapacity = weightList[j];</span><br><span class="line">             <span class="keyword">if</span> (currentGoods.getWeight() &gt; currentBagCapacity) &#123;</span><br><span class="line">                 <span class="comment">// 如果当前商品重量大于子背包重量，则将valueCalculate[i-1][j]的值作为</span></span><br><span class="line">                 <span class="comment">// 当前项的最大值</span></span><br><span class="line">                 <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                     valueCalculate[i][j] = valueCalculate[i - <span class="number">1</span>][j];</span><br><span class="line">                     valueRecord[i][j] = valueRecord[i - <span class="number">1</span>][j];</span><br><span class="line">                     <span class="keyword">continue</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 如果当前商品重量小于等于子背包重量，则需要比较valueCalculate[i][j]</span></span><br><span class="line">             <span class="comment">// 和valueCalculate[i][j - 1]的大小</span></span><br><span class="line">             <span class="keyword">int</span> maxGoodsValue = currentGoods.getValue();</span><br><span class="line">             currentBagCapacity = currentBagCapacity - currentGoods.getWeight();</span><br><span class="line">             <span class="comment">// 计算子背包剩余容量价值</span></span><br><span class="line">             <span class="keyword">if</span> (currentBagCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> w = weightList.length - <span class="number">1</span>; w &gt;= <span class="number">0</span>; w--) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (weightList[w] &lt;= currentBagCapacity) &#123;</span><br><span class="line">                         <span class="comment">// 找到背包剩余容量最大价值</span></span><br><span class="line">                         <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                             maxGoodsValue += valueCalculate[i - <span class="number">1</span>][w];</span><br><span class="line">                             <span class="comment">// 这里千万不要写成valueRecord[i][j] = valueRecord[i - 1][w]，被坑了一天</span></span><br><span class="line">                             <span class="comment">// 如果你这样做的话，它们是指向同一个列表，修改的时候是同时修改</span></span><br><span class="line">                             <span class="keyword">for</span> (Goods g : valueRecord[i - <span class="number">1</span>][w]) &#123;</span><br><span class="line">                                 valueRecord[i][j].add(g);</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                 valueCalculate[i][j] = maxGoodsValue;</span><br><span class="line">                 valueRecord[i][j].add(currentGoods);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (maxGoodsValue &gt; valueCalculate[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                     valueCalculate[i][j] = maxGoodsValue;</span><br><span class="line">                     valueRecord[i][j].add(currentGoods);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     valueCalculate[i][j] = valueCalculate[i - <span class="number">1</span>][j];</span><br><span class="line">                     <span class="comment">// 需要先清空残留记录</span></span><br><span class="line">                     valueRecord[i][j].clear();</span><br><span class="line">                     <span class="keyword">for</span> (Goods g : valueRecord[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                         valueRecord[i][j].add(g);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<blockquote>
<h4 id="对上述问题进行优化："><a href="#对上述问题进行优化：" class="headerlink" title="对上述问题进行优化："></a>对上述问题进行优化：</h4><p>$$<br>为了方便讨论，定义如下变量： \假设当前放入物品的索引为i，当前背包容量的索引为j。那么对应物品重量则为W_{i}，\ 对应的物品价值则为V_{i}，对应的背包容量为C_{j}，扣去当前物理重量，剩余背包容量对应的索引为k。\再定义一个变量F_{i,j}表示放入一个容量为C_{j}的背包，可以获得的最大价值。那么会有如下方程：<br>$$</p>
</blockquote>
<blockquote>
<p>$$<br>F_{i,j}=\left{\begin{matrix}V_{i} \quad\quad  i=0&amp;&amp;W_{i}&lt;=C_{j} \ 0 \quad\quad i=0&amp;&amp;W_{i}&gt;C_{j} \F_{i-1,j} \quad\quad i&gt;=1&amp;&amp;W_{i}&gt;C_{j} \max{ F_{i-1,j}\quad , F_{i-1,k}+V_{i} } \quad\quad i&gt;=1&amp;&amp;W_{i}&lt;=C_{j} \\end{matrix}\right.  \<br>$$</p>
<p>这4个式子，可以优化成剩下两个。需要增加一项：i=0时，表示没有物品放入背包。那么F0j就可以都表示为0。上述方程就可以优化成：<br>$$<br>F_{i,j}=\left{\begin{matrix}F_{i-1,j} \quad\quad W_{i}&gt;C_{j} \max{ F_{i-1,j}\quad , F_{i-1,k}+V_{i} } \quad\quad W_{i}&lt;=C_{j} \\end{matrix}\right.  \<br>$$</p>
</blockquote>
<blockquote>
<h4 id="关于背包初始化的问题"><a href="#关于背包初始化的问题" class="headerlink" title="关于背包初始化的问题"></a>关于背包初始化的问题</h4><p>上面的背包问题要求我们将背包内物品的价值最大化，并没有要求我们将背包装满。而背包初始化问题可以分成两类：一类就是背包内物品价值最大化，但不要求背包装满；另一类就是要求背包恰好装满时的最优解。</p>
<p>如果是第一类背包初始化问题，没有要求背包装满，只是希望价格尽可能大，那么初始化时应该将F0,j全部设为0。如果是第二类背包初始化问题，要求背包恰好装满的最优解，那么在初始化的时候除了F0,0=0，其他的Fi,j均应设为-∞，这样就可以保证最终得到的Fi,j为恰好装满背包的最优解。</p>
<p>这样做的原因就是，初始化的F数组实际上就是没有在装入任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可以在什么也不装且价值为0的情况下被恰好装满，其他容量的背包均处于未定义的状态，或者说还没有合法的解，应该被赋值为-∞。如果背包并非必须被装满，那么任何容量的背包都有一个合法解——什么都不装，这个解的价值为0，索引初始时状态的值也就全部为0。</p>
</blockquote>
<h2 id="背包问题2——完全背包"><a href="#背包问题2——完全背包" class="headerlink" title="背包问题2——完全背包"></a>背包问题2——完全背包</h2><blockquote>
<p>问题描述：</p>
<p>有N件物品和一个容量为V的背包，每种物品都有无限件可用，放入第i件的物品耗费的空间为Ci，得到的价值为Wi。如何组合，才能使背包里物品的价值最大？</p>
<ol>
<li>描述最优解结构。</li>
</ol>
<p>  <img src="/images/%E5%B0%8F%E5%81%B7%E8%83%8C%E5%8C%85%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0.png"></p>
<ol start="2">
<li>递归定义最优解的值<br>$$<br>定义如下变量：\<br>假设当前放入的物品索引为i，当前背包容量索引为j，放入物品数量为k。那么放入的物品重量则为W_{i}*k，\对应的物品价值为V_{i}<em>k,对应的背包容量为C_{j}，剩余背包容量对应的索引为C_{j}-k</em>W_{i}。\最后定义一个变量F_{i,j}表示容量为C_{j}的背包在当前物品情况下可以获取的最大价值。那么方程如下：<br>$$</li>
</ol>
<p>$$<br>  F_{i,j}=\left{\begin{matrix}F_{i-1,j} \quad\quad W_{i}&gt;C_{j} \max{ F_{i-1,C_{j}-k*W_{i}}+V_{i}<em>k \quad 0&lt;=k</em>W_{i}&lt;=C_{j} \quad k \in[0,1,2,3…] } \quad\quad W_{i}&lt;=C_{j} \\end{matrix}\right.  \<br>$$</p>
<ol start="3">
<li><p>按自底向上的方式求解最优解</p>
</li>
<li><p>用代码实现</p>
</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThiefWithMultipleGoodsProblem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bagCapacity;  <span class="comment">// 背包容量</span></span><br><span class="line">    <span class="keyword">private</span> Goods[] goodsList;  <span class="comment">// 商品列表</span></span><br><span class="line">    <span class="keyword">private</span> Double[] weightList; <span class="comment">//重量列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] valueCalculate;  <span class="comment">//偷走商品价值计算</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Goods&gt;[][] valueRecord;  <span class="comment">//偷走商品记录</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThiefWithMultipleGoodsProblem</span><span class="params">(Goods[] goodsList, <span class="keyword">int</span> bagCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bagCapacity = bagCapacity;</span><br><span class="line">        <span class="keyword">this</span>.goodsList = <span class="keyword">new</span> Goods[goodsList.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">this</span>.goodsList[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0.0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.goodsList.length; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.goodsList[i] = goodsList[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据重量从小到大排序</span></span><br><span class="line">        Arrays.sort(<span class="keyword">this</span>.goodsList);</span><br><span class="line">        TreeSet&lt;Double&gt; weightTempList = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Goods g : <span class="keyword">this</span>.goodsList) &#123;</span><br><span class="line">            weightTempList.add(g.getWeight());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.weightList = weightTempList.toArray(<span class="keyword">new</span> Double[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        valueCalculate = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.goodsList.length][weightList.length];</span><br><span class="line">        valueRecord = <span class="keyword">new</span> ArrayList[<span class="keyword">this</span>.goodsList.length][weightList.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueRecord.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; valueRecord[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                valueRecord[i][j] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; valueCalculate[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            valueCalculate[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; valueCalculate.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; valueCalculate[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                Goods currentGoods = <span class="keyword">this</span>.goodsList[i];</span><br><span class="line">                <span class="keyword">double</span> currentCapacity = <span class="keyword">this</span>.weightList[j];</span><br><span class="line">                valueCalculate[i][j] = valueCalculate[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">for</span> (Goods g : valueRecord[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                    valueRecord[i][j].add(g);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (currentGoods.getWeight() &gt; currentCapacity) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k * currentGoods.getWeight() &lt;= currentCapacity; k++) &#123;</span><br><span class="line">                    <span class="comment">// k = 0 的情况就是用[i-1][j]的值和记录进行替代</span></span><br><span class="line">                    <span class="keyword">int</span> maxValue = valueCalculate[i][j];</span><br><span class="line">                    <span class="keyword">double</span> remainCapacity = currentCapacity - k * currentGoods.getWeight();</span><br><span class="line">                    <span class="keyword">int</span> valueCalculateTemp = <span class="number">0</span>;  <span class="comment">//暂时记录计算值</span></span><br><span class="line">                    ArrayList&lt;Goods&gt; valueRecordTemp = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 暂时记录计算商品</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (remainCapacity != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> w = valueCalculate[<span class="number">0</span>].length - <span class="number">1</span>; w &gt;= <span class="number">0</span>; w--) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (valueCalculate[i - <span class="number">1</span>][w] &lt;= remainCapacity) &#123;</span><br><span class="line">                                valueCalculateTemp = valueCalculate[i - <span class="number">1</span>][w];</span><br><span class="line">                                <span class="keyword">for</span> (Goods g : valueRecord[i - <span class="number">1</span>][w]) &#123;</span><br><span class="line">                                    valueRecordTemp.add(g);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (maxValue &lt; k * currentGoods.getValue() + valueCalculateTemp) &#123;</span><br><span class="line">                        valueCalculate[i][j] = k * currentGoods.getValue() + valueCalculateTemp;</span><br><span class="line">                        valueRecord[i][j] = valueRecordTemp;  <span class="comment">// 清理原有记录并更改引用</span></span><br><span class="line">                        <span class="keyword">if</span> (k != <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;= k; m++) &#123;</span><br><span class="line">                                valueRecord[i][j].add(currentGoods);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">// max &gt;= k * currentGoods.getValue() + valueCalculateTemp 则不用进行替换</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="背包问题3——多重背包"><a href="#背包问题3——多重背包" class="headerlink" title="背包问题3——多重背包"></a>背包问题3——多重背包</h2><blockquote>
<p>问题描述：</p>
<p>有N件物品和一个容量为V的背包，每种物品只有Ni件物品可用(Ni&gt;=1)，放入第i件的物品耗费的空间为Ci，得到的价值为Wi。如何组合，才能使背包里物品的价值最大？</p>
<p>这和完全背包的问题几乎一致，只需进行细节部分的处理：对物品取走个数的限制，而不是偷到背包满。因此，只需要对内层循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k * currentGoods.getWeight() &lt;= currentCapacity; k++) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做修改，改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= limitNumber &amp;&amp; k * currentGoods.getWeight() &lt;= currentCapacity; k++) </span><br></pre></td></tr></table></figure>

<p>即可</p>
</blockquote>
]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树(BST)</title>
    <url>/2020/09/11/%E4%BA%8C%E5%8F%89%E6%A0%91(BST)/</url>
    <content><![CDATA[<p>树（Tree）是一种很有趣的数据结构，它既能像链表那样快速的插入和删除，又能像有序数组那样快速查找。树的种类很多，本节将记录一种特殊的树————二叉树（Binary Tree）。二叉树的每个节点最多只能有两个子节点，通常称为左子节点和右子节点。如果一个二叉树的每个节点的左子节点的关键字值小于该节点，右子节点的关键字值大于等于该节点，那么这种二叉树也称为二叉搜索树（Binary Search Tree,<strong>BST</strong>）</p>
<span id="more"></span>

<h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><p><img src="/images/BST%E4%BE%8B%E5%AD%90.png"></p>
<ul>
<li>路径：从一个节点走到另一个节点，经过的节点顺序就称为路径；</li>
<li>根：树的顶端节点称为根，一个数只能有一个根节点，并且从根节点到任意子节点只能有一条路径；</li>
<li>父节点：每个节点（除了根）都有一条边向上连接到另一个节点，这个节点就是下面节点的父节点；</li>
<li>子节点：每个节点（除了叶子节点）都有一条或两条边向下连接其他节点，下面这些节点就是当前节点的子节点。子节点分为左子节点和右子节点；</li>
<li>叶节点：没有子节点的节点称为叶子节点，或叶节点；</li>
<li>关键字：节点中的数据，比如上图中的数值。</li>
</ul>
<h2 id="操作BST"><a href="#操作BST" class="headerlink" title="操作BST"></a>操作BST</h2><p>在操作BST前，我们先用代码定义一个BST的骨架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的这些操作都以这个BST为例：</p>
<p><img src="/images/BST%E5%AE%9E%E4%BE%8B.png"></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>假如我们需要插入一个key为88的节点，需要经过如下步骤：</p>
<ol>
<li>从根节点出发，88比72大，所以走右子节点82路径；</li>
<li>88比82大，所以走右子节点90路径；</li>
<li>88比90小，所以走左子节点87路径；</li>
<li>88比87大，并且87的右子节点为空，所以我们最终把88作为87的右子节点插入树中。</li>
</ol>
<p>当key重复时，可以选择覆盖或者忽略，这由业务决定。</p>
<p>上述过程动态图如下所示：</p>
<p><img src="/images/BST%E6%8F%92%E5%85%A5%E5%8A%A8%E5%9B%BE.gif"></p>
<p>Java代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 插入 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个新节点</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果根为null，则这个新节点就是根</span></span><br><span class="line">            root = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果跟不为null，则从根开始搜索插入位置</span></span><br><span class="line">            Node currentNode = root;</span><br><span class="line">            <span class="comment">// 用于暂存父节点</span></span><br><span class="line">            Node parentNode;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 父节点设置为当前节点</span></span><br><span class="line">                parentNode = currentNode;</span><br><span class="line">                <span class="keyword">if</span> (key &lt; currentNode.key) &#123;</span><br><span class="line">                    currentNode = currentNode.leftChild;</span><br><span class="line">                    <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果key小于当前节点key，并且当前节点的左子节点为空，则将新节点</span></span><br><span class="line">                        <span class="comment">// 设置为当前节点（父节点暂存对象）的左子节点，退出循环</span></span><br><span class="line">                        parentNode.leftChild = newNode;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; currentNode.key) &#123;</span><br><span class="line">                    currentNode = currentNode.rightChild;</span><br><span class="line">                    <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果key大于当前节点key，并且当前节点的右子节点为空，则将新节点</span></span><br><span class="line">                        <span class="comment">// 设置为当前节点（父节点暂存对象）的又子节点，退出循环</span></span><br><span class="line">                        parentNode.rightChild = newNode;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果key等于当前节点key，则将value覆盖当前节点value</span></span><br><span class="line">                    currentNode.value = newNode.value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearchTree bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">        Arrays.asList(<span class="number">72</span>, <span class="number">57</span>, <span class="number">82</span>, <span class="number">30</span>, <span class="number">63</span>, <span class="number">79</span>, <span class="number">90</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">62</span>, <span class="number">67</span>, <span class="number">80</span>, <span class="number">87</span>, <span class="number">48</span>).forEach(key -&gt; &#123;</span><br><span class="line">            String value = <span class="string">&quot;我是key为&quot;</span> + key + <span class="string">&quot;的value&quot;</span>;</span><br><span class="line">            bst.insert(key, value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%8F%92%E5%85%A5%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>假如我们需要查找key为67的节点，需要经过如下步骤：</p>
<ol>
<li>从根节点出发，67比72小，所以走左子节点57路径；</li>
<li>67比57大，所以走右子节点63路径；</li>
<li>67比63大，所以走右子节点67路径；</li>
<li>67等于67，找到目标节点，退出；</li>
<li>如果搜索直到叶子节点都没找到，则返回空。</li>
</ol>
<p>上述过程动态图如下所示：</p>
<p><img src="/images/BST%E6%9F%A5%E6%89%BE%E5%8A%A8%E5%9B%BE.gif"></p>
<p>Java代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 查找 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从根节点开始查找</span></span><br><span class="line">        Node currentNode = root;</span><br><span class="line">        <span class="comment">// 当前节点的key不等于被查找的key时</span></span><br><span class="line">        <span class="keyword">while</span> (currentNode.key != key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; currentNode.key) &#123;</span><br><span class="line">                <span class="comment">// 如果key值小于当前节点key，则查找左子节点</span></span><br><span class="line">                currentNode = currentNode.leftChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果key值大于等于当前节点key，则查找右子节点</span></span><br><span class="line">                currentNode = currentNode.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前节点为null，说明查到叶子节点了，仍没查到目标key，则直接返回null</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回当前节点（退出while循环要么key相等，要么没找到，结果为null）</span></span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearchTree bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">        Arrays.asList(<span class="number">72</span>, <span class="number">57</span>, <span class="number">82</span>, <span class="number">30</span>, <span class="number">63</span>, <span class="number">79</span>, <span class="number">90</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">62</span>, <span class="number">67</span>, <span class="number">80</span>, <span class="number">87</span>, <span class="number">48</span>).forEach(key -&gt; &#123;</span><br><span class="line">            String value = <span class="string">&quot;我是key为&quot;</span> + key + <span class="string">&quot;的value&quot;</span>;</span><br><span class="line">            bst.insert(key, value);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(bst.find(<span class="number">87</span>).value);</span><br><span class="line">        bst.insert(<span class="number">87</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        System.out.println(bst.find(<span class="number">87</span>).value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">我是<span class="built_in">key</span>为<span class="number">87</span>的value</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h3 id="最大最小值"><a href="#最大最小值" class="headerlink" title="最大最小值"></a>最大最小值</h3><p>在BST里查找最大值和最小值是非常容易的一件事，根据BST特性，小的值都分布在左节点，大的值都分布在右节点，所以<strong>最小值查找方法为：从根节点出发，一直往下查找左子节点，当该节点不再有左子节点时，该节点就是最小节点；最大值查找方法为：从根节点出发，一直往下查找右子节点，当该节点不再有右子节点时，该节点就是最大节点</strong>。</p>
<p>查找最小值图示：</p>
<p><img src="/images/BST%E6%9F%A5%E6%89%BE%E6%9C%80%E5%B0%8F%E5%80%BC.gif"></p>
<p>查找最大值图示：</p>
<p><img src="/images/BST%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC.gif"></p>
<p>Java代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最小值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node currentNode = root;</span><br><span class="line">        <span class="keyword">while</span> (currentNode.leftChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentNode = currentNode.leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node currentNode = root;</span><br><span class="line">        <span class="keyword">while</span> (currentNode.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentNode = currentNode.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearchTree bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">        Arrays.asList(<span class="number">72</span>, <span class="number">57</span>, <span class="number">82</span>, <span class="number">30</span>, <span class="number">63</span>, <span class="number">79</span>, <span class="number">90</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">62</span>, <span class="number">67</span>, <span class="number">80</span>, <span class="number">87</span>, <span class="number">48</span>).forEach(key -&gt; &#123;</span><br><span class="line">            String value = <span class="string">&quot;我是key为&quot;</span> + key + <span class="string">&quot;的value&quot;</span>;</span><br><span class="line">            bst.insert(key, value);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(bst.min().value);</span><br><span class="line">        System.out.println(bst.max().value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下所示：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">我是<span class="built_in">key</span>为<span class="number">27</span>的value</span><br><span class="line">我是<span class="built_in">key</span>为<span class="number">90</span>的value</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除是BST操作里最复杂的一个，因为需要考虑的因素比较多：</p>
<ol>
<li>被删除的节点是叶子节点；</li>
<li>被删除的节点只有一个子节点；</li>
<li>被删除的节点有两个子节点。</li>
</ol>
<p>下面我们逐个分析：</p>
<h4 id="被删除的节点是叶子节点"><a href="#被删除的节点是叶子节点" class="headerlink" title="被删除的节点是叶子节点"></a>被删除的节点是叶子节点</h4><p>这种情况最为简单，删除节点前需要先找到该节点，过程和上面的查找类似。找到需要删除的节点后，如果是叶子节点，则将该节点的父节点引用置为null，被删除的节点没了引用，后续由GC自动回收。</p>
<p>假如我们需要删除key为48的节点，需要经过如下步骤：</p>
<ol>
<li>从根节点出发，48比72小，所以走左子节点57路径；</li>
<li>48比57小，所以走左子节点30路径；</li>
<li>48比30大，所以走右子节点40路径；</li>
<li>48比40大，所以走右子节点48路径；</li>
<li>48等于48，所以当前节点就是需要被删除节点；</li>
<li>48没有子节点，为叶子节点，所以直接将40的右子节点引用设置为null即可。</li>
</ol>
<p>该过程如下图所示：</p>
<p><img src="/images/BST%E5%88%A0%E9%99%A4%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9.gif"></p>
<p>Java代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 删除 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* --------- 查找需要被删除的节点以及它的父节点 ------- */</span></span><br><span class="line">        <span class="comment">// 从根节点开始查找</span></span><br><span class="line">        Node deleteNode = root;</span><br><span class="line">        <span class="comment">// 暂存需要被删除节点的父节点</span></span><br><span class="line">        Node parentNode = root;</span><br><span class="line">        <span class="comment">// 标识被删除的节点时父节点的左子节点还是右子节点</span></span><br><span class="line">        <span class="keyword">boolean</span> isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 下面这个过程和查找一致，只不过加了isLeftChild标识</span></span><br><span class="line">        <span class="keyword">while</span> (deleteNode.key != key) &#123;</span><br><span class="line">            parentNode = deleteNode;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; deleteNode.key) &#123;</span><br><span class="line">                isLeftChild = <span class="keyword">true</span>;</span><br><span class="line">                deleteNode = deleteNode.leftChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">                deleteNode = deleteNode.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果目标key对应的节点为空，则不需要删除，直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (deleteNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* --------- 情况1：被删除的节点是叶子节点 ------- */</span></span><br><span class="line">        <span class="keyword">if</span> (deleteNode.leftChild == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; deleteNode.rightChild == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deleteNode == root) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的节点为root，则直接将root节点设置为null</span></span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的左子节点，则将父节点的左子节点关联置为null</span></span><br><span class="line">                parentNode.leftChild = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的右子节点，则将父节点的右子节点关联置为null</span></span><br><span class="line">                parentNode.rightChild = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearchTree bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">        Arrays.asList(<span class="number">72</span>, <span class="number">57</span>, <span class="number">82</span>, <span class="number">30</span>, <span class="number">63</span>, <span class="number">79</span>, <span class="number">90</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">62</span>, <span class="number">67</span>, <span class="number">80</span>, <span class="number">87</span>, <span class="number">48</span>).forEach(key -&gt; &#123;</span><br><span class="line">            String value = <span class="string">&quot;我是key为&quot;</span> + key + <span class="string">&quot;的value&quot;</span>;</span><br><span class="line">            bst.insert(key, value);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(bst.delete(<span class="number">49</span>));</span><br><span class="line">        System.out.println(bst.delete(<span class="number">48</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>可以看到40的右子节点已经被删除</p>
<h4 id="被删除的节点只有一个子节点"><a href="#被删除的节点只有一个子节点" class="headerlink" title="被删除的节点只有一个子节点"></a>被删除的节点只有一个子节点</h4><p>这种情况也比较简单，只需要将被删除节点的子节点和其父节点建立连接关系即可。</p>
<p>假如我们需要删除key为79的节点，需要经过如下步骤：</p>
<ol>
<li>从根节点出发，79比72大，所以走右子节点82路径；</li>
<li>79比82小，所以走左子节点79路径；</li>
<li>79等于79，所以当前节点就是需要被删除节点；</li>
<li>79只有一个右子节点，因为79是82的左子节点，所以直接将80设置为82的左子节点即可。</li>
</ol>
<p>该过程如下图所示：</p>
<p><img src="/images/BST%E8%A2%AB%E5%88%A0%E8%8A%82%E7%82%B9%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9.gif"></p>
<p>Java代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* --------- 查找需要被删除的节点以及它的父节点 ------- */</span></span><br><span class="line">        <span class="comment">// 从根节点开始查找</span></span><br><span class="line">        Node deleteNode = root;</span><br><span class="line">        <span class="comment">// 暂存需要被删除节点的父节点</span></span><br><span class="line">        Node parentNode = root;</span><br><span class="line">        <span class="comment">// 标识被删除的节点时父节点的左子节点还是右子节点</span></span><br><span class="line">        <span class="keyword">boolean</span> isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 下面这个过程和查找一致，只不过加了isLeftChild标识</span></span><br><span class="line">        <span class="keyword">while</span> (deleteNode.key != key) &#123;</span><br><span class="line">            parentNode = deleteNode;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; deleteNode.key) &#123;</span><br><span class="line">                isLeftChild = <span class="keyword">true</span>;</span><br><span class="line">                deleteNode = deleteNode.leftChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">                deleteNode = deleteNode.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果目标key对应的节点为空，则不需要删除，直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (deleteNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* --------- 情况1：被删除的节点是叶子节点 ------- */</span></span><br><span class="line">        <span class="keyword">if</span> (deleteNode.leftChild == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; deleteNode.rightChild == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deleteNode == root) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的节点为root，则直接将root节点设置为null</span></span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的左子节点，则将父节点的左子节点关联置为null</span></span><br><span class="line">                parentNode.leftChild = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的右子节点，则将父节点的右子节点关联置为null</span></span><br><span class="line">                parentNode.rightChild = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deleteNode.leftChild != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; deleteNode.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* --------- 情况3：被删除的节点有两个子节点 ------- */</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* --------- 情况2：被删除的节点只有一个子节点 ------- */</span></span><br><span class="line">            <span class="comment">// 获取被删除节点的唯一子节点</span></span><br><span class="line">            Node deleteNodeChild = deleteNode.leftChild == <span class="keyword">null</span> ?</span><br><span class="line">                    deleteNode.rightChild : deleteNode.leftChild;</span><br><span class="line">            <span class="keyword">if</span> (deleteNode == root) &#123;</span><br><span class="line">                <span class="comment">// 如果被删除节点就是root，那么将其唯一子节点设置为root</span></span><br><span class="line">                root = deleteNodeChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的左子节点，则将父节点的左子节点关联置为被删除节点的唯一子节点</span></span><br><span class="line">                parentNode.leftChild = deleteNodeChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的右子节点，则将父节点的右子节点关联置为被删除节点的唯一子节点</span></span><br><span class="line">                parentNode.rightChild = deleteNodeChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearchTree bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">        Arrays.asList(<span class="number">72</span>, <span class="number">57</span>, <span class="number">82</span>, <span class="number">30</span>, <span class="number">63</span>, <span class="number">79</span>, <span class="number">90</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">62</span>, <span class="number">67</span>, <span class="number">80</span>, <span class="number">87</span>, <span class="number">48</span>).forEach(key -&gt; &#123;</span><br><span class="line">            String value = <span class="string">&quot;我是key为&quot;</span> + key + <span class="string">&quot;的value&quot;</span>;</span><br><span class="line">            bst.insert(key, value);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(bst.delete(<span class="number">79</span>));</span><br><span class="line">        System.out.println(bst.find(<span class="number">82</span>).leftChild.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line">我是<span class="built_in">key</span>为<span class="number">80</span>的value</span><br></pre></td></tr></table></figure>

<h4 id="被删除的节点有两个子节点"><a href="#被删除的节点有两个子节点" class="headerlink" title="被删除的节点有两个子节点"></a>被删除的节点有两个子节点</h4><p>这种情况比较复杂，删除的节点不能用删除节点的某个子节点来代替。比如现在需要删除上述BST的57节点，假如用57节点的右子节点63代替该节点，那么63的左子节点既不能是62，也不能是57的左子节点30。</p>
<p>这种情况下需要找到被删除节点的中序后继节点（successor）来代替它。所谓的中序后继节点就是：<strong>整个树中关键字值比被删除节点大，并且比被删除节点右子节点小的那部分节点中的关键字值最小的节点</strong>。</p>
<p>根据中序后继节点的定义来看，要找到它也很简单：</p>
<ol>
<li>从被删除节点的右子节点出发，一直往下找左子节点，当该节点不再有左子节点时，该节点就是中序后继节点；</li>
<li>如果被删除节点的右子节点没有左子节点，那么它就是要找的中序后继节点。</li>
</ol>
<p>举个例子，比如现在需要删除上述BST的57节点，那么它的中序后继节点为62；假如要删除的节点为63，那么它的中序后继为67：</p>
<ol>
<li><p>当删除的节点为57时，过程如下所示：</p>
<p><img src="/images/BST%E8%A2%AB%E5%88%A0%E9%99%A4%E7%9A%84%E8%8A%82%E7%82%B9%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9.gif"></p>
</li>
<li><p>当删除的节点为63时，过程如下所示：</p>
<p><img src="/images/BST%E8%A2%AB%E5%88%A0%E9%99%A4%E7%9A%84%E8%8A%82%E7%82%B9%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B91.gif"></p>
</li>
</ol>
<p>编写查找中序后继节点的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找中序后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getSuccessor</span><span class="params">(Node deleteNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暂存中序后继节点的父节点</span></span><br><span class="line">        Node successorParent = deleteNode;</span><br><span class="line">        <span class="comment">// 暂存中序后继节点</span></span><br><span class="line">        Node successor = deleteNode;</span><br><span class="line">        <span class="comment">// 先从删除节点的右子节点开始查找</span></span><br><span class="line">        Node currentNode = deleteNode.rightChild;</span><br><span class="line">        <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            successorParent = successor;</span><br><span class="line">            successor = currentNode;</span><br><span class="line">            <span class="comment">// 一直往下查找当前节点的左子节点，直到为空</span></span><br><span class="line">            currentNode = currentNode.leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如上面文章所说，中序后继节点和删除节点有两种可能性，</span></span><br><span class="line">        <span class="comment">// 当中序后继节点不是删除节点的右子节点时，需要做如下额外操作</span></span><br><span class="line">        <span class="keyword">if</span> (successor != deleteNode.rightChild) &#123;</span><br><span class="line">            <span class="comment">// 如果中序后继节点的右子节点不为空的话，将其和中序后继节点父节点的左子节点挂钩</span></span><br><span class="line">            <span class="keyword">if</span> (successor.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">                successorParent.leftChild = successor.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 中序后继节点的右子节点和删除节点的右子节点挂钩</span></span><br><span class="line">            successor.rightChild = deleteNode.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中序后继节点的左子节点和删除节点的左子节点挂钩</span></span><br><span class="line">        successor.leftChild = deleteNode.leftChild;</span><br><span class="line">        <span class="comment">// 剩下的删除节点的父节点和中序后继节点的连接关系在删除方法里处理，</span></span><br><span class="line">        <span class="comment">// 因为这个方法内无法获取删除节点的父节点对象</span></span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成删除方法的最后一个部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* --------- 查找需要被删除的节点已经它的父节点 ------- */</span></span><br><span class="line">        <span class="comment">// 从根节点开始查找</span></span><br><span class="line">        Node deleteNode = root;</span><br><span class="line">        <span class="comment">// 暂存需要被删除节点的父节点</span></span><br><span class="line">        Node parentNode = root;</span><br><span class="line">        <span class="comment">// 标识被删除的节点时父节点的左子节点还是右子节点</span></span><br><span class="line">        <span class="keyword">boolean</span> isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 下面这个过程和查找一致，只不过加了isLeftChild标识</span></span><br><span class="line">        <span class="keyword">while</span> (deleteNode.key != key) &#123;</span><br><span class="line">            parentNode = deleteNode;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; deleteNode.key) &#123;</span><br><span class="line">                isLeftChild = <span class="keyword">true</span>;</span><br><span class="line">                deleteNode = deleteNode.leftChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">                deleteNode = deleteNode.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果目标key对应的节点为空，则不需要删除，直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (deleteNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* --------- 情况1：被删除的节点是叶子节点 ------- */</span></span><br><span class="line">        <span class="keyword">if</span> (deleteNode.leftChild == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; deleteNode.rightChild == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deleteNode == root) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的节点为root，则直接将root节点设置为null</span></span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的左子节点，则将父节点的左子节点关联置为null</span></span><br><span class="line">                parentNode.leftChild = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的右子节点，则将父节点的右子节点关联置为null</span></span><br><span class="line">                parentNode.rightChild = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deleteNode.leftChild != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; deleteNode.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* --------- 情况3：被删除的节点有两个子节点 ------- */</span></span><br><span class="line">            <span class="comment">// 获取删除节点的中序后继节点</span></span><br><span class="line">            Node successor = getSuccessor(deleteNode);</span><br><span class="line">            <span class="comment">// 如果伤处节点就是根节点的话，中序后继节点直接成为新的根</span></span><br><span class="line">            <span class="keyword">if</span> (deleteNode == root) &#123;</span><br><span class="line">                root = successor;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">                <span class="comment">// 如果删除节点是父节点的左子节点，则将父节点的左子节点和中序后继节点挂钩</span></span><br><span class="line">                parentNode.leftChild = successor;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果删除节点是父节点的右子节点，则将父节点的右子节点和中序后继节点挂钩</span></span><br><span class="line">                parentNode.rightChild = successor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* --------- 情况2：被删除的节点只有一个子节点 ------- */</span></span><br><span class="line">            <span class="comment">// 获取被删除节点的唯一子节点</span></span><br><span class="line">            Node deleteNodeChild = deleteNode.leftChild == <span class="keyword">null</span> ?</span><br><span class="line">                    deleteNode.rightChild : deleteNode.leftChild;</span><br><span class="line">            <span class="keyword">if</span> (deleteNode == root) &#123;</span><br><span class="line">                <span class="comment">// 如果被删除节点就是root，那么将其唯一子节点设置为root</span></span><br><span class="line">                root = deleteNodeChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的左子节点，则将父节点的左子节点关联置为被删除节点的唯一子节点</span></span><br><span class="line">                parentNode.leftChild = deleteNodeChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的右子节点，则将父节点的右子节点关联置为被删除节点的唯一子节点</span></span><br><span class="line">                parentNode.rightChild = deleteNodeChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序测试一下：</p>
<p>当删除的节点为57时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearchTree bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">        Arrays.asList(<span class="number">72</span>, <span class="number">57</span>, <span class="number">82</span>, <span class="number">30</span>, <span class="number">63</span>, <span class="number">79</span>, <span class="number">90</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">62</span>, <span class="number">67</span>, <span class="number">80</span>, <span class="number">87</span>, <span class="number">48</span>).forEach(key -&gt; &#123;</span><br><span class="line">            String value = <span class="string">&quot;我是key为&quot;</span> + key + <span class="string">&quot;的value&quot;</span>;</span><br><span class="line">            bst.insert(key, value);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除57节点: &quot;</span> + bst.delete(<span class="number">57</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;72节点的左子节点为: &quot;</span> + bst.find(<span class="number">72</span>).leftChild.key);</span><br><span class="line">        BinarySearchTree.Node node62 = bst.find(<span class="number">62</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;62节点的左子节点为: &quot;</span> + node62.leftChild.key);</span><br><span class="line">        System.out.println(<span class="string">&quot;62节点的右子节点为: &quot;</span> + node62.rightChild.key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">删除57节点: true</span></span><br><span class="line"><span class="section">72节点的左子节点为: 62</span></span><br><span class="line"><span class="section">62节点的左子节点为: 30</span></span><br><span class="line"><span class="section">62节点的右子节点为: 63</span></span><br></pre></td></tr></table></figure>

<p>当删除的节点为63时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearchTree bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">        Arrays.asList(<span class="number">72</span>, <span class="number">57</span>, <span class="number">82</span>, <span class="number">30</span>, <span class="number">63</span>, <span class="number">79</span>, <span class="number">90</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">62</span>, <span class="number">67</span>, <span class="number">80</span>, <span class="number">87</span>, <span class="number">48</span>).forEach(key -&gt; &#123;</span><br><span class="line">            String value = <span class="string">&quot;我是key为&quot;</span> + key + <span class="string">&quot;的value&quot;</span>;</span><br><span class="line">            bst.insert(key, value);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除63节点: &quot;</span> + bst.delete(<span class="number">63</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;57节点的右子节点为: &quot;</span> + bst.find(<span class="number">57</span>).rightChild.key);</span><br><span class="line">        BinarySearchTree.Node node67 = bst.find(<span class="number">67</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;67节点的左子节点为: &quot;</span> + node67.leftChild.key);</span><br><span class="line">        System.out.println(<span class="string">&quot;67节点的右子节点为: &quot;</span> + (node67.rightChild == <span class="keyword">null</span> ? <span class="keyword">null</span> : node67.rightChild.key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">删除63节点: true</span></span><br><span class="line"><span class="section">57节点的右子节点为: 67</span></span><br><span class="line"><span class="section">67节点的左子节点为: 62</span></span><br><span class="line"><span class="section">67节点的右子节点为: null</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>遍历树指的是以一种特定顺序访问树的每一个节点，这个顺序分为：中序、前序和后序。</p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>中序遍历的步骤为：</p>
<ol>
<li>递归遍历目标节点的左子节点；</li>
<li>访问目标节点本身；</li>
<li>递归遍历目标节点的右子节点。</li>
</ol>
<p>Java实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 遍历需要从根开始遍历，所以添加根的get方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 中序遍历 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node targetNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (targetNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的左子节点</span></span><br><span class="line">            inOrder(targetNode.leftChild);</span><br><span class="line">            <span class="comment">// 访问目标节点本身</span></span><br><span class="line">            System.out.print(targetNode.key + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的右子节点</span></span><br><span class="line">            inOrder(targetNode.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearchTree bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">        Arrays.asList(<span class="number">72</span>, <span class="number">57</span>, <span class="number">82</span>, <span class="number">30</span>, <span class="number">63</span>, <span class="number">79</span>, <span class="number">90</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">62</span>, <span class="number">67</span>, <span class="number">80</span>, <span class="number">87</span>, <span class="number">48</span>).forEach(key -&gt; &#123;</span><br><span class="line">            String value = <span class="string">&quot;我是key为&quot;</span> + key + <span class="string">&quot;的value&quot;</span>;</span><br><span class="line">            bst.insert(key, value);</span><br><span class="line">        &#125;);</span><br><span class="line">        bst.inOrder(bst.getRoot());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">27</span> <span class="number">30</span> <span class="number">40</span> <span class="number">48</span> <span class="number">57</span> <span class="number">62</span> <span class="number">63</span> <span class="number">67</span> <span class="number">72</span> <span class="number">79</span> <span class="number">80</span> <span class="number">82</span> <span class="number">87</span> <span class="number">90</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/BST%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.gif"></p>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>前序遍历的步骤为：</p>
<ol>
<li>访问目标节点本身；</li>
<li>递归遍历目标节点的左子节点；</li>
<li>递归遍历目标节点的右子节点。</li>
</ol>
<p>Java实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 遍历需要从根开始遍历，所以添加根的get方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 前序遍历 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node targetNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (targetNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 访问目标节点本身</span></span><br><span class="line">            System.out.print(targetNode.key + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的左子节点</span></span><br><span class="line">            preOrder(targetNode.leftChild);</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的右子节点</span></span><br><span class="line">            preOrder(targetNode.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearchTree bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">        Arrays.asList(<span class="number">72</span>, <span class="number">57</span>, <span class="number">82</span>, <span class="number">30</span>, <span class="number">63</span>, <span class="number">79</span>, <span class="number">90</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">62</span>, <span class="number">67</span>, <span class="number">80</span>, <span class="number">87</span>, <span class="number">48</span>).forEach(key -&gt; &#123;</span><br><span class="line">            String value = <span class="string">&quot;我是key为&quot;</span> + key + <span class="string">&quot;的value&quot;</span>;</span><br><span class="line">            bst.insert(key, value);</span><br><span class="line">        &#125;);</span><br><span class="line">        bst.preOrder(bst.getRoot());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">72</span> <span class="number">57</span> <span class="number">30</span> <span class="number">27</span> <span class="number">40</span> <span class="number">48</span> <span class="number">63</span> <span class="number">62</span> <span class="number">67</span> <span class="number">82</span> <span class="number">79</span> <span class="number">80</span> <span class="number">90</span> <span class="number">87</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/BST%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.gif"></p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>后序遍历的步骤为：</p>
<ol>
<li>递归遍历目标节点的左子节点；</li>
<li>递归遍历目标节点的右子节点；</li>
<li>访问目标节点本身。</li>
</ol>
<p>Java实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 遍历需要从根开始遍历，所以添加根的get方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 后续遍历 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node targetNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (targetNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的左子节点</span></span><br><span class="line">            postOrder(targetNode.leftChild);</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的右子节点</span></span><br><span class="line">            postOrder(targetNode.rightChild);</span><br><span class="line">            <span class="comment">// 访问目标节点本身</span></span><br><span class="line">            System.out.print(targetNode.key + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearchTree bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">        Arrays.asList(<span class="number">72</span>, <span class="number">57</span>, <span class="number">82</span>, <span class="number">30</span>, <span class="number">63</span>, <span class="number">79</span>, <span class="number">90</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">62</span>, <span class="number">67</span>, <span class="number">80</span>, <span class="number">87</span>, <span class="number">48</span>).forEach(key -&gt; &#123;</span><br><span class="line">            String value = <span class="string">&quot;我是key为&quot;</span> + key + <span class="string">&quot;的value&quot;</span>;</span><br><span class="line">            bst.insert(key, value);</span><br><span class="line">        &#125;);</span><br><span class="line">        bst.postOrder(bst.getRoot());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">27</span> <span class="number">48</span> <span class="number">40</span> <span class="number">30</span> <span class="number">62</span> <span class="number">67</span> <span class="number">63</span> <span class="number">57</span> <span class="number">80</span> <span class="number">79</span> <span class="number">87</span> <span class="number">90</span> <span class="number">82</span> <span class="number">72</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/BST%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.gif"></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BST</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历需要从根开始遍历，所以添加根的get方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个新节点</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果根为null，则这个新节点就是根</span></span><br><span class="line">            root = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果跟不为null，则从根开始搜索插入位置</span></span><br><span class="line">            Node currentNode = root;</span><br><span class="line">            <span class="comment">// 用于暂存父节点</span></span><br><span class="line">            Node parentNode;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 父节点设置为当前节点</span></span><br><span class="line">                parentNode = currentNode;</span><br><span class="line">                <span class="keyword">if</span> (key &lt; currentNode.key) &#123;</span><br><span class="line">                    currentNode = currentNode.leftChild;</span><br><span class="line">                    <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果key小于当前节点key，并且当前节点的左子节点为空，则将新节点</span></span><br><span class="line">                        <span class="comment">// 设置为当前节点（父节点暂存对象）的左子节点，退出循环</span></span><br><span class="line">                        parentNode.leftChild = newNode;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; currentNode.key) &#123;</span><br><span class="line">                    currentNode = currentNode.rightChild;</span><br><span class="line">                    <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果key大于当前节点key，并且当前节点的右子节点为空，则将新节点</span></span><br><span class="line">                        <span class="comment">// 设置为当前节点（父节点暂存对象）的又子节点，退出循环</span></span><br><span class="line">                        parentNode.rightChild = newNode;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果key等于当前节点key，则将value覆盖当前节点value</span></span><br><span class="line">                    currentNode.value = newNode.value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从根节点开始查找</span></span><br><span class="line">        Node currentNode = root;</span><br><span class="line">        <span class="comment">// 当前节点的key不等于被查找的key时</span></span><br><span class="line">        <span class="keyword">while</span> (currentNode.key != key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; currentNode.key) &#123;</span><br><span class="line">                <span class="comment">// 如果key值小于当前节点key，则查找左子节点</span></span><br><span class="line">                currentNode = currentNode.leftChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果key值大于等于当前节点key，则查找右子节点</span></span><br><span class="line">                currentNode = currentNode.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前节点为null，说明查到叶子节点了，仍没查到目标key，则直接返回null</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回当前节点（退出while循环要么key相等，要么没找到，结果为null）</span></span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最小值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node currentNode = root;</span><br><span class="line">        <span class="keyword">while</span> (currentNode.leftChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentNode = currentNode.leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node currentNode = root;</span><br><span class="line">        <span class="keyword">while</span> (currentNode.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentNode = currentNode.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* --------- 查找需要被删除的节点已经它的父节点 ------- */</span></span><br><span class="line">        <span class="comment">// 从根节点开始查找</span></span><br><span class="line">        Node deleteNode = root;</span><br><span class="line">        <span class="comment">// 暂存需要被删除节点的父节点</span></span><br><span class="line">        Node parentNode = root;</span><br><span class="line">        <span class="comment">// 标识被删除的节点时父节点的左子节点还是右子节点</span></span><br><span class="line">        <span class="keyword">boolean</span> isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 下面这个过程和查找一致，只不过加了isLeftChild标识</span></span><br><span class="line">        <span class="keyword">while</span> (deleteNode.key != key) &#123;</span><br><span class="line">            parentNode = deleteNode;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; deleteNode.key) &#123;</span><br><span class="line">                isLeftChild = <span class="keyword">true</span>;</span><br><span class="line">                deleteNode = deleteNode.leftChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">                deleteNode = deleteNode.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果目标key对应的节点为空，则不需要删除，直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (deleteNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* --------- 情况1：被删除的节点是叶子节点 ------- */</span></span><br><span class="line">        <span class="keyword">if</span> (deleteNode.leftChild == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; deleteNode.rightChild == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deleteNode == root) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的节点为root，则直接将root节点设置为null</span></span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的左子节点，则将父节点的左子节点关联置为null</span></span><br><span class="line">                parentNode.leftChild = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的右子节点，则将父节点的右子节点关联置为null</span></span><br><span class="line">                parentNode.rightChild = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deleteNode.leftChild != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; deleteNode.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* --------- 情况3：被删除的节点有两个子节点 ------- */</span></span><br><span class="line">            <span class="comment">// 获取删除节点的中序后继节点</span></span><br><span class="line">            Node successor = getSuccessor(deleteNode);</span><br><span class="line">            <span class="comment">// 如果伤处节点就是根节点的话，中序后继节点直接成为新的根</span></span><br><span class="line">            <span class="keyword">if</span> (deleteNode == root) &#123;</span><br><span class="line">                root = successor;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">                <span class="comment">// 如果删除节点是父节点的左子节点，则将父节点的左子节点和中序后继节点挂钩</span></span><br><span class="line">                parentNode.leftChild = successor;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果删除节点是父节点的右子节点，则将父节点的右子节点和中序后继节点挂钩</span></span><br><span class="line">                parentNode.rightChild = successor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* --------- 情况2：被删除的节点只有一个子节点 ------- */</span></span><br><span class="line">            <span class="comment">// 获取被删除节点的唯一子节点</span></span><br><span class="line">            Node deleteNodeChild = deleteNode.leftChild == <span class="keyword">null</span> ?</span><br><span class="line">                    deleteNode.rightChild : deleteNode.leftChild;</span><br><span class="line">            <span class="keyword">if</span> (deleteNode == root) &#123;</span><br><span class="line">                <span class="comment">// 如果被删除节点就是root，那么将其唯一子节点设置为root</span></span><br><span class="line">                root = deleteNodeChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的左子节点，则将父节点的左子节点关联置为被删除节点的唯一子节点</span></span><br><span class="line">                parentNode.leftChild = deleteNodeChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的右子节点，则将父节点的右子节点关联置为被删除节点的唯一子节点</span></span><br><span class="line">                parentNode.rightChild = deleteNodeChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 中序遍历 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node targetNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (targetNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的左子节点</span></span><br><span class="line">            inOrder(targetNode.leftChild);</span><br><span class="line">            <span class="comment">// 访问目标节点本身</span></span><br><span class="line">            System.out.print(targetNode.key + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的右子节点</span></span><br><span class="line">            inOrder(targetNode.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 前序遍历 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node targetNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (targetNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 访问目标节点本身</span></span><br><span class="line">            System.out.print(targetNode.key + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的左子节点</span></span><br><span class="line">            preOrder(targetNode.leftChild);</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的右子节点</span></span><br><span class="line">            preOrder(targetNode.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 后续遍历 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node targetNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (targetNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的左子节点</span></span><br><span class="line">            postOrder(targetNode.leftChild);</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的右子节点</span></span><br><span class="line">            postOrder(targetNode.rightChild);</span><br><span class="line">            <span class="comment">// 访问目标节点本身</span></span><br><span class="line">            System.out.print(targetNode.key + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找中序后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getSuccessor</span><span class="params">(Node deleteNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暂存中序后继节点的父节点</span></span><br><span class="line">        Node successorParent = deleteNode;</span><br><span class="line">        <span class="comment">// 暂存中序后继节点</span></span><br><span class="line">        Node successor = deleteNode;</span><br><span class="line">        <span class="comment">// 先从删除节点的右子节点开始查找</span></span><br><span class="line">        Node currentNode = deleteNode.rightChild;</span><br><span class="line">        <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            successorParent = successor;</span><br><span class="line">            successor = currentNode;</span><br><span class="line">            <span class="comment">// 一直往下查找当前节点的左子节点，直到为空</span></span><br><span class="line">            currentNode = currentNode.leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如上面文章所说，中序后继节点和删除节点有两种可能性，</span></span><br><span class="line">        <span class="comment">// 当中序后继节点不是删除节点的右子节点时，需要做如下额外操作</span></span><br><span class="line">        <span class="keyword">if</span> (successor != deleteNode.rightChild) &#123;</span><br><span class="line">            <span class="comment">// 如果中序后继节点的右子节点不为空的话，将其和中序后继节点父节点的左子节点挂钩</span></span><br><span class="line">            <span class="keyword">if</span> (successor.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">                successorParent.leftChild = successor.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 中序后继节点的右子节点和删除节点的右子节点挂钩</span></span><br><span class="line">            successor.rightChild = deleteNode.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中序后继节点的左子节点和删除节点的左子节点挂钩</span></span><br><span class="line">        successor.leftChild = deleteNode.leftChild;</span><br><span class="line">        <span class="comment">// 剩下的删除节点的父节点和中序后继节点的连接关系在删除方法里处理，</span></span><br><span class="line">        <span class="comment">// 因为这个方法内无法获取删除节点的父节点对象</span></span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 关键字</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 额外携带的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 左子节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 右子节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BST效率"><a href="#BST效率" class="headerlink" title="BST效率"></a>BST效率</h3><p>节点的查找需要从根节点开始一层一层往下找，树节点数和层数的关系如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">节点数</th>
<th align="left">层数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">1023</td>
<td align="left">10</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">32767</td>
<td align="left">15</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">1048575</td>
<td align="left">20</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">33554432</td>
<td align="left">25</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">1073741824</td>
<td align="left">30</td>
</tr>
</tbody></table>
<p>假设节点数为N，层数为L，那么不难看出它们的关系为：N=2^(L-1)，所以L=log2(N+1)，大约为log2N，大O表示法为O(logN)</p>
<h3 id="BST缺陷"><a href="#BST缺陷" class="headerlink" title="BST缺陷"></a>BST缺陷</h3><p>虽然BST结合了数组和链表的优势，但它也不是完美的，当BST不平衡的时候，查找操作效率急剧下降。举个比较极端的例子：</p>
<p>假如插入的数据是升序数据：2，4，6，8，10，12…，这时候BST如下所示：</p>
<p><img src="/images/BST%E7%BC%BA%E9%99%B7.png"></p>
<p>这时候BST实际上就是一个链表结构了，搜索效率为O(N)。一个BST完全平衡和完全不平衡的情况比较少见，就概率来说，BST的搜索效率介于O(N)与O(logN)之间</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>为了解决非平衡树搜索效率下降的问题，人们又提出了红黑树的概念。在红黑树中，每个节点要么是红色的要么是黑色的，红黑树在插入和删除的过程中，需要遵循某些特定的规则，遵循这些规则可以确保数始终是趋于平衡的。</p>
<p>红黑树除了遵循基本的BST规则外，还需遵循以下4个规则：</p>
<ol>
<li>每一个节点不是红色就是黑色；</li>
<li>根节点一定是黑色的；</li>
<li>如果节点时红色的，那么它的子节点必须都是黑色的；</li>
<li>从根节点到叶子节点或空子节点的每条路径，必须包含相同数目的黑色节点。</li>
</ol>
<p>在数据插入和删除过程中，如果违背了上述4个规则，则树会执行以下操作进行修正，以重新满足上述4个规则：</p>
<ol>
<li>改变节点的颜色；</li>
<li>执行旋转操作。</li>
</ol>
]]></content>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Linux命令</title>
    <url>/2020/03/19/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>为了今后学习更复杂的知识，打算先分类地逐步掌握这些基础的Linux命令，命令内容分类：系统工作、系统状态、工作目录、文件、打包压缩、搜索等。</p>
<span id="more"></span>

<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">命令名称 [命令参数] [命令对象]</span><br></pre></td></tr></table></figure>

<p>命令参数的长格式和短格式(举例说明)：</p>
<ul>
<li>man –help</li>
<li>man -h</li>
</ul>
<p>命令参数的合并规则：</p>
<ul>
<li>长格式和长格式间不能合并</li>
<li>长格式和短格式间不能合并</li>
<li>短格式和短格式间可以合并，如 wget -r -p  可以合并成 wget -rp</li>
</ul>
</blockquote>
<h3 id="常用系统工作命令"><a href="#常用系统工作命令" class="headerlink" title="常用系统工作命令"></a>常用系统工作命令</h3><blockquote>
<h4 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h4><p>重启计算机</p>
<h4 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h4><p>关机</p>
<h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><p>echo命令用于在终端输出字符串或变量提取后的值，格式为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">echo</span> [字符串|$变量]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">echo</span> dougWilson</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span></span><br></pre></td></tr></table></figure>

<h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><p>date命令用于显示和设置系统的时间及日期，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">显示当前时间：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">date</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">按指定格式显示时间：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">date <span class="string">&quot;+%Y-%m-%d %H:%M:%S&quot;</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">设置系统当前时间：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">date -s <span class="string">&quot;20200518 8:30:00&quot;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="ping-traceroute-netstat"><a href="#ping-traceroute-netstat" class="headerlink" title="ping traceroute netstat"></a>ping traceroute netstat</h4><ul>
<li>ping 向网络主机发送特殊数据包</li>
<li>traceroute 跟踪网络数据包的传输路径</li>
<li>netstat 检查网络设置及相关统计数据</li>
</ul>
<p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">ping url</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">traceroute url</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">netstat [参数]</span></span><br></pre></td></tr></table></figure>

<h4 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h4><p>wget命令用于在终端中下载网络文件，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">wget [参数] 下载地址</span></span><br></pre></td></tr></table></figure>

<p>参数：</p>
<table>
<thead>
<tr>
<th>-b</th>
<th>后台下载模式</th>
</tr>
</thead>
<tbody><tr>
<td>-p</td>
<td>下载页面所有资源</td>
</tr>
<tr>
<td>-P</td>
<td>下载到指定目录</td>
</tr>
<tr>
<td>-t</td>
<td>最大尝试次数</td>
</tr>
<tr>
<td>-c</td>
<td>断点续传</td>
</tr>
<tr>
<td>-r</td>
<td>递归下载</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">wget http://www.dougwilson.com/file/linux.pdf</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">wget -pr http://www.dougwilson.com</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="系统状态检测命令"><a href="#系统状态检测命令" class="headerlink" title="系统状态检测命令"></a>系统状态检测命令</h3><blockquote>
<h4 id="who"><a href="#who" class="headerlink" title="who"></a>who</h4><p>who命令用于查看当前登入主机的用户信息</p>
<h4 id="last"><a href="#last" class="headerlink" title="last"></a>last</h4><p>last命令用于查看所有系统的登录记录</p>
<h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><p>history命令用于显示历史执行过的命令，格式为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">history -c</span><br></pre></td></tr></table></figure>

<h4 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h4><p>ifconfig命令用于获取网卡配置与网络状态等信息，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig [网络设备] [参数]</span><br><span class="line">如：</span><br><span class="line">ifconfig 查看本机当前网卡配置与网络状态等信息</span><br><span class="line">		inet 192.168.125.129  netmask 255.255.255.0  broadcast 192.168.125.255</span><br><span class="line">        inet6 fe80::2726:fb6f:db31:6505  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:d1:76:ad  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 175  bytes 42815 (42.8 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 154  bytes 20761 (20.7 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">        device interrupt 19  base 0x2000  </span><br><span class="line">inet为IPV4的IP地址</span><br><span class="line">inet6为IPV6的IP地址</span><br><span class="line">ether为网卡硬件地址，即MAC地址</span><br></pre></td></tr></table></figure>

<h4 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h4><p>uname命令用于查看系统内核与系统版本信息，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname [-a]</span><br><span class="line">如：</span><br><span class="line">uname</span><br><span class="line">uname -a</span><br></pre></td></tr></table></figure>

<h4 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h4><p>uptime命令用于查看系统负载信息</p>
<h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>free命令用于显示当前系统中内存的使用量信息，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">free [-h]</span><br><span class="line">如：</span><br><span class="line">free</span><br><span class="line">free -h</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="工作目录切换命令"><a href="#工作目录切换命令" class="headerlink" title="工作目录切换命令"></a>工作目录切换命令</h3><blockquote>
<h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>pwd命令用于显示当前所处工作目录</p>
<h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p>cd命令用于切换工作路径，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd [目录名称]</span><br><span class="line">如：</span><br><span class="line">cd /etc  切换到etc目录</span><br><span class="line">cd -     返回上一次所处目录</span><br><span class="line">cd ~     返回到用户的家目录</span><br><span class="line">cd ..    返回到上级目录</span><br></pre></td></tr></table></figure>

<h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>ls命令用于显示目录中的文件信息，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls [选项] [文件]</span><br><span class="line">如：</span><br><span class="line">ls -a</span><br><span class="line">ls -l</span><br><span class="line">ls -al</span><br><span class="line">ls -a /usr</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<table>
<thead>
<tr>
<th>短格式</th>
<th>长格式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>–all</td>
<td>列出所有文件，包含隐藏文件</td>
</tr>
<tr>
<td>-d</td>
<td>–directory</td>
<td>与-l选项结合使用，用于查看目录的详细信息而不是目录中的内容</td>
</tr>
<tr>
<td>-F</td>
<td>–classify</td>
<td>在每个列出的名字后面加上类型指示符(比如，如果为目录名称，则会加上\)</td>
</tr>
<tr>
<td>-h</td>
<td>–human-readable</td>
<td>以可读的方式显示文件大小，而不是以字节的方式</td>
</tr>
<tr>
<td>-l</td>
<td></td>
<td>以长格式显示结果</td>
</tr>
<tr>
<td>-r</td>
<td>–reverse</td>
<td>以相反的顺序显示结果</td>
</tr>
<tr>
<td>-S</td>
<td></td>
<td>按文件大小对结果进行排序</td>
</tr>
<tr>
<td>-t</td>
<td></td>
<td>按修改时间排序</td>
</tr>
</tbody></table>
<h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><p>file命令可以帮助我们确定文件类型，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file filename</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ file Documents</span><br><span class="line">Documents: directory</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="文件目录管理命令"><a href="#文件目录管理命令" class="headerlink" title="文件目录管理命令"></a>文件目录管理命令</h3><blockquote>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>由于shell经常使用文件名，因此提供了一些特殊字符来快速指定一组文件名，这些符号称为通配符：</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>匹配项</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配任意多个字符(包括0个和1个)</td>
</tr>
<tr>
<td>？</td>
<td>匹配任一单个字符(不包括0个)</td>
</tr>
<tr>
<td>[characters]</td>
<td>匹配任意一个属于字符集中的字符</td>
</tr>
<tr>
<td>[!characters]</td>
<td>匹配任意一个不属于字符集中的字符</td>
</tr>
<tr>
<td>[[:class:]]</td>
<td>匹配任意一个属于指定<strong>字符类</strong>中的字符</td>
</tr>
</tbody></table>
<p>对于字符类，常用的如下：</p>
<table>
<thead>
<tr>
<th>字符类</th>
<th>匹配项</th>
</tr>
</thead>
<tbody><tr>
<td>[:alnum:]</td>
<td>匹配任意一个字母或数字</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>匹配任意一个字母</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>匹配任意一个数字</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>匹配任意一个小写字母</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>匹配任意一个大写字母</td>
</tr>
</tbody></table>
<p>常用匹配内容：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>匹配项</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>所有文件</td>
</tr>
<tr>
<td>g*</td>
<td>以g开头的任一文件</td>
</tr>
<tr>
<td>b*.txt</td>
<td>以b开头，并以.txt结尾的任一文件</td>
</tr>
<tr>
<td>Data???</td>
<td>以Data开头，后面跟3个字符的任一文件</td>
</tr>
<tr>
<td>[abc]*</td>
<td>以abc中任一一个字符开头的任一文件</td>
</tr>
<tr>
<td>BACKUP.[0-9][0-9]</td>
<td>以BACKUP.开头，后面紧跟2个数字的任一文件</td>
</tr>
<tr>
<td>[[:upper:]]*</td>
<td>以大写字母开头的任一文件</td>
</tr>
<tr>
<td>[![:digit:]]*</td>
<td>不以数字开头的任一文件</td>
</tr>
<tr>
<td>*[[:lower:]123]</td>
<td>以小写字母或数字123中任一一个结尾的任一文件</td>
</tr>
</tbody></table>
<h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>mkdir命令用于创建空文件目录，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">mkdir [选项] 目录名</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">mkdir doug   在当前目录下创建目录doug</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">mkdir -p a/b/c  在当前目录下创建递归目录</span></span><br></pre></td></tr></table></figure>

<h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>cp目录用于复制文件或目录，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">cp [选项] 源文件 目标文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">将单个文件或目录复制到另一个文件或目录中：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">cp item1 item2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">将多个文件或目录复制到另一个目录中：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">cp item... directory</span></span><br></pre></td></tr></table></figure>

<p>常用选项及示例：</p>
<table>
<thead>
<tr>
<th>短格式</th>
<th>长格式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>–archive</td>
<td>复制文件和目录及其属性，具有所有权限</td>
</tr>
<tr>
<td>-i</td>
<td>–interactive</td>
<td>覆盖一个文件前，提示用户进行确认。如果没有该选项，cp会默认覆盖文件</td>
</tr>
<tr>
<td>-r</td>
<td>–recursive</td>
<td>递归地复制目录及其内容，复制目录时需要该选项或-a选项</td>
</tr>
<tr>
<td>-u</td>
<td>–update</td>
<td>将一个文件从一个目录复制到另一个目录时，只会复制那些目标目录不存在的文件或是相应的更新文件</td>
</tr>
<tr>
<td>-v</td>
<td>–verbose</td>
<td>复制文件时，显示信息</td>
</tr>
</tbody></table>
<h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>mv命令用于剪切或重命名文件，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">mv [选项] 源文件 目标文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">将单个文件或目录剪切到另一个文件或目录中：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">mv item1 item2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">将多个文件或目录剪切到另一个目录中：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">cp item... directory</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">重命名</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">mv item1 item2</span></span><br></pre></td></tr></table></figure>

<p>mv用法和cp用法基本相似</p>
<h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>rm命令用于删除文件或目录，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">rm [选项] 文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">rm item</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">rm item1 item2 item3</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">rm -r directory 递归删除目录中的文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">rm -i item  删除文件或目录前进行询问</span></span><br></pre></td></tr></table></figure>

<p>注意，Linux系统并不包含还原删除操作的命令，一旦使用rm命令，就彻底删除了。</p>
<h4 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h4><p>ln命令用于创建硬链接和符号链接，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">ln file link 创建硬链接</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ln -s item link 创建符号链接</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ln /etc/passwd passwd-hard  在当前目录中创建一个硬链接指向/etc/passwd</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ln /etc/passwd dir1/passwd-hard  在dir1目录中创建一个硬链接指向/etc/passwd</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ln -s /etc/passwd passwd-hard  在当前目录中创建一个符号链接</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ln -s /etc/passwd dir1/passwd-hard  在dir1目录中创建一个符号链接</span></span><br></pre></td></tr></table></figure>

<p>这里解释一下硬链接和符号链接：</p>
<h5 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h5><p>硬链接是UNIX系统最初用来创建链接的方式。默认情况下，每个文件都有一个硬链接，该硬链接会给文件起名字。当为一个文件创建一个硬链接时，也为这个文件创建了一个额外的目录条目。总而言之，创建硬链接时，实际上是创建了文件的额外名称，这些名称都指向同一数据部分。（文件由两部分组成：包含文件内容的数据部分和包含文件名的名称部分。系统分配一系列盘块给索引节点，这些节点与文件名称部分建立关联，然后指向文件内容。而创建一个硬链接相当于创建索引节点，因此，创建硬链接实际上是创建文件的额外名称，其所在索引节点指向文件的数据部分。）</p>
<p>硬链接的局限性为：</p>
<ol>
<li>硬链接不能引用与该链接不在同一磁盘分区的文件</li>
<li>硬链接无法引用目录</li>
</ol>
<p>当文件的一个硬链接删除时，只是删除了这个链接，但是文件内容依然存在。除非文件所有的链接都被删除，则文件空间会被释放。</p>
<h5 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h5><p>符号链接克服了硬链接的局限性，通过创建一个特殊类型的文件，该文件包含指向文件或目录的文本指针，类似于windows的快捷方式。</p>
<p>当删除一个符号链接时，删除的只是符号链接没有删除文件。如果在符号链接删除前删除文件，那么这个符号链接依然存在，只不过不指向任何一个文件，此时的链接称为坏链接。</p>
<p>符号链接是一种特殊类型的文件，包含了指向目标文件或目录的文本指针。</p>
</blockquote>
<h3 id="文本文件编辑命令"><a href="#文本文件编辑命令" class="headerlink" title="文本文件编辑命令"></a>文本文件编辑命令</h3><blockquote>
<h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><p>less命令用于查看文本文件，如PDF，txt等。less为我们查看文件提供了方便。格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">less filename</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">less howTomcatWork.pdf</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">然后可以通过滚轮或page up/page down方向键进行阅读</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">Q键退出阅读</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">G键  大写G跳到文本末尾  小写g跳到文本开头</span></span><br></pre></td></tr></table></figure>

<h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h4><p>stat命令用于查看文件的具体存储信息和时间等信息，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">stat</span> filename</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">stat</span> howTomcatWork.pdf</span></span><br></pre></td></tr></table></figure>

<h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><p>wc命令用于统计指定文本的行数、字数、字节数，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">wc [参数] 文本</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">dougwilson@doug:~$ wc howTomcatWork.pdf</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">64090   342871 17676281 howTomcatWork.pdf</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="重定向命令"><a href="#重定向命令" class="headerlink" title="重定向命令"></a>重定向命令</h3><blockquote>
<p>重定向可以将命令行的输入，重定向为从文件获取内容。也可以将命令行的输出，重定向到文件中。甚至可以利用重定向将多个命令行关联起来，形成管道。</p>
<h5 id="标准输入、标准输出、标准错误"><a href="#标准输入、标准输出、标准错误" class="headerlink" title="标准输入、标准输出、标准错误"></a>标准输入、标准输出、标准错误</h5><p>输出通常为两种类型：一种为程序运行的结果，即该程序生成的数据。另一种为状态和错误信息，表示程序当前的运行情况。</p>
<p>与UNIX”一切都是文件”的思想一致，类似于 <code>ls</code> 的程序实际上会将它们的运行结果发送到一个称为标准输出（standard output，通常表示为 stdout）的特殊文件中，它们的状态信息则发送到另一个称为标准错误（standard error，通常表示为stderr）的文件中。默认情况下，标准输出和标准错误都将被链接到屏幕上，而不会被保存在磁盘文件中。</p>
<p>而标准输入则是许多程序从一个称为标准输入（standard input，表示为 stdin）的设备得到输入。默认情况下，标准输入连接到键盘。</p>
<h4 id="gt"><a href="#gt" class="headerlink" title="&gt;"></a>&gt;</h4><p>&gt;命令为标准输出重定向命令，用于将标准输出重定向到指定位置，格式为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">[<span class="built_in">command</span>] &gt; filename 将标准输出重定向到另外一个文件中，覆盖原来的内容</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">[<span class="built_in">command</span>] &gt;&gt; filename 将标准输出重定向到另外一个文件中，在原来的内容上进行内容的追加</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt; filename 删除一个文件的文件内容，或者创建一个新的空文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ls -l /usr/bin &gt; ls-output.txt  将ls命令的输出重定向到ls-output.txt文件中保存，而不是输出到屏幕上</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ls -l /usr/bin &gt;&gt; ls-output.txt 将ls命令输出追加到ls-output.txt文件中</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt; ls-output.txt 清空ls-output.txt文件内容</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如果我们尝试访问一个不存在的目录或文件，则会产生错误信息：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">dougwilson@doug:~$ ls -l /bin/usr &gt; ls-output.txt</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ls: cannot access <span class="string">&#x27;/bin/usr&#x27;</span>: No such file or directory</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">但这个错误信息并不会输出到ls-output.txt文件，而是显示到屏幕上。这就涉及到上面说的，输出有两个类型，标准输出，标准错误。当产生错误时，错误信息会输入到标准错误的文件中，而&gt;命令只会重定向标准输出文件，而标准错误的文件内容依然是重定向到屏幕进行输出。如何进行标准错误的重定向？</span></span><br></pre></td></tr></table></figure>

<h4 id="标准错误重定向"><a href="#标准错误重定向" class="headerlink" title="标准错误重定向"></a>标准错误重定向</h4><p>标准错误重定向并不能简单地用一个专用的重定向符号来实现，需要用到文件描述符。</p>
<p>一个程序可以将生成的输出内容发送到任意的文件流中，文件流的前3个对应标准输入文件，标准输出文件和标准错误文件，分别用文件描述符0，1，2描述。因此，标准错误等同于文件描述符2，所以可以用如下写法完成上面的标准错误的重定向：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">ls -l /bin/usr 2&gt; ls-error.txt</span></span><br></pre></td></tr></table></figure>

<h4 id="标准输出和标准错误重定向到同一个文件"><a href="#标准输出和标准错误重定向到同一个文件" class="headerlink" title="标准输出和标准错误重定向到同一个文件"></a>标准输出和标准错误重定向到同一个文件</h4><p>还是上面的例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1</span></span><br></pre></td></tr></table></figure>

<p>该操作执行了两个重定向操作。首先是将标准输出重定向到 <code>ls-output.txt</code> 文件中，然后使用标记符 <code>2&gt;&amp;1</code> 将标准错误重定向到标准输出中。</p>
<p>注意，标准错误的重定向在标准输出重定向之后，该顺序是不能颠倒的，必须严格遵守，否则将不起作用。比如，如果将上面的顺序改为 <code>ls -l /bin/usr 2&gt;&amp;1&gt; ls-output.txt</code> ，那么标准错误将会重定向到屏幕上。</p>
<h4 id="位桶-dev-null"><a href="#位桶-dev-null" class="headerlink" title="位桶/dev/null"></a>位桶/dev/null</h4><p>用于接受输入但是不对输入进行任何处理。</p>
<p>还是上面的例子，我们隐藏错误信息，不在屏幕显示，也不重定向到文件中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">ls -l /bin/usr 2&gt; /dev/null</span></span><br></pre></td></tr></table></figure>

<h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>cat命令用于读取一个或多个文件，并将它们复制到标准输出文件中，在屏幕上进行显示，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">cat [file...]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">cat ls-output.txt ls-error.txt</span></span><br></pre></td></tr></table></figure>

<p>cat命令也常用于重定向。因为cat命令可以接受多个文件作为输入参数，因此可以通过重定向将已经被拆分的多个部分合在一起还原成原来的文件。比如：movie.avi.000 movie.avi.001  ……  movie.avi.066</p>
<p>则可以使用cat命令将这些部分通过重定向拼接在一起还原文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">cat movie.avi.0* &gt; movie.avi</span></span><br></pre></td></tr></table></figure>

<p>如果cat命令缺少文件参数，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">cat</span></span><br></pre></td></tr></table></figure>

<p>那么它就和标准输入——键盘建立连接。可以在屏幕中输入字符，并以<kbd>ctrl</kbd>+<kbd>D</kbd>结束输入。如果要将标准输入重定向到文件中，也是可以：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">cat &gt; cat-input.txt</span></span><br></pre></td></tr></table></figure>

<h4 id="管道"><a href="#管道" class="headerlink" title="管道 |"></a>管道 |</h4><p>管道命令 | 可以将一个命令的标准输出传送到另一个命令的标准输入中，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">command1 | command2 | <span class="built_in">command</span>...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ls . /usr/<span class="built_in">local</span> | less</span></span><br></pre></td></tr></table></figure>

<h4 id="过滤器命令-sort-uniq-wc-grep-head-tail-tee"><a href="#过滤器命令-sort-uniq-wc-grep-head-tail-tee" class="headerlink" title="过滤器命令 sort uniq wc grep head tail tee"></a>过滤器命令 sort uniq wc grep head tail tee</h4><p>通常而言，我们会对改变数据的显示方式，比如排序，过滤重复行，等等。此时的管道就通常别称为过滤器，而使用的命令就称为过滤器命令。常用过滤器命令：</p>
<ul>
<li><strong>sort</strong> 对标准输入进行排序</li>
<li><strong>uniq</strong> 忽略或查看文件中的重复行</li>
<li><strong>wc</strong> 打印行数、字数、字节数</li>
<li><strong>grep</strong> 打印匹配行</li>
<li><strong>head/tail</strong> 打印文件的开头部分/结尾部分</li>
<li><strong>tee</strong> 从标准输入读取数据，并同时输出到标准输出或文件中</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">ls . /usr/<span class="built_in">local</span> | sort | less 将两个目录的文件名进行排序，从而产生一个排好序的列表</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ls . /usr/<span class="built_in">local</span> | sort | uniq | less 删除了列表的重复行，确保列表没有重复行</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ls . /usr/<span class="built_in">local</span> | sort | uniq -d | less 查看列表的重复行</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ls . /usr/<span class="built_in">local</span> | sort | uniq | wc 查看排好序列表的行数、子数、字节数</span></span><br></pre></td></tr></table></figure>

<p>grep是一个强大的命令，用于在文件中查找匹配文本，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">grep pattern [file...]   pattern的内容为正则表达式</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ls . /usr/<span class="built_in">local</span> | sort | uniq | grep zip  搜索文件名包含zip的所有文件</span></span><br></pre></td></tr></table></figure>

<p>head/tail用于在不需要输出所有内容时，只显示开头几行或结尾几行，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">head -n lines filename   显示filename的开头lines行</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">tail -n lines filename   显示filename的结尾lines行</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">head -n 10 ls-output.txt  显示ls-output.txt文件的开头10行</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">应用在管道中：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ls . /usr/<span class="built_in">local</span> | sort | uniq | tail -n 5</span></span><br></pre></td></tr></table></figure>

<p>tail中有一个选项 <code>-f</code> 可以用于实时查看文件，该选项在观察正在被写入的日志文件的进展状态很有用。使用该选项后，tail将持续监视文件，一旦添加新行，新行会立即显示在屏幕上，直到<kbd>Ctrl</kbd>+<kbd>C</kbd>按下后停止。格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">tail -f filename</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">比如经常用该命令查看messages文件：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">tail -f /var/<span class="built_in">log</span>/messages</span></span><br></pre></td></tr></table></figure>

<p>tee类似于“分流”的效果，用于将读取的标准输入复制到标准输出或若干个文件中去（即允许数据继续向下传递到管道中）。比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">ls /usr/bin | tee ls-tee.txt | grep zip</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">在grep过滤管道内容前，通过tee命令先将内容输出到ls-tee.txt文件中，然后才传递给grep命令进行过滤</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><blockquote>
<p>bash再执行命令前会对文本进行多重处理，使得文本在执行前被扩展成其他内容，这个结果产生的过程就被称为扩展。</p>
<h4 id="路径名扩展-通配符"><a href="#路径名扩展-通配符" class="headerlink" title="路径名扩展(通配符*)"></a>路径名扩展(通配符*)</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo *</span><br><span class="line">echo D*</span><br><span class="line">echo *s</span><br><span class="line">echo [[:upper:]]*</span><br><span class="line">echo /usr/*/share</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ *</span><br><span class="line">cat-input.txt: command not found</span><br><span class="line">dougwilson@doug:~$ echo *</span><br><span class="line">cat-input.txt Desktop Documents Downloads less LinuxProbe.pdf ls-error.txt ls-output.txt Music Pictures Public Templates Videos</span><br><span class="line">dougwilson@doug:~$ echo D*</span><br><span class="line">Desktop Documents Downloads</span><br><span class="line">dougwilson@doug:~$ echo *s</span><br><span class="line">Documents Downloads less Pictures Templates Videos</span><br><span class="line">dougwilson@doug:~$ echo /usr/*/share</span><br><span class="line">/usr/local/share</span><br><span class="line">dougwilson@doug:~$ echo [[:upper:]]*</span><br><span class="line">Desktop Documents Downloads LinuxProbe.pdf Music Pictures Public Templates Videos</span><br></pre></td></tr></table></figure>

<h4 id="波浪线扩展-波浪符"><a href="#波浪线扩展-波浪符" class="headerlink" title="波浪线扩展(波浪符~)"></a>波浪线扩展(波浪符~)</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo ~</span><br><span class="line">echo ~用户名</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ echo ~</span><br><span class="line">/home/dougwilson</span><br><span class="line">dougwilson@doug:~$ echo ~dougwilson</span><br><span class="line">/home/dougwilson</span><br></pre></td></tr></table></figure>

<h4 id="算术扩展-美元符"><a href="#算术扩展-美元符" class="headerlink" title="算术扩展(美元符$)"></a>算术扩展(美元符$)</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">格式为：  $((experssion))</span><br><span class="line">echo $((2+2))</span><br><span class="line">echo $((2*2))</span><br><span class="line">echo $((2%2))</span><br><span class="line">echo $(($((2*2))*2))</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ echo $((2+2))</span><br><span class="line">4</span><br><span class="line">dougwilson@doug:~$ echo $((2*2))</span><br><span class="line">4</span><br><span class="line">dougwilson@doug:~$ echo $((2%2))</span><br><span class="line">0</span><br><span class="line">dougwilson@doug:~$ echo $(($((2*2))*2))</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<h4 id="花括号扩展-花括号"><a href="#花括号扩展-花括号" class="headerlink" title="花括号扩展(花括号{})"></a>花括号扩展(花括号{})</h4><p>可以通过花括号的模式创建多种文本字符串，括号中的模式不能包含内嵌的空白：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo Front-&#123;A,B,C&#125;-Back</span><br><span class="line">echo Number_&#123;1..5&#125;   ..表示区间连续</span><br><span class="line">echo a&#123;A&#123;1,2&#125;,B&#123;3,4&#125;&#125;b</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ echo Front-&#123;A,B,C&#125;-Back</span><br><span class="line">Front-A-Back Front-B-Back Front-C-Back</span><br><span class="line">dougwilson@doug:~$ echo Number_&#123;1..5&#125;</span><br><span class="line">Number_1 Number_2 Number_3 Number_4 Number_5</span><br><span class="line">dougwilson@doug:~$ echo a&#123;A&#123;1,2&#125;,B&#123;3,4&#125;&#125;b</span><br><span class="line">aA1b aA2b aB3b aB4b</span><br></pre></td></tr></table></figure>

<p>花括号扩展经常用于创建一系列目录。比如存放日志的目录，你希望日志按照时间进行存储，那么就可以按如下方式创建一系列目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir logDir</span><br><span class="line">cd logDir</span><br><span class="line">mkdir &#123;2020..2021&#125;-0&#123;1..9&#125; &#123;2020..2021&#125;-&#123;10..12&#125;</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ mkdir logDir</span><br><span class="line">dougwilson@doug:~$ cd logDir</span><br><span class="line">dougwilson@doug:~/logDir$ mkdir &#123;2020..2021&#125;-0&#123;1..9&#125; &#123;2020..2021&#125;-&#123;10..12&#125;</span><br><span class="line">dougwilson@doug:~/logDir$ ls</span><br><span class="line">2020-01  2020-04  2020-07  2020-10  2021-01  2021-04  2021-07  2021-10</span><br><span class="line">2020-02  2020-05  2020-08  2020-11  2021-02  2021-05  2021-08  2021-11</span><br><span class="line">2020-03  2020-06  2020-09  2020-12  2021-03  2021-06  2021-09  2021-12</span><br></pre></td></tr></table></figure>

<h4 id="参数扩展-变量"><a href="#参数扩展-变量" class="headerlink" title="参数扩展(变量)"></a>参数扩展(变量)</h4><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">格式为：   <span class="variable">$变</span>量名</span><br><span class="line">echo <span class="variable">$USER</span></span><br><span class="line">echo <span class="variable">$SHELL</span></span><br><span class="line">printenv | less  查看可用变量名</span><br><span class="line">如：</span><br><span class="line">dougwilson<span class="variable">@doug</span><span class="symbol">:~/logDir</span><span class="variable">$ </span>echo <span class="variable">$USER</span></span><br><span class="line">dougwilson</span><br><span class="line">dougwilson<span class="variable">@doug</span><span class="symbol">:~/logDir</span><span class="variable">$ </span>echo <span class="variable">$SHELL</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h4><p>将一个命令的输出结果作为一个扩展模式使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">格式为：  $(command expression)</span><br><span class="line">echo $(ls)</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ ls</span><br><span class="line">cat-input.txt  Downloads       logDir         Music     Templates</span><br><span class="line">Desktop        less            ls-error.txt   Pictures  Videos</span><br><span class="line">Documents      LinuxProbe.pdf  ls-output.txt  Public</span><br><span class="line">dougwilson@doug:~$ echo $(ls)</span><br><span class="line">cat-input.txt Desktop Documents Downloads less LinuxProbe.pdf logDir ls-error.txt ls-output.txt Music Pictures Public Templates Videos</span><br></pre></td></tr></table></figure>

<h4 id="避免扩展-双引号和单引号"><a href="#避免扩展-双引号和单引号" class="headerlink" title="避免扩展(双引号和单引号)"></a>避免扩展(双引号和单引号)</h4><p>可以通过控制扩展(引用机制)来有选择性地避免不想要的扩展：</p>
<p>先来看一组内容，务必区分：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo The total is $100.00</span><br><span class="line">echo The total is $100</span><br><span class="line">echo The total is $price:100.00</span><br><span class="line">echo The total is $100price</span><br><span class="line">上面几个结果是完全不同的：</span><br><span class="line">dougwilson@doug:~$ echo The total is $100.00</span><br><span class="line">The total is 00.00</span><br><span class="line">dougwilson@doug:~$ echo The total is $100</span><br><span class="line">The total is 00</span><br><span class="line">dougwilson@doug:~$ echo The total is $price:100.00</span><br><span class="line">The total is :100.00</span><br><span class="line">dougwilson@doug:~$ echo The total is $100price</span><br><span class="line">The total is 00price</span><br><span class="line">dougwilson@doug:~$ echo The total is $p100rice</span><br><span class="line">The total is</span><br><span class="line">说明，当$后是一个数字时，则会寻找该数字对应的变量。当$后是一个字符时，则会将寻找$后字符串</span><br></pre></td></tr></table></figure>

<h4 id="双引号控制扩展"><a href="#双引号控制扩展" class="headerlink" title="双引号控制扩展"></a>双引号控制扩展</h4><p>双引号控制扩展，除了：</p>
<ul>
<li>美元符号 $</li>
<li>反斜杠  \</li>
<li>反引号  ‘</li>
</ul>
<p>之外，其他在双引号中的特殊字符都将失去其特殊意义。这意味着：单词扩展、路径名扩展、波浪线扩展、花括号扩展都将失效。</p>
<p>此外，双引号可用阻止单词分割，使得文件名可以包含空白符：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ <span class="keyword">ls</span> -<span class="keyword">l</span> <span class="keyword">two</span> words.txt</span><br><span class="line"><span class="keyword">ls</span>: cannot access &#x27;<span class="keyword">two</span>&#x27;: <span class="keyword">No</span> such <span class="keyword">file</span> or directory</span><br><span class="line"><span class="keyword">ls</span>: cannot access &#x27;words.txt&#x27;: <span class="keyword">No</span> such <span class="keyword">file</span> or directory</span><br><span class="line">dougwilson@doug:~$ <span class="keyword">ls</span> -<span class="keyword">l</span> <span class="string">&quot;two words.txt&quot;</span></span><br><span class="line"><span class="keyword">ls</span>: cannot access &#x27;<span class="keyword">two</span> words.txt&#x27;: <span class="keyword">No</span> such <span class="keyword">file</span> or directory</span><br></pre></td></tr></table></figure>

<p>默认清空下，单词分割会先查找是否存在空格、制表符以及换行符，然后把它们当作单词的界定符。这意味着，如果没有双引号包起来的空格、制表符和换行符，都不会被当作文本的一部分，而只是被当成分隔符。</p>
<p>但是如果加上双引号，单词分割功能将失效，嵌入的空格不再被当成界定符，而是被当作参数的一部分。</p>
<h4 id="单引号控制扩展"><a href="#单引号控制扩展" class="headerlink" title="单引号控制扩展"></a>单引号控制扩展</h4><p>单引号可以抑制所有的扩展。举例说明：不控制扩展，使用双引号控制扩展，使用单引号控制扩展的区别：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ echo text ~/*.txt &#123;a,b&#125; $(echo dougwilson) $((2+2)) $USER</span><br><span class="line">text /home/dougwilson/cat-input.txt /home/dougwilson/ls-error.txt /home/dougwilson/ls-output.txt a b dougwilson 4 dougwilson</span><br><span class="line">dougwilson@doug:~$ echo &quot;text ~/*.txt &#123;a,b&#125; $(echo dougwilson) $((2+2)) $USER&quot;</span><br><span class="line">text ~/*.txt &#123;a,b&#125; dougwilson 4 dougwilson</span><br><span class="line">dougwilson@doug:~$ echo &#x27;text ~/*.txt &#123;a,b&#125; $(echo dougwilson) $((2+2)) $USER&#x27;</span><br><span class="line">text ~/*.txt &#123;a,b&#125; $(echo dougwilson) $((2+2)) $USER</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><blockquote>
<p>UNIX操作系统是多用户系统，意味着同一时间内可以有多个用户使用同一台计算机。比如，如果计算机连接到一个网络或者互联网中，远程用户可以通过SSH登录并操作这台计算机。</p>
<p>这和早期的计算机发展有关。在个人计算机普遍之前，计算机普遍为体积大，价格昂贵的系统。比如，一个典型的校园计算机系统，是由一台在某建筑里面的超大型计算机和遍布校园的多台终端组成的，每台终端都连接到中央计算机上。为了包证多用户功能实际可用，系统就设计了一种方案保护当前用户不受其他用户操作的影响。</p>
<p>UNIX安全模型：</p>
<ul>
<li>一个用户可以拥有目录和文件，并对拥有的目录和文件的访问权限具有控制权</li>
<li>用户归属于群组（group），群组由一个用户和多个用户组成</li>
</ul>
<h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>id命令可以获得用户身份标识的相关信息，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ id</span><br><span class="line">uid=1000(dougwilson) gid=1000(dougwilson) groups=1000(dougwilson),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),121(lpadmin),132(lxd),133(sambashare)</span><br></pre></td></tr></table></figure>

<p>在创建用户的账号的时候，用户都会被分配一个用户ID——uid。同时，用户也会被分配一个组ID——gid。一个用户可以属于多个群组。这些信息保存在：</p>
<ul>
<li>用户账号  <code>/etc/passwd</code></li>
<li>用户密码  <code>/etc/shadow</code></li>
<li>用户的组   <code>/etc/group</code></li>
</ul>
<h4 id="文件的读取、写入、执行"><a href="#文件的读取、写入、执行" class="headerlink" title="文件的读取、写入、执行"></a>文件的读取、写入、执行</h4><p>首先查看文件的信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ ls -l howTomcatWork.pdf</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 17676281  9月 22  2020 howTomcatWork.pdf</span><br></pre></td></tr></table></figure>

<p>前10个字符。按表示含义分成两组，第1个字符表示文件类型和剩余9个字符表示文件模式(文件所有者，文件所属群组，读取、写入、执行权限)。</p>
<p><strong>第一个字符——文件类型</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>文件类型</th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>普通文件</td>
</tr>
<tr>
<td>d</td>
<td>目录文件</td>
</tr>
<tr>
<td>l</td>
<td>符号链接。对于符号链接文件，剩下9个字符格式是固定的：rwxrwxrwx，它是个伪装属性值，符号链接指向的文件属性才是真正的文件属性</td>
</tr>
<tr>
<td>c</td>
<td>字符设备文件。表示以字节流形式处理数据的设备，如终端或调制解调器</td>
</tr>
<tr>
<td>b</td>
<td>块设备文件。表示以数据块方式处理数据的设备，如硬盘驱动或光盘驱动</td>
</tr>
</tbody></table>
<p><strong>剩下9个字符——文件模式</strong></p>
<p>3个字符一组，2、3、4字符表示文件所有者权限；5、6、7表示文件所有者所在组成员权限；8、9、10表示其他组成员权限</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>文件</th>
<th>目录</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>允许打开和读取文件</td>
<td>如果设置了执行权限，则允许列出目录下的内容</td>
</tr>
<tr>
<td>w</td>
<td>允许写入</td>
<td>该权限不允许重命名或删除文件</td>
</tr>
<tr>
<td>x</td>
<td>允许把文件当作程序一样执行</td>
<td>允许进入目录，如 cd directory</td>
</tr>
</tbody></table>
<p>常见文件属性设置：</p>
<table>
<thead>
<tr>
<th>文件属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-rwx——</td>
<td>普通文件，文件所有者具有读取、写入和执行权限。组成员和其他用户没有任何访问权限</td>
</tr>
<tr>
<td>-rw——-</td>
<td>普通文件，文件所有者具有读取和写入权限。组成员和其他用户没有任何访问权限</td>
</tr>
<tr>
<td>-rw-r–r–</td>
<td>普通文件，文件所有者具有读取和写入权限。文件对所有用户可读</td>
</tr>
<tr>
<td>-rwxr-xr-x</td>
<td>普通文件，文件所有者具有读取、写入和执行权限。所有用户对文件可读、可执行</td>
</tr>
<tr>
<td>-rw-rw—-</td>
<td>普通文件，文件所有者具有读取、写入权限。文件所有者组成员具有读取和写入权限</td>
</tr>
<tr>
<td>lrwxrwxrwx</td>
<td>符号链接。所有符号链接文件显示的都是伪权限属性，真正的权限属性由符号链接指向的实际文件决定</td>
</tr>
<tr>
<td>dwxrwx—-</td>
<td>目录文件。文件所有者和所有者所在的组成员可以进入该目录，并对目录下的文件进行创建，重命名，删除操作</td>
</tr>
<tr>
<td>drwxr-x—</td>
<td>目录文件。文件所有者可以进入该目录，并具有所有权限。文件所有者所在组成员可以进入目录，但是没有创建、重命名和删除操作权限</td>
</tr>
</tbody></table>
<h4 id="文件模式的修改chmod"><a href="#文件模式的修改chmod" class="headerlink" title="文件模式的修改chmod"></a>文件模式的修改chmod</h4><p>chmod可用于更改文件或目录的文件模式（权限），但只有文件所有者和超级用户才能进行修改。格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod pattern filename</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ ls -l howTomcatWork.pdf</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 17676281  9月 22  2020 howTomcatWork.pdf</span><br><span class="line">dougwilson@doug:~$ chmod 600 howTomcatWork.pdf</span><br><span class="line">dougwilson@doug:~$ ls -l howTomcatWork.pdf</span><br><span class="line">-rw------- 1 dougwilson dougwilson 17676281  9月 22  2020 howTomcatWork.pdf</span><br><span class="line">dougwilson@doug:~$ chmod 664 howTomcatWork.pdf</span><br><span class="line">dougwilson@doug:~$ ls -l howTomcatWork.pdf</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 17676281  9月 22  2020 howTomcatWork.pdf</span><br></pre></td></tr></table></figure>

<p><strong>八进制表示法</strong></p>
<p>使用3个二进制数和文件模式的结构一一对应</p>
<table>
<thead>
<tr>
<th>八进制</th>
<th>二进制</th>
<th>文件模式</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>000</td>
<td>—</td>
</tr>
<tr>
<td>1</td>
<td>001</td>
<td>–x</td>
</tr>
<tr>
<td>2</td>
<td>010</td>
<td>-w-</td>
</tr>
<tr>
<td>3</td>
<td>011</td>
<td>-wx</td>
</tr>
<tr>
<td>4</td>
<td>100</td>
<td>r–</td>
</tr>
<tr>
<td>5</td>
<td>101</td>
<td>r-x</td>
</tr>
<tr>
<td>6</td>
<td>110</td>
<td>rw-</td>
</tr>
<tr>
<td>7</td>
<td>111</td>
<td>rwx</td>
</tr>
</tbody></table>
<p><strong>符号表示法</strong></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u</td>
<td>user缩写，文件所有者</td>
</tr>
<tr>
<td>g</td>
<td>group缩写，文件所有者所在组</td>
</tr>
<tr>
<td>o</td>
<td>others缩写，其他所有用户</td>
</tr>
<tr>
<td>a</td>
<td>all缩写，ugo结合</td>
</tr>
<tr>
<td>+</td>
<td>添加某个权限</td>
</tr>
<tr>
<td>-</td>
<td>去掉某个权限</td>
</tr>
<tr>
<td>=</td>
<td>指定权限</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>读取权限</td>
</tr>
<tr>
<td>w</td>
<td>写入权限</td>
</tr>
<tr>
<td>x</td>
<td>执行权限</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod u+x howTomcatWork.pdf</span><br><span class="line">chmod u-x howTomcatWork.pdf</span><br><span class="line">chmod a+x howTomcatWork.pdf</span><br><span class="line">chmod u+x,go=rx howTomcatWork.pdf  指定多种权限时, 用逗号 , 分隔</span><br></pre></td></tr></table></figure>

<h4 id="设置默认权限umask"><a href="#设置默认权限umask" class="headerlink" title="设置默认权限umask"></a>设置默认权限umask</h4><p>默认权限的获得并没有想象的那么简单，通过8进制并不能直接设置。</p>
<p>Linux采用一种：<strong>原始文件模式+掩码</strong>   的方式设置文件的默认文件模式，即权限。</p>
<p>原始文件模式是不会变的，格式为：</p>
<table>
<thead>
<tr>
<th>原始文件模式</th>
<th>—</th>
<th>rw-</th>
<th>rw-</th>
<th>rw-</th>
</tr>
</thead>
</table>
<p>掩码，可以通过umask设置，得到不同的掩码值，进而改变文件的默认权限。权限对应二进制位为1时，表示删除该权限，为0时，不改变对应位置的权限。比如掩码为0022时：</p>
<table>
<thead>
<tr>
<th>原始文件模式</th>
<th>—</th>
<th>rw-</th>
<th>rw-</th>
<th>rw-</th>
</tr>
</thead>
<tbody><tr>
<td>掩码</td>
<td>000</td>
<td>000</td>
<td>010</td>
<td>010</td>
</tr>
<tr>
<td>结果</td>
<td>—</td>
<td>rw-</td>
<td>r–</td>
<td>r–</td>
</tr>
</tbody></table>
<p>因此，当掩码为0000时，掩码无效，原始文件模式为默认文件权限。当掩码为1111或0111时，文件不可访问，且为锁定状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">umask   查看掩码值</span><br><span class="line">umask 0022  设置掩码值</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ ls -l cat-input.txt</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 0  5月 20 08:59 cat-input.txt</span><br><span class="line">dougwilson@doug:~$ umask</span><br><span class="line">0002</span><br><span class="line">dougwilson@doug:~$ umask 0777</span><br><span class="line">dougwilson@doug:~$ rm cat-input.txt</span><br><span class="line">dougwilson@doug:~$ &gt; cat-input.txt</span><br><span class="line">dougwilson@doug:~$ ls -l cat-input.txt</span><br><span class="line">---------- 1 dougwilson dougwilson 0  5月 20 09:00 cat-input.txt</span><br><span class="line">dougwilson@doug:~$ umask 0002</span><br></pre></td></tr></table></figure>

<h4 id="更改身份-su-sudo"><a href="#更改身份-su-sudo" class="headerlink" title="更改身份 su sudo"></a>更改身份 su sudo</h4><h5 id="su"><a href="#su" class="headerlink" title="su"></a>su</h5><p>su命令以另一个用户的身份来启动shell，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su [-[l]] [user]</span><br><span class="line">如：</span><br><span class="line">su - dougwilson  指定用户</span><br><span class="line">su -l 没有指定用户，则默认为超级用户</span><br><span class="line">exit  退出当前用户环境，返回到之前的shell环境</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ ls -l howTomcatWork.pdf</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 17676281  9月 22  2020 howTomcatWork.pdf</span><br><span class="line">dougwilson@doug:~$ su -l </span><br><span class="line">Password: </span><br><span class="line">root@doug:~# ls</span><br><span class="line">snap</span><br><span class="line">root@doug:~# exit</span><br><span class="line">logout</span><br><span class="line">dougwilson@doug:~$ </span><br></pre></td></tr></table></figure>

<p>如果包含”-l”选项，那么得到的shell会话界面是用于指定用户的登录shell界面，并且对应的用户运行环境将被加载，工作目录也会切换到指定用户的家目录。需要注意的是，”-l”可以缩写成”-“，且含义相同。</p>
<p>如果你想执行某一个命令，但是不希望切换用户，那么可以采用如下方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su -c &#x27;command&#x27;   必须要单引号</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ su -c &#x27;ls -l /root/*&#x27;</span><br><span class="line">Password: </span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x 4 root root 4096  5月 17 10:46 snap-store</span><br></pre></td></tr></table></figure>

<p>这样，单个命令行就会被传递到一个新的shell环境下执行，然后将结果返回到当前shell环境</p>
<h5 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h5><p>sudo命令很类似于su命令，但它还具有一些重要的功能。如，允许一个用户以不同的身份执行命令，而只需要输入自己的密码进行验证，不需要输入如超级用户的密码，就可以执行特定身份下的命令。更重要的区别在于sudo命令不需要启动一个新的shell环境，也不需要加载另一个用户的运行环境。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo command  会提示输入密码，输入正确则执行</span><br></pre></td></tr></table></figure>

<h4 id="修改密码-passwd"><a href="#修改密码-passwd" class="headerlink" title="修改密码 passwd"></a>修改密码 passwd</h4><p>passwd命令可以修改用户当前密码</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">passwd</span>  </span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote>
<h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>kill命令用于终止某个指定PID服务进程，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">kill</span> [参数] [进程PID]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">kill</span> 2566</span></span><br></pre></td></tr></table></figure>

<h4 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h4><p>killall命令用于终止某个指定名称服务对应的全部进程，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">killall [服务名称]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">killall httpd</span></span><br></pre></td></tr></table></figure>

<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>top命令用于动态地监视进程活动与系统负载等信息。前5行为系统的整体统计信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">dougwilson@doug:~$ top</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">top - 21:54:05 up 1 min,  1 user,  load average: 0.76, 0.38, 0.14</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">Tasks: 331 total,   1 running, 330 sleeping,   0 stopped,   0 zombie</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">%Cpu(s):  0.1 us,  0.2 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">MiB Mem :   1890.7 total,    524.2 free,    779.6 used,    586.9 buff/cache</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.    945.8 avail Mem</span> </span><br></pre></td></tr></table></figure>

<p>第一行：系统时间，运行时间，登录终端数，系统负载(三个数值为1分钟、5分钟、15分钟内平均值)</p>
<p>第二行：进程总数，运行中的进程数，睡眠中的进程数，停止的进程数，僵死的线程数</p>
<p>第三行：用户占用资源百分比，系统内核占用资源百分比，改变过优先级的进程资源百分比，空闲的资源百分比</p>
<p>第四行：显示物理RAM的使用清空</p>
<p>第五行：显示交换空间的使用情况</p>
<h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>ps命令用于查看系统中的进程状态，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">ps [参数]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">参数有：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-a 显示所有进程</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-u 用户及其他详细信息</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-x 显示没有控制中断的进程</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ps</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ps -a</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ps -u</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ps -au</span></span><br></pre></td></tr></table></figure>

<p>进程的状态：</p>
<ul>
<li>运行(R)：进程正在运行或在运行队列中等待</li>
<li>中断(S)：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离中断状态</li>
<li>不可中断(D)：进程不响应系统异步信号，即使使用kill命令也不能将其中断</li>
<li>僵死(Z)：进程已经终止，但进程描述符依然存在，直到父进程调用wait4()系统函数将其释放</li>
<li>停止(T)：进程收到停止信号后停止运行</li>
</ul>
<h4 id="暂停进程-Ctrl-Z"><a href="#暂停进程-Ctrl-Z" class="headerlink" title="暂停进程 Ctrl+Z"></a>暂停进程 Ctrl+Z</h4><p>在终端窗口中按下<kbd>Ctrl</kbd>+<kbd>Z</kbd>可以暂停进程执行</p>
<h4 id="中断进程-Ctrl-C"><a href="#中断进程-Ctrl-C" class="headerlink" title="中断进程 Ctrl + C"></a>中断进程 Ctrl + C</h4><p>执行一个程序，如果想中断其执行，可以在终端窗口中按下<kbd>Ctrl</kbd>+<kbd>C</kbd>，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">dougwilson@doug:~$ xlogo</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">^C   这里按下了Ctrl+C</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">dougwilson@doug:~$</span> </span><br></pre></td></tr></table></figure>

<h4 id="使进程在后台运行，但不中断其运行-amp"><a href="#使进程在后台运行，但不中断其运行-amp" class="headerlink" title="使进程在后台运行，但不中断其运行 &amp;"></a>使进程在后台运行，但不中断其运行 &amp;</h4><p>假设我们想shell提示符返回，但不终止程序，则可以将程序设置为后台运行，需要在命令后面加上&amp;符号实现。如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">dougwilson@doug:~$ xlogo &amp;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">[1] 3870           作业编号为1  进程的PID为3870</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">dougwilson@doug:~$</span> </span><br></pre></td></tr></table></figure>

<h4 id="使进程从后台返回到前台执行-fg"><a href="#使进程从后台返回到前台执行-fg" class="headerlink" title="使进程从后台返回到前台执行 fg"></a>使进程从后台返回到前台执行 fg</h4><p>后台运行的进程不会受到键盘输入的影响，因此如键盘输入Ctrl+C无法中断进程的执行。</p>
<p>想要让进程从后台返回到前台执行，需要依靠fg命令，以及对应进程的作业编号，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">fg</span> %作业编号</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">dougwilson@doug:~$ <span class="built_in">jobs</span>     查看作业</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">[1]+  Running                 xlogo &amp;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">dougwilson@doug:~$ <span class="built_in">fg</span> %1</span>    </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">xlogo</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">^C</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">dougwilson@doug:~$</span> </span><br></pre></td></tr></table></figure>

<h4 id="使进程移到后台运行-bg"><a href="#使进程移到后台运行-bg" class="headerlink" title="使进程移到后台运行 bg"></a>使进程移到后台运行 bg</h4><p>使用方式和fg一样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">bg</span> %作业编号</span></span><br></pre></td></tr></table></figure>


</blockquote>
]]></content>
      <tags>
        <tag>linux, 命令</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习Java线程池</title>
    <url>/2020/08/17/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>如果没有线程池，需要通过<code>new Thread</code>来创建一个线程，由于线程的创建和销毁都需要消耗一定的CPU资源，所以在高并发下这种创建线程的方式将严重影响代码执行效率。而线程池的作用就是让一个线程执行结束后不马上销毁，继续执行新的任务，这样就节省了不断创建线程和销毁线程的开销。</p>
<span id="more"></span>

<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>Java线程池最为核心的类为<code>ThreadPoolExecutor</code>，其类结构图为：</p>
<p><img src="/images/ThreadPoolExecutor%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<p>它提供了四种构造函数来创建线程池，其中最为核心的构造函数如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                              RejectedExecutionHandler handler)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>这7个参数的含义如下：</p>
<ol>
<li><strong>corePoolSize</strong> 线程池核心线程数。即线程池中保留的线程个数，即使这些线程是空闲的，也不会被销毁，除非通过ThreadPoolExecutor的<code>allowCoreThreadTimeOut(true)</code>方法开启了核心线程的超时策略；</li>
<li><strong>maximumPoolSize</strong> 线程池中允许的最大线程个数；</li>
<li><strong>keepAliveTime</strong> 用于设置那些超出核心线程数量的线程的最大等待时间，超过这个时间还没有新任务的话，超出的线程将被销毁；</li>
<li><strong>unit</strong> 超时时间单位；</li>
<li><strong>workQueue</strong> 线程队列。用于保存通过execute方法提交的，等待被执行的任务；</li>
<li><strong>threadFactory</strong> 线程创建工程，即指定怎样创建线程；</li>
<li><strong>handler</strong> 拒绝策略。即指定当线程提交的数量超出了maximumPoolSize后，该使用什么策略处理超出的线程。</li>
</ol>
<p>在通过这个构造方法创建线程池的时候，这几个参数必须满足以下条件，否则将抛出<code>IllegalArgumentException</code>异常：</p>
<ol>
<li>corePoolSize不能小于0；</li>
<li>keepAliveTime不能小于0；</li>
<li>maximumPoolSize 不能小于等于0；</li>
<li>maximumPoolSize不能小于corePoolSize；</li>
</ol>
<p>此外，workQueue、threadFactory和handler不能为null，否则将抛出空指针异常。</p>
<p>下面举些例子来深入理解这几个参数的含义。</p>
<p>使用上面的构造方法创建一个线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">System.out.println(<span class="string">&quot;线程池创建完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> activeCount = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> queueSize = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeCount != threadPoolExecutor.getActiveCount()</span><br><span class="line">            || queueSize != threadPoolExecutor.getQueue().size()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;活跃线程个数 &quot;</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">        System.out.println(<span class="string">&quot;核心线程个数 &quot;</span> + threadPoolExecutor.getCorePoolSize());</span><br><span class="line">        System.out.println(<span class="string">&quot;队列线程个数 &quot;</span> + threadPoolExecutor.getQueue().size());</span><br><span class="line">        System.out.println(<span class="string">&quot;最大线程数 &quot;</span> + threadPoolExecutor.getMaximumPoolSize());</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        activeCount = threadPoolExecutor.getActiveCount();</span><br><span class="line">        queueSize = threadPoolExecutor.getQueue().size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码创建了一个核心线程数量为1，允许最大线程数量为2，最大活跃时间为10秒，线程队列长度为1的线程池。</p>
<p>假如通过execute方法向线程池提交1个任务，看看结果如何：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">System.out.println(<span class="string">&quot;线程池创建完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> activeCount = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> queueSize = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeCount != threadPoolExecutor.getActiveCount()</span><br><span class="line">            || queueSize != threadPoolExecutor.getQueue().size()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;活跃线程个数 &quot;</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">        System.out.println(<span class="string">&quot;核心线程个数 &quot;</span> + threadPoolExecutor.getCorePoolSize());</span><br><span class="line">        System.out.println(<span class="string">&quot;队列线程个数 &quot;</span> + threadPoolExecutor.getQueue().size());</span><br><span class="line">        System.out.println(<span class="string">&quot;最大线程数 &quot;</span> + threadPoolExecutor.getMaximumPoolSize());</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        activeCount = threadPoolExecutor.getActiveCount();</span><br><span class="line">        queueSize = threadPoolExecutor.getQueue().size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行sleep方法&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别注意：<strong>ThreadPoolExecutor的execute和submit方法都可以向线程池提交任务，区别是，submit方法能够返回执行结果，返回值类型为Future</strong></p>
<p>控制台输出结果如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">线程池创建完毕</span><br><span class="line">活跃线程个数 <span class="number">1</span></span><br><span class="line">核心线程个数 <span class="number">1</span></span><br><span class="line">队列线程个数 <span class="number">0</span></span><br><span class="line">Th<span class="built_in">read-0</span>线程执行<span class="built_in">sleep</span>方法</span><br><span class="line">最大线程数 <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>线程池核心线程数量为1，通过execute提交了一个任务后，由于核心线程是空闲的，所以任务被执行了。由于这个任务的逻辑是休眠100秒，所以在这100秒内，线程池的活跃线程数量为1。此外，因为提交的任务被核心线程执行了，所以并没有线程需要被放到线程队列里等待，线程队列长度为0。</p>
<p>假如通过execute方法向线程池提交2个任务，看看结果如何：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">threadPoolExecutor.execute<span class="function"><span class="params">(() -&gt; sleep(<span class="number">100</span>))</span>;</span></span><br><span class="line"><span class="function"><span class="title">threadPoolExecutor</span>.<span class="title">execute</span><span class="params">(() -&gt; sleep(<span class="number">100</span>))</span>;</span></span><br></pre></td></tr></table></figure>

<p>控制台输出结果如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">线程池创建完毕</span><br><span class="line">Th<span class="built_in">read-0</span>线程执行<span class="built_in">sleep</span>方法</span><br><span class="line">活跃线程个数 <span class="number">1</span></span><br><span class="line">核心线程个数 <span class="number">1</span></span><br><span class="line">队列线程个数 <span class="number">1</span></span><br><span class="line">最大线程数 <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>线程池核心线程数量为1，通过execute提交了2个任务后，一开始核心线程是空闲的，Thread-0被执行。由于这个任务的逻辑是休眠100秒，所以在这100秒内，线程池的活跃线程数量为1。因为核心线程数量为1，所以另外一个任务在这100秒内不能被执行，于是被放到线程队列里等待，线程队列长度为1。</p>
<p>假如通过execute方法向线程池提交3个任务，看看结果如何：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>

<p>控制台输出结果如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">线程池创建完毕</span><br><span class="line">Th<span class="built_in">read-0</span>线程执行<span class="built_in">sleep</span>方法</span><br><span class="line">Th<span class="built_in">read-1</span>线程执行<span class="built_in">sleep</span>方法</span><br><span class="line">活跃线程个数 <span class="number">2</span></span><br><span class="line">核心线程个数 <span class="number">1</span></span><br><span class="line">队列线程个数 <span class="number">1</span></span><br><span class="line">最大线程数 <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>这三个任务都是休眠100秒，所以核心线程池中第一个任务正在被执行，第二个任务被放入到了线程队列。而当第三个任务被提交进来时，线程队列满了（我们定义的长度为1），由于该线程池允许的最大线程数量为2，所以线程池还可以再创建一个线程来执行另外一个任务，于是乎之前在线程队列里的线程被取出执行（FIFO），第三个任务被放入到了线程队列。</p>
<p>改变第二个和第三个任务的睡眠时间，观察输出：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">threadPoolExecutor.execute<span class="function"><span class="params">(() -&gt; sleep(<span class="number">100</span>))</span>;</span></span><br><span class="line"><span class="function"><span class="title">threadPoolExecutor</span>.<span class="title">execute</span><span class="params">(() -&gt; sleep(<span class="number">5</span>))</span>;</span></span><br><span class="line"><span class="function"><span class="title">threadPoolExecutor</span>.<span class="title">execute</span><span class="params">(() -&gt; sleep(<span class="number">5</span>))</span>;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BA%BF%E7%A8%8B%E8%BE%93%E5%87%BA.png"></p>
<p>第二个任务提交5秒后，任务执行完毕，所以线程队列里的任务被执行，于是队列线程个数为0，活跃线程数量为2（第一个和第三个任务）。再过5秒后，第三个任务执行完毕，于是活跃线程数量为1（第一个100秒还没执行完毕）。</p>
<p>在第三个任务结束的瞬间，我们观察线程快照:</p>
<p><img src="/images/%E7%BA%BF%E7%A8%8B%E5%BF%AB%E7%85%A71.png"></p>
<p>可以看到，线程池中有两个线程，Thread-0在执行第一个任务（休眠100秒，还没结束），Thread-1执行完第三个任务后并没有马上被销毁。过段时间后（10秒钟后）再观察线程快照:</p>
<p><img src="/images/%E7%BA%BF%E7%A8%8B%E5%BF%AB%E7%85%A72.png"></p>
<p>可以看到，Thread-1这个线程被销毁了，因为我们在创建线程池的时候，指定keepAliveTime 为10秒，10秒后，超出核心线程池线程外的那些线程将被销毁。</p>
<p>假如一次性提交4个任务，看看会怎样：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">threadPoolExecutor.execute<span class="function"><span class="params">(() -&gt; sleep(<span class="number">100</span>))</span>;</span></span><br><span class="line"><span class="function"><span class="title">threadPoolExecutor</span>.<span class="title">execute</span><span class="params">(() -&gt; sleep(<span class="number">100</span>))</span>;</span></span><br><span class="line"><span class="function"><span class="title">threadPoolExecutor</span>.<span class="title">execute</span><span class="params">(() -&gt; sleep(<span class="number">100</span>))</span>;</span></span><br><span class="line"><span class="function"><span class="title">threadPoolExecutor</span>.<span class="title">execute</span><span class="params">(() -&gt; sleep(<span class="number">100</span>))</span>;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BA%BF%E7%A8%8B%E8%BE%93%E5%87%BA1.png"></p>
<p>因为设置的拒绝策略为AbortPolicy，所以最后提交的那个任务直接被拒绝了。更多拒绝策略下面会介绍到</p>
<h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><p>线程池包含以下几个状态：</p>
<p><img src="/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png"></p>
<p>当线程池中所有任务都处理完毕后，线程并不会自己关闭。我们可以通过调用<code>shutdown</code>和<code>shutdownNow</code>方法来关闭线程池。两者的区别在于：</p>
<ol>
<li><code>shutdown</code>方法将线程池置为shutdown状态，拒绝新的任务提交，但线程池并不会马上关闭，而是等待所有正在执行的和线程队列里的任务都执行完毕后，线程池才会被关闭。所以这个方法是平滑的关闭线程池。</li>
<li><code>shutdownNow</code>方法将线程池置为stop状态，拒绝新的任务提交，中断正在执行的那些任务，并且清除线程队列里的任务并返回。所以这个方法是比较“暴力”的。</li>
</ol>
<p>举两个例子观察下两者的区别：</p>
<p><code>shutdown</code>例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;已经执行了线程池shutdown方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行shortTask完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;shortTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行longTask完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;longTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出如下：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">已经执行了线程池shutdown方法</span><br><span class="line"><span class="keyword">Thread</span>-<span class="number">0</span>执行shortTask完毕</span><br><span class="line"><span class="keyword">Thread</span>-<span class="number">1</span>执行longTask完毕</span><br><span class="line"><span class="keyword">Thread</span>-<span class="number">1</span>执行shortTask完毕</span><br><span class="line"><span class="keyword">Thread</span>-<span class="number">0</span>执行longTask完毕</span><br></pre></td></tr></table></figure>

<p>可以看到，虽然在任务都被提交后马上执行了<code>shutdown</code>方法，但是并不会马上关闭线程池，而是等待所有被提交的任务都执行完了才关闭。</p>
<p><code>shutdownNow</code>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line"></span><br><span class="line">    List&lt;Runnable&gt; runnables = threadPoolExecutor.shutdownNow(); <span class="comment">// 马上关闭，并返回还未被执行的任务</span></span><br><span class="line">    System.out.println(runnables);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;已经执行了线程池shutdownNow方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行shortTask完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;shortTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行longTask完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;longTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">已经执行了线程池<span class="built_in">shutdown</span>方法</span><br><span class="line">longTask执行过程中被打断<span class="built_in">sleep</span> interrupted</span><br><span class="line">shortTask执行过程中被打断<span class="built_in">sleep</span> interrupted</span><br></pre></td></tr></table></figure>

<p>可以看到，在执行<code>shutdownNow</code>方法后，线程池马上就被关闭了，正在执行中的两个任务被打断，并且返回了线程队列中等待被执行的两个任务。</p>
<p>通过上面两个例子我们还可以看到<code>shutdown</code>和<code>shutdownNow</code>方法都不是阻塞的。常与<code>shutdown</code>搭配的方法有<code>awaitTermination</code>。</p>
<p><code>awaitTermination</code>方法接收timeout和TimeUnit两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测ExecutorService是否已经关闭，若关闭则返回true，否则返回false。该方法是阻塞的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">    <span class="keyword">boolean</span> isShutdown = threadPoolExecutor.awaitTermination(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (isShutdown) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程池在3秒内成功关闭&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;等了3秒还没关闭，不等了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行shortTask完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;shortTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行longTask完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;longTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">Thread-0执行shortTask完毕</span><br><span class="line"><span class="section">等了3秒还没关闭，不等了</span></span><br><span class="line"><span class="section">----------</span></span><br><span class="line">Thread-1执行longTask完毕</span><br><span class="line">Thread-0执行longTask完毕</span><br><span class="line">Thread-1执行shortTask完毕</span><br></pre></td></tr></table></figure>

<h2 id="4大拒绝策略"><a href="#4大拒绝策略" class="headerlink" title="4大拒绝策略"></a>4大拒绝策略</h2><p>当线程池无法再接收新的任务的时候，可采取如下四种策略：</p>
<p><img src="/images/%E7%BA%BF%E7%A8%8B%E6%B1%A04%E5%A4%A7%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5.png"></p>
<h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3><p><code>CallerRunsPolicy</code>策略：由调用线程处理该任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">&quot;任务1&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">&quot;任务2&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">&quot;任务3&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">&quot;任务4&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">&quot;任务5&quot;</span>));</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">shortTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行shortTask-name-&quot;</span> + name + <span class="string">&quot;完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;shortTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">longTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行longTask-name-&quot;</span> + name + <span class="string">&quot;完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;longTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的线程池最多只能一次性提交4个任务，第5个任务提交后会被拒绝策略处理。启动程序输出如下：</p>
<p><img src="/images/CallerRunsPolicy%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5.png"></p>
<p>可以看到，第5个提交的任务由调用线程（即main线程）处理该任务。</p>
<h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3><p><code>AbortPolicy</code>策略：丢弃任务，并抛出<code>RejectedExecutionException</code>异常。前面的例子就是使用该策略，所以不再演示。</p>
<h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3><p><code>DiscardOldestPolicy</code>策略：丢弃最早被放入到线程队列的任务，将新提交的任务放入到线程队列末端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">&quot;任务1&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">&quot;任务2&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">&quot;任务3&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">&quot;任务4&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">&quot;任务5&quot;</span>));</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">shortTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行shortTask-name-&quot;</span> + name + <span class="string">&quot;完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;shortTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">longTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行longTask-name-&quot;</span> + name + <span class="string">&quot;完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;longTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动程序输出如下：</p>
<p><img src="/images/DiscardOldestPolicy%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5.png"></p>
<p>可以看到最后提交的任务被执行了，而第3个任务是第一个被放到线程队列的任务，被丢弃了。</p>
<h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3><p><code>DiscardPolicy</code>策略：直接丢弃新的任务，不抛异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">&quot;任务1&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">&quot;任务2&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">&quot;任务3&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">&quot;任务4&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">&quot;任务5&quot;</span>));</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">shortTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行shortTask-name-&quot;</span> + name + <span class="string">&quot;完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;shortTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">longTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行longTask-name-&quot;</span> + name + <span class="string">&quot;完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;longTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动程序，输出如下：</p>
<p><img src="/images/DiscardPolicy%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5.png"></p>
<p>第5个任务直接被拒绝丢弃了，而没有抛出任何异常</p>
<h2 id="线程池工厂方法"><a href="#线程池工厂方法" class="headerlink" title="线程池工厂方法"></a>线程池工厂方法</h2><p>除了使用ThreadPoolExecutor的构造方法创建线程池外，我们也可以使用<code>Executors</code>提供的工厂方法来创建不同类型的线程池：</p>
<p><img src="/images/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0.png"></p>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>查看<code>newFixedThreadPool</code>方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，通过<code>newFixedThreadPool</code>创建的是一个固定大小的线程池，大小由<code>nThreads</code>参数指定，它具有如下几个特点:</p>
<ol>
<li>因为corePoolSize和maximumPoolSize的值都为nThreads，所以线程池中线程数量永远等于nThreads，不可能新建除了核心线程数的线程来处理任务，即keepAliveTime实际上在这里是无效的。</li>
<li>LinkedBlockingQueue是一个无界队列（最大长度为Integer.MAX_VALUE），所以这个线程池理论是可以无限的接收新的任务，这就是为什么上面没有指定拒绝策略的原因。</li>
</ol>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>查看<code>newCachedThreadPool</code>方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是一个理论上无限大小的线程池：</p>
<ol>
<li>核心线程数为0，SynchronousQueue队列是没有长度的队列，所以当有新的任务提交，如果有空闲的还未超时的（最大空闲时间60秒）线程则执行该任务，否则新增一个线程来处理该任务。</li>
<li>因为线程数量没有限制，理论上可以接收无限个新任务，所以这里也没有指定拒绝策略。</li>
</ol>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>查看<code>newSingleThreadExecutor</code>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>核心线程数和最大线程数都为1，每次只能有一个线程处理任务。</li>
<li>LinkedBlockingQueue队列可以接收无限个新任务。</li>
</ol>
<h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>查看<code>newScheduledThreadPool</code>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以<code>newScheduledThreadPool</code>理论是也是可以接收无限个任务，DelayedWorkQueue也是一个无界队列。</p>
<p>使用newScheduledThreadPool创建的线程池除了可以处理普通的Runnable任务外，它还具有调度的功能：</p>
<ol>
<li><p>延迟指定时间后执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 延迟5秒执行</span></span><br><span class="line">executorService.schedule(() -&gt; System.out.println(<span class="string">&quot;hello&quot;</span>), <span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></li>
<li><p>按指定的速率执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 延迟1秒执行，然后每5秒执行一次</span></span><br><span class="line">executorService.scheduleAtFixedRate(</span><br><span class="line">        () -&gt; System.out.println(LocalTime.now()), <span class="number">1</span>, <span class="number">5</span>, TimeUnit.SECONDS</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%8C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E9%80%9F%E7%8E%87%E6%89%A7%E8%A1%8C.png"></p>
</li>
<li><p>按指定的时延执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">executorService.scheduleWithFixedDelay(</span><br><span class="line">        () -&gt; System.out.println(LocalTime.now()), <span class="number">1</span>, <span class="number">5</span>, TimeUnit.SECONDS</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%8C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E6%97%B6%E5%BB%B6%E6%89%A7%E8%A1%8C.png"></p>
</li>
</ol>
<p>看起来，scheduleAtFixedRate和scheduleWithFixedDelay没啥区别，实际它们还是有区别的：</p>
<ul>
<li>scheduleAtFixedRate按照固定速率执行任务，比如每5秒执行一个任务，即使上一个任务没有结束，5秒后也会开始处理新的任务；</li>
<li>scheduleWithFixedDelay按照固定的时延处理任务，比如每延迟5秒执行一个任务，无论上一个任务处理了1秒，1分钟还是1小时，下一个任务总是在上一个任务执行完毕后5秒钟后开始执行。</li>
</ul>
<h3 id="线程池工厂方法使用"><a href="#线程池工厂方法使用" class="headerlink" title="线程池工厂方法使用"></a>线程池工厂方法使用</h3><p><img src="/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8.png"></p>
<p>因为这几个线程池理论是都可以接收无限个任务，所以这就有内存溢出的风险。实际上只要我们掌握了ThreadPoolExecutor构造函数7个参数的含义，我们就可以根据不同的业务来创建出符合需求的线程池。一般线程池的创建可以参考如下规则：</p>
<ul>
<li>IO密集型任务：IO密集型任务线程并不是一直在执行任务，应该配置尽可能多的线程，线程池线程数量推荐设置为2 * CPU核心数；对于IO密集型任务，网络上也有另一种线程池数量计算公式：CPU核心数/(1 - 阻塞系数)，阻塞系数取值0.8~0.9，至于这两种公式使用哪一个，可以根据实际环境测试比较得出；</li>
<li>计算密集型任务：此类型需要CPU的大量运算，所以尽可能的去压榨CPU资源，线程池线程数量推荐设置为CPU核心数 + 1。</li>
</ul>
<p>CPU核心数可以使用<code>Runtime</code>获得：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Runtime</span>.</span></span>get<span class="constructor">Runtime()</span>.available<span class="constructor">Processors()</span></span><br></pre></td></tr></table></figure>

<h2 id="一些API的用法"><a href="#一些API的用法" class="headerlink" title="一些API的用法"></a>一些API的用法</h2><h4 id="ThreadPoolExecutor几个判断线程池状态的方法："><a href="#ThreadPoolExecutor几个判断线程池状态的方法：" class="headerlink" title="ThreadPoolExecutor几个判断线程池状态的方法："></a>ThreadPoolExecutor几个判断线程池状态的方法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;线程池为shutdown状态：&quot;</span> + threadPoolExecutor.isShutdown());</span><br><span class="line">    System.out.println(<span class="string">&quot;线程池正在关闭：&quot;</span> + threadPoolExecutor.isTerminating());</span><br><span class="line">    System.out.println(<span class="string">&quot;线程池已经关闭：&quot;</span> + threadPoolExecutor.isTerminated());</span><br><span class="line">    threadPoolExecutor.awaitTermination(<span class="number">6</span>, TimeUnit.SECONDS);</span><br><span class="line">    System.out.println(<span class="string">&quot;线程池已经关闭&quot;</span> + threadPoolExecutor.isTerminated());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">线程池为shutdown状态：<span class="literal">true</span></span><br><span class="line">线程池正在关闭：<span class="literal">true</span></span><br><span class="line">线程池已经关闭：<span class="literal">false</span></span><br><span class="line">线程池已经关闭<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="allowCoreThreadTimeOut"><a href="#allowCoreThreadTimeOut" class="headerlink" title="allowCoreThreadTimeOut"></a>allowCoreThreadTimeOut</h4><p>前面我们提到，线程池核心线程即使是空闲状态也不会被销毁，除非使用<code>allowCoreThreadTimeOut</code>设置了允许核心线程超时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">               <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">               <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">               <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">       );</span><br><span class="line">       threadPoolExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">       threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">               System.out.println(<span class="string">&quot;任务执行完毕&quot;</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="ThreadPoolExecutor提供了一些remove方法"><a href="#ThreadPoolExecutor提供了一些remove方法" class="headerlink" title="ThreadPoolExecutor提供了一些remove方法"></a>ThreadPoolExecutor提供了一些<code>remove</code>方法</h4><p>查看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = workQueue.remove(task);</span><br><span class="line">    tryTerminate(); <span class="comment">// In case SHUTDOWN and now empty</span></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知，它删除的是线程队列中的任务，而非正在被执行的任务。比如说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;任务执行完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Runnable r = () -&gt; System.out.println(<span class="string">&quot;看看我是否会被删除&quot;</span>);</span><br><span class="line">    threadPoolExecutor.execute(r);</span><br><span class="line">    threadPoolExecutor.remove(r);</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">任务执行完毕</span><br></pre></td></tr></table></figure>

<p>可看到任务并没有被执行，已经被删除，因为唯一一个核心线程已经在执行任务了，所以后提交的这个任务被放到了线程队列里，然后通过remove方法删除。</p>
<h4 id="prestartCoreThread"><a href="#prestartCoreThread" class="headerlink" title="prestartCoreThread"></a>prestartCoreThread</h4><p>默认情况下，只有当往线程池里提交了任务后，线程池才会启动核心线程处理任务。我们可以通过调用<code>prestartCoreThread</code>方法，让核心线程即使没有任务提交，也处于等待执行任务的活跃状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line">    System.out.println(<span class="string">&quot;活跃线程数: &quot;</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">    threadPoolExecutor.prestartCoreThread();</span><br><span class="line">    System.out.println(<span class="string">&quot;活跃线程数: &quot;</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">    threadPoolExecutor.prestartCoreThread();</span><br><span class="line">    System.out.println(<span class="string">&quot;活跃线程数: &quot;</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">    threadPoolExecutor.prestartCoreThread();</span><br><span class="line">    System.out.println(<span class="string">&quot;活跃线程数: &quot;</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">活跃线程数：0</span><br><span class="line">活跃线程数：1</span><br><span class="line">活跃线程数：2</span><br><span class="line">活跃线程数：2</span><br></pre></td></tr></table></figure>

<p>该方法返回boolean类型值，如果所以核心线程都启动了，返回false，反之返回true。</p>
<p>还有一个和它类似的<code>prestartAllCoreThreads</code>方法，它的作用是一次性启动所有核心线程，让其处于活跃地等待执行任务的状态。</p>
<p>ThreadPoolExecutor的invokeAny方法用于随机执行任务集合中的某个任务，并返回执行结果，该方法是同步方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务集合</span></span><br><span class="line">    List&lt;Callable&lt;Integer&gt;&gt; tasks = IntStream.range(<span class="number">0</span>, <span class="number">4</span>).boxed().map(i -&gt; (Callable&lt;Integer&gt;) () -&gt; &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 随机执行结果</span></span><br><span class="line">    Integer result = threadPoolExecutor.invokeAny(tasks);</span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    threadPoolExecutor.shutdownNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>

<h4 id="invokeAll"><a href="#invokeAll" class="headerlink" title="invokeAll"></a>invokeAll</h4><p>ThreadPoolExecutor的invokeAll则是执行任务集合中的所有任务，返回Future集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    List&lt;Callable&lt;Integer&gt;&gt; tasks = IntStream.range(<span class="number">0</span>, <span class="number">4</span>).boxed().map(i -&gt; (Callable&lt;Integer&gt;) () -&gt; &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    List&lt;Future&lt;Integer&gt;&gt; futureList = threadPoolExecutor.invokeAll(tasks);</span><br><span class="line">    futureList.stream().map(f-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdownNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">allowCoreThreadTimeOut(boolean value)</td>
<td align="left">是否允许核心线程空闲后超时，是的话超时后核心线程将销毁，线程池自动关闭</td>
</tr>
<tr>
<td align="left">awaitTermination(long timeout, TimeUnit unit)</td>
<td align="left">阻塞当前线程，等待线程池关闭，timeout用于指定等待时间。</td>
</tr>
<tr>
<td align="left">execute(Runnable command)</td>
<td align="left">向线程池提交任务，没有返回值</td>
</tr>
<tr>
<td align="left">submit(Runnable task)</td>
<td align="left">向线程池提交任务，返回Future</td>
</tr>
<tr>
<td align="left">isShutdown()</td>
<td align="left">判断线程池是否为shutdown状态</td>
</tr>
<tr>
<td align="left">isTerminating()</td>
<td align="left">判断线程池是否正在关闭</td>
</tr>
<tr>
<td align="left">isTerminated()</td>
<td align="left">判断线程池是否已经关闭</td>
</tr>
<tr>
<td align="left">remove(Runnable task)</td>
<td align="left">移除线程队列中的指定任务</td>
</tr>
<tr>
<td align="left">prestartCoreThread()</td>
<td align="left">提前让一个核心线程处于活跃状态，等待执行任务</td>
</tr>
<tr>
<td align="left">prestartAllCoreThreads()</td>
<td align="left">提前让所有核心线程处于活跃状态，等待执行任务</td>
</tr>
<tr>
<td align="left">getActiveCount()</td>
<td align="left">获取线程池活跃线程数</td>
</tr>
<tr>
<td align="left">getCorePoolSize()</td>
<td align="left">获取线程池核心线程数</td>
</tr>
<tr>
<td align="left">threadPoolExecutor.getQueue()</td>
<td align="left">获取线程池线程队列</td>
</tr>
<tr>
<td align="left">getMaximumPoolSize()</td>
<td align="left">获取线程池最大线程数</td>
</tr>
<tr>
<td align="left">shutdown()</td>
<td align="left">让线程池处于shutdown状态，不再接收任务，等待所有正在运行中的任务结束后，关闭线程池</td>
</tr>
<tr>
<td align="left">shutdownNow()</td>
<td align="left">让线程池处于stop状态，不再接受任务，尝试打断正在运行中的任务，并关闭线程池，返回线程队列中的任务</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>java, 线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Spring循环依赖</title>
    <url>/2020/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<p>所谓循环依赖指的是：BeanA对象的创建依赖于BeanB，BeanB对象的创建也依赖于BeanA，这就造成了死循环，如果不做处理的话势必会造成栈溢出。Spring通过提前曝光机制，利用三级缓存解决循环依赖问题。本节将记录单实例Bean的创建过程，并且仅记录两种常见的循环依赖情况：普通Bean与普通Bean之间的循环依赖，普通Bean与代理Bean之间的循环依赖。</p>
<span id="more"></span>

<h2 id="Bean创建过程"><a href="#Bean创建过程" class="headerlink" title="Bean创建过程"></a>Bean创建过程</h2><p>先通过源码熟悉下Bean创建过程（源码仅贴出相关部分）：</p>
<p>IOC容器获取Bean的入口为AbstractBeanFactory类的getBean方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">extends</span> <span class="title">FactoryBeanRegistrySupport</span> <span class="keyword">implements</span> <span class="title">ConfigurableBeanFactory</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法是一个空壳方法，具体逻辑都在doGetBean方法内：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">extends</span> <span class="title">FactoryBeanRegistrySupport</span> <span class="keyword">implements</span> <span class="title">ConfigurableBeanFactory</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Bean名称</span></span><br><span class="line">        String beanName = transformedBeanName(name);</span><br><span class="line">        Object bean;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从三级缓存中获取目标Bean实例</span></span><br><span class="line">        Object sharedInstance = getSingleton(beanName);</span><br><span class="line">        <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 不为空，则进行后续处理并返回</span></span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ......</span><br><span class="line">                RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// 从三级缓存中没有获取到Bean实例，并且目标Bean是单实例Bean的话</span></span><br><span class="line">                <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                    <span class="comment">// 通过getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory)方法创建Bean实例</span></span><br><span class="line">                    sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 创建Bean实例</span></span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                            ......</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="comment">// 后续处理，并返回</span></span><br><span class="line">                    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> (T) bean;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doGetBean方法中先通过getSingleton(String beanName)方法从三级缓存中获取Bean实例，如果不为空则进行后续处理；如果为空，则通过getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory)方法创建Bean实例并进行后续处理。</p>
<p>这两个方法都是AbstractBeanFactory父类DefaultSingletonBeanRegistry的方法，AbstractBeanFactory层级关系图如下所示：</p>
<p><img src="/images/AbstractBeanFactory%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB%E5%9B%BE.png"></p>
<p>getSingleton(String beanName)相关源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从一级缓存中获取目标Bean实例</span></span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="comment">// 如果从一级缓存中没有获取到，并且该Bean处于正在创建中的状态时</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="comment">// 从二级缓存获取目标Bean实例</span></span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">// 如果没有获取到，并且允许提前曝光的话</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">                    <span class="comment">// 在锁内重新从一级缓存中往下查找</span></span><br><span class="line">                    singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 从三级缓存中取出目标Bean工厂对象</span></span><br><span class="line">                            ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                            <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 工厂对象不为空，则通过调用getObject方法实例化Bean实例</span></span><br><span class="line">                                singletonObject = singletonFactory.getObject();</span><br><span class="line">                                <span class="comment">// 放到二级缓存中</span></span><br><span class="line">                                <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                                <span class="comment">// 删除对应的三级缓存</span></span><br><span class="line">                                <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所谓的三级缓存指的是DefaultSingletonBeanRegistry类的三个成员变量：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>singletonObjects</td>
<td>一级缓存，key为Bean名称，value为Bean实例。这里的Bean实例指的是已经完全创建好的，即已经经历实例化-&gt;属性填充-&gt;初始化以及各种后置处理过程的Bean，可直接使用。</td>
</tr>
<tr>
<td>earlySingletonObjects</td>
<td>二级缓存，key为Bean名称，value为Bean实例。这里的Bean实例指的是仅完成实例化的Bean，还未进行属性填充等后续操作。用于提前曝光，供别的Bean引用，解决循环依赖。</td>
</tr>
<tr>
<td>singletonFactories</td>
<td>三级缓存，key为Bean名称，value为Bean工厂。在Bean实例化后，属性填充之前，如果允许提前曝光，Spring会把该Bean转换成Bean工厂并加入到三级缓存。在需要引用提前曝光对象时再通过工厂对象的getObject()方法获取。</td>
</tr>
</tbody></table>
<p>如果通过三级缓存的查找都没有找到目标Bean实例，则通过getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory)方法创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 从一级缓存获取</span></span><br><span class="line">            Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 为空则继续</span></span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// 方法内会将当前Bean名称添加到正在创建Bean的集合（singletonsCurrentlyInCreation）中</span></span><br><span class="line">                beforeSingletonCreation(beanName);</span><br><span class="line">                <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 通过函数式接口创建Bean实例，该实例已经经历实例化-&gt;属性填充-&gt;初始化以及各种后置处理过程，可直接使用</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    newSingleton = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                   ......</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                    <span class="comment">// 添加到缓存中</span></span><br><span class="line">                    addSingleton(beanName, singletonObject);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> singletonObject;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 添加到一级缓存</span></span><br><span class="line">            <span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">            <span class="comment">// 删除对应的二三级缓存</span></span><br><span class="line">            <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码重点关注singletonFactory.getObject()，singletonFactory是一个函数式接口，对应AbstractBeanFactory的doGetBean方法中的lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Bean实例</span></span><br><span class="line">        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>重点关注createBean方法。该方法为抽象方法，由AbstractBeanFactory子类AbstractAutowireCapableBeanFactory实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">AutowireCapableBeanFactory</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建Bean实例</span></span><br><span class="line">            Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">            <span class="keyword">return</span> beanInstance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doCreateBean源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">AutowireCapableBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 实例化Bean</span></span><br><span class="line">        <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line">        Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行MergedBeanDefinitionPostProcessor类型后置处理器</span></span><br><span class="line">                    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果该Bean是单例，并且allowCircularReferences属性为true（标识允许循环依赖的出现）以及该Bean正在创建中</span></span><br><span class="line">        <span class="comment">// 的话，earlySingletonExposure就为true，标识允许单实例Bean提前暴露原始对象引用（仅实例化）</span></span><br><span class="line">        <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">            <span class="comment">// 添加到单实例工厂集合中，即三级缓存对象，该方法第二个参数类型为ObjectFactory&lt;?&gt; singletonFactory，</span></span><br><span class="line">            <span class="comment">// 前面提到过，它是一个函数式接口，这里用lambda表达式() -&gt; getEarlyBeanReference(beanName, mbd, bean)表示</span></span><br><span class="line">            addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object exposedObject = bean;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 属性赋值操作</span></span><br><span class="line">            populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">            <span class="comment">// 初始化Bean（初始化操作主要包括xxxxAware注入，BeanPostProcessor后置处理器方法调用以</span></span><br><span class="line">            <span class="comment">// 及InitializingBean接口方法调用，感兴趣的可以自己查看源码）</span></span><br><span class="line">            exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果earlySingletonExposure为true</span></span><br><span class="line">        <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">            <span class="comment">// 第二个参数为false表示仅从一级和二级缓存中获取Bean实例</span></span><br><span class="line">            Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                    <span class="comment">// 如果从一级和二级缓存中获取Bean实例不为空，并且exposedObject == bean的话，</span></span><br><span class="line">                    <span class="comment">// 将earlySingletonReference赋值给exposedObject返回</span></span><br><span class="line">                    exposedObject = earlySingletonReference;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 返回最终Bean实例</span></span><br><span class="line">        <span class="keyword">return</span> exposedObject;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">        Object exposedObject = bean;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="comment">// SmartInstantiationAwareBeanPostProcessor类型后置处理，常见的场景为AOP代理</span></span><br><span class="line">            <span class="keyword">for</span> (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) &#123;</span><br><span class="line">                exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exposedObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addSingletonFactory方法为父类DefaultSingletonBeanRegistry的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 一级缓存没有目标Bean实例的话，添加三级缓存</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">                <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">                <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述整个过程可以用下图来总结（可右键选择新标签页中打开图片）：</p>
<p><img src="/images/bean%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.svg"></p>
<p>下面我们通过两个场景来加深理解</p>
<h3 id="普通Bean与普通Bean间的循环依赖"><a href="#普通Bean与普通Bean间的循环依赖" class="headerlink" title="普通Bean与普通Bean间的循环依赖"></a>普通Bean与普通Bean间的循环依赖</h3><p>新建CircularReferenceTest类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularReferenceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(BeanA.class, BeanB.class);</span><br><span class="line">        BeanA beanA = context.getBean(BeanA.class);</span><br><span class="line">        BeanB beanB = context.getBean(BeanB.class);</span><br><span class="line">        BeanB beanBInBeanA = beanA.getBeanB();</span><br><span class="line">        BeanA beanAInBeanB = beanB.getBeanA();</span><br><span class="line">        System.out.println(beanA);</span><br><span class="line">        System.out.println(beanB);</span><br><span class="line">        System.out.println(beanB == beanBInBeanA);</span><br><span class="line">        System.out.println(beanA == beanAInBeanB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanB beanB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanB <span class="title">getBeanB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanB</span><span class="params">(BeanB beanB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanB = beanB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanA beanA;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanA <span class="title">getBeanA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanA</span><span class="params">(BeanA beanA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanA = beanA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码通过AnnotationConfigApplicationContext创建了IOC容器，并先后注册了BeanA和BeanB，BeanA和BeanB相互依赖。程序测试结果如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">com.dougWilson.<span class="symbol">BeanA@</span><span class="number">368f</span>2016</span><br><span class="line">com.dougWilson.<span class="symbol">BeanB@</span><span class="number">6f</span>03482</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>可以看到，Spring成功解决了循环依赖。下面配合源码来分析这个过程</p>
<p>上面程序中，先创建BeanA，Spring内部调用doGetBean方法获取BeanA。一开始三级缓存中肯定没有BeanA和BeanB相关实例：</p>
<p><img src="/images/BeanA%E5%92%8CBeanB%E7%9B%B8%E5%85%B3%E5%AE%9E%E4%BE%8B1.png"></p>
<p><img src="/images/BeanA%E5%92%8CBeanB%E7%9B%B8%E5%85%B3%E5%AE%9E%E4%BE%8B2.png"></p>
<p>所以我们直接看doCreateBean相关源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">AutowireCapableBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 实例化BeanA，BeanA的早期对象，属性还未赋值，还未进行后置处理</span></span><br><span class="line">        <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line">        Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BeanA是单例对象，并且allowCircularReferences为true，BeanA正在创建中，所以</span></span><br><span class="line">        <span class="comment">// 最终earlySingletonExposure为true</span></span><br><span class="line">        <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">            <span class="comment">// 将BeanA早期对象传递给Bean工厂，并添加到三级缓存中</span></span><br><span class="line">            addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object exposedObject = bean;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 属性赋值操作</span></span><br><span class="line">            populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码，Spring实例化了BeanA，然后往三级缓存中添加了BeanA的工厂对象，根据前面getEarlyBeanReference方法的源码我们可以知道，在不存在AOP代理的情况下，该方法直接返回原始BeanA对象。所以通过该工厂方法创建的BeanA对象仅仅是进行了实例化操作，属性还未被赋值，换句话说，该工厂用于提前曝光BeanA实例。</p>
<p>接着调用populateBean方法对BeanA属性赋值，赋值过程发现BeanA依赖于BeanB，所以Spring重复以上步骤创建BeanB。创建过程中同样会遇到populateBean方法对BeanB属性赋值，赋值过程中发现BeanB依赖于BeanA，于是Spring又回头创建BeanA，不过这时候情况就开始不一样了！！</p>
<p>doGetBean方法内部从三级缓存中获取BeanA对象时，三级缓存内容如下：</p>
<p><img src="/images/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B8%AD%E8%8E%B7%E5%8F%96BeanA%E5%AF%B9%E8%B1%A11.png"></p>
<p><img src="/images/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B8%AD%E8%8E%B7%E5%8F%96BeanA%E5%AF%B9%E8%B1%A12.png"></p>
<p><img src="/images/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B8%AD%E8%8E%B7%E5%8F%96BeanA%E5%AF%B9%E8%B1%A13.png"></p>
<p>可以看到一级缓存和二级缓存没有什么不一样，但三级缓存中已经存在BeanA和BeanB的工厂对象了！</p>
<p>所以此时getSingleton(String beanName, boolean allowEarlyReference)方法内的逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="comment">// 一级缓存中没有BeanA，并且BeanA正在创建中</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">// 二级缓存中也没有BeanA</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">                    <span class="comment">// 在锁内重新从一级缓存中往下查找</span></span><br><span class="line">                    singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 从三级缓存中取出目标BeanA的工厂对象</span></span><br><span class="line">                            ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                            <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 工厂对象不为空，调用getObject方法获取前面提前曝光的BeanA早期实例</span></span><br><span class="line">                                singletonObject = singletonFactory.getObject();</span><br><span class="line">                                <span class="comment">// 将BeanA早期实例放到二级缓存中</span></span><br><span class="line">                                <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                                <span class="comment">// 删除对应的三级缓存</span></span><br><span class="line">                                <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回BeanA早期实例</span></span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时查看二级缓存：</p>
<p><img src="/images/%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.png"></p>
<p>可以看到，BeanA确实只是早期实例，属性BeanB还未被赋值。随后BeanB在属性填充的时候获取到了BeanA早期实例，完成属性填充、初始化等后续操作，BeanB创建完毕。BeanB完整创建完毕后，BeanA随之也完成属性填充、初始化等后续操作，BeanA也创建完毕，循环依赖得以解决。</p>
<p>BeanB虽然获取到的是BeanA的早期对象，但当BeanA完整创建完毕后，BeanB里的BeanA也将会是完整的，因为指针指向的都是同一个BeanA地址。</p>
<p>画个图总结上面的过程（可右键选择新标签页中打开图片）：</p>
<p><img src="/images/%E6%99%AE%E9%80%9Abean%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%A7%A3%E5%86%B3.svg"></p>
<h3 id="普通bean与代理bean间的循环依赖"><a href="#普通bean与代理bean间的循环依赖" class="headerlink" title="普通bean与代理bean间的循环依赖"></a>普通bean与代理bean间的循环依赖</h3><p>普通Bean和代理Bean之间的循环依赖和上面过程差不多，不过细节上有些许差异。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(MyApplication.class, args);</span><br><span class="line">        BeanA beanA = context.getBean(BeanA.class);</span><br><span class="line">        BeanB beanB = context.getBean(BeanB.class);</span><br><span class="line">        BeanB beanBInBeanA = beanA.getBeanB();</span><br><span class="line">        BeanA beanAInBeanB = beanB.getBeanA();</span><br><span class="line">        System.out.println(<span class="string">&quot;BeanA是否为代理对象：&quot;</span> + AopUtils.isAopProxy(beanA));</span><br><span class="line">        System.out.println(<span class="string">&quot;BeanB是否为代理对象：&quot;</span> + AopUtils.isAopProxy(beanB));</span><br><span class="line">        System.out.println(<span class="string">&quot;beanAInBeanB是否为代理对象：&quot;</span> + AopUtils.isAopProxy(beanAInBeanB));</span><br><span class="line">        System.out.println(beanB == beanBInBeanA);</span><br><span class="line">        System.out.println(beanA == beanAInBeanB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanB beanB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanB <span class="title">getBeanB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanB</span><span class="params">(BeanB beanB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanB = beanB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanA beanA;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanA <span class="title">getBeanA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanA</span><span class="params">(BeanA beanA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanA = beanA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * cc.mrbird.BeanA.getBeanB())&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;onBefore：&quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot;方法开始执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为MyAspect切面类的存在，BeanA将会是个代理类，而BeanB则是普通Bean，程序输出如下：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">onBefore：getBeanB方法开始执行</span><br><span class="line">BeanA是否为代理对象：<span class="literal">true</span></span><br><span class="line">BeanB是否为代理对象：<span class="literal">false</span></span><br><span class="line">beanAInBeanB是否为代理对象：<span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>假设容器先创建BeanA，过程和上面的例子一致，属性填充时，发现BeanA依赖BeanB，然后Spring开始创建BeanB。创建BeanB时候又发现其依赖BeanA，这时三级缓存中已经存在BeanA的工厂对象了，所以直接通过该工厂对象获取BeanA的早期实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="comment">// 一级缓存中没有BeanA，并且BeanA正在创建中</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">// 二级缓存中也没有BeanA</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">                    <span class="comment">// 在锁内重新从一级缓存中往下查找</span></span><br><span class="line">                    singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 从三级缓存中取出目标BeanA的工厂对象</span></span><br><span class="line">                            ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                            <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 工厂对象不为空，调用getObject方法获取前面提前曝光的BeanA早期实例</span></span><br><span class="line">                                singletonObject = singletonFactory.getObject();</span><br><span class="line">                                <span class="comment">// 将BeanA早期实例放到二级缓存中</span></span><br><span class="line">                                <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                                <span class="comment">// 删除对应的三级缓存</span></span><br><span class="line">                                <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回BeanA早期实例</span></span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>singletonFactory.getObject()实际实现为lambda表达式() -&gt; getEarlyBeanReference(beanName, mbd, bean)，getEarlyBeanReference方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) &#123;</span><br><span class="line">            exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在引入AOP依赖后，容器中将会有一个SmartInstantiationAwareBeanPostProcessor接口的实现类AbstractAutoProxyCreator，用于创建AOP代理，所以上面getEarlyBeanReference方法里的bp.getEarlyBeanReference(exposedObject, beanName)逻辑实际上为AbstractAutoProxyCreator实现的getEarlyBeanReference方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生成缓存Key</span></span><br><span class="line">        Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="comment">// 放入earlyProxyReferences集合中，标识BeanA为早期代理对象</span></span><br><span class="line">        <span class="keyword">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line">        <span class="comment">// 在这个例子中，BeanA将被包装为代理对象</span></span><br><span class="line">        <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以BeanB从三级缓存中获取到的为代理后的BeanA实例：</p>
<p><img src="/images/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%8E%B7%E5%8F%96bean%E5%AE%9E%E4%BE%8B.png"></p>
<p>BeanB创建完毕后，BeanA属性填充操作随之结束。</p>
<p>通过《深入理解Spring AOP原理》对AOP的学习我们知道，代理对象是在后置处理BeanPostProcessor的postProcessAfterInitialization方法内完成的，而该方法的调用时机为Bean属性填充后的初始化操作时，所以在BeanA属性填充操作结束时，BeanA还只是一个普通对象，而BeanB里的BeanA已经是代理对象了。</p>
<p>继续BeanA的创建过程，BeanA属性填充完后，执行initializeBean(beanName, exposedObject, mbd)方法进行初始化操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">AutowireCapableBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        Object exposedObject = bean;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 属性赋值操作</span></span><br><span class="line">            populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">            <span class="comment">// 初始化操作</span></span><br><span class="line">            exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们主要关注初始化操作阶段执行动态代理的后置处理方法过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">            <span class="comment">// 在BeanB填充属性时，BeanA已经被放入到earlyProxyReferences集合中了</span></span><br><span class="line">            <span class="comment">// 所以该if不成立，直接跳过，避免二次代理</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">                <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所以这里返回的还是BeanA原始对象，并非代理对象</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<p>到这里BeanA依旧是普通对象，继续查看doCreateBean方法的后续逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">AutowireCapableBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 原始BeanA赋值给exposedObject</span></span><br><span class="line">        Object exposedObject = bean;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 属性赋值操作</span></span><br><span class="line">            populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">            <span class="comment">// 初始化操作，通过上面分析，此时返回的还是原始的BeanA对象</span></span><br><span class="line">            exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">            <span class="comment">// 从缓存中获取BeanA，此时二级缓存中已经存在BeanA的代理对象了，所以</span></span><br><span class="line">            <span class="comment">// 这里earlySingletonReference为BeanA的代理对象（如下图）</span></span><br><span class="line">            Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// exposedObject和bean相等，因为BeanA并未在初始化的时候被二次代理</span></span><br><span class="line">                <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                    <span class="comment">// 这里将代理对象BeanA赋值给exposedObject</span></span><br><span class="line">                    exposedObject = earlySingletonReference;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 最终返回的exposedObject对象为从二级缓存中获取到的BeanA代理对象</span></span><br><span class="line">        <span class="keyword">return</span> exposedObject;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E4%BE%8Bbean%E6%9C%80%E7%BB%88.png"></p>
<p>到这里，无论是BeanB里的BeanA，还是IOC容器中的BeanA，都是代理后的BeanA了。</p>
<p>画张图总结下上面的过程（可右键选择新标签页中打开图片）：</p>
<p><img src="/images/%E6%99%AE%E9%80%9Abean%E4%B8%8E%E4%BB%A3%E7%90%86bean%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%A7%A3%E5%86%B3.svg"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面的例子都是基于属性注入的情况，假如存在构造器注入情况下的循环依赖，Spring将没办法解决。这是因为对象的提前曝光时机发生在对象实例化之后，而构造器注入时机为对象实例化时，所以此时还未进行提前曝光操作，循环依赖也就没办法解决了，比如下面这种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanB beanB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanA</span><span class="params">(BeanB beanB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanB = beanB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanB <span class="title">getBeanB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanB</span><span class="params">(BeanB beanB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanB = beanB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanA beanA;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanB</span><span class="params">(BeanA beanA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanA = beanA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanA <span class="title">getBeanA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanA</span><span class="params">(BeanA beanA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanA = beanA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序将抛出如下异常：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line"><span class="keyword">Description</span>:</span><br><span class="line"></span><br><span class="line">The <span class="keyword">dependencies</span> of some of the beans in the application context form a cycle:</span><br><span class="line"></span><br><span class="line">┌─────┐</span><br><span class="line">|  beanA defined in <span class="keyword">file</span> [<span class="regexp">/Users/m</span>rbird<span class="regexp">/idea workspace/</span>aop-deep-learn<span class="regexp">/target/</span>classes<span class="regexp">/cc/m</span>rbird/BeanA.<span class="keyword">class</span>]</span><br><span class="line">↑     ↓</span><br><span class="line">|  beanB defined in <span class="keyword">file</span> [<span class="regexp">/Users/m</span>rbird<span class="regexp">/idea workspace/</span>aop-deep-learn<span class="regexp">/target/</span>classes<span class="regexp">/cc/m</span>rbird/BeanB.<span class="keyword">class</span>]</span><br><span class="line">└─────┘</span><br></pre></td></tr></table></figure>

<p>此外，这里讨论了普通Bean与普通Bean之间的循环依赖，代理Bean与普通Bean之间的循环依赖，实际情况还可能存在工厂Bean与普通Bean、代理Bean之间的循环依赖，这种情况比较复杂，本文不讨论，因为就理解Spring解决循环依赖的思想而言，上面两种情况搞清楚了就OK了。</p>
]]></content>
      <tags>
        <tag>spring, 循环依赖</tag>
      </tags>
  </entry>
</search>
