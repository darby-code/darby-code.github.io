<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AJAX工作原理解析</title>
    <url>/2020/04/01/AJAX%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>在前面的一篇文章《Tomcat服务器解析》中，有简单地介绍AJAX如何使用，但也仅限于此。而AJAX技术的关键，在于XMLHttpRequest对象的使用。因此，与其说AJAX是一个技术，不如说AJAX是一个XMLHttpRequest对象的使用技巧。</p>
<span id="more"></span>

<h2 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h2><h3 id="XMLHttpRequest对象概述"><a href="#XMLHttpRequest对象概述" class="headerlink" title="XMLHttpRequest对象概述"></a>XMLHttpRequest对象概述</h3><blockquote>
<p>在使用XMLHttpRequest对象发送请求和处理相应前，必须使用JavaScript创建一个XMLHttpRequest对象。由于XMLHttpRequest不是一个W3C标准，不同浏览器对其实例对象有不同实现，比如Internet Explorer将XMLHttpRequest实现为一个ActiveX对象，其它浏览器将其实现为一个本地的JavaScript对象。因此需要根据不同的浏览器，创建相应的XMLHttpRequest对象。大体上可以分为两类：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlHttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line"> 	<span class="comment">//通用浏览器</span></span><br><span class="line">	xmlHttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> 	xmlHttp = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="XMLHttpRequest对象常用方法"><a href="#XMLHttpRequest对象常用方法" class="headerlink" title="XMLHttpRequest对象常用方法"></a>XMLHttpRequest对象常用方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>abort()</td>
<td>停止当前请求</td>
</tr>
<tr>
<td>getAllResponseHeaders()</td>
<td>将响应的响应头部分数据以键值对返回</td>
</tr>
<tr>
<td>getResponseHeader(“key”)</td>
<td>获取响应头中，键对应的值</td>
</tr>
<tr>
<td>open(“method”, “url”)</td>
<td>建立对服务器的调用。method参数可以是GET/POST/PUT 而url参数可以是相对URL或绝对URL。此外，该方法还包括3个可选参数，但较少使用到</td>
</tr>
<tr>
<td>send(content)</td>
<td>向服务器发送请求</td>
</tr>
<tr>
<td>setRequestHeader(“key”, “value”)</td>
<td>设置请求头，注意，在设置请求头之前必须先调用open方法</td>
</tr>
</tbody></table>
<p><strong>open(string method, string url, boolean asynch, string username, string password)</strong></p>
<blockquote>
<p>这个方法会建立对服务器的调用，是一个初始化一个请求的纯脚本方法。该方法有两个必要参数method及url，3个可选参数asynch/username/password。三个可选参数比较常用的是asynch参数，指示这个调用是异步的还是同步的，默认为true，表示请求本质上是异步的，如果设置为false，则请求将会是同步的，处理就会等待，直到从服务器返回响应为止。另外两个参数username和password，顾名思义就是指定一个特定的用户名和密码。</p>
</blockquote>
<p><strong>void send(content)</strong></p>
<blockquote>
<p>这个方法具体向服务器发出请求。如果请求声明是异步的，这个方法就会立即返回，否则它会等待直到接收到响应为止。参数content不是必要的，如果设置了，则会作为请求体的一部分发送。</p>
</blockquote>
<p><strong>void setRequestHeader(string key, string value)</strong></p>
<blockquote>
<p>这个方法用于在请求头中设定一个键值对，该方法必须在调用open方法之后才能调用</p>
</blockquote>
<p><strong>void abort()</strong></p>
<blockquote>
<p>这个方法用于终止请求</p>
</blockquote>
<p><strong>string getAllResponseHeaders()</strong></p>
<blockquote>
<p>这个方法将响应的响应头部分数据以键值对返回</p>
</blockquote>
<p><strong>string getResponseHeader(string key)</strong></p>
<blockquote>
<p>这个方法获取响应头中，键对应的值</p>
</blockquote>
<h4 id="XMLHttpRequest对象常用属性"><a href="#XMLHttpRequest对象常用属性" class="headerlink" title="XMLHttpRequest对象常用属性"></a>XMLHttpRequest对象常用属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>onreadystatechange</td>
<td>每个状态改变时都会触发这个事件处理器，通常会调用一个JavaScript函数</td>
</tr>
<tr>
<td>readySatate</td>
<td>请求的状态。有5个值可取：0=未初始化，还没有调用open方法；1=请求已建立，但是还没有发送，即还没有调用send方法；2=请求已发送，正在处理中，可以获取响应头；3=请求正在处理中，响应有部分数据可用，但是响应还未完成；4=响应已经完成</td>
</tr>
<tr>
<td>responseText</td>
<td>服务器的响应内容表示为一个字符串，常使用json对象</td>
</tr>
<tr>
<td>responseXML</td>
<td>服务器的响应内容表示为一个XML，可以解析为一个DOM对象</td>
</tr>
<tr>
<td>status</td>
<td>http状态码，如200，404</td>
</tr>
<tr>
<td>statusText</td>
<td>http状态码对应字符，如OK，Not Found</td>
</tr>
</tbody></table>
<h4 id="XMLHttpRequest对象使用示例"><a href="#XMLHttpRequest对象使用示例" class="headerlink" title="XMLHttpRequest对象使用示例"></a>XMLHttpRequest对象使用示例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 创建XMLHttpRequest对象</span></span><br><span class="line"><span class="keyword">var</span> xmlHttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line"> <span class="comment">//通用浏览器</span></span><br><span class="line"> xmlHttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> xmlHttp = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 调用open方法设置请求参数</span></span><br><span class="line">xmlHttp.open(<span class="string">&quot;method&quot;</span>, <span class="string">&quot;url&quot;</span>, <span class="literal">true</span>); <span class="comment">//true为异步，false为同步</span></span><br><span class="line"><span class="comment">//3. 在send方法前绑定onreadystatechange事件</span></span><br><span class="line">xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (xmlHttp.readyState == <span class="number">4</span> &amp;&amp; xmlHttp.status == <span class="number">200</span>) &#123;</span><br><span class="line">     <span class="comment">//成功响应</span></span><br><span class="line">     xmlHttp.responseText(); <span class="comment">//获取响应数据</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果请求为POST请求，还需要加上下面这行代码</span></span><br><span class="line"><span class="comment">//xmlHttp.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span></span><br><span class="line"><span class="comment">//4. 调用send发送请求</span></span><br><span class="line">xmlHttp.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面是底层代码，jQuery封装了该部分，简化了使用</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line"> <span class="attr">url</span>: <span class="string">&quot;请求地址&quot;</span>,</span><br><span class="line"> <span class="attr">data</span>: <span class="string">&quot;请求数据&quot;</span>,</span><br><span class="line"> <span class="attr">type</span>: <span class="string">&quot;GET OR POST&quot;</span>,</span><br><span class="line"> <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">     <span class="comment">//data为响应数据</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="attr">dataType</span>:<span class="string">&quot;text XML JSON 根据响应内容进行设置&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</blockquote>
]]></content>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Shiro简介</title>
    <url>/2020/09/24/Apache-Shiro%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>Apache Shiro（发音为<code>shee-roh</code>，日语堡垒（Castle）的意思）是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理功能，可为任何应用提供安全保障 - 从命令行应用、移动应用到大型网络及企业应用。相较于Spring Security来说较为简单，易于上手。</p>
<span id="more"></span>

<p>Apache Shiro有三个核心的概念Subject，SecurityManager和Realms，如下图所示：</p>
<p><img src="/images/shiro%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.png"></p>
<p><strong>1、</strong><a href="http://shiro.apache.org/static/1.3.2/apidocs/org/apache/shiro/subject/Subject.html">Subject</a>：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等，即一个抽象概念。所有Subject 都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager。可以把Subject认为是一个门面，SecurityManager才是实际的执行者。</p>
<p>在shiro中通过<code>org.apache.shiro.SecurityUtils</code>类来获取Subject对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line">...</span><br><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br></pre></td></tr></table></figure>

<p><strong>2、</strong><a href="http://shiro.apache.org/static/1.3.2/apidocs/org/apache/shiro/mgt/SecurityManager.html">SecurityManager</a>：安全管理器，即所有与安全有关的操作都会与SecurityManager交互，且它管理着所有Subject，可以看出它是Shiro的核心。它负责与后边介绍的其他组件进行 交互，类似于Spring MVC中的DispatcherServlet前端控制器。</p>
<p><strong>3、</strong><a href="http://shiro.apache.org/static/1.3.2/apidocs/org/apache/shiro/realm/Realm.html">Realm</a>：域，Shiro从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法。 也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作。</p>
<p>简而言之，创建一个基本的Shiro应用过程为：</p>
<ul>
<li>应用代码通过Subject来进行认证和授权，而Subject又委托给SecurityManager；</li>
<li>我们需要给Shiro的SecurityManager注入Realm，从而让SecurityManager能得到合法的用户及其权限进行判断。</li>
</ul>
<p><strong>注意：Shiro并没有为我们提供Realm的实现，需要我们手动编写实现。基本过程为继承<code>org.apache.shiro.realm.AuthorizingRealm</code>抽象类，实现doGetAuthorizationInfo和doGetAuthenticationInfo方法。</strong></p>
<h2 id="Shiro功能模块"><a href="#Shiro功能模块" class="headerlink" title="Shiro功能模块"></a>Shiro功能模块</h2><p><img src="/images/shiro%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97.png"></p>
<p>Shiro提供了四大基本安全功能：认证，授权，会话管理和加密。</p>
<ul>
<li>**身份验证(Authentication)**：也称为登录验证，即验证用户名和密码是否正确；</li>
<li>**授权(Authorization)**：根据用户的角色和权限来控制用户可访问的资源；</li>
<li>**会话管理(Session Management)**：即使在非Web或EJB应用程序中，也可以管理用户特定的SESSION会话；</li>
<li>**密码学(Cryptography)**：使用加密算法保证数据安全，同时易于使用。</li>
</ul>
<p>除此之外，Shiro也支持以下特性：</p>
<ul>
<li>**Web支持(Web Support)**：Shiro提供的web程序API可以帮助轻松保护Web应用程序；</li>
<li>**缓存(Caching)**：缓存可确保安全验证操作保持快速高效；</li>
<li>**并发性(Concurrency)**：Apache Shiro支持具有并发功能的多线程应用程序；</li>
<li>**测试(Testing)**：测试API帮助您编写单元测试和集成测试；</li>
<li>**运行方式(Run As)**：允许用户以别的用户身份（如果允许）登录；</li>
<li>**记住我(Remember Me)**：在会话中记住用户的身份，只有在强制登录时才需要登录。</li>
</ul>
]]></content>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>BigDecimal类的使用</title>
    <url>/2020/04/21/BigDecimal%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在编程中，一些浮点数无法精确表示，比如0.1，0.12在计算机中只能近似表示（浮点数计算过程在另一篇文章《计算机程序运行基本知识》）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2^-1 = 0.5</span><br><span class="line">2^-2 = 0.25</span><br><span class="line">2^-3 = 0.125</span><br><span class="line">2^-4 = 0.0625</span><br><span class="line">2^-5 = 0.03125</span><br><span class="line">2^-6 = 0.015625</span><br><span class="line">2^-7 = 0.0078125</span><br><span class="line">...</span><br><span class="line">浮点数由这些数组合而成，因此一些数无法精确表示，比如：</span><br><span class="line">0.1 约等于 0.9765625</span><br><span class="line">0.1 + 0.2  约等于  0.300000000000004</span><br><span class="line">0.3 - 0.2 约等于 0.09999999999998</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>如果我们需要精确的计算结果，比如在物理和金融中，普通的浮点数计算就无法满足我们的需求。Java提供的BigDecimal类，则支持任何精度的浮点数，可以用它来精确计算值。</p>
<p>BigDecimal类提供了4个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal(<span class="keyword">int</span>);   <span class="comment">//将int类型转为BigDecimal类型</span></span><br><span class="line">BigDecimal(<span class="keyword">double</span>);  <span class="comment">//将double类型转为BigDecimal类型</span></span><br><span class="line">BigDecimal(<span class="keyword">long</span>);  <span class="comment">//将long类型转为BigDecimal类型</span></span><br><span class="line">BigDecimal(String);  <span class="comment">//将String类型转为BigDecimal类型</span></span><br></pre></td></tr></table></figure>

<p>在实际使用过程，一般使用 <code>BigDecimal(String);</code> 构造方法。因为，将String类型转为BigDecimal的结果是可以预知的，其他构造方法不能得到精确表示浮点数，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.1&quot;</span>));  <span class="comment">//0.1</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> BigDecimal(<span class="number">0.1</span>));   <span class="comment">//0.100000000000055511151...</span></span><br></pre></td></tr></table></figure>

<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ol>
<li><p>加法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal add=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.1&quot;</span>).add(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.2&quot;</span>));</span><br><span class="line">System.out.println(add);  <span class="comment">//0.3</span></span><br><span class="line"><span class="comment">//保留两位有效数字</span></span><br><span class="line">BigDecimal add1=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.1&quot;</span>)</span><br><span class="line">        .add(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.22222222222&quot;</span>),<span class="keyword">new</span> MathContext(<span class="number">2</span>));</span><br><span class="line">System.out.println(add1); <span class="comment">//0.32</span></span><br></pre></td></tr></table></figure></li>
<li><p>减法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal sub=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.3&quot;</span>).subtract(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.1&quot;</span>));</span><br><span class="line">System.out.println(sub);   <span class="comment">//0.2</span></span><br><span class="line"><span class="comment">//保留两位有效数字</span></span><br><span class="line">BigDecimal sub=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.3&quot;</span>)</span><br><span class="line">        .subtract(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.111111111&quot;</span>),<span class="keyword">new</span> MathContext(<span class="number">2</span>));</span><br><span class="line">System.out.println(sub);   <span class="comment">//0.19</span></span><br></pre></td></tr></table></figure></li>
<li><p>乘法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal mul=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.1&quot;</span>).multiply(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.2&quot;</span>));</span><br><span class="line">System.out.println(mul); <span class="comment">//0.02</span></span><br><span class="line"><span class="comment">//保留两位有效数字</span></span><br><span class="line">BigDecimal mul1=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.1&quot;</span>)</span><br><span class="line">     .multiply(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.2222222222&quot;</span>),<span class="keyword">new</span> MathContext(<span class="number">2</span>));</span><br><span class="line">System.out.println(mul1); <span class="comment">//0.022</span></span><br></pre></td></tr></table></figure></li>
<li><p>除法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal div=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.2&quot;</span>).divide(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;3&quot;</span>));</span><br><span class="line">System.out.println(div);﻿ <span class="comment">//0.4</span></span><br><span class="line"><span class="comment">//保留两位有效数字</span></span><br><span class="line">BigDecimal div1=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        .divide(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;3&quot;</span>),<span class="keyword">new</span> MathContext(<span class="number">2</span>));</span><br><span class="line">System.out.println(div1);  <span class="comment">//0.33</span></span><br><span class="line"><span class="comment">//四舍五入，保留两位小数</span></span><br><span class="line">BigDecimal div2=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        .divide(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;3&quot;</span>), <span class="number">2</span>, RoundingMode.HALF_UP);</span><br><span class="line">System.out.println(div2);  <span class="comment">//0.67</span></span><br></pre></td></tr></table></figure></li>
<li><p>比较大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小于，返回-1</span></span><br><span class="line"><span class="keyword">int</span> result=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.1&quot;</span>).compareTo(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.2&quot;</span>));</span><br><span class="line">System.out.println(result);   <span class="comment">//-1 </span></span><br><span class="line"><span class="comment">//等于，返回 0</span></span><br><span class="line"><span class="keyword">int</span> result=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.2&quot;</span>).compareTo(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.2&quot;</span>));</span><br><span class="line">System.out.println(result); <span class="comment">//0</span></span><br><span class="line"><span class="comment">//大于，返回 1</span></span><br><span class="line"><span class="keyword">int</span> result=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.3&quot;</span>).compareTo(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.2&quot;</span>));</span><br><span class="line">System.out.println(result);  <span class="comment">//1</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>BigDecimal</tag>
      </tags>
  </entry>
  <entry>
    <title>ClassLoader类加载器及加载机制</title>
    <url>/2020/02/03/ClassLoader%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<p>类加载器负责将Class加载到JVM中。并且对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。这意味着，比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类也必然不相等。比如下面的测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">                    InputStream inputStream = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[inputStream.available()];</span><br><span class="line">                    inputStream.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Object obj = myLoader.loadClass(<span class="string">&quot;com.doug.wilson.classloading.TestClassLoader&quot;</span>).newInstance();</span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> com.doug.wilson.classloading.TestClassLoader);</span><br><span class="line">        <span class="comment">//结果为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="ClassLoader类结构"><a href="#ClassLoader类结构" class="headerlink" title="ClassLoader类结构"></a>ClassLoader类结构</h2><blockquote>
<p>类结构主要有以下方法：</p>
<ol>
<li><p><code>Class&lt;?&gt; defineClass(byte[], int, int)</code></p>
<p>defineClass方法将字节流解析成JVM能够识别的Class对象。有了这个方法，意味着我们不仅可以通过class文件实例化对象，还可以通过其它方式，如网络传输字节文件生成Class类来实例化对象。</p>
</li>
<li><p><code>Class&lt;?&gt; findClass(String)</code></p>
<p>findClass方法通常和defineClass方法一起使用，可以通过覆盖ClassLoader的findClass方法来实现类的加载规则，从而取得要加载类的字节码，然后调用defineClass方法生成类的Class对象。注意，这时候的类对象还没有被链接，如果你想在类被加载到JVM中就被链接，那么可以调用resolveClass方法。</p>
</li>
<li><p><code>Class&lt;?&gt; loadClass(String)</code></p>
<p>load方法可以在运行时加载自己指定的一个类，通过this.getClass().getClassLoader().loadClass(“class”)需要注意的是，经过loadClass方法加载的类还没有进行链接过程(验证、准备、解析)，你可以决定在什么时候实现其其链接过程。</p>
</li>
<li><p><code>void resolveClass(Class&lt;?&gt;)</code> 完成Class类对象的链接过程</p>
</li>
</ol>
</blockquote>
<h2 id="类加载器的底层实现原理"><a href="#类加载器的底层实现原理" class="headerlink" title="类加载器的底层实现原理"></a>类加载器的底层实现原理</h2><blockquote>
<p>在介绍类加载器的加载机制前，先介绍类加载器的类别。从JVM虚拟机的角度，类加载器可以分为两类：默认类加载器和其它类加载器。启动类加载器是虚拟机的一部分。而其它类加载器则是由Java语言编写，独立于虚拟机，继承于抽象类ClassLoader。</p>
<p>默认类加载器分为以下三种：</p>
<ol>
<li>启动类加载器，BootstrapClassLoader。该类加载器负责将<strong>lib</strong>目录下或者**-Xbootclasspath**参数指定路径中的类，加载到虚拟机中</li>
<li>扩展类加载器，ExtClassLoder。该加载器负责加载lib\ext目录或者java.ext.dirs系统遍历所指定路径中的所有类</li>
<li>应用程序类加载器，AppClassLoader。该类加载器负责加载用户类路径上所指定的类。</li>
</ol>
<p>通常而言，如果我们要实现自己的类加载器，不管是直接实现抽象类ClassLoader还是继承URLClassLoader类，或者其它子类，它的父类加载器都是AppClassLoader。理由是：不管自定义的类加载器调用哪个父类构造器，创建的对象都必须最终调用getSystemClassLoader()作为父类加载器。而getSystemClassLoader()方法获取到的正是AppClassLoader扩展类加载器。</p>
<p>关系如下：</p>
<p><img src="/images/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png"></p>
<p>BootstrapClassLoader类加载器并不属于JVM的类等级层次，因为BootstrapClassLoader没有遵守ClassLoader的加载规则，既没有父类也没有子类。</p>
<p>ExtClassLoader的父类加载器不是BootstrapClassLoader，也没有父类加载器。它是我们能够访问到的顶层父类加载器。</p>
<p>AppClassLoader和ExtClassLoader的关系可用下面的一张图表示：</p>
<p><img src="/images/App%E5%92%8CExt%E5%85%B3%E7%B3%BB.png"></p>
<p>看起来，ExtClassLoader和AppClassLoader是平级关系，但是不然。ExtClassLoader和AppClassLoader都继承了URLClassLoader类，而URLClassLoader又实现了抽象类ClassLoader，在创建Launcher对象时，首先会创建ExtClassLoader，然后将ExtClassLoader对象作为父类加载器创建AppClassLoader对象，而通过Launcher.getClassLoader()方法获取到的ClassLoader就是AppClassLoader对象。所有，如果Java应用没有自定义类加载器，那么除了ExtClassLoader加载的内容外，其它的类都是由AppClassLoader进行加载。</p>
<blockquote>
<p>通过上述的描述，现在可以对类加载器的加载机制(或者说类加载器的底层实现原理)进行一个解释：</p>
<p>类加载器采用双亲委派模型(Ext和App)定义层次关系。除了ExtClassLoade扩展类加载器外，其余的类加载器都应当有自己的父类加载器。并且，这些类加载器之间的父子关系不会用过继承的关系实现，而是使用组合来复用父类加载器的代码(这点可以通过ExtClassLoader和AppClassLoader的关系可以看出)。</p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是将这个请求委派给父类加载器去完成，只有当父类加载器不存在或者父类加载器反馈自己无法完成类加载请求时，子类加载器才会尝试自己去加载类，以此类推。</p>
<p>使用双亲委派模型来组织类加载器间的关系，有一个显而易见的好处，就是Java类和它的类加载器一起具备了一种带有优先级的层次关系。比如Object类，无论哪一个类加载器加载这个类，最终都会委派给模型最顶层的类加载器进行实现，也就意味着Object类在程序的各种类加载环境中都是同一个类，即由类加载器和类本身共同确立了唯一性。</p>
<p>双亲委派的实现在ClassLoader抽象类的loadClass方法中。首先会检查类是否已经被加载过，如果没有，则调用父加载器的loadClass()方法。如果父类加载器不存在，或者父类加载器加载失败，抛出ClassNotFoundException异常，则再调用自己的findClass()方法进行加载。需要注意的是，经过上述步骤加载完成的类还没有进行链接过程，如果要对类进行链接，则需要再调用resolveClass()方法。大体过程由如下代码进行表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">//首先检查请求加载的类是否被加载过，如果c为null说明没有被加载过</span></span><br><span class="line">        <span class="comment">//如果加载过了，则什么都不做，结束方法</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果父类加载器存在，则先由父类加载器尝试加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>); <span class="comment">//false表示不进行链接</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果父类加载器不存在，则尝试由BootstrapClassLoader尝试加载</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                <span class="comment">//如果抛出该异常，说明父类加载器或启动类加载器无法完成类加载请求</span></span><br><span class="line">                <span class="comment">//则需要由当前类加载器进行类的加载</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                c = findClass(name); <span class="comment">//加载</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果resolve为true，则加载的类还要进行链接过程，为false则不进行链接过程</span></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h2 id="类加载器的类加载机制"><a href="#类加载器的类加载机制" class="headerlink" title="类加载器的类加载机制"></a>类加载器的类加载机制</h2><blockquote>
<p>虚拟机把描述的类数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的Java类型。在Java中，类的加载，链接和初始化，都是在程序运行期间完成的。虽然这种策略会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性。</p>
<p>类从被加载到虚拟机内存，到卸载出内存，整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载。其中验证、准备、解析部分统称为链接。</p>
<p>相对于类加载过程的其他阶段，一个非数组类的加载阶段(获取类的二进制流)是开发人员最可控的。因为加载阶段可以使用系统提供的类加载器来完成，也可以通过用户自定义的类加载器完成。开发人员可以通过自定义的类加载器去控制字节流的获取方式。这使得类加载阶段有一个广阔的舞台：网络获取、运行时实时生成。这也是类加载器近些年得到快速发展的原因。</p>
<p>前面这段话有一个前提，就是**”非数组类的加载”**。为什么要强调这一点？因为数组类不由类加载器创建，而是直接由虚拟机创建。但是数组类依然和类加载器有很密切的关系，因为数组的元素类型最终需要依靠类加载器加载。</p>
<h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><h5 id="加载："><a href="#加载：" class="headerlink" title="加载："></a>加载：</h5><p>加载什么时候开始？</p>
<blockquote>
<p>new一个实例对象、读取或设置一个类的静态属性、调用一个静态方法、使用反射获取类的信息、初始化一个类时，其父类也会被自动加载等等。</p>
</blockquote>
<p>加载会做些什么?</p>
<blockquote>
<ol>
<li>通过一个类的全限定名来获取类的二进制字节流</li>
<li>将二进制字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在方法区中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
</blockquote>
<h5 id="验证："><a href="#验证：" class="headerlink" title="验证："></a>验证：</h5><blockquote>
<p>验证阶段，主要确保class文件的字节码信息符合虚拟机要求，不会危害虚拟机安全。主要有以下四个阶段的验证过程：</p>
<ol>
<li>文件格式验证。验证字节流是否符合class文件规范，能否被当前版本虚拟机加载。</li>
<li>元数据验证。对字节码描述进行语义分析，确保字节码信息符合Java语言规范的要求，比如是否继承并实现了父类接口的全部方法。</li>
<li>字节码验证。通过数据流和控制流分析，确定语法和语义是合法的、符合逻辑的。</li>
<li>符号引用验证。验证能否通过符号引用找到对应的类，该类中的字段方法能否通过符号引用进行访问。</li>
</ol>
</blockquote>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><blockquote>
<p>准备阶段是正式为类变量（被static修饰的变量）分配内存并设置类变量初始值的阶段。这些变量所使用的内存都将在方法区中进行分配。而实例变量的初始化将随对象一起分配在堆内存中。</p>
<p>比如 <code>public static int value = 123;</code></p>
<p>在准备阶段过后，初始值为value = 0而不是value = 123 ，将value赋值为123的动作在初始化阶段才会完成。但是存在一种特殊情况，即当变量为常量时，在准备阶段就会进行赋值：</p>
<p><code>public static final int value = 123;</code>在准备阶段就会将value赋值为123</p>
<p><strong>该阶段还会有静态块的执行</strong></p>
</blockquote>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><blockquote>
<p>解析阶段是将常量池中的符号引用替换为直接引用的过程。</p>
</blockquote>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>初始化是类加载过程的最后一步。</p>
<p>初始化阶段，根据程序开发人员制订的主观计划，初始化类变量和其他资源。并且，编译器还会自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生&lt;clint&gt;()方法，编译器收集的顺序为语句在源码文件中出现的顺序(静态语句出现在非静态语句前等)。并且编译器会保证父类的&lt;clint&gt;()放在子类的&lt;clint&gt;()方法之前。</p>
</blockquote>
]]></content>
      <tags>
        <tag>classLoader, 类加载器, 加载机制</tag>
      </tags>
  </entry>
  <entry>
    <title>CopyOnWriteArrayList源码解析</title>
    <url>/2020/09/16/CopyOnWriteArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>CopyOnWriteArrayList为线程安全的ArrayList，本文分析下CopyOnWriteArrayList的源码，基于JDK1.8</p>
<span id="more"></span>

<h2 id="类结构关系"><a href="#类结构关系" class="headerlink" title="类结构关系"></a>类结构关系</h2><p>CopyOnWriteArrayList类关系图：</p>
<p><img src="/images/CopyOnWriteArrayList%E7%B1%BB%E5%85%B3%E7%B3%BB.png"></p>
<p>CopyOnWriteArrayList实现了List接口的所有方法，主要包含如下两个成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可重入锁，用于对写操作加锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object类型数组，存放数据，volatile修饰，目的是一个线程对这个字段的修改另外一个线程立即可见</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure>

<p>CopyOnWriteArrayList中并没有和容量有关的属性或者常量，下面通过对一些常用方法的源码解析，就可以知道原因</p>
<h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><code>CopyOnWriteArrayList()</code>空参构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无参构造函数直接创建了一个长度为0的Object数组。</p>
<p><code>CopyOnWriteArrayList(Collection&lt;? extends E&gt; c)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList.class)</span><br><span class="line">        <span class="comment">// 如果集合类型就是CopyOnWriteArrayList，则直接将其array赋值给当前CopyOnWriteArrayList</span></span><br><span class="line">        elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不是CopyOnWriteArrayList类型，则将集合转换为数组</span></span><br><span class="line">        elements = c.toArray();</span><br><span class="line">        <span class="comment">// 就如ArrayList源码分析所述那样，c.toArray()返回类型不一定是Object[].class，所以需要转换</span></span><br><span class="line">        <span class="keyword">if</span> (elements.getClass() != Object[].class)</span><br><span class="line">            elements = Arrays.copyOf(elements, elements.length, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置array值</span></span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CopyOnWriteArrayList(E[] toCopyIn)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 入参为数组，拷贝一份赋值给array</span></span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h3><p><code>add(E e)</code>往CopyOnWriteArrayList末尾添加元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 上锁，同一时间内只能有一个线程进入</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前array属性值</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 获取当前array数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 复制一份新数组，新数组长度为当前array数组长度+1</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 在新数组末尾添加元素</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 新数组赋值给array属性</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 锁释放</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，add操作通过ReentrantLock来确保线程安全。通过add方法，我们也可以看出CopyOnWriteArrayList修改操作的基本思想为：复制一份新的数组，新数组长度刚好能够容纳下需要添加的元素；在新数组里进行操作；最后将新数组赋值给array属性，替换旧数组。这种思想也称为“写时复制”，所以称为CopyOnWriteArrayList</p>
<h3 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h3><p><code>add(int index, E element)</code>指定下标添加指定元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 上锁，同一时间内只能有一个线程进入</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前array属性值</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">         <span class="comment">// 获取当前array数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 下标检查</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index+</span><br><span class="line">                                                <span class="string">&quot;, Size: &quot;</span>+len);</span><br><span class="line">        Object[] newElements;</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// numMoved为0，说明是在末尾添加，过程和add(E e)方法一致</span></span><br><span class="line">            newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则创建一个新数组，数组长度为旧数组长度值+1</span></span><br><span class="line">            newElements = <span class="keyword">new</span> Object[len + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 分两次复制，分别将index之前和index+1之后的元素复制到新数组中</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index, newElements, index + <span class="number">1</span>,</span><br><span class="line">                             numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在新数组的index位置添加指定元素</span></span><br><span class="line">        newElements[index] = element;</span><br><span class="line">        <span class="comment">// 新数组赋值给array属性，替换旧数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 锁释放</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set-int-index-E-element"><a href="#set-int-index-E-element" class="headerlink" title="set(int index, E element)"></a>set(int index, E element)</h3><p><code>set(int index, E element)</code>设置指定位置的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 上锁，同一时间内只能有一个线程进入</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// 获取当前array属性值</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 获取当前array指定index下标值</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">        	<span class="comment">// 如果新值和旧值不相等</span></span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            <span class="comment">// 复制一份新数组，长度和旧数组一致</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            <span class="comment">// 修改新数组index下标值</span></span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            <span class="comment">// 新数组赋值给array属性，替换旧数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 即使新值和旧值一致，为了确保volatile语义，需要重新设置array</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    	<span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h3><p><code>remove(int index)</code>删除指定下标元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 上锁，同一时间内只能有一个线程进入</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// 获取当前array属性值</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 获取当前array长度</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 获取旧值</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">        	<span class="comment">// 如果删除的是最后一个元素，则将当前array设置为新数组</span></span><br><span class="line">        	<span class="comment">// 新数组长度为旧数组长度-1，这样刚好截去了最后一个元素</span></span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// 分段复制，将index前的元素和index+1后的元素复制到新数组</span></span><br><span class="line">        	<span class="comment">// 新数组长度为旧数组长度-1</span></span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            <span class="comment">// 设置array</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    	<span class="comment">// 锁释放</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，CopyOnWriteArrayList中的增删改操作都是在新数组中进行的，并且通过加锁的方式确保同一时刻只能有一个线程进行操作，操作完后赋值给array属性，替换旧数组，旧数组失去了引用，最终由GC回收</p>
<h3 id="get-int-index"><a href="#get-int-index" class="headerlink" title="get(int index)"></a>get(int index)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>get(int index)</code>操作是分两步进行的：</p>
<ol>
<li>通过<code>getArray()</code>获取array属性值；</li>
<li>获取array数组index下标值。</li>
</ol>
<p>这个过程并没有加锁，所以在并发环境下可能出现如下情况：</p>
<ol>
<li>线程1调用<code>get(int index)</code>方法获取值，内部通过<code>getArray()</code>方法获取到了array属性值；</li>
<li>线程2调用CopyOnWriteArrayList的增删改方法，内部通过<code>setArray</code>方法修改了array属性的值；</li>
<li>线程1还是从旧的array数组中取值。</li>
</ol>
<p><strong>所以<code>get</code>方法是弱一致性的</strong>。</p>
<h3 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getArray().length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>size()</code>方法返回当前array属性长度，因为CopyOnWriteArrayList中的array数组每次复制都刚好能够容纳下所有元素，并不像ArrayList那样会预留一定的空间。所以CopyOnWriteArrayList中并没有size属性，元素的个数和数组的长度是相等的</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** Snapshot of the array */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">    <span class="comment">/** Index of element to be returned by subsequent call to next.  */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，迭代器也是弱一致性的，并没有在锁中进行。如果其他线程没有对CopyOnWriteArrayList进行增删改的操作，那么snapshot还是创建迭代器时获取的array，但是如果其他线程对CopyOnWriteArrayList进行了增删改的操作，旧的数组会被新的数组给替换掉，但是snapshot还是原来旧的数组的引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>CopyOnWriteArrayList体现了写时复制的思想，增删改操作都是在复制的新数组中进行的；</li>
<li>CopyOnWriteArrayList的取值方法是弱一致性的，无法确保实时取到最新的数据；</li>
<li>CopyOnWriteArrayList的增删改方法通过可重入锁确保线程安全；</li>
<li>CopyOnWriteArrayList线程安全体现在多线程增删改不会抛出<code>java.util.ConcurrentModificationException</code>异常，并不能确保数据的强一致性；</li>
<li>同一时刻只能有一个线程对CopyOnWriteArrayList进行增删改操作，而读操作没有限制，并且 CopyOnWriteArrayList增删改操作都需要复制一份新数组，增加了内存消耗，所以CopyOnWriteArrayList适合读多写少的情况。</li>
</ol>
]]></content>
      <tags>
        <tag>CopyOnWriteArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>CopyOnWriteArraySet源码解析</title>
    <url>/2020/09/16/CopyOnWriteArraySet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>CopyOnWriteArraySet为线程安全的Set实现，本文记录CopyOnWriteArraySet源码解析，基于JDK1.8</p>
<span id="more"></span>

<h2 id="类结构关系"><a href="#类结构关系" class="headerlink" title="类结构关系"></a>类结构关系</h2><p>CopyOnWriteArraySet的类层级关系图：</p>
<p><img src="/images/CopyOnWriteArraySet%E7%9A%84%E7%B1%BB%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.png"></p>
<p>内部属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 就一个属性，CopyOnWriteArraySet内部采用CopyOnWriteArrayList存储元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br></pre></td></tr></table></figure>

<p>和HashSet不一样的是，CopyOnWriteArraySet内部采用CopyOnWriteArrayList存储元素，这也是CopyOnWriteArraySet名字的由来，因为CopyOnWriteArrayList是线程安全的，CopyOnWriteArraySet的方法都是基于CopyOnWriteArrayList实现的，所以CopyOnWriteArraySet自然而然也是线程安全的，同样的，在并发环境下获取数据是弱一致性的！</p>
<h3 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空参构造函数，实际就是初始化CopyOnWriteArrayList</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入集合对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 分两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArraySet.class) &#123;</span><br><span class="line">    	<span class="comment">// 如果集合就是CopyOnWriteArraySet类型，说明数据是不重复的</span></span><br><span class="line">    	<span class="comment">// 直接全部添加到CopyOnWriteArrayList中</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> CopyOnWriteArraySet&lt;E&gt; cc =</span><br><span class="line">            (CopyOnWriteArraySet&lt;E&gt;)c;</span><br><span class="line">        al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;(cc.al);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 否则调用addAllAbsent添加所有当前集合中不存在的元素，确保数据的唯一性</span></span><br><span class="line">        al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">        al.addAllAbsent(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h4><p><code>add(E e)</code>添加指定元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 实际调用CopyOnWriteArrayList的addIfAbsent方法</span></span><br><span class="line">	<span class="comment">// 元素不存在，则添加，返回true；元素存在，则不添加，返回false</span></span><br><span class="line">    <span class="keyword">return</span> al.addIfAbsent(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CopyOnWriteArraySet的add方法通过调用CopyOnWriteArrayList的addIfAbsent来确保元素不重复，以满足Set的特性</p>
]]></content>
      <tags>
        <tag>CopyOnWriteArraySet</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS域名解析过程</title>
    <url>/2020/02/10/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>我们通过URL来发布和请求资源，而URL中的域名则主要由IP地址和端口号组成，只有知道IP地址才能对IP地址的服务器进行访问。如何解析出域名中的IP地址，需要借助DNS(Domain Name System)系统。</p>
<span id="more"></span>

<h2 id="DNS解析过程如下"><a href="#DNS解析过程如下" class="headerlink" title="DNS解析过程如下"></a>DNS解析过程如下</h2><p>当用户在浏览器地址栏输入URL回车后，会有如下解析过程：</p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><blockquote>
<p>浏览器检查缓存中是否存在域名已经解析完成的IP地址，有，则解析过程结束。</p>
<p>对于浏览器缓存这里要多说一句，浏览器缓存域名存在缓存时间限制，通常这个时间为几分钟到几小时不等。缓存时间太长或太短都不好，太长的话，当IP地址变化，用户在缓存时间内都无法对域名所在的服务器访问，太短，则用户每次访问网站都要重新解析一次域名。</p>
</blockquote>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><blockquote>
<p>如果浏览器缓存中没有域名对应解析完成的IP地址，则会到操作系统缓存中查找域名对应的DNS解析结果。操作系统也会有一个域名解析过程，在windows操作系统中，解析后的结果会放在：<code>C:/Windows/System32/drivers/etc/hosts</code>文件中，在Linux操作系统中，解析的结果则放在：<code>/etc/hosts</code>中。比如对于经常挂的GitHub，就可以将其IP地址及对应域名放入到hosts文件中，才能较快速地访问网站。</p>
<p>不过这种本地解析也是有风险的，黑客可以通过修改你的本地域名解析来将特定的域名解析到它指定的IP地址上，导致这些域名被劫持。所以，这也是为什么host文件设置成只读的，防止这个文件被轻易地修改。</p>
</blockquote>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><blockquote>
<p>当浏览器缓存和操作系统缓存中均没有域名对应的解析结果，则会真正请求域名服务器解析域名。</p>
<p>每个计算机都会有一个网络配置，网络配置中会有“DNS服务器地址”这一项。当前两步均无法完成域名的解析时，操作系统就会将域名发送给LDNS——本地区的域名服务器。比如，你在学校，那么这个本地区域名服务器就在学校中，如果在小区，则这个本地区域名服务器为接入互联网的网络供应商，大约80%的域名解析到这里就已经解析完成，也就是说LDNS主要承担了域名的解析工作。</p>
</blockquote>
<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><blockquote>
<p>如果LDNS仍然没有名中，则会到Root Server域名服务器请求解析</p>
</blockquote>
<h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><blockquote>
<p>第四步根域名服务器会返回给本地域名服务器LDNS一个所查询域的主域名服务器(gTLD Server)地址。主域名服务器gTLD大概有13台，比如 .<code>com</code>   <code>.cn</code>   <code>.org</code>等</p>
</blockquote>
<h3 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h3><blockquote>
<p>本地域名服务器LDNS向主域名服务器gTLD发送请求</p>
</blockquote>
<h3 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h3><blockquote>
<p>接收请求的gTLD主域名服务器查找域名对应的**Name Server域名服务器地址(即域名注册时的域名服务器，如果你是在某个域名服务提供商申请的域名，则该域名解析任务由该域名服务提供商完成)**。</p>
</blockquote>
<h3 id="第八步"><a href="#第八步" class="headerlink" title="第八步"></a>第八步</h3><blockquote>
<p>本地域名服务器LDNS会向gTLD主域名服务器返回的Name Server域名服务器地址发送域名解析请求。对应的Name Server域名服务器会查询存储的域名和IP的映射关系表，将查找到的目标IP连同一个**TTL(Time To Live)**值返回给LDNS本地域名服务器。</p>
</blockquote>
<h3 id="第九步"><a href="#第九步" class="headerlink" title="第九步"></a>第九步</h3><blockquote>
<p>LDNS将得到的IP地址和TTL值返回给用户主机，并缓存这个域名和IP的对应关系，缓存的时间由TTL控制。</p>
</blockquote>
<h3 id="第十步"><a href="#第十步" class="headerlink" title="第十步"></a>第十步</h3><blockquote>
<p>用户主机将IP和域名的对应关系进行缓存，缓存的时间也由TTL控制。到这里，域名解析结束，用户可以对域名对应的服务器进行访问。</p>
<p><img src="/images/DNS%E8%A7%A3%E6%9E%90%E8%AF%B7%E6%B1%82.png"></p>
</blockquote>
<h4 id="以下内容来自《Java-Web技术内幕》"><a href="#以下内容来自《Java-Web技术内幕》" class="headerlink" title="以下内容来自《Java Web技术内幕》"></a>以下内容来自《Java Web技术内幕》</h4><blockquote>
<p>在Java应用中JVM也会缓存DNS的解析结果，这个缓存是在InetAddress类中完成的，而且这个缓存时间比较特殊，它有两种缓存策略：一种是正确解析结果缓存，另一种为失败的解析结果缓存。这两个缓存时间由两个配置项控制，配置项是在%JAVA_HOME%\lib\security\java.security文件中进行配置。两个配置项分别是<strong>networkaddress.cache.ttl</strong>和<strong>networkaddress.cache.negative.ttl</strong>，默认值为-1(永不失效)和10(缓存10秒)。</p>
<p>要修改这两个值有几种方式：</p>
<ul>
<li>直接修改java.security文件中的默认值</li>
<li>在Java的启动参数中增加 <code>-Dsun.net.inetaddr.ttl=xxx</code></li>
<li>通过InetAddress类动态修改</li>
</ul>
<p>另外，如果我们需要用InetAddress类解析域名，必须是单例模式，不然会有严重性能问题，如果每次都创建InetAddress实例，则每次都要进行一次完整的域名解析，非常耗时，这点要特别注意。</p>
</blockquote>
]]></content>
      <tags>
        <tag>DNS, 域名</tag>
      </tags>
  </entry>
  <entry>
    <title>Git工作原理探究</title>
    <url>/2020/04/15/Git%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="Git存储文件过程及分支工作原理"><a href="#Git存储文件过程及分支工作原理" class="headerlink" title="Git存储文件过程及分支工作原理"></a>Git存储文件过程及分支工作原理</h2><p>在Git中提交时，会保存一个提交对象，它包含一个指向暂存内容快照的指针，作者和相关附属信息，以及一定数量（也可能没有）指向该提交对象直接祖先的指针。</p>
<p>当执行 <code>git add</code>暂存操作时。暂存操作会对每一个文件计算校验和（SHA-1哈希字符串），然后将当前版本的文件快照保存到Git仓库中（Git使用blob类型对象存储这些快照），并将校验和加入暂存区域。</p>
<span id="more"></span>

<p>当执行 <code>git commit</code>提交操作时，Git会先计算每一个子目录的校验和，然后在Git仓库中将这些目录保存为树对象，之后Git创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此就可以在将来需要的时候，重现此快照的内容。</p>
<p>因此，在Git仓库中，除了文件快照内容的blob对象，还会有2个对象：一个记录目录树内容及其各个文件对应blob对象索引的tree对象。以及一个包含指向tree对象（根目录）的索引和其他提交信息元数据的commit对象。如下图所示：</p>
<p><img src="/images/Git%E4%BB%93%E5%BA%93blob%E5%AF%B9%E8%B1%A1.png"></p>
<p>做些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针。两次提交后，上面的图就会变成下面的样子：</p>
<p><img src="/images/Git%E4%BF%AE%E6%94%B9%E6%8F%90%E4%BA%A4%E5%90%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%8F%98%E5%8A%A8.png"></p>
<p>而分支，实质上仅仅是个指向commit对象的可变指针。比如默认分支master，在提交若干次后，它在每次提交的时候都会向前移动，指向最新提交的commit对象。</p>
<p><img src="/images/%E5%88%86%E6%94%AFmaster%E7%A7%BB%E5%8A%A8.png"></p>
<p>当创建一个分支时，就会在当前分支上创建一个新的分支指针。比如创建一个dev1分支：</p>
<p><img src="/images/dev1%E5%88%86%E6%94%AF.png"></p>
<p>切换分支，则是将HEAD指针在分支指针间切换。比如从master分支切换到dev1分支：</p>
<p><img src="/images/%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AFmaster.png"></p>
<p><img src="/images/%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AFdev1.png"></p>
<p>在dev1分支提交修改时：</p>
<p><img src="/images/%E5%9C%A8dev1%E5%88%86%E6%94%AF%E4%B8%8A%E6%8F%90%E4%BA%A4%E4%BF%AE%E6%94%B9.png"></p>
<p>切换回master分支：</p>
<p><img src="/images/%E4%BB%8Edev1%E5%88%86%E6%94%AF%E5%88%87%E6%8D%A2%E5%9B%9Emaster%E5%88%86%E6%94%AF.png"></p>
<p>在master分支上提交修改：</p>
<p><img src="/images/%E5%9C%A8master%E5%88%86%E6%94%AF%E4%B8%8A%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0.png"></p>
<p>Git中的分支实际上是一个仅包含所指对象校验和（40个字符串长度的SHA-1字符串）的文件，所以创建和销毁一个分支十分廉价。简而言之就是，新建分支就是向一个文件写入41个字节（SHA-1字符串加一个换行符）。</p>
<p>这和大多数版本控制系统形成了鲜明的对比，它们管理分支大多数采用备份所有项目文件到特定目录的方式，所以根据项目文件数量和大小不同，花费的时间差别也相当大，快的几秒，慢的就要几分钟。而Git的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。同时，因为每次提交时都记录了parent对象信息，所以当合并分支时，也相当便捷。</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git指令</title>
    <url>/2020/04/13/Git%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>版本控制系统用于记录若干文件的内容变化，通过命令将文件或整个项目改变到某给版本。为了更好学习Git，这里先区分版本控制系统类别：</p>
<ul>
<li><em>本地版本控制系统</em>。采用某种简单的数据库来记录文件的历次更新差异。最流行的是RCS，基本工作原理为保存并管理文件补丁patch。文件补丁是一种特定格式的文本文件，记录对应文件修订前后的内容变化，根据每次修订后的补丁，计算出各个版本的文件内容。</li>
<li><em>集中化的版本控制系统</em>。通过一个单一的集中管理的服务器，保存所有文件的修订版本，协同工作的人们通过客户端连接到服务器，取出最新的文件或者提交更新。当中央服务器故障时，其它主机就无法进行提交和更新，甚至中央服务器还可能出现数据丢失的情况。</li>
<li><em>分布式版本控制系统</em>。在集中化的版本控制系统基础上，客户端每一次取文件都会把原始的代码仓库完整地镜像下来，这样，当服务器出现故障时，可以通过任何一个镜像出来的文件进行恢复。</li>
</ul>
<span id="more"></span>

<h2 id="Git和其它版本控制系统的差异"><a href="#Git和其它版本控制系统的差异" class="headerlink" title="Git和其它版本控制系统的差异"></a>Git和其它版本控制系统的差异</h2><p>Git属于分布式版本控制系统，和其它版本控制系统的主要差别在于，Git只关心文件数据的整体发生变化，而大多数其它系统则关心文件内容的具体差异，比如，每次记录有哪些文件更新，更新了什么内容。Git则是每次提交更新时，浏览一遍所有文件的指纹信息，并对文件作一快照，然后保存一个指向这次快照的索引，如果文件没有变化，Git只对上次保存的快照作一连接。（其它版本控制系统需要记录具体文件差异，Git则是对文件快照保存一个索引，文件不变，索引不变，文件改变，索引指向新的文件快照）</p>
<p><img src="/images/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B7%AE%E5%BC%82.png"></p>
<p><img src="/images/Git%E6%96%87%E4%BB%B6%E5%BF%AB%E7%85%A7.png"></p>
<p>此外，Git中的绝大部分操作都只需要访问本地文件和资源，不用联网。在本地磁盘上就保存着当前项目的历史更新，当想提交更新时，都可以进行愉快地提交更新，等到有网络时在上传到远程的镜像仓库。</p>
<h3 id="Git时刻保持数据完整性"><a href="#Git时刻保持数据完整性" class="headerlink" title="Git时刻保持数据完整性"></a>Git时刻保持数据完整性</h3><p>Git采用SHA-1算法计算数据的校验和，通过对文件的内容或目录结构计算出一个SHA-1哈希值作为指纹字符串，该指纹字符串由40个十六进制字符组成。</p>
<p>文件在保存到Git前，所有数据都要进行内容的校验和计算，并将此结构作为数据的唯一标识符和索引。换句话说，不可能你在修改文件和目录时，Git一无所知。因此，当文件在传输时变得不完整或者磁盘损坏导致文件数据缺失，Git都能立即检查到。</p>
<h3 id="Git的三种状态"><a href="#Git的三种状态" class="headerlink" title="Git的三种状态"></a>Git的三种状态</h3><ul>
<li>已提交 committed  已提交表示该文件已经被安全地保存在本地数据库中</li>
<li>已修改 modified 已修改表示修改了某个文件，但是还没有提交保存</li>
<li>已暂存 staged 已暂存表示把已修改的文件放在下次提交时要保存的清单中</li>
</ul>
<p>也因为Git三种状态的存在，Git管理项目时，文件会流转3个区域：Git的本地数据目录，工作目录，暂存区域</p>
<ul>
<li>本地数据目录。每一个项目都有一个git目录，是Git用于保存元数据和对象数据库的地方，每次克隆镜像仓库的时候，实际拷贝的就是该目录中的数据</li>
<li>工作目录。从项目取出某个版本的所有文件和目录，用于开始后续工作</li>
<li>暂存区。一个文件，存放在git目录中</li>
</ul>
<p>工作流程：在工作目录修改某些文件——&gt;对修改的文件作快照，并保存到暂存区中——&gt;提交更新，将保存在暂存区的文件快照转储到git目录中</p>
<h3 id="Git暂存区"><a href="#Git暂存区" class="headerlink" title="Git暂存区"></a>Git暂存区</h3><p>以自己的Git仓库地址为例：</p>
<p><img src="/images/git%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E7%9B%AE%E5%BD%95.png"></p>
<p>仓库地址：<code>F:/GitTool/repository/.git/</code></p>
<p>工作区：<code>repository目录</code>，可见的</p>
<p>版本库：<code>.git目录</code>，不可见的，隐藏的，称为Git的版本库</p>
<p>暂存区：<code>index文件</code></p>
<p>初始化Git仓库时，Git会为我们自动创建第一个分支master以及指向master的一个指针HEAD</p>
<p>当将一个文件提交到Git仓库时，会分成两步执行：</p>
<ol>
<li>$ git add 路径+文件名   将文件修改添加到暂存区</li>
<li>$ git commit -m “文件说明”  则是将暂存区的所有内容提交到当前所在分支</li>
</ol>
<h2 id="常用Git指令"><a href="#常用Git指令" class="headerlink" title="常用Git指令"></a>常用Git指令</h2><h4 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h4><blockquote>
<p>初始化仓库</p>
</blockquote>
<h4 id="cd-F-GitTool-repository"><a href="#cd-F-GitTool-repository" class="headerlink" title="cd F:/GitTool/repository/"></a>cd F:/GitTool/repository/</h4><blockquote>
<p>进入到仓库主目录</p>
</blockquote>
<h4 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h4><blockquote>
<p>查看仓库当前状态</p>
</blockquote>
<h4 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h4><blockquote>
<p>查看具体被修改的内容</p>
</blockquote>
<h4 id="git-add-路径-文件名"><a href="#git-add-路径-文件名" class="headerlink" title="git add 路径+文件名"></a>git add 路径+文件名</h4><blockquote>
<p>添加文件快照到暂存区</p>
</blockquote>
<h4 id="git-commit-m”文件说明”"><a href="#git-commit-m”文件说明”" class="headerlink" title="git commit -m”文件说明”"></a>git commit -m”文件说明”</h4><blockquote>
<p>将暂存区中的文件快照保存到git目录中</p>
</blockquote>
<h4 id="git-log-查看历史版本"><a href="#git-log-查看历史版本" class="headerlink" title="git log 查看历史版本"></a>git log 查看历史版本</h4><blockquote>
<p>一般而言，该命令会给出具体的历史版本信息，版本号从上到下，提交时间由近到远：</p>
<p><img src="/images/git%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC.png"></p>
<p>如果你不想要这么多信息，可以在该命令上加上一些参数：git log –pretty=oneline</p>
<p><img src="/images/git%E7%AE%80%E5%8C%96%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF.png"></p>
<p>前面的一串数字就是版本号，十六进制表示，通过SHA1算法计算出。在Git中，HEAD表示当前版本，也就是最新提交的版本。HEAD^表示上一个版本，HEAD^^表示上上个版本，以此类推。如果要回退的版本数很多，比如要回退10个版本，也可以通过HEAD~10进行回退。</p>
</blockquote>
<h4 id="git-reset-–hard-HEAD"><a href="#git-reset-–hard-HEAD" class="headerlink" title="git reset –hard HEAD^"></a>git reset –hard HEAD^</h4><blockquote>
<p>回退到上一个版本</p>
</blockquote>
<h4 id="git-reset-–hard-21f6306ffb4a5d8a15a0c9"><a href="#git-reset-–hard-21f6306ffb4a5d8a15a0c9" class="headerlink" title="git reset –hard  21f6306ffb4a5d8a15a0c9"></a>git reset –hard  21f6306ffb4a5d8a15a0c9</h4><blockquote>
<p>切换到版本号对应的版本</p>
</blockquote>
<blockquote>
<p>（无论是回退到历史版本还是恢复到原来的版本，都称为版本切换）版本切换的内部实现原理很简单。Git内部有个指向当前版本的HEAD指针，当回退版本时，Git只是改变HEAD的指向而已，然后将工作区的文件进行更新。所有，你让HEAD指向哪个版本号，就把当前版本定位在哪里</p>
</blockquote>
<h4 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h4><blockquote>
<p>记录每个命令以及命令对应操作文件的版本号</p>
</blockquote>
<blockquote>
<p>该命令通常和**git reset –hard 21f6306ffb4a5d8a15a0c9 **一起组合使用，切换到版本号对应的版本</p>
</blockquote>
<h4 id="git-checkout-–-文件名"><a href="#git-checkout-–-文件名" class="headerlink" title="git checkout   – 文件名"></a>git checkout   – 文件名</h4><blockquote>
<p>撤销修改</p>
</blockquote>
<blockquote>
<p>该命令只对两种情况有效：</p>
<ol>
<li>修改的文件还在工作区中，还没有进行提交，此时进行checkout，文件会回到修改前的版本号状态</li>
<li>文件提交到暂存区了，然后又对文件进行修改，那么进行checkout的文件会回到提交到暂存区时的状</li>
</ol>
<p>这意味着，只要你还没有进行commit操作，就可以撤销文件的修改。一旦commit，checkout命令就无效</p>
</blockquote>
<h4 id="rm-路径-文件名-git-rm-路径-文件名"><a href="#rm-路径-文件名-git-rm-路径-文件名" class="headerlink" title="rm  路径+文件名  git rm 路径+文件名"></a>rm  路径+文件名  git rm 路径+文件名</h4><blockquote>
<p>文件的删除</p>
</blockquote>
<blockquote>
<p>rm 路径+文件名并不会真正删除文件，而确定要真正删除文件，还需要再rm命令基础上，加上git rm命令，确定文件删除，最后执行git commit命令，提交修改。</p>
</blockquote>
<h4 id="git-remote-或者-git-remote-v"><a href="#git-remote-或者-git-remote-v" class="headerlink" title="git remote 或者 git remote -v"></a>git remote 或者 git remote -v</h4><blockquote>
<p>查看和本地仓库关联的远程仓库信息</p>
</blockquote>
<h4 id="git-remote-show-远程仓库别名"><a href="#git-remote-show-远程仓库别名" class="headerlink" title="git remote show 远程仓库别名"></a>git remote show 远程仓库别名</h4><blockquote>
<p>查看一个远程仓库的详细信息</p>
</blockquote>
<h4 id="git-remote-rename-远程仓库别名-新别名"><a href="#git-remote-rename-远程仓库别名-新别名" class="headerlink" title="git remote rename 远程仓库别名 新别名"></a>git remote rename 远程仓库别名 新别名</h4><blockquote>
<p>修改某个远程仓库的别名</p>
</blockquote>
<h4 id="git-remote-rm-远程仓库别名"><a href="#git-remote-rm-远程仓库别名" class="headerlink" title="git remote rm 远程仓库别名"></a>git remote rm 远程仓库别名</h4><blockquote>
<p>删除本地仓库与某个远程仓库的关联</p>
</blockquote>
<h4 id="git-remote-add-远程仓库别名-103-105-x74-64-x67-x69-x74-104-x75-x62-46-99-111-109-账户名-仓库名-git"><a href="#git-remote-add-远程仓库别名-103-105-x74-64-x67-x69-x74-104-x75-x62-46-99-111-109-账户名-仓库名-git" class="headerlink" title="git remote add 远程仓库别名 &#103;&#105;&#x74;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#111;&#109;:账户名/仓库名.git"></a>git remote add 远程仓库别名 <a href="mailto:&#103;&#105;&#x74;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#111;&#109;">&#103;&#105;&#x74;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#99;&#111;&#109;</a>:账户名/仓库名.git</h4><blockquote>
<p>将本地仓库与远程仓库间建立关联</p>
</blockquote>
<h4 id="git-push-u-远程仓库别名-本地仓库分支名"><a href="#git-push-u-远程仓库别名-本地仓库分支名" class="headerlink" title="git push -u 远程仓库别名 本地仓库分支名"></a>git push -u 远程仓库别名 本地仓库分支名</h4><blockquote>
<p>将本地仓库的分支推送到远程仓库中</p>
</blockquote>
<blockquote>
<p>可以不带-u参数。带上-u参数一般是在第一次推送分支的时候，这样Git不但会将本地master分支内容推送到远程仓库中，也会将本地的分支和远程的分支关联起来，在以后的推送和拉取时简化命令。</p>
</blockquote>
<h4 id="git-clone-x67-x69-x74-x40-103-x69-116-104-x75-x62-x2e-99-111-x6d-账户名-仓库名-git"><a href="#git-clone-x67-x69-x74-x40-103-x69-116-104-x75-x62-x2e-99-111-x6d-账户名-仓库名-git" class="headerlink" title="git clone &#x67;&#x69;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#x6d;:账户名/仓库名.git"></a>git clone <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#x6d;">&#x67;&#x69;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#x6d;</a>:账户名/仓库名.git</h4><blockquote>
<p>克隆远程仓库</p>
</blockquote>
<h4 id="git-fetch-远程仓库别名"><a href="#git-fetch-远程仓库别名" class="headerlink" title="git fetch 远程仓库别名"></a>git fetch 远程仓库别名</h4><blockquote>
<p>将远程仓库的数据抓取到本地（只会拉取本地仓库还没有的数据，也就是说会抓取自从你上次克隆以来，此远程仓库的所有更新），但不会自动合并到当前工作分支，必须进行手动合并</p>
</blockquote>
<h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><blockquote>
<p>从远程仓库中抓取对应内容，并自动合并到本地仓库中当前分支</p>
</blockquote>
<h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><blockquote>
<p>当我们和别人协作开发项目时，开发周期一般都为数个星期。如果没有分支，我们写完代码就往仓库中提交，因为代码是不完整的，而不完整的代码库会让别人无法继续编写代码和进行测试工作。而且我们也不能等代码全部写完一次性提交，存在丢失进度的风险。所以需要分时来帮助我们规避上面的我呢提。创建一个属于自己的分支，别人无法访问，我们在自己的分支上进行代码的提交和修改，等到开发完毕后再一次性合并到项目分支中，这样就可以解决上面的问题。</p>
</blockquote>
<p><strong>分支底层原理</strong></p>
<blockquote>
<p><img src="/images/%E5%88%86%E6%94%AF%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.png"></p>
<p>如图所示，每个分支包含的版本号为：</p>
<p>dev1分支 v2-2 v2-1 v2 v1</p>
<p>dev2分支 v4-2 v4 v3 v2 v1 </p>
<p>dev3分支 v4-3 v4 v3 v2 v1</p>
<p>master分支 v4 v3 v2 v1</p>
<ol>
<li>当创建一个分支时就是创建一个指针。比如当前分支为master，创建分支指针为dev4，则指针dev4指向v4版本号</li>
<li>切换分支就是切换指针。比如当前分支为master，那么HEAD指针就会指向master指针。如果切换到dev2分支，则HEAD指针就会指向dev2指针</li>
<li>查看分支就是查看分支指针有哪些，并在当前分支前加上*表示区别。比如当前分支为master，调用命令 git branch则会显示：dev1 dev2 dev3 *master</li>
<li>回退版本就是将分支指针移动到相应版本号，其它什么也不做</li>
<li>删除分支就是删除分支的指针。比如删除dev2分支，就表示删除dev2指针，版本号并不删除</li>
<li>合并分支时会有两种情况。一种是合并后不会冲突，一种合并后产生冲突。合并后不会冲突指两个分支有且最多只有一个分支对文件进行了修改。那么此时不会产生冲突，所做的也只是移动指针到相应的版本号。如果合并的两个分支都对文件做了修改，当合并时就会产生冲突，这时候需要在文件中手动地进行修改，然后对修改的文件重新进行add和commit。</li>
</ol>
</blockquote>
<p>常用分支命令：</p>
<h5 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h5><blockquote>
<p>查看分支</p>
</blockquote>
<h5 id="git-branch-name"><a href="#git-branch-name" class="headerlink" title="git branch name"></a>git branch name</h5><blockquote>
<p>创建分支</p>
</blockquote>
<h5 id="git-checkout-name"><a href="#git-checkout-name" class="headerlink" title="git checkout name"></a>git checkout name</h5><blockquote>
<p>切换分支</p>
</blockquote>
<h5 id="git-checkout-b-name"><a href="#git-checkout-b-name" class="headerlink" title="git checkout -b name"></a>git checkout -b name</h5><blockquote>
<p>创建并切换分支</p>
</blockquote>
<h5 id="git-merge-name"><a href="#git-merge-name" class="headerlink" title="git merge name"></a>git merge name</h5><blockquote>
<p>合并某分支到当前分支</p>
</blockquote>
<h5 id="git-merge-–no-ff-m-“合并信息描述”"><a href="#git-merge-–no-ff-m-“合并信息描述”" class="headerlink" title="git merge –no-ff -m “合并信息描述”"></a>git merge –no-ff -m “合并信息描述”</h5><blockquote>
<p>禁用ff模式进行分支合并</p>
</blockquote>
<h5 id="git-log-–graph-pretty-oneline-–abbrev-commit"><a href="#git-log-–graph-pretty-oneline-–abbrev-commit" class="headerlink" title="git log –graph -pretty=oneline –abbrev-commit"></a>git log –graph -pretty=oneline –abbrev-commit</h5><blockquote>
<p>查看分支历史</p>
</blockquote>
<h5 id="git-branch-d-name"><a href="#git-branch-d-name" class="headerlink" title="git branch -d name"></a>git branch -d name</h5><blockquote>
<p>删除分支</p>
</blockquote>
<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><blockquote>
<p>在实际开发过程中，应该按照几个基本原则进行分支管理：</p>
<ol>
<li>master分支应该是非常稳定的，仅用于发布新版本</li>
<li>dev分支是不稳定的，等需要发布版本时，再把dev分支合并到master分支上</li>
<li>团队的每个人都在dev分支上工作，每个人都有自己的分支，可以随时往dev分支上合并</li>
</ol>
<p><img src="/images/%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86.png"></p>
<p>合并时还要注意，有两种模式。Fast Forward合并模式和普通合并模式。ff合并模式下，删除分支后会丢掉分支信息。而普通合并模式则相反，删除分支后会保留分支信息。如果要禁用ff模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
</blockquote>
<h4 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h4><blockquote>
<p>需要注意的两个问题：</p>
<ol>
<li>默认情况下，从远程仓库clone时，只能看到master分支。因此，为了创建dev分支进行修改，就必须在本地创建远程仓库的dev分支：<code>git checkout -b dev 远程仓库别名/dev</code>  然后就可以在本地分支dev上修改，然后将dev分支上的内容push到远程仓库中</li>
<li>推送时产生的分支冲突。这和本地的分支冲突相同，你得先将最新的提交从远程仓库相应分支上抓取下来，然后在本地进行合并，手动解决冲突，然后进行add，commit操作，最后再push</li>
</ol>
</blockquote>
<h5 id="多人协作流程"><a href="#多人协作流程" class="headerlink" title="多人协作流程"></a>多人协作流程</h5><blockquote>
<ol>
<li>首先，试图用 <code>git push 远程仓库别名 分支</code> 推送自己的修改</li>
<li>如果推送失败，是因为远程分支比本地的分支版本更新，需要由拉取内容到本地尝试进行分支合并</li>
<li>如果合并有冲突，需要解决冲突，并在本地进行提交</li>
<li>没有冲突或冲突解决后，再通过 <code>git push 远程仓库别名 分支名</code>推送就能推送成功</li>
<li>如果 <code>git pull</code>提示“no tracking information” 则说明本地分支和远程分支的链接关系没有创建，则需要通过命令： <code>git branch -set-upstream 本地分支名 远程仓库别名/分支名</code> 进行创建</li>
</ol>
</blockquote>
<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><blockquote>
<p>Git使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是一个不会变化的分支，指向特定提交对象的引用。而含附注标签，则实际上是一个独立的对象，有自身的的校验信息，标签名称，电子邮件和日期，标签说明，标签本身也可通过GNU来签署和验证。通常而言，会更多地使用含附注标签。</p>
</blockquote>
<h5 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h5><blockquote>
<p>显示已有标签</p>
</blockquote>
<h5 id="git-show-标签名"><a href="#git-show-标签名" class="headerlink" title="git show 标签名"></a>git show 标签名</h5><blockquote>
<p>显示相应标签的详细信息，和打标签的提交对象</p>
</blockquote>
<h5 id="git-tag-标签名"><a href="#git-tag-标签名" class="headerlink" title="git tag 标签名"></a>git tag 标签名</h5><blockquote>
<p>创建一个轻量级标签</p>
</blockquote>
<h5 id="git-tag-a-标签名-m-‘标签信息描述’"><a href="#git-tag-a-标签名-m-‘标签信息描述’" class="headerlink" title="git tag -a 标签名 -m ‘标签信息描述’"></a>git tag -a 标签名 -m ‘标签信息描述’</h5><blockquote>
<p>创建一个含附注的标签</p>
</blockquote>
<h5 id="git-tag-s-标签名-m-‘标签信息描述’"><a href="#git-tag-s-标签名-m-‘标签信息描述’" class="headerlink" title="git tag -s 标签名 -m ‘标签信息描述’"></a>git tag -s 标签名 -m ‘标签信息描述’</h5><blockquote>
<p>用GPG来签署标签</p>
</blockquote>
<h5 id="git-push-远程仓库别名-标签名"><a href="#git-push-远程仓库别名-标签名" class="headerlink" title="git push 远程仓库别名 标签名"></a>git push 远程仓库别名 标签名</h5><blockquote>
<p>默认情况下，git push并不会将标签传送到远程仓库上，只有通过显示命令才能分享标签到远程仓库</p>
</blockquote>
<h4 id="git-push-远程仓库别名-–tags"><a href="#git-push-远程仓库别名-–tags" class="headerlink" title="git push 远程仓库别名 –tags"></a>git push 远程仓库别名 –tags</h4><blockquote>
<p>一次性将所有本地所有的标签推送到远程仓库上（只推送本地新增的，已推的不会再推送）</p>
</blockquote>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava RateLimiter</title>
    <url>/2020/08/09/Guava-RateLimiter/</url>
    <content><![CDATA[<p>Google Guava提供的<code>RateLimiter</code>使用的是令牌桶算法。令牌桶算法的基本思想是以固定的速率生成令牌，在执行请求之前都需要从令牌桶里获取足够的令牌。当令牌数量不足的时候，请求将被阻塞进入等待状态或者直接返回失败。<code>RateLimiter</code>常用于限制访问资源的速率。</p>
<span id="more"></span>

<h2 id="RateLimiter使用示例"><a href="#RateLimiter使用示例" class="headerlink" title="RateLimiter使用示例"></a>RateLimiter使用示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1秒钟产生0.5张令牌</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> RateLimiter limiter = RateLimiter.create(<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">5</span>).forEach(i -&gt; service.submit(RateLimiterTest::testLimiter));</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testLimiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot; waiting &quot;</span> + limiter.acquire());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，定义了一个<code>RateLimiter</code>实例，每秒钟产生0.5张令牌，即每2秒钟产生1张令牌。<code>testLimiter</code>方法中通过<code>limiter.acquire()</code>方法获取令牌（不带参数时默认获取1张令牌）。<code>Executors.newFixedThreadPool(5)</code>生成五个线程，并发调用<code>testLimiter</code>方法，执行代码，控制台输出如下所示：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Thread</span>[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main] waiting <span class="number">0</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">Thread</span>[pool-<span class="number">1</span>-thread-<span class="number">5</span>,<span class="number">5</span>,main] waiting <span class="number">1</span>.<span class="number">908947</span></span><br><span class="line"><span class="attribute">Thread</span>[pool-<span class="number">1</span>-thread-<span class="number">4</span>,<span class="number">5</span>,main] waiting <span class="number">3</span>.<span class="number">908935</span></span><br><span class="line"><span class="attribute">Thread</span>[pool-<span class="number">1</span>-thread-<span class="number">3</span>,<span class="number">5</span>,main] waiting <span class="number">5</span>.<span class="number">908919</span></span><br><span class="line"><span class="attribute">Thread</span>[pool-<span class="number">1</span>-thread-<span class="number">2</span>,<span class="number">5</span>,main] waiting <span class="number">7</span>.<span class="number">908808</span></span><br></pre></td></tr></table></figure>

<p>可以看到每个线程调用时间相隔大约为2秒钟。那为什么第一个线程没有等待2秒，直接就获取到了令牌然后执行了呢？是这样的，Guava RateLimiter允许某次请求获取超出剩余令牌数的令牌，但是下一次请求将为此付出代价，一直等到令牌亏空补上。来看个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RateLimiter limiter = RateLimiter.create(<span class="number">1</span>);</span><br><span class="line">        System.out.println(limiter.acquire(<span class="number">4</span>));</span><br><span class="line">        System.out.println(limiter.acquire(<span class="number">3</span>));</span><br><span class="line">        System.out.println(limiter.acquire(<span class="number">2</span>));</span><br><span class="line">        System.out.println(limiter.acquire(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">0</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">3</span>.<span class="number">996602</span></span><br><span class="line"><span class="attribute">2</span>.<span class="number">997448</span></span><br><span class="line"><span class="attribute">2</span>.<span class="number">000229</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，一秒钟产生一张令牌，第一次请求直接取出4张令牌，所以第二次请求需要等待4/1秒才能取到令牌。经过大约4秒后，第二次请求直接取出3张令牌，所以第三次请求需要等待3/1秒后才能取到令牌，依此类推。</p>
<h2 id="设置超时时间"><a href="#设置超时时间" class="headerlink" title="设置超时时间"></a>设置超时时间</h2><p>可以设置等待令牌的超时时间，如果等待令牌的时间大于超时时间，将直接返回false，不再等待：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RateLimiter limiter = RateLimiter.create(<span class="number">1</span>);</span><br><span class="line">        System.out.println(limiter.acquire(<span class="number">3</span>));</span><br><span class="line">        System.out.println(limiter.tryAcquire(<span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子<code>limiter.tryAcquire</code>设置了超时时间为2秒，由于第一次请求一次性获取了3张令牌，所以这里需要等待大约3秒钟，超出了2秒的超时时间，所以<code>limiter.tryAcquire</code>不会等待3秒，而是直接返回false。</p>
]]></content>
      <tags>
        <tag>guava</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava缓存</title>
    <url>/2020/08/09/Guava%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>Guava缓存是轻量级的，它将内容缓存到运行内存中。如果系统中某些值（比如一些配置表）被频繁查询使用，并且我们愿意消耗一些内存空间来提升应用的速度，减轻数据库压力的话，Guava缓存将会是一个不错的选择。由于缓存是存储在运行内存中的，所以需要确保缓存的大小不超出内存的容量。</p>
<span id="more"></span>

<h2 id="创建缓存"><a href="#创建缓存" class="headerlink" title="创建缓存"></a>创建缓存</h2><p>可以直接创建Guava缓存对象，而不使用任何的CacheLoader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">System.out.println(cache.getIfPresent(<span class="string">&quot;hello&quot;</span>)); <span class="comment">//  world</span></span><br></pre></td></tr></table></figure>

<p>key值是大小写敏感的，所以使用<code>cache.getIfPresent(&quot;HELLO&quot;)</code>将返回null值。</p>
<p>接下来看看如何使用CacheLoader创建缓存对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CacheLoader&lt;String, String&gt; loader = <span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sayHello(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(loader);</span><br><span class="line"></span><br><span class="line">String mrbird = cache.getUnchecked(<span class="string">&quot;mrbird&quot;</span>);</span><br><span class="line">System.out.println(mrbird); <span class="comment">// hello mrbird</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">sayHello</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;hello %s&quot;</span>, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法<code>getUnchecked</code>作用为：当值不存在时，会通过CacheLoader计算出值，然后存到缓存中</p>
<h2 id="驱逐机制"><a href="#驱逐机制" class="headerlink" title="驱逐机制"></a>驱逐机制</h2><p>可以定义一些驱逐缓存的机制来限制缓存的大小</p>
<h3 id="限制缓存数目"><a href="#限制缓存数目" class="headerlink" title="限制缓存数目"></a>限制缓存数目</h3><p>可以通过<code>maximumSize</code>来限制缓存的条目：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().maximumSize(<span class="number">3</span>).build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;k4&quot;</span>, <span class="string">&quot;v4&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(cache.size()); <span class="comment">// 3</span></span><br><span class="line">System.out.println(cache.getIfPresent(<span class="string">&quot;k1&quot;</span>)); <span class="comment">// null</span></span><br><span class="line">System.out.println(cache.asMap()); <span class="comment">// &#123;k3=v3, k4=v4, k2=v2&#125;</span></span><br></pre></td></tr></table></figure>

<p>限制最多只能存储3个值，所以k4的存入把最早的k1给驱逐出去了，类似于FIFO</p>
<h3 id="限制缓存大小"><a href="#限制缓存大小" class="headerlink" title="限制缓存大小"></a>限制缓存大小</h3><p>可以自定义权重函数来限制缓存的大小：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Weigher&lt;String, String&gt; weigher = (key, value) -&gt; value.length();</span><br><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().maximumWeight(<span class="number">15</span>).weigher(weigher).build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;11111&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;22222&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;33333&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;k4&quot;</span>, <span class="string">&quot;4444&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;k5&quot;</span>, <span class="string">&quot;5555&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(cache.size()); <span class="comment">// 3</span></span><br><span class="line">System.out.println(cache.getIfPresent(<span class="string">&quot;k1&quot;</span>)); <span class="comment">// null</span></span><br><span class="line">System.out.println(cache.asMap()); <span class="comment">// &#123;k3=33333, k5=5555, k4=4444&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，通过<code>maximumWeight(15)</code>指定了缓存的最大容量，权重规则为value的长度。k3，k4和k5的value长度加起来为13，所以k1和k2的值存不下了，被驱逐</p>
<h3 id="设置缓存时间"><a href="#设置缓存时间" class="headerlink" title="设置缓存时间"></a>设置缓存时间</h3><p>可以设置缓存的有效时间和缓存的活跃时间</p>
<h4 id="设置缓存的活跃时间为2s"><a href="#设置缓存的活跃时间为2s" class="headerlink" title="设置缓存的活跃时间为2s"></a>设置缓存的活跃时间为2s</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().expireAfterAccess(<span class="number">2</span>, TimeUnit.SECONDS).build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line"></span><br><span class="line">cache.getIfPresent(<span class="string">&quot;k1&quot;</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">cache.getIfPresent(<span class="string">&quot;k1&quot;</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(cache.getIfPresent(<span class="string">&quot;k1&quot;</span>)); <span class="comment">// v1</span></span><br><span class="line">System.out.println(cache.getIfPresent(<span class="string">&quot;k2&quot;</span>)); <span class="comment">// null</span></span><br><span class="line">System.out.println(cache.size()); <span class="comment">// 1</span></span><br><span class="line">System.out.println(cache.asMap()); <span class="comment">// &#123;k1=v1&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，我们通过<code>cache.getIfPresent(&quot;k1&quot;)</code>获取了k1的值，然后让线程阻塞1秒，这时候k1和k2的有效时间大约为1秒左右。接着又获取了k1的值，所以k1的有效时间还是2秒，k2为1秒，再次让线程阻塞1秒后，k1的有效时间为1秒，k2已经失效了。打印输出的结果和我们预期的一致。</p>
<h4 id="设置缓存的有效时间为2s"><a href="#设置缓存的有效时间为2s" class="headerlink" title="设置缓存的有效时间为2s"></a>设置缓存的有效时间为2s</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().expireAfterWrite(<span class="number">2</span>, TimeUnit.SECONDS).build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line"></span><br><span class="line">cache.getIfPresent(<span class="string">&quot;k1&quot;</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">cache.getIfPresent(<span class="string">&quot;k1&quot;</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(cache.getIfPresent(<span class="string">&quot;k1&quot;</span>)); <span class="comment">// null</span></span><br><span class="line">System.out.println(cache.getIfPresent(<span class="string">&quot;k2&quot;</span>)); <span class="comment">// null</span></span><br><span class="line">System.out.println(cache.size()); <span class="comment">// 0</span></span><br><span class="line">System.out.println(cache.asMap()); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>设置缓存有效时间为2秒，所以2秒后所有缓存都过期失效了，无论期间获取过多少次缓存</p>
<h3 id="weakKeys-amp-softValues"><a href="#weakKeys-amp-softValues" class="headerlink" title="weakKeys&amp;softValues"></a>weakKeys&amp;softValues</h3><p>默认情况下，Guava缓存键值都有强引用，我们可以使用weakKeys和softValues来让键值变为弱引用，这样垃圾收集器在必要的情况下将会工作：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = <span class="module-access"><span class="module"><span class="identifier">CacheBuilder</span>.</span></span><span class="keyword">new</span><span class="constructor">Builder()</span>.weak<span class="constructor">Keys()</span>.soft<span class="constructor">Values()</span>.build<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>

<h2 id="刷新缓存"><a href="#刷新缓存" class="headerlink" title="刷新缓存"></a>刷新缓存</h2><p>可以通过<code>refreshAfterWrite</code>设置缓存自动刷新间隔，或者可以直接调用<code>refresh</code>方法来手动刷新缓存：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = <span class="module-access"><span class="module"><span class="identifier">CacheBuilder</span>.</span></span><span class="keyword">new</span><span class="constructor">Builder()</span>.refresh<span class="constructor">AfterWrite(1,TimeUnit.SECONDS)</span>.build<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>

<h2 id="添加多个缓存"><a href="#添加多个缓存" class="headerlink" title="添加多个缓存"></a>添加多个缓存</h2><p>通过<code>putAll</code>来一次性添加多个缓存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build();</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; map = Maps.newHashMap();</span><br><span class="line">map.put(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>);</span><br><span class="line"></span><br><span class="line">cache.putAll(map);</span><br><span class="line">System.out.println(cache.size()); <span class="comment">// 3</span></span><br><span class="line">System.out.println(cache.asMap()); <span class="comment">// &#123;k3=v3, k1=v1, k2=v2&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="删除缓存"><a href="#删除缓存" class="headerlink" title="删除缓存"></a>删除缓存</h2><p><code>Cache.invalidate(key)</code>方法通过key来删除缓存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build();</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; map = Maps.newHashMap();</span><br><span class="line">map.put(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">cache.putAll(map);</span><br><span class="line"></span><br><span class="line">System.out.println(cache.asMap()); <span class="comment">// &#123;k1=v1&#125;</span></span><br><span class="line">cache.invalidate(<span class="string">&quot;k1&quot;</span>);</span><br><span class="line">System.out.println(cache.asMap()); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>除此之外，我们也可以通过<code>Cache.invalidateAll(keys)</code>一次性删除多个缓存或者<code>Cache.invalidateAll()</code>删除全部缓存。</p>
<p>我们还可以给删除事件添加监听器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RemovalListener&lt;String, String&gt; listener</span><br><span class="line">                = notification -&gt; System.out.println(<span class="string">&quot;监听到删除事件，key=&quot;</span> + notification.getKey() + <span class="string">&quot;，value=&quot;</span> + notification.getValue());</span><br><span class="line"></span><br><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().removalListener(listener).build();</span><br><span class="line">cache.put(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line"></span><br><span class="line">cache.invalidate(<span class="string">&quot;k1&quot;</span>); <span class="comment">// 监听到删除事件，key=k1，value=v1</span></span><br></pre></td></tr></table></figure>

<h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaCacheUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(GuavaCacheUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Cache&lt;String, String&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        RemovalListener&lt;String, String&gt; listener</span><br><span class="line">                = n -&gt; logger.info(<span class="string">&quot;监听到删除事件，key=&#123;&#125;，value=&#123;&#125;&quot;</span>, n.getKey(), n.getValue());</span><br><span class="line">        cache = CacheBuilder.newBuilder()</span><br><span class="line">                .removalListener(listener).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(key) &amp;&amp; StringUtils.isNotBlank(value)) &#123;</span><br><span class="line">            cache.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量添加缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map key,value集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        cache.putAll(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(key)) &#123;</span><br><span class="line">            cache.invalidate(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys key集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(List&lt;String&gt; keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(keys)) &#123;</span><br><span class="line">            cache.invalidateAll(keys);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cache.invalidateAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.isNotBlank(key) ? cache.getIfPresent(key) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量获取缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys 键集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ImmutableMap&lt;String, String&gt; <span class="title">get</span><span class="params">(List&lt;String&gt; keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CollectionUtils.isNotEmpty(keys) ? cache.getAllPresent(keys) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>guava</tag>
      </tags>
  </entry>
  <entry>
    <title>HashSet源码解析</title>
    <url>/2020/09/15/HashSet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>HashSet源码解析，基于JDK1.8</p>
<span id="more"></span>

<h2 id="HashSet类结构关系"><a href="#HashSet类结构关系" class="headerlink" title="HashSet类结构关系"></a>HashSet类结构关系</h2><p>HashSet类层级关系图：</p>
<p><img src="/images/HashSet%E7%B1%BB%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.png"></p>
<p>HashSet实现了Set接口，为什么叫HashSet？因为HashSet内部采用哈希表（实际就是HashMap）来存储不重复的数据，查看HashSet内部属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用HashMap存储数据，HashSet的数据实际为HashMap的key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="comment">// HashMap value占位符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<p>HashMap的key是不允许重复的，这也正好符合Set的特性。因为HashSet内部采用HashMap存储数据，所以HashSet可以存储null值，支持快速失败，非线程安全。</p>
<h3 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空参构造函数，内部初始化map属性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入集合对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化map，计算map的容量</span></span><br><span class="line">    <span class="comment">// 计算公式为 c.size/0.75f + 1，如果值小于16，则取值16。</span></span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    <span class="comment">// 将集合中的所有元素添加进去</span></span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动指定容量和加载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动指定容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，创建HashSet的本质就是初始化HashMap。</p>
<h4 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h4><p><code>add(E e)</code>添加指定元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 往map里添加元素，如果key已经存在则返回false，否则返回true</span></span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h4><p><code>size()</code>获取元素个数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 本质就是获取map的元素个数</span></span><br><span class="line">    <span class="keyword">return</span> map.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="contains-Object-o"><a href="#contains-Object-o" class="headerlink" title="contains(Object o)"></a>contains(Object o)</h4><p><code>contains(Object o)</code>判断是否包含指定元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 本质就是判断map中是否包含该key</span></span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty()"></a>isEmpty()</h4><p><code>isEmpty()</code>判断集合是否为空：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 本质就是判断map是否为空</span></span><br><span class="line">    <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h4><p><code>remove(Object o)</code>删除指定元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 本质就是通过key删除map中的元素，如果该key存在，则返回true，否则返回false</span></span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h4><p><code>clear()</code>清空集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 本质就是清空map</span></span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="iterator"><a href="#iterator" class="headerlink" title="iterator()"></a>iterator()</h4><p><code>iterator()</code>获取迭代器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 本质就是获取map key的迭代器</span></span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>HashTable源码解析</title>
    <url>/2020/09/07/HashTable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>HashTable是Map接口线程安全实现版本，数据结构和方法实现与HashMap类似，本文记录HashTable源码解析，基于JDK1.8</p>
<span id="more"></span>

<h2 id="类层级关系"><a href="#类层级关系" class="headerlink" title="类层级关系"></a>类层级关系</h2><p>HashTable类层级关系图：</p>
<p><img src="/images/HashTable%E7%B1%BB%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.png"></p>
<p>主要成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部采用Entry数组存储键值对数据，Entry实际为单向链表的表头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"><span class="comment">// HashTable里键值对个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">// 扩容阈值，当超过这个值时，进行扩容操作，计算方式为：数组容量*加载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 加载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">// 用于快速失败</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>table属性通过transient修饰，原因在介绍<a href="https://mrbird.cc/Java-HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html">HashMap源码</a>的时候分析过。</p>
<p>Entry代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Entry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Entry&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key =  key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Entry为单向链表节点，HashTable采用数组加链表的方式存储数据，不过没有类似于HashMap中当链表过长时转换为红黑树的操作</p>
<h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置指定容量和加载因子，初始化HashTable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Load: &quot;</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 容量最小为1</span></span><br><span class="line">        initialCapacity = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    table = <span class="keyword">new</span> Entry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    <span class="comment">// 初始扩容阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置指定容量初始HashTable，加载因子为0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动指定数组初始容量为11，加载因子为0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h3><p><code>put(K key, V value)</code>添加指定键值对，键和值都不能为null：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法synchronized修饰，线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">// 得到key的哈希值</span></span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">// 得到该key存在到数组中的下标</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">// 得到该下标对应的Entry</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="comment">// 如果该下标的Entry不为null，则进行链表遍历</span></span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="comment">// 遍历链表，如果存在key相等的节点，则替换这个节点的值，并返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果数组下标对应的节点为空，或者遍历链表后发现没有和该key相等的节点，则执行插入操作</span></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">// 判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">        <span class="comment">// 如果count大于等于扩容阈值，则进行扩容</span></span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line">        tab = table;</span><br><span class="line">        <span class="comment">// 扩容后，重新计算该key在扩容后table里的下标</span></span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creates the new entry.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">// 采用头插的方式插入，index位置的节点为新节点的next节点</span></span><br><span class="line">    <span class="comment">// 新节点取代inde位置节点</span></span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">// count+1</span></span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash()"></a>rehash()</h3><p><code>rehash</code>扩容操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 暂存旧的table和容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新容量为旧容量的2n+1倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 判断新容量是否超过最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果旧容量已经是最大容量大话，就不扩容了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 新容量最大值只能是MAX_ARRAY_SIZE</span></span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用新容量创建一个新Entry数组</span></span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line">    <span class="comment">// 模数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 重新计算下次扩容阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将新Entry数组赋值给table</span></span><br><span class="line">    table = newMap;</span><br><span class="line">    <span class="comment">// 遍历数组和链表，进行新table赋值操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h3><p><code>get(Object key)</code>获取指定key对应的value：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">// 根据key哈希得到index，遍历链表取值</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized修饰，线程安全</p>
<h3 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove(Object key)"></a>remove(Object key)</h3><p><code>remove(Object key)</code>删除指定key，返回对应的value：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">// 获取key对应的index</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">// 遍历链表，如果找到key相等的节点，则改变前继和后继节点的关系，并删除相应引用，让GC回收</span></span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; prev = <span class="keyword">null</span> ; e != <span class="keyword">null</span> ; prev = e, e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.next = e.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index] = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized修饰，线程安全</p>
<h2 id="和HashMap对比"><a href="#和HashMap对比" class="headerlink" title="和HashMap对比"></a>和HashMap对比</h2><ol>
<li><p>线程是否安全：HashMap是线程不安全的，HashTable是线程安全的；HashTable内部的方法基本都经过 synchronized修饰；</p>
</li>
<li><p>对Null key 和Null value的支持：HashMap中，null可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为null；HashTable中key和value都不能为null，否则抛出空指针异常；</p>
</li>
<li><p>初始容量大小和每次扩充容量大小的不同：</p>
<p>3.1. 创建时如果不指定容量初始值，Hashtable默认的初始大小为11，之后每次扩容，容量变为原来的2n+1。HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍；</p>
<p>3.2. 创建时如果给定了容量初始值，那么Hashtable会直接使用你给定的大小，而HashMap会将其扩充 为2的幂次方大小。</p>
</li>
<li><p>底层数据结构：JDK1.8及以后的HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间，Hashtable没有这样的机制。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON</title>
    <url>/2020/04/27/JSON/</url>
    <content><![CDATA[<p>JSON全称 <code>JavaScript Object Notation</code>，是一种轻量级的数据交换格式。虽然格式上和JavaScript对象很像，但是两者间没有什么直接的联系。如果硬要说关联的话，那么JSON是一个具有严格条件的JavaScript对象，比如：</p>
<table>
<thead>
<tr>
<th>对比内容</th>
<th>JSON</th>
<th>JavaScript对象</th>
</tr>
</thead>
<tbody><tr>
<td>键名</td>
<td>必须加双引号“ ”</td>
<td>可加双引号，也可不加；也可以加单引号</td>
</tr>
<tr>
<td>属性值</td>
<td>只能是数值，字符串，布尔值，null等符合JSON要求的对象，不能是函数</td>
<td>什么都可以</td>
</tr>
<tr>
<td>逗号问题</td>
<td>最后一个属性后面不能有逗号</td>
<td>可以</td>
</tr>
<tr>
<td>数值</td>
<td>不能以0开头，小数点后面必须有数字</td>
<td>没有限制</td>
</tr>
</tbody></table>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;; <span class="comment">// 这只是 JS 对象</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 可把这个称做：JSON 格式的 JavaScript 对象 </span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    <span class="string">&quot;width&quot;</span>:<span class="number">100</span>,</span><br><span class="line">    <span class="string">&quot;height&quot;</span>:<span class="number">200</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;rose&quot;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 可把这个称做：JSON 格式的字符串</span></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">	&quot;width&quot;:100,</span></span><br><span class="line"><span class="string">        &quot;height&quot;:200,</span></span><br><span class="line"><span class="string">            &quot;name&quot;:&quot;rose&quot;&#125;&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这个可叫 JSON 格式的数组，是 JSON 的稍复杂一点的形式</span></span><br><span class="line"><span class="keyword">var</span> arr = [  </span><br><span class="line">    &#123;<span class="string">&quot;width&quot;</span>:<span class="number">100</span>,<span class="string">&quot;height&quot;</span>:<span class="number">200</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;rose&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;width&quot;</span>:<span class="number">100</span>,<span class="string">&quot;height&quot;</span>:<span class="number">200</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;rose&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;width&quot;</span>:<span class="number">100</span>,<span class="string">&quot;height&quot;</span>:<span class="number">200</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;rose&quot;</span>&#125;,</span><br><span class="line">];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这个可叫稍复杂一点的 JSON 格式的字符串     </span></span><br><span class="line"><span class="keyword">var</span> str2=<span class="string">&#x27;[&#x27;</span>+  </span><br><span class="line">    <span class="string">&#x27;&#123;&quot;width&quot;:100,&quot;height&quot;:200,&quot;name&quot;:&quot;rose&quot;&#125;,&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;&#123;&quot;width&quot;:100,&quot;height&quot;:200,&quot;name&quot;:&quot;rose&quot;&#125;,&#x27;</span>+</span><br><span class="line">    <span class="string">&#x27;&#123;&quot;width&quot;:100,&quot;height&quot;:200,&quot;name&quot;:&quot;rose&quot;&#125;,&#x27;</span>+</span><br><span class="line"><span class="string">&#x27;]&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="将JavaScript对象转化为JSON字符串"><a href="#将JavaScript对象转化为JSON字符串" class="headerlink" title="将JavaScript对象转化为JSON字符串"></a>将JavaScript对象转化为JSON字符串</h2><p><strong>JSON.stringify</strong></p>
<p><code>JSON.stringify(value, replacer, space)</code></p>
<h3 id="仅使用一个参数"><a href="#仅使用一个参数" class="headerlink" title="仅使用一个参数"></a>仅使用一个参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建js对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;DougWilson&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">24</span>&#125;;</span><br><span class="line"><span class="comment">//将此对象转成json字符串</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line"><span class="comment">// &quot;&#123;&quot;name&quot;:&quot;DougWilson&quot;,&quot;age&quot;:24&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用两个参数"><a href="#使用两个参数" class="headerlink" title="使用两个参数"></a>使用两个参数</h3><h4 id="第二个参数是一个函数"><a href="#第二个参数是一个函数" class="headerlink" title="第二个参数是一个函数"></a>第二个参数是一个函数</h4><p>序列化过程的每个属性都会被这个函数进行转化和处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> friend=&#123;  </span><br><span class="line">    <span class="string">&quot;firstName&quot;</span>: <span class="string">&quot;Doug&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lastName&quot;</span>: <span class="string">&quot;Wilson&quot;</span>,</span><br><span class="line">    <span class="string">&quot;phone&quot;</span>:<span class="string">&quot;773445&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:<span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> friendAfter=<span class="built_in">JSON</span>.stringify(friend,<span class="function"><span class="keyword">function</span>(<span class="params">key,value</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(key===<span class="string">&quot;phone&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(0592-)&quot;</span>+value;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> value === <span class="string">&quot;number&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> value + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> value; <span class="comment">//如果你把这个else分句删除，那么结果会是undefined</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(friendAfter);  </span><br><span class="line"><span class="comment">//输出：&#123;&quot;firstName&quot;:&quot;Doug&quot;,&quot;lastName&quot;:&quot;Wilson&quot;,&quot;phone&quot;:&quot;(0592-)773445&quot;,&quot;age&quot;:28&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="第二个参数是一个数组"><a href="#第二个参数是一个数组" class="headerlink" title="第二个参数是一个数组"></a>第二个参数是一个数组</h4><p>只有在这个数组中的属性才会被序列化到JSON字符串结果中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> friend=&#123;  </span><br><span class="line">    <span class="string">&quot;firstName&quot;</span>: <span class="string">&quot;Doug&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lastName&quot;</span>: <span class="string">&quot;Wilson&quot;</span>,</span><br><span class="line">    <span class="string">&quot;phone&quot;</span>:<span class="string">&quot;773445&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:<span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//注意下面的数组有一个值并不是上面对象的任何一个属性名</span></span><br><span class="line"><span class="keyword">var</span> friendAfter=<span class="built_in">JSON</span>.stringify(friend,[<span class="string">&quot;firstName&quot;</span>,<span class="string">&quot;address&quot;</span>,<span class="string">&quot;phone&quot;</span>]);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(friendAfter);  </span><br><span class="line"><span class="comment">//&#123;&quot;firstName&quot;:&quot;Doug&quot;,&quot;phone&quot;:&quot;773445&quot;&#125;</span></span><br><span class="line"><span class="comment">//指定的“address”由于没有在原来的对象中找到而被忽略</span></span><br><span class="line"><span class="comment">//而age则因为不在数组中也被忽略</span></span><br></pre></td></tr></table></figure>

<h4 id="第二个参数为null"><a href="#第二个参数为null" class="headerlink" title="第二个参数为null"></a>第二个参数为null</h4><p>和没有第二个参数没有区别，但是在不想设置第二个参数，只想设置第三个参数时，就可以将第二个参数设置为null</p>
<h3 id="使用三个参数"><a href="#使用三个参数" class="headerlink" title="使用三个参数"></a>使用三个参数</h3><p>第三个参数用于美化输出：</p>
<ol>
<li>如果为1-10的某个数字，代表使用几个空白符进行缩进</li>
<li>如果是字符串，表示用该字符串代替空格，最多取该字符串前10个字符</li>
<li>没有设置该参数或者设置为null，等同于没有使用第三个参数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> friend=&#123;  </span><br><span class="line">    <span class="string">&quot;firstName&quot;</span>: <span class="string">&quot;Doug&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lastName&quot;</span>: <span class="string">&quot;Wilson&quot;</span>,</span><br><span class="line">    <span class="string">&quot;phone&quot;</span>:&#123;<span class="string">&quot;home&quot;</span>:<span class="string">&quot;1234567&quot;</span>,<span class="string">&quot;work&quot;</span>:<span class="string">&quot;7654321&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//直接转化是这样的：</span></span><br><span class="line"><span class="comment">//&#123;&quot;firstName&quot;:&quot;Doug&quot;,&quot;lastName&quot;:&quot;Wilson&quot;,&quot;phone&quot;:&#123;&quot;home&quot;:&quot;1234567&quot;,&quot;work&quot;:&quot;7654321&quot;&#125;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> friendAfter=<span class="built_in">JSON</span>.stringify(friend,<span class="literal">null</span>,<span class="number">4</span>);  </span><br><span class="line"><span class="built_in">console</span>.log(friendAfter);  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    &quot;firstName&quot;: &quot;Doug&quot;,</span></span><br><span class="line"><span class="comment">    &quot;lastName&quot;: &quot;Wilson&quot;,</span></span><br><span class="line"><span class="comment">    &quot;phone&quot;: &#123;</span></span><br><span class="line"><span class="comment">        &quot;home&quot;: &quot;1234567&quot;,</span></span><br><span class="line"><span class="comment">        &quot;work&quot;: &quot;7654321&quot;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> friendAfter=<span class="built_in">JSON</span>.stringify(friend,<span class="literal">null</span>,<span class="string">&quot;HAHAHAHA&quot;</span>);  </span><br><span class="line"><span class="built_in">console</span>.log(friendAfter);  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">HAHAHAHA&quot;firstName&quot;: &quot;Doug&quot;,  </span></span><br><span class="line"><span class="comment">HAHAHAHA&quot;lastName&quot;: &quot;Wilson&quot;,  </span></span><br><span class="line"><span class="comment">HAHAHAHA&quot;phone&quot;: &#123;  </span></span><br><span class="line"><span class="comment">HAHAHAHAHAHAHAHA&quot;home&quot;: &quot;1234567&quot;,  </span></span><br><span class="line"><span class="comment">HAHAHAHAHAHAHAHA&quot;work&quot;: &quot;7654321&quot;  </span></span><br><span class="line"><span class="comment">HAHAHAHA&#125;  </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> friendAfter=<span class="built_in">JSON</span>.stringify(friend,<span class="literal">null</span>,<span class="string">&quot;WhatAreYouDoingNow&quot;</span>);  </span><br><span class="line"><span class="built_in">console</span>.log(friendAfter);  </span><br><span class="line"><span class="comment">/* 最多只取10个字符</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">WhatAreYou&quot;firstName&quot;: &quot;Doug&quot;,  </span></span><br><span class="line"><span class="comment">WhatAreYou&quot;lastName&quot;: &quot;Wilson&quot;,  </span></span><br><span class="line"><span class="comment">WhatAreYou&quot;phone&quot;: &#123;  </span></span><br><span class="line"><span class="comment">WhatAreYouWhatAreYou&quot;home&quot;: &quot;1234567&quot;,  </span></span><br><span class="line"><span class="comment">WhatAreYouWhatAreYou&quot;work&quot;: &quot;7654321&quot;  </span></span><br><span class="line"><span class="comment">WhatAreYou&#125;  </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="需要注意的几个地方"><a href="#需要注意的几个地方" class="headerlink" title="需要注意的几个地方"></a>需要注意的几个地方</h3><ol>
<li><p>键名不是双引号的（包括没有引号或者是单引号），会自动变成双引号；字符串是单引号的，会自动变成双引号。</p>
</li>
<li><p>最后一个属性后面有逗号的，会被自动去掉。</p>
</li>
<li><p>非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中 这个好理解，也就是对非数组对象在最终字符串中不保证属性顺序和原来一致。</p>
</li>
<li><p>布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值 也就是你的什么<code>new String(“bala”)</code>会变成”bala”，<code>new Number(2017)</code>会变成2017。</p>
</li>
<li><p><code>undefined</code>、任意的函数（除了一个toJSON函数）以及 symbol值。</p>
<ul>
<li>出现在非数组对象的属性值中：在序列化过程中会被忽略。</li>
<li>出现在数组中时：被转换成 <code>null</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="attr">x</span>: <span class="literal">undefined</span>, <span class="attr">y</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;, <span class="attr">z</span>: <span class="built_in">Symbol</span>(<span class="string">&quot;&quot;</span>)&#125;);  </span><br><span class="line"><span class="comment">//出现在非数组对象的属性值中被忽略：&quot;&#123;&#125;&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify([<span class="literal">undefined</span>, <span class="built_in">Object</span>, <span class="built_in">Symbol</span>(<span class="string">&quot;&quot;</span>)]);  </span><br><span class="line"><span class="comment">//出现在数组对象的属性值中，变成null：&quot;[null,null,null]&quot;</span></span><br></pre></td></tr></table></figure>

<p> 如果在一个JavaScript对象上实现了 <code>JSON.stringify</code> 序列化对象时，调用了这个对象的 <code>toJSON</code> 函数返回值作为参数，那么该函数就不会被忽略：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> info=&#123;  </span><br><span class="line">    <span class="string">&quot;msg&quot;</span>:<span class="string">&quot;I Love You&quot;</span>,</span><br><span class="line">    <span class="string">&quot;toJSON&quot;</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> replaceMsg=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">        replaceMsg[<span class="string">&quot;msg&quot;</span>]=<span class="string">&quot;Go Die&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> replaceMsg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">JSON</span>.stringify(info);  </span><br><span class="line"><span class="comment">//返回的是：&#x27;&quot;&#123;&quot;msg&quot;:&quot;Go Die&quot;&#125;&quot;&#x27;, 函数并不会被忽略</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="将JSON字符串解析为JavaScript数据结构"><a href="#将JSON字符串解析为JavaScript数据结构" class="headerlink" title="将JSON字符串解析为JavaScript数据结构"></a>将JSON字符串解析为JavaScript数据结构</h2><p><strong>JSON.parse</strong></p>
<p><code>JSON.parse(text, reviver)</code></p>
<p>如果只使用第一个参数，如果该字符串不是合法的JSON字符串的话，就会抛出错误。这里的第二个参数如果使用的话，必须是一个函数，这个函数的作用是在属性被解析完成但是还没有返回前，将属性处理后再返回：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> friend=&#123;  </span><br><span class="line">    <span class="string">&quot;firstName&quot;</span>: <span class="string">&quot;Good&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lastName&quot;</span>: <span class="string">&quot;Man&quot;</span>,</span><br><span class="line">    <span class="string">&quot;phone&quot;</span>:&#123;<span class="string">&quot;home&quot;</span>:<span class="string">&quot;1234567&quot;</span>,<span class="string">&quot;work&quot;</span>:[<span class="string">&quot;7654321&quot;</span>,<span class="string">&quot;999000&quot;</span>]&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//我们先将其序列化</span></span><br><span class="line"><span class="keyword">var</span> friendAfter=<span class="built_in">JSON</span>.stringify(friend);  </span><br><span class="line"><span class="comment">//&#x27;&#123;&quot;firstName&quot;:&quot;Good&quot;,&quot;lastName&quot;:&quot;Man&quot;,&quot;phone&quot;:&#123;&quot;home&quot;:&quot;1234567&quot;,&quot;work&quot;:[&quot;7654321&quot;,&quot;999000&quot;]&#125;&#125;&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//再将其解析出来，在第二个参数的函数中打印出key和value</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(friendAfter,<span class="function"><span class="keyword">function</span>(<span class="params">k,v</span>)</span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(k);</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;----&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">firstName  </span></span><br><span class="line"><span class="comment">Good  </span></span><br><span class="line"><span class="comment">----</span></span><br><span class="line"><span class="comment">lastName  </span></span><br><span class="line"><span class="comment">Man  </span></span><br><span class="line"><span class="comment">----</span></span><br><span class="line"><span class="comment">home  </span></span><br><span class="line"><span class="comment">1234567  </span></span><br><span class="line"><span class="comment">----</span></span><br><span class="line"><span class="comment">0  </span></span><br><span class="line"><span class="comment">7654321  </span></span><br><span class="line"><span class="comment">----</span></span><br><span class="line"><span class="comment">1  </span></span><br><span class="line"><span class="comment">999000  </span></span><br><span class="line"><span class="comment">----</span></span><br><span class="line"><span class="comment">work  </span></span><br><span class="line"><span class="comment">[]</span></span><br><span class="line"><span class="comment">----</span></span><br><span class="line"><span class="comment">phone  </span></span><br><span class="line"><span class="comment">Object  </span></span><br><span class="line"><span class="comment">----</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">Object  </span></span><br><span class="line"><span class="comment">----</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>仔细看一下输出，可以发现这个遍历是由内而外的，这个由内而外指的是对于复合属性来说的，通俗地讲，遍历的时候，从头到尾进行遍历，如果是简单属性值（数值、字符串、布尔值和null），那么直接遍历完成，如果是遇到属性值是对象或者数组形式的，那么暂停，先遍历这个子JSON，而遍历的原则也是一样的，等这个复合属性遍历完成，那么再完成对这个属性的遍历返回。</p>
<p>本质上，这就是一个深度优先的遍历。</p>
]]></content>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP常用语法</title>
    <url>/2020/01/16/JSP%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>JSP页面本质上为一个Servlet程序，当我们第一次访问JSP页面时，服务器会将JSP页面翻译成一个Servlet类。比如，一个JSP文件为 user.jsp  那么就会被翻译成 public final class user_jsp extends HttpJspBase implements…</p>
<p>而HttpJspBase extends HttpServlet implements HttpJspPage</p>
<p>具体做的事情给个简单例子：</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=utf-8&quot;</span> language=<span class="string">&quot;java&quot;</span>%&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    	......</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    	......</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>编译后，会将该jsp文件内容转化成servlet文件，内容大体如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">void</span> <span class="function"><span class="title">_jspService</span>(<span class="params">HttpServletRequest request, HttpServletResponse response</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//省略其它内容</span></span><br><span class="line">    out = pageContext.getOut();</span><br><span class="line">    _jspx_out = out;</span><br><span class="line">    out.write(<span class="string">&quot;rn&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;!DOCTYPE HTML PUBLIC &#x27;-//W3C//DTD HTML 4.0 Transitional//EN&#x27;&gt;rn&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;html&gt;rn&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;head&gt;rn&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;...rn&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;/head&gt;rn&quot;</span>)</span><br><span class="line">    out.write(<span class="string">&quot;&lt;body&gt;rn&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;...rn&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;/body&gt;rn&quot;</span>);</span><br><span class="line">    out.write(<span class="string">&quot;&lt;/html&gt;rn&quot;</span>);</span><br><span class="line">    <span class="comment">//省略其它内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h2><blockquote>
<p><strong>头部page指令：设置页面的一些参数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;&lt;%@ page  language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html;charset=utf-8&quot;</span> pageEncoding=<span class="string">&quot;utf-8&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>

<p>常用属性：</p>
<p>contentType——设置响应数据字符集</p>
<p>pageEncoding——设置页面的字符集</p>
<p>import——导入java包，用于编写JSP页面中的java代码</p>
<p>errorPage——页面出错时的跳转地址</p>
</blockquote>
<blockquote>
<p><strong>声明脚本：属性声明，静态代码块使用，方法，内部类，注释，都遵守Java语法。相当于在编译后的Servlet类中定义这些java代码</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">&lt;%! </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="comment">//静态块代码</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//方法</span></span><br><span class="line">	&#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">user_jsp</span> <span class="title">extends</span> <span class="title">HttpJspBase</span> <span class="title">implements</span>... &#123;</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="comment">//静态块代码</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> _jspService(HttpServletRequest request, HttpServletResponse response&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>表达式脚本：在页面中显示的值</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;%=在页面中展示的值%&gt;</span><br><span class="line">如：</span><br><span class="line">&lt;%=<span class="string">&quot;12 * 12 = &quot;</span> + <span class="number">12</span> * <span class="number">12</span>%&gt;</span><br><span class="line">&lt;%=request.getParameter(<span class="string">&quot;username&quot;</span>)%&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">public <span class="keyword">void</span> _jspService(HttpServletRequest request, HttpServletResponse response&#123;</span><br><span class="line">	<span class="comment">//省略其它内容</span></span><br><span class="line">    out.write(<span class="string">&quot;12 * 12 = &quot;</span> + <span class="number">12</span> * <span class="number">12</span> + <span class="string">&quot;rn&quot;</span>);</span><br><span class="line">	out.write(request.getParameter(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>JSP注释：代码说明</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;%-- 注释 --%&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>Java代码脚本：相当于在编译后的Servlet类的_jspService方法中定义代码内容</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">12</span>;</span><br><span class="line">	System.out.println(<span class="string">&quot;i的值：&quot;</span> + i);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspService</span><span class="params">(HttpServletRequest request, HttpServletResponse response&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">	//省略其它内容</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> i = <span class="number">12</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    System.out.println(<span class="string">&quot;i的值：&quot;</span> + i)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>JSP的两种include指令机制：</strong></p>
<p><code>&lt;%@ include file=”header.jsp” %&gt;</code> 也称为include指令。通过file属性来指定包含的页面，当JSP转换成Servlet时引入指定文件。</p>
<p><code>&lt;jsp:include page=”header.jsp” /&gt;</code> 也称为include动作。通过page属性来指定被包含的页面，当JSP页面被请求时引入指定文件，通常用于经常改动的JSP页面，且因为被包含的JSP的改动不会影响到包含的JSP，因此不需要对包含文件进行重新编译。</p>
<p>用法区别：</p>
<ol>
<li>引入的内容不同，执行时间不同</li>
</ol>
<p>  &lt;%@include file=””%&gt; (静态包含)将被包含的文件原封不动第插入到包含页面中使用该指令的位置，然后JSP编译器再对这个合成的文件进行编译，最终编译后的文件只有一个，在翻译阶段执行。</p>
<p>  (该指令属于编译指令，发生在JSP转换为Servlet阶段。简单来说，就是在转换阶段将被包含的文件内容复制到当前页面中，然后和当前页面一起编译生成一个Servlet文件。由于容器是把两个文件合并后再执行编译，所以编译后只会生成一个class文件，因此，不管是主文件或者是被包含文件发送改变，容器都需要重新编译主文件。所以，一般而言，include指令包含静态的资源文件，比如页眉和页脚。)</p>
<ol start="2">
<li>&lt;jsp:include page=””/&gt; (动态包含)包含文件时，当该动作标识执行后，JSP程序会将请求转发到(不是重定向)被包含页面，并将执行结果输出到浏览器中，然后继续执行后面的代码，因为web容器执行两个文件，所以JSP编译器会分别对这两个文件进行编译，在请求处理阶段执行。</li>
</ol>
<p>  (该动作属于运行时方法调用，发生再运行Servlet生成响应的阶段。简单来说，就是在运行servlet时插入被包含文件的响应内容。该动作的关键在于，容器需要根据页面属性创建出一个RequestDispatcher并调用include()方法，将被包含文件的响应插到当前响应中，然后一起输出。</p>
<p>  使用include动作时，容器会分别对主文件和被包含文件进行单独的编译，所以编译后会产生两个class文件。另外，被包含文件的编译工作是在主文件运行时发生的。因此，被包含文件发送改变时，只需要重新编译被包含文件即可，而无须重新编译主文件。一般使用include动作包含经常需要变动的文件。)</p>
<p>使用注意：<br>对于include指令，由于是在编译时包含源文件，所以被包含页面可以包含可能影响主页面的JSP构造，如文档类型的设定等，不过要避免声明相同的变量或方法，否则会产生编译错误。</p>
<p>对于include动作，由于是在运行时包含响应内容，因此被包含页面不能使用任何会影响主页面的JSP构造。另外被包含页面不能包含开始和结束html及body标签。被包含页面不能修改响应状态码或者设置首部。</p>
</blockquote>
<h2 id="JSP内置对象"><a href="#JSP内置对象" class="headerlink" title="JSP内置对象"></a>JSP内置对象</h2><blockquote>
<h4 id="request-response-session-application-out-pageContext-config-page-exception"><a href="#request-response-session-application-out-pageContext-config-page-exception" class="headerlink" title="request/response/session/application/out/pageContext/config/page/exception"></a>request/response/session/application/out/pageContext/config/page/exception</h4></blockquote>
<hr>
<blockquote>
<p><strong>request对象：</strong> HttpServletRequest，封装客户端的请求信息，主要包括HTTP头信息、系统信息、请求方式、请求参数等。常用方法如下</p>
<table>
<thead>
<tr>
<th>String getParameter(String name)</th>
<th>根据name属性的值获取请求数据</th>
</tr>
</thead>
<tbody><tr>
<td>String[] getParameterValues(String name)</td>
<td>根据name属性的值获取多个请求数据</td>
</tr>
<tr>
<td>void setCharacterEncoding(String enc)</td>
<td>设定解析请求数据的编码格式，防止读取的数据的编码格式和请求数据编码格式的不一致出现乱码问题</td>
</tr>
<tr>
<td>request getRequestDispatcher(String path)</td>
<td>请求转发</td>
</tr>
<tr>
<td>void setAttribute(String name, Object)</td>
<td>将数据保存到request范围的变量中</td>
</tr>
<tr>
<td>Object getAttribute(String name)</td>
<td>获取request范围的变量中的数据</td>
</tr>
<tr>
<td>void removeAttribute(String name)</td>
<td>删除request范围的变量中的数据</td>
</tr>
<tr>
<td>Cookie[] getCookies()</td>
<td>获取所有Cookie对象</td>
</tr>
</tbody></table>
<p><strong>request作用域：一次请求过程</strong></p>
</blockquote>
<hr>
<blockquote>
<p><strong>response对象：</strong> HttpServletResponse，对客户端的响应，想客户端输出信息。常用方法如下：</p>
<table>
<thead>
<tr>
<th>sendRedirect(String path)</th>
<th>网页重定向</th>
</tr>
</thead>
<tbody><tr>
<td>setHeader(String name, String value)</td>
<td>设置HTTP响应报头信息</td>
</tr>
</tbody></table>
<p><strong>response作用域：在JSP页面内有效</strong></p>
</blockquote>
<hr>
<blockquote>
<p><strong>session对象：</strong>HttpSession，由于HTTP协议为无状态协议，当一个客户端向服务器发出请求，服务器接收到请求并返回响应后，该连接就结束了，而服务器并不保存相关的信息。为了弥补这一缺点，HTTP协议提供的session，通过session可以在应用程序的web页面间进行跳转时，保存用户的状态，使整个用户会话一直存在下去，直到浏览器关闭。</p>
<p><strong>session作用域：</strong>一次会话内有效(浏览器关闭前)</p>
</blockquote>
<hr>
<blockquote>
<p><strong>application对象：</strong>ServletContext，保存所有应用中共有数据，在服务器启动时自动创建，在服务器停止时销毁，所有用户均可访问，类似于全局变量</p>
<p><strong>application作用域：</strong>整个应用中都有效，保存的信息为全局变量</p>
</blockquote>
<hr>
<blockquote>
<p><strong>out对象：</strong>JspWriter，用于在浏览器内输出信息，并管理应用服务器上的输出缓冲区</p>
<p><strong>out作用域：</strong>当前页面内有效</p>
</blockquote>
<hr>
<blockquote>
<p><strong>pageContext对象：</strong>PageContext，由容器进行初始化和创建，可以获取当前页面的request/response/session/out/exception等对象</p>
<p><strong>pageContext作用域：</strong>当前页面内有效</p>
</blockquote>
<hr>
<blockquote>
<p><strong>config对象：</strong>ServletConfig，读取web.xml配置信息。当一个Servlet初始化时，容器会把某些信息通过config对象传递给这个Servlet。开发者可以在web.xml文件中为应用程序环境中的Servlet程序和JSP页面提供初始化参数。</p>
</blockquote>
<hr>
<blockquote>
<p><strong>page对象：</strong>JspPage，代表JSP页面本身</p>
<p><strong>page作用域：</strong>当前页面内有效</p>
</blockquote>
<hr>
<blockquote>
<p><strong>exception：</strong>JspException，处理JSP文件执行时发生的所有错误和一次，只要在page指令中设置isErrorPage属性值为true的页面中才可使用</p>
</blockquote>
<hr>
<h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><blockquote>
<p><strong>EL表达式主要用于代替JSP页面中的表达式脚本&lt;%=…%&gt;</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;%=request.getAttribute(<span class="string">&quot;username&quot;</span>)%&gt;</span><br><span class="line">用EL表达式代替：$&#123;username&#125;</span><br></pre></td></tr></table></figure>

<p>因为一个页面内存在多个域对象，而域对象间是会存在相同key名称的键值对。因此，EL在进行数据搜索时，会按照如下的顺序搜索：pageContext域（当前页面）——&gt;request域（当前请求）——&gt;session域（会话）——&gt;application域（ServletContext）</p>
<p>当4个域对象都有同名键值对时，EL表达式只会搜索到pageContext域对象中的键值对。</p>
<p>此外，因为四个域对象的setAttribute(String key, Object value)方法签名相同，所有EL表达式的写法固定，均为${key}，而因为获取到的value是Object类型的，这意味着${key}得到的可以是对象，数组，链表，基本数据类型，Map等任何数据。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String[] school;</span><br><span class="line">    List&lt;String&gt; city;</span><br><span class="line">    Map&lt;String, String&gt; family;</span><br><span class="line">    <span class="comment">//对应的getter和setter方法省略</span></span><br><span class="line">&#125;</span><br><span class="line">Person person = <span class="keyword">new</span> Person(省略);</span><br><span class="line">request.setAttribute(<span class="string">&quot;doug&quot;</span>, person);</span><br><span class="line">通过EL表达式，我们就可以对属性(必须要有getter和setter方法)进行如下操作:</span><br><span class="line">$&#123;darby&#125;  获取person对象</span><br><span class="line">$&#123;darby.name&#125;  获取person对象的name属性(通过getName方法)</span><br><span class="line">$&#123;darby.school&#125;  获取person对象的school属性(通过getSchool方法)</span><br><span class="line">$&#123;darby.school[<span class="number">0</span>]&#125; 获取shool属性中的值</span><br><span class="line">$&#123;darby.city&#125;</span><br><span class="line">$&#123;darby.city[<span class="number">0</span>]&#125;</span><br><span class="line">$&#123;darby.family&#125;  获取family属性(通过getFamily方法)</span><br><span class="line">$&#123;darby.family.mother&#125;  获取family属性某个特定键值对中的value</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h2><blockquote>
<p>全称：Jsp Standard Tag Library Jsp标准标签库</p>
<p><strong>主要用于替换JSP在的java代码脚本 &lt;%    %&gt;</strong></p>
<p>主要标签库：</p>
<p><strong>核心标签库：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span>%&gt;</span><br></pre></td></tr></table></figure>

<p>格式化标签库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;fmt&quot;</span> uri=<span class="string">&quot;http://java.sum.com/jsp/jstl/fmt&quot;</span>%&gt;</span><br></pre></td></tr></table></figure>

<p>函数标签库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;fmt&quot;</span> uri=<span class="string">&quot;http://java.sum.com/jsp/jstl/functions&quot;</span>%&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <tags>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC之CountDownLatch</title>
    <url>/2020/08/27/JUC%E4%B9%8BCountDownLatch/</url>
    <content><![CDATA[<p>CountDownLatch允许一个或多个线程等待其他线程完成操作。定义CountDownLatch的时候，需要传入一个正数来初始化计数器（虽然传入0也可以，但这样的话CountDownLatch没什么实际意义）。其<code>countDown</code>方法用于递减计数器，<code>await</code>方法会使当前线程阻塞，直到计数器递减为0。所以CountDownLatch常用于多个线程之间的协调工作。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>假设现在有这样一个需求：</p>
<ol>
<li>从数据库获取数据</li>
<li>对这批数据进行处理</li>
<li>保存这批数据</li>
</ol>
<p>为了让程序执行效率更高，第2步中我们可以使用多线程来并行处理这批数据，大致过程如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 模拟从数据库获取数据</span></span><br><span class="line">        <span class="keyword">int</span>[] data = query();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取数据完毕&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 数据处理</span></span><br><span class="line">        IntStream.range(<span class="number">0</span>, data.length).forEach(i -&gt; &#123;</span><br><span class="line">            ExecutorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;处理第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> value = data[i];</span><br><span class="line">                <span class="keyword">if</span> (value % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    data[i] = value * <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    data[i] = value * <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;所有数据都处理完了&quot;</span>);</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        ExecutorService.shutdown();</span><br><span class="line">        <span class="comment">// 3. 保存数据</span></span><br><span class="line">        save(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] query() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存数据 - &quot;</span> + Arrays.toString(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于线程获取CPU时间片的不确定性，所以有可能数据还没有处理完毕，第3步就执行完了：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">获取数据完毕</span><br><span class="line">所有数据都处理完了</span><br><span class="line">保存数据 - [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">2</span>,<span class="number">5</span>,main]处理第<span class="number">2</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">1</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">2</span>,<span class="number">5</span>,main]处理第<span class="number">3</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">4</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">6</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">2</span>,<span class="number">5</span>,main]处理第<span class="number">5</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">7</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">9</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">2</span>,<span class="number">5</span>,main]处理第<span class="number">8</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">10</span>条数据</span><br></pre></td></tr></table></figure>

<p>可以借助CountDownLatch解决这个问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService ExecutorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 模拟从数据库获取数据</span></span><br><span class="line">        <span class="keyword">int</span>[] data = query();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取数据完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 数据处理</span></span><br><span class="line">        IntStream.range(<span class="number">0</span>, data.length).forEach(i -&gt; &#123;</span><br><span class="line">            ExecutorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;处理第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> value = data[i];</span><br><span class="line">                <span class="keyword">if</span> (value % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    data[i] = value * <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    data[i] = value * <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有数据都处理完了&quot;</span>);</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        ExecutorService.shutdown();</span><br><span class="line">        <span class="comment">// 3. 保存数据</span></span><br><span class="line">        save(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] query() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存数据 - &quot;</span> + Arrays.toString(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码定义一个CountDownLatch，计数器值为10，和数据量一致。然后在第2步中，当每个线程执行完毕的时候调用<code>countDown</code>方法，让计数器减1。在第3步前调用<code>await</code>方法让main线程阻塞等待，直到计数器被减为0。所以这就保证了只有当所有数据加工完毕才执行保存数据操作。</p>
<p>执行方法，程序输出如下所示：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">获取数据完毕</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">1</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">3</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">4</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">5</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">6</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">7</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">8</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">9</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]处理第<span class="number">10</span>条数据</span><br><span class="line"><span class="keyword">Thread</span>[pool-<span class="number">1</span>-<span class="keyword">thread</span>-<span class="number">2</span>,<span class="number">5</span>,main]处理第<span class="number">2</span>条数据</span><br><span class="line">所有数据都处理完了</span><br><span class="line">保存数据 - [<span class="number">10</span>, <span class="number">4</span>, <span class="number">30</span>, <span class="number">8</span>, <span class="number">50</span>, <span class="number">12</span>, <span class="number">70</span>, <span class="number">16</span>, <span class="number">90</span>, <span class="number">20</span>]</span><br></pre></td></tr></table></figure>

<p><code>await</code>有重载方法：<code>await(long timeout, TimeUnit unit)</code>，设置最大等待时间，超过这个时间程序将继续执行不再被阻塞：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;线程执行完毕&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"> </span><br><span class="line">        latch.await(<span class="number">3</span>, TimeUnit.SECONDS); <span class="comment">// 最多等待 3秒</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main线程执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">main</span>线程执行完毕</span><br><span class="line"><span class="attribute">Thread</span>[thread<span class="number">1</span>,<span class="number">5</span>,main]线程执行完毕</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>countDownLatch</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC之CyclicBarrier</title>
    <url>/2020/08/27/JUC%E4%B9%8BCyclicBarrier/</url>
    <content><![CDATA[<p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。CyclicBarrier默认的构造方法是<code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用<code>await</code>方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>使用“人满发车”的例子来演示CyclicBarrier：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;快上车来不及解释了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;已上车&quot;</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;所有人已上车，发车&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Jane&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;已上车&quot;</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;所有人已上车，发车&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Mike&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中我们定义了一个等待2个线程完成的CyclicBarrier，在两个线程内部调用了<code>await</code>方法，让其阻塞等待，并告知CyclicBarrier我已经到达屏障了。只有当两个线程都执行到<code>barrier.await()</code>这一行时，屏障开启，线程才会继续往下执行。程序输出如下所示：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">快上车来不及解释了</span><br><span class="line"><span class="keyword">Thread</span>[Mike,<span class="number">5</span>,main]已上车</span><br><span class="line"><span class="keyword">Thread</span>[Jane,<span class="number">5</span>,main]已上车</span><br><span class="line">所有人已上车，发车</span><br><span class="line">所有人已上车，发车</span><br></pre></td></tr></table></figure>

<p>CyclicBarrier的构造函数支持传入一个回调方法：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier<span class="function"><span class="params">(n, () -&gt; &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    System.out.println(<span class="string">&quot;当所有线程到达屏障时，执行该回调&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span>;</span></span><br></pre></td></tr></table></figure>



<p>改造上面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发车，嘟嘟嘟&quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;快上车来不及解释了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;已上车&quot;</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;所有人已上车&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Jane&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;已上车&quot;</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;所有人已上车&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Mike&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下所示：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">快上车来不及解释了</span><br><span class="line"><span class="keyword">Thread</span>[Mike,<span class="number">5</span>,main]已上车</span><br><span class="line"><span class="keyword">Thread</span>[Jane,<span class="number">5</span>,main]已上车</span><br><span class="line">发车，嘟嘟嘟</span><br><span class="line">所有人已上车，发车</span><br><span class="line">所有人已上车，发车</span><br></pre></td></tr></table></figure>

<h2 id="设置超时时间"><a href="#设置超时时间" class="headerlink" title="设置超时时间"></a>设置超时时间</h2><p><code>await</code>的重载方法：<code>await(long timeout, TimeUnit unit)</code>可以设置最大等待时长，超出这个时间屏障还没有开启的话则抛出<code>TimeoutException</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;继续执行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier.await(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;继续执行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/cyclicBarrier%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE.png"></p>
<h2 id="BrokenBarrierException"><a href="#BrokenBarrierException" class="headerlink" title="BrokenBarrierException"></a>BrokenBarrierException</h2><p>抛出<code>BrokenBarrierException</code>异常时表示屏障破损，此时标志位broken=true。抛出<code>BrokenBarrierException</code>异常的情况主要有：</p>
<ol>
<li>其他等待的线程被中断，则当前线程抛出<code>BrokenBarrierException</code>异常；</li>
<li>其他等待的线程超时，则当前线程抛出<code>BrokenBarrierException</code>异常；</li>
<li>当前线程在等待时，其他线程调用CyclicBarrier.reset()方法，则当前线程抛出BrokenBarrierException异常。</li>
</ol>
<p>模拟第1种情况，其他等待的线程被中断，则当前线程抛出<code>BrokenBarrierException</code>异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;继续执行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;继续执行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread2.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/BrokenBarrierException%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></p>
<p>上面例子中thread2线程睡眠1秒后先到达屏障点，然后进入等待状态。2秒后main线程执行<code>thread2.interrupt()</code>中断等待中的thread2线程，所以程序抛出<code>BrokenBarrierException</code>异常。3秒后thread1线程到达屏障点，此时屏障已经被破坏了，所以也抛出<code>BrokenBarrierException</code>异常。</p>
<p>模拟第2种情况：其他等待的线程超时，则当前线程抛出<code>BrokenBarrierException</code>异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;继续执行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                barrier.await(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;继续执行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException | TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="/images/BrokenBarrierException%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C2.png"></p>
<p>上面例子中thread2睡眠1秒后到达屏障点，然后进入等待状态（最多等待1秒），然而因为thread1要3秒后才能到达屏障点，所以thread2将抛出<code>TimeoutException</code>。3秒后，thread1到达屏障点，但这时候由于thread2的<code>await</code>方法抛出的异常破坏了屏障，所以thread1将抛出<code>BrokenBarrierException</code>异常。</p>
<p>模拟第3中情况：当前线程在等待时，其他线程调用CyclicBarrier.reset()方法，则当前线程抛出BrokenBarrierException异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;继续执行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;继续执行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        System.out.println(barrier.getNumberWaiting());</span><br><span class="line">        barrier.reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="/images/BrokenBarrierException%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C3.png"></p>
<p>上面例子中，thread2睡眠1秒后到达屏障点，然后进入等待状态。2秒后main线程调用<code>reset</code>方法重置了屏障，所以在等待状态中的thread2抛出<code>BrokenBarrierException</code>异常。3秒后，thread1到达屏障点，由于<code>reset</code>方法重置了屏障，所以thread1并不会抛出<code>BrokenBarrierException</code>异常，而是一直在屏障点进行等待别的线程到达屏障点。</p>
<p><strong>从上面的三个例子中可以看到，无论是哪种情况导致屏障破坏，屏障点后面的代码都没有被执行，main方法也没有退出。</strong></p>
<h2 id="和CountDownLatch区别"><a href="#和CountDownLatch区别" class="headerlink" title="和CountDownLatch区别"></a>和CountDownLatch区别</h2><ol>
<li>CountDownLatch：一个线程(或者多个)，等待另外N个线程完成某个事情之后才能执行；CyclicBarrier：N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。</li>
<li>CountDownLatch：一次性的；CyclicBarrier：可以重复使用。</li>
</ol>
]]></content>
      <tags>
        <tag>cyclicBarrier</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC之Exchanger</title>
    <url>/2020/08/24/JUC%E4%B9%8BExchanger/</url>
    <content><![CDATA[<p>JUC中的Exchanger允许<strong>成对的</strong>线程在指定的同步点上通过<code>exchange</code>方法来交换数据。如果第一个线程先执行<code>exchange</code>方法，它会一直等待第二个线程也 执行<code>exchange</code>方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将当前线程生产 出来的数据传递给对方。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>两个线程通过Exchanger交换数据的简单示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1开始&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">&quot;来自thread1的数据&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收thread2发送的数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2开始&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">&quot;来自thread2的数据&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收thread1发送的数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在定义Exchanger的时候需要指定交换的数据类型，这里为String类型。<code>exchange</code>方法用于向另一个线程发送数据，方法的返回值为另一个线程发送过来的数据。上面例子输出如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">thread1开始</span><br><span class="line">thread2开始</span><br><span class="line">接收thread2发送的数据：来自thread2的数据</span><br><span class="line">thread1结束</span><br><span class="line">接收thread1发送的数据：来自thread1的数据</span><br><span class="line">thread2结束</span><br></pre></td></tr></table></figure>

<p>只有当成对的线程都到达同步点的时候，才会执行数据交换操作。现在让thread2休眠一会儿，看看thread1是否会进入等待：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> ExchangerTest &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        final Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Thread(()</span> -&gt; &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;thread1开始&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">&quot;来自thread1的数据&quot;</span>);</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;接收thread2发送的数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;thread1结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Thread(()</span> -&gt; &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;thread2开始&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">TimeUnit</span>.</span><span class="module"><span class="identifier">SECONDS</span>.</span></span>sleep(<span class="number">3</span>); <span class="comment">// thread1也会进入等待，直到双方都准备好交换数据。</span></span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">&quot;来自thread2的数据&quot;</span>);</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;接收thread1发送的数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;thread2结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">thread1开始</span><br><span class="line">thread2开始</span><br><span class="line"><span class="regexp">//</span> 等待几秒后</span><br><span class="line">接收thread1发送的数据：来自thread1的数据</span><br><span class="line">thread2结束</span><br><span class="line">接收thread2发送的数据：来自thread2的数据</span><br><span class="line">thread1结束</span><br></pre></td></tr></table></figure>

<p>如果线程不成对会出现什么情况呢？我们添加thread3线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1开始&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">&quot;发送数据-thread1&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2开始&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">&quot;发送数据-thread2&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread3开始&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">&quot;发送数据-thread3&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread3结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread3&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下所示：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">thread1开始</span><br><span class="line">thread3开始</span><br><span class="line">接收数据：发送数据-thread1</span><br><span class="line">thread3结束</span><br><span class="line">thread2开始</span><br><span class="line">接收数据：发送数据-thread3</span><br><span class="line">thread1结束</span><br></pre></td></tr></table></figure>

<p>可看到thread1和thread3交换了数据然后正常停止了，而thread2由于没有线程和它交换数据而苦苦等待，线程永远不会停止。查看线程快照可以证明这点：</p>
<p><img src="/images/thread2%E5%BF%AB%E7%85%A7.png"></p>
<p>线程匹配是随机的，所以也有可能thread1和thread2匹配，thread3进入无休止的等待</p>
<p>另一个值得一提的点就是通过Exchanger交换的是同一个对象，而不是对象的拷贝：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;Object&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1开始&quot;</span>);</span><br><span class="line">            Object object = <span class="keyword">new</span> Object();</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1发送数据：&quot;</span> + object);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object exchange = exchanger.exchange(object);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收thread2发送的数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2开始&quot;</span>);</span><br><span class="line">            Object object = <span class="keyword">new</span> Object();</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2发送数据：&quot;</span> + object);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object exchange = exchanger.exchange(object);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收thread1发送的数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">thread<span class="number">1</span>开始</span><br><span class="line">thread<span class="number">2</span>开始</span><br><span class="line">thread<span class="number">2</span>发送数据：java.lang.Object<span class="title">@6</span>d<span class="number">559005</span></span><br><span class="line">thread<span class="number">1</span>发送数据：java.lang.Object<span class="title">@7702</span><span class="keyword">c</span><span class="number">19</span></span><br><span class="line">接收thread<span class="number">2</span>发送的数据：java.lang.Object<span class="title">@6</span>d<span class="number">559005</span></span><br><span class="line">接收thread<span class="number">1</span>发送的数据：java.lang.Object<span class="title">@7702</span><span class="keyword">c</span><span class="number">19</span></span><br><span class="line">thread<span class="number">2</span>结束</span><br><span class="line">thread<span class="number">1</span>结束</span><br></pre></td></tr></table></figure>

<p>可以看到thread1发送的对象和thread2接收的对象句柄是一致的。</p>
<h2 id="设置超时时间"><a href="#设置超时时间" class="headerlink" title="设置超时时间"></a>设置超时时间</h2><p>如果不想线程在交换数据的时候等待过长的时间，我们可以使用<code>exchanger</code>的重载方法<code>exchange(V x, long timeout, TimeUnit unit)</code>来指定超时时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1开始&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">&quot;来自thread1的数据&quot;</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收thread2发送的数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2开始&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">&quot;来自thread2的数据&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收thread1发送的数据：&quot;</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中，thread2休眠10秒后才开始交换数据，而thread1在等待5秒后没能成功交换数据就抛出<code>TimeoutException</code>异常了。10秒后由于没有线程再和thread2交换数据，所以thread2会一直等待：</p>
<p><img src="/images/thread2%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C.png"></p>
<p><img src="/images/%E8%B6%85%E6%97%B6%E5%BF%AB%E7%85%A7.png"></p>
]]></content>
      <tags>
        <tag>juc, exchanger</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC之Semaphore</title>
    <url>/2020/08/27/JUC%E4%B9%8BSemaphore/</url>
    <content><![CDATA[<p>JUC的Semaphore俗称信号量，可用来控制同时访问特定资源的线程数量。通过它的构造函数可以指定信号量（称为许可证permits可能更为明确）的数量，线程可以调用Semaphore对象的<code>acquire</code>方法获取一个许可证，调用<code>release</code>来归还一个许可证。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面举个Semaphore的基本使用示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 定义许可证数量</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">4</span>).forEach(i -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire(); <span class="comment">// 一次拿一个许可证</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取许可证&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;释放许可证&quot;</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">            &#125;, <span class="string">&quot;thread&quot;</span> + (i + <span class="number">1</span>)).start();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，定义许可证的数量为2个，然后4个线程通过<code>acquire</code>方法去获取许可证，结束行通过<code>release</code>方法释放许可证。<code>acquire</code>方法默认一次只拿一个许可证，所以上面的例子中，同一时刻最多只有两个线程同时执行。</p>
<p>程序输出如下所示：</p>
<p><img src="/images/samphore%E6%B5%8B%E8%AF%951.gif"></p>
<p><code>acquire</code>的重载方法<code>acquire(int permits)</code>允许线程一次性获取N个许可证；同样的<code>release</code>的重载方法<code>release(int permits)</code>允许线程一次性释放N个许可证。</p>
<p>Semaphore还有一个<code>tryAcquire</code>，它允许线程尝试去获取1个许可证，如果许可证不足没有获取到的话，线程也会继续执行，而非阻塞等待。<code>tryAcquire</code>方法的重载方法<code>tryAcquire(long timeout, TimeUnit unit)</code>可以指定尝试获取许可证的超时时间。</p>
<h2 id="acquireUninterruptibly"><a href="#acquireUninterruptibly" class="headerlink" title="acquireUninterruptibly"></a>acquireUninterruptibly</h2><p>从上面的例子会发现<code>acquire</code>方法会抛出<code>InterruptedException</code>异常，说明这个方法是可以被打断的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;semaphore InterruptedException&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.MICROSECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子thread1线程获取2个许可证，但许可证总数只有1个，所以会阻塞等待。main线程通过调用thread1的<code>interrupt</code>方法去打断thread1线程，结果如下：</p>
<p><img src="/images/samephore%E7%BA%BF%E7%A8%8B%E8%A2%AB%E6%89%93%E6%96%AD.png"></p>
<p>而通过<code>acquireUninterruptibly</code>方法去获取许可证是不可被打断的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            semaphore.acquireUninterruptibly(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.MICROSECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序并不会抛出<code>InterruptedException</code>，thread1会一直处于阻塞状态。</p>
<h2 id="drainPermits"><a href="#drainPermits" class="headerlink" title="drainPermits"></a>drainPermits</h2><p><code>drainPermits</code>方法一次性获取所有许可证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;availablePermits: &quot;</span> + semaphore.availablePermits());</span><br><span class="line">            semaphore.drainPermits(); <span class="comment">// 获取所有许可证，抽干</span></span><br><span class="line">            System.out.println(<span class="string">&quot;availablePermits: &quot;</span> + semaphore.availablePermits());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            semaphore.release(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>availablePermits</code>方法用于获取当前可用许可证数量的预估值。程序输出如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">availablePermits</span>：<span class="number">5</span></span><br><span class="line"><span class="attribute">availablePermits</span>：<span class="number">0</span></span><br><span class="line"><span class="attribute">thread1</span>结束</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>hasQueuedThreads</code>方法用于判断是否有处于等待获取许可证状态的线程；<code>getQueueLength</code>用于获取处于等待获取许可证状态的线程的数量；<code>getQueuedThreads</code>用于获取处于等待获取许可证状态的线程集合。</p>
<p><code>getQueuedThreads</code>是<code>protected</code>的，所以要使用它，我们得自定义一个Semaphore的子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义许可证数量</span></span><br><span class="line">        <span class="keyword">final</span> MySemaphore semaphore = <span class="keyword">new</span> MySemaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">4</span>).forEach(i -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取许可证&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;释放许可证&quot;</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">            &#125;, <span class="string">&quot;thread&quot;</span> + (i + <span class="number">1</span>)).start();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (semaphore.hasQueuedThreads()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;等待线程数量：&quot;</span> + semaphore.getQueueLength());</span><br><span class="line">                Collection&lt;Thread&gt; queuedThreads = semaphore.getQueuedThreads();</span><br><span class="line">                System.out.println(<span class="string">&quot;等待线程：&quot;</span> + queuedThreads.stream().map(Thread::getName).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MySemaphore</span> <span class="keyword">extends</span> <span class="title">Semaphore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2595494765642942297L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MySemaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MySemaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(permits, fair);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.getQueuedThreads();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下所示（截取一部分）：</p>
<p><img src="/images/semaphore%E7%BB%93%E6%9E%9C.png"></p>
<h2 id="常用方法总结"><a href="#常用方法总结" class="headerlink" title="常用方法总结"></a>常用方法总结</h2><p>Semaphore常用的方法：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>acquire()</code></td>
<td align="left">获取一个许可证，可以被打断，没有足够的许可证时阻塞等待</td>
</tr>
<tr>
<td align="left"><code>acquire(int permits)</code></td>
<td align="left">获取指定数量的许可证，可以被打断，没有足够的许可证时阻塞等待</td>
</tr>
<tr>
<td align="left"><code>acquireUninterruptibly()</code></td>
<td align="left">获取一个许可证，不可被打断，没有足够的许可证时阻塞等待</td>
</tr>
<tr>
<td align="left"><code>acquireUninterruptibly(int permits)</code></td>
<td align="left">获取指定数量的许可证，不可被打断，没有足够的许可证时阻塞等待</td>
</tr>
<tr>
<td align="left"><code>tryAcquire()</code></td>
<td align="left">尝试获取一个许可证，没有足够的许可证时程序继续执行，不会被阻塞</td>
</tr>
<tr>
<td align="left"><code>tryAcquire(int permits)</code></td>
<td align="left">尝试获取指定数量的许可证，没有足够的许可证时程序继续执行，不会被阻塞</td>
</tr>
<tr>
<td align="left"><code>tryAcquire(long timeout, TimeUnit unit)</code></td>
<td align="left">在指定的时间范围内尝试获取1个许可证，没有足够的许可证时程序继续执行， 不会被阻塞，在该时间方位内可以被打断</td>
</tr>
<tr>
<td align="left"><code>tryAcquire(int permits, long timeout, TimeUnit unit)</code></td>
<td align="left">在指定的时间范围内尝试获取指定数量的许可证，没有足够的许可证时程序 继续执行，不会被阻塞，在该时间方位内可以被打断</td>
</tr>
<tr>
<td align="left"><code>release()</code></td>
<td align="left">释放一个许可证</td>
</tr>
<tr>
<td align="left"><code>drainPermits()</code></td>
<td align="left">一次性获取所有可用的许可证</td>
</tr>
<tr>
<td align="left"><code>availablePermits()</code></td>
<td align="left">获取当前可用许可证数量的预估值</td>
</tr>
<tr>
<td align="left"><code>hasQueuedThreads()</code></td>
<td align="left">判断是否有处于等待获取许可证状态的线程</td>
</tr>
<tr>
<td align="left"><code>getQueueLength()</code></td>
<td align="left">获取处于等待获取许可证状态的线程的数量的预估值</td>
</tr>
<tr>
<td align="left"><code>getQueuedThreads()</code></td>
<td align="left">获取处于等待获取许可证状态的线程集合</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>juc, semaphore</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM相关知识</title>
    <url>/2020/01/31/JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h3 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h3><blockquote>
<p>JVM由以下四部分组成：</p>
<ol>
<li>类加载器。在JVM启动时或者在类运行时将需要的class字节码文件加载到JVM中。</li>
<li>执行引擎。负责执行class文件中的字节码指令，相当于实际机器上的CPU。</li>
<li>内存区。将内存划分成若干个区，以模拟在实际机器上的存储、记录、调度功能模块。这是很重要的一部分。</li>
<li>本地方法调用，调用C或C++实现的本地方法代码。</li>
</ol>
<p><img src="/images/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"></p>
<span id="more"></span>

<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>之前一篇文章讲述过该方面知识，这里不再过多说明。</p>
<h4 id="JVM内存管理"><a href="#JVM内存管理" class="headerlink" title="JVM内存管理"></a>JVM内存管理</h4><p>不管是在Windows系统还是Linux系统下，我们要运行程序，都要向操作系统先申请内存地址。通常操作系统管理内存的申请空间是按照进程来管理的，每个进程拥有一段独立的地址空间，每个进程间不会相互重合，操作系统也会保证每个进程只能访问自己的内存空间。但是随着程序越来越庞大，以及设计的多样性，有可能程序所需的内存空间大于物理内存大小，这时候怎么办？虚拟内存出现。虚拟内存只将程序运行需要的数据页加载到内存中，而暂时还未用到的数据则继续留在磁盘中。当程序运行需要用到磁盘上的数据时，会先让访问磁盘数据的操作”陷入陷阱”，然后将磁盘中的数据读取到内存中，再执行该”陷入陷阱”的操作。虚拟内存使得多个进程在同时运行时可以共享物理内存。这里的共享只是空间的共享，只是让进程共享物理内存，提高内存利用率，逻辑上进程间仍然不能相互访问。当进程不活动时，操作系统就会将物理内存中的数据移到一个磁盘文件中(Windows系统上的页面文件，Linux上的交换分区)，而真正高效的物理内存留给正在活动的程序使用。<strong>注意，这种交换要尽可能地减少，如果操作系统频繁地交换内存和磁盘的数据，效率会非常低下。</strong></p>
<blockquote>
<p>内核空间与用户空间</p>
<p>一个计算机有一定大小的内存空间，但是程序并不能完全使用这些地址空间。程序不能访问的空间称为内核空间，能够访问的内存空间称为用户空间。</p>
<p>之所以这么划分，主要是要保证操作系统的稳定性及安全性。内核空间主要用于存放操作系统运行时所需要的——程序调度、虚拟内存的使用、连接硬件资源的程序逻辑等。</p>
</blockquote>
<h5 id="JVM中需要分配内存的组件"><a href="#JVM中需要分配内存的组件" class="headerlink" title="JVM中需要分配内存的组件"></a>JVM中需要分配内存的组件</h5><blockquote>
<p><strong>再次强调：请牢记这些组件，当内存泄漏时，就可以从这些组件中排查。</strong></p>
<ul>
<li><strong>Java堆，存放对象</strong></li>
<li><strong>线程，程序的执行实体，每个线程都包括栈和程序计数器。通常一个线程大小在256KB~756KB之间</strong></li>
<li><strong>方法区，存放加载的类以及类加载器</strong></li>
<li><strong>NIO，NIO使用java.io.ByteBuffer.allocateDirect()方法分配内存，这里的内存是直接内存而不是Java内存，要特别注意</strong></li>
<li><strong>JNI，调用本地方法需要占用本机内存</strong></li>
</ul>
</blockquote>
<h5 id="Java内存分配"><a href="#Java内存分配" class="headerlink" title="Java内存分配"></a>Java内存分配</h5><blockquote>
<ol>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>Java堆</li>
<li>方法区</li>
<li>本地方法栈</li>
</ol>
</blockquote>
<p>Java堆和方法区是被所有线程共享的一块内存。Java堆用于存放对象实例，如果在堆中没有完成实例分配，并且堆也无法进行扩展时，就会抛出OutOfMemoryError异常；方法区则用于存储已经被虚拟机加载的类信息、常量、静态变量等数据，当方法区无法满足内存分配需求时，也会抛出OutOfMemoryError异常。</p>
<p>虚拟机栈、程序计数器都属于线程私有内容，生命周期和线程一致。每个方法在执行的时候都会在虚拟机栈中创建栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。当方法执行完毕，栈帧就会出栈。当线程请求的栈深度大于虚拟机所允许的值，就会抛出StakOverflowError异常；程序计数器或者称为PC寄存器，用于确保线程的指令能够正确地执行。</p>
<p>本地方法栈，则是用于调用本地方法时使用的内存区域。</p>
<h4 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h4><p>执行引擎是JVM的核心部分，作用就是解析JVM字节码指令，得到执行结果。执行引擎其实质是一个Java线程，即每个Java线程都是一个执行引擎的实例，因此，同一时刻会同时有多个执行引擎（Java线程）在工作，有的执行用户程序，有的执行垃圾回收等。</p>
<p>接下来，就是要探究JVM是如何工作的。</p>
</blockquote>
<h3 id="JVM工作机制"><a href="#JVM工作机制" class="headerlink" title="JVM工作机制"></a>JVM工作机制</h3><blockquote>
<p>计算机只执行机器指令，因此高级语言必须经过编译器编译成机器指令才能正确地被计算机正确执行，所以从高级语言到机器语言之间必须要有个翻译的过程。通常而言，机器指令和硬件是密切相关的，不同机器间的机器指令存在差异。而高级语言则不存在这种差异，这种差异被屏蔽就是得益于编译环节过程。因此，对于高级语言，不同的硬件平台，所需要的编译器是不同的。这种硬件差异在计算机发展的早期十分明显，但是随着计算机的发展，这种硬件差异逐渐被软件平台所代替，我们开始常常说，你这是装在Windows操作系统上还是Linux系统上，而不会说你的CPU是什么型号等等。</p>
<p>通常，一个程序从编写到执行会经历以下一些阶段：</p>
<p>源代码(source code) ——&gt; 预处理器(preprocessor) ——&gt; 编译器(compiler) ——&gt; 汇编程序(assembler) ——&gt; 目标代码(object code) ——&gt; 链接器(Linker) ——&gt; 可执行程序(executables)</p>
<p>除了源代码和最后的可执行程序，中间的所有环节都是由编译器统一完成。比如在Linux操作系统中，安装一个软件需要经过<strong>configure/make/make install/make clean四个步骤</strong>。</p>
<ul>
<li>configure为这个程序在当前操作系统环境下选择合适的编译器来编译程序代码</li>
<li>make则对程序代码执行编译操作，将源码编译成可执行的目标文件</li>
<li>make install将已经编译好的可执行文件安装到操作系统指定或默认的安装目录下</li>
<li>make clean用于删除编译时临时产生的目录或文件</li>
</ul>
<h5 id="JVM基于栈的架构"><a href="#JVM基于栈的架构" class="headerlink" title="JVM基于栈的架构"></a>JVM基于栈的架构</h5><p>JVM执行字节码指令是基于栈的架构，所有的操作数必须先入栈，然后根据指令中的操作码选择从栈顶弹出若干元素进行计算后在压入栈中。这和一般的基于寄存器的操作有所不同，基于栈的操作需要频繁地入栈和出栈，比如进行一个加法运算，如果两个操作数都在本地变量中，那么一个加法操作需要有5次栈操作：两个操作数入栈，两个操作数出栈，执行完后的结果入栈。</p>
</blockquote>
]]></content>
      <tags>
        <tag>JVM, 虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Base64算法</title>
    <url>/2020/08/05/Java-Base64%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>Base64算法并不是加密算法，它的出现是为了解决ASCII码在传输过程中可能出现乱码的问题。Base64是网络上最常见的用于传输8bit字节码的可读性编码算法之一。可读性编码算法不是为了保护数据的安全性，而是为了可读性。可读性编码不改变信息内容，只改变信息内容的表现形式。Base64使用了64种字符：大写A到Z、小写a到z、数字0到9、“+”和“/”，故得此名。</p>
<span id="more"></span>

<h2 id="中文字符在不同编码下所占的字节数"><a href="#中文字符在不同编码下所占的字节数" class="headerlink" title="中文字符在不同编码下所占的字节数"></a>中文字符在不同编码下所占的字节数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    String a = <span class="string">&quot;威&quot;</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] utf8Bytes = a.getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">byte</span> b : utf8Bytes) &#123;</span><br><span class="line">        System.out.print(b);</span><br><span class="line">        System.out.print(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">        System.out.println(Integer.toBinaryString(b));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="keyword">byte</span>[] gbkBytes = a.getBytes(<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">byte</span> b : gbkBytes) &#123;</span><br><span class="line">        System.out.print(b);</span><br><span class="line">        System.out.print(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">        System.out.println(Integer.toBinaryString(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-23    11111111111111111111111111101001</span></span><br><span class="line"><span class="deletion">-72    11111111111111111111111110111000</span></span><br><span class="line"><span class="deletion">-97    11111111111111111111111110011111</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-60    11111111111111111111111111000100</span></span><br><span class="line"><span class="deletion">-15    11111111111111111111111111110001</span></span><br></pre></td></tr></table></figure>

<p>所以在UTF-8编码下，一个中文占3个字节；在GBK编码下，一个中文占2个字节</p>
<h2 id="Base64编码原理"><a href="#Base64编码原理" class="headerlink" title="Base64编码原理"></a>Base64编码原理</h2><p>Base64编码表：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>索引</strong></td>
<td><strong>对应字符</strong></td>
<td><strong>索引</strong></td>
<td><strong>对应字符</strong></td>
<td><strong>索引</strong></td>
<td><strong>对应字符</strong></td>
<td><strong>索引</strong></td>
<td><strong>对应字符</strong></td>
</tr>
<tr>
<td>0</td>
<td><strong>A</strong></td>
<td>17</td>
<td><strong>R</strong></td>
<td>34</td>
<td><strong>i</strong></td>
<td>51</td>
<td><strong>z</strong></td>
</tr>
<tr>
<td>1</td>
<td><strong>B</strong></td>
<td>18</td>
<td><strong>S</strong></td>
<td>35</td>
<td><strong>j</strong></td>
<td>52</td>
<td><strong>0</strong></td>
</tr>
<tr>
<td>2</td>
<td><strong>C</strong></td>
<td>19</td>
<td><strong>T</strong></td>
<td>36</td>
<td><strong>k</strong></td>
<td>53</td>
<td><strong>1</strong></td>
</tr>
<tr>
<td>3</td>
<td><strong>D</strong></td>
<td>20</td>
<td><strong>U</strong></td>
<td>37</td>
<td><strong>l</strong></td>
<td>54</td>
<td><strong>2</strong></td>
</tr>
<tr>
<td>4</td>
<td><strong>E</strong></td>
<td>21</td>
<td><strong>V</strong></td>
<td>38</td>
<td><strong>m</strong></td>
<td>55</td>
<td><strong>3</strong></td>
</tr>
<tr>
<td>5</td>
<td><strong>F</strong></td>
<td>22</td>
<td><strong>W</strong></td>
<td>39</td>
<td><strong>n</strong></td>
<td>56</td>
<td><strong>4</strong></td>
</tr>
<tr>
<td>6</td>
<td><strong>G</strong></td>
<td>23</td>
<td><strong>X</strong></td>
<td>40</td>
<td><strong>o</strong></td>
<td>57</td>
<td><strong>5</strong></td>
</tr>
<tr>
<td>7</td>
<td><strong>H</strong></td>
<td>24</td>
<td><strong>Y</strong></td>
<td>41</td>
<td><strong>p</strong></td>
<td>58</td>
<td><strong>6</strong></td>
</tr>
<tr>
<td>8</td>
<td><strong>I</strong></td>
<td>25</td>
<td><strong>Z</strong></td>
<td>42</td>
<td><strong>q</strong></td>
<td>59</td>
<td><strong>7</strong></td>
</tr>
<tr>
<td>9</td>
<td><strong>J</strong></td>
<td>26</td>
<td><strong>a</strong></td>
<td>43</td>
<td><strong>r</strong></td>
<td>60</td>
<td><strong>8</strong></td>
</tr>
<tr>
<td>10</td>
<td><strong>K</strong></td>
<td>27</td>
<td><strong>b</strong></td>
<td>44</td>
<td><strong>s</strong></td>
<td>61</td>
<td><strong>9</strong></td>
</tr>
<tr>
<td>11</td>
<td><strong>L</strong></td>
<td>28</td>
<td><strong>c</strong></td>
<td>45</td>
<td><strong>t</strong></td>
<td>62</td>
<td><strong>+</strong></td>
</tr>
<tr>
<td>12</td>
<td><strong>M</strong></td>
<td>29</td>
<td><strong>d</strong></td>
<td>46</td>
<td><strong>u</strong></td>
<td>63</td>
<td><strong>/</strong></td>
</tr>
<tr>
<td>13</td>
<td><strong>N</strong></td>
<td>30</td>
<td><strong>e</strong></td>
<td>47</td>
<td><strong>v</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>14</td>
<td><strong>O</strong></td>
<td>31</td>
<td><strong>f</strong></td>
<td>48</td>
<td><strong>w</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td><strong>P</strong></td>
<td>32</td>
<td><strong>g</strong></td>
<td>49</td>
<td><strong>x</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>16</td>
<td><strong>Q</strong></td>
<td>33</td>
<td><strong>h</strong></td>
<td>50</td>
<td><strong>y</strong></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Base64编码的过程：</p>
<ol>
<li>将字符串转换为字符数组；</li>
<li>将每个字符转换为ASCII码；</li>
<li>将ASCII码转换为8bit二进制码；</li>
<li>然后每3个字节为一组（一个字节为8个bit，所以每组24个bit）；</li>
<li>将每组的24个bit分为4份，每份6个bit；</li>
<li>在每6个bit前补0，补齐8bit（前面补0不影响数值大小）；</li>
<li>然后将每8bit转换为10进制数，根据上面的Base64编码表进行转换。</li>
</ol>
<p>（上面步骤中，之所以将每组24个bit分为4份，每份6个bit是因为6bit的最大值为111111，转换为十进制为63，所以6bit的取值范围为0~63，这和base64编码表长度一致。）</p>
<p>根据上面的过程，举个例子：现要对hello这个字符串进行Base64编码，过程如下：</p>
<ol>
<li>hello转换为字符数组：h e l l o；</li>
<li>对应的ASCII码为：104 101 108 108 111；</li>
<li>转换为8bit二进制数：01101000 01100101 01101100 01101100 01101111</li>
<li>分组，每组24个bit（不足24个bit的用00000000补齐）： 011010000110010101101100 011011000110111100000000；</li>
<li>每组24bit分为4份，每份6bit：011010 000110 010101 101100 011011 000110 111100 000000；</li>
<li>在每6个bit前补0，补齐8bit：00011010 00000110 00010101 00101100 00011011 00000110 00111100 00000000；</li>
<li>将每8bit转换为10进制数：26 6 21 44 27 6 60 0</li>
<li>从上面Base64编码表中找到十进制数对应的字符（末尾的0并不是A，而是用=等号补位）：a G V s b G 8 =</li>
</ol>
<p>所以hello经过Base64编码的结果为aGVsbG8=</p>
<p>可以用代码验证下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base64Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Base64.getEncoder().encodeToString(<span class="string">&quot;hello&quot;</span>.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">测试结果：</span><br><span class="line"><span class="attribute">aGVsbG8</span>=</span><br></pre></td></tr></table></figure>

<h2 id="URL-Base64算法"><a href="#URL-Base64算法" class="headerlink" title="URL Base64算法"></a>URL Base64算法</h2><p>Base64编码值通过URL传输会出现问题，因为Base64编码中的“+”和“/”符号是不允许出现在URL中的。同样，符号“=”用做参数分隔符，也不允许出现在URL中，根据RFC 4648中的建议，“<del>”和“.”符都有可能替代“=”符号。但“</del>”符号与文件系统相冲突，不能使用；如果使用“.”符号，某些文件系统认为该符号连续出现两次则为错误。</p>
<p>所以common codec包下的URL Base64算法舍弃了填充符，使用了不定长URL Base64编码</p>
<p>引入common codec依赖包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base64Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String value = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(Base64.encodeBase64String(value.getBytes()));</span><br><span class="line">     System.out.println(Base64.encodeBase64URLSafeString(value.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">aG<span class="attr">VsbG8</span>=</span><br><span class="line">aG<span class="attr">VsbG8</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>base64算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Javac为我们做了哪些工作</title>
    <url>/2020/01/28/Javac%E4%B8%BA%E6%88%91%E4%BB%AC%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<p>Javac能够将Java源码编译成字节码文件，然后被JVM识别并执行。虽然从文件名上看，只是从.java文件转化成.class文件，但实际上是将Java源码转化成一连串二进制数字，只不过这些二进制数是有格式的。为了自己能够将编码这件事情做的更出色，尝试了解编译过程，看看自己能否从中学习到什么。</p>
<span id="more"></span>

<h2 id="Javac编译器"><a href="#Javac编译器" class="headerlink" title="Javac编译器"></a>Javac编译器</h2><blockquote>
<p>Javac编译器的作用就是将Java源码转换成JVM能识别的字节码。这个过程如何转换？</p>
<ol>
<li>首先是以字节为单位读取源码，并找出字节中哪些是定义的语法关键词，如if/else/for/while等，这需要借助词法分析。词法分析就是从源码中找出规范化的标记流，也称为Token流。就好比我们说中文，我们从说出的一句话中，知道哪些是主语，哪些是谓语，那些是动词，哪些是名词。比如，你今天吃饭了吗？<em>你</em>是主语，<em>吃</em>是动词，<em>了吗</em>是语气词。</li>
<li>对第一步的Token流进行<strong>语法分析</strong>，检查关键词的组合是否符合Java语法规范。比如if后面是否是一个布尔类型的判断表达式，一个类是否实现了继承接口的全部方法等等。</li>
<li>语法分析完成后，其产生的结果就是会形成一棵符合java语法的抽象语法树，将语言的主要词法用一个结构化的形式组织在一起。然后就会进行<strong>语义分析</strong>。经过语法分析后，说明Token流不存在语法问题，那么就会验证语义的正确性，并将复杂的语法简单化。比如将foreach转换成for循环结构。</li>
<li>最后就会通过字节码生成器生成字节码。</li>
</ol>
<p><img src="/images/%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png"></p>
<p>总结来说，Javac编译器主要模块为：词法分析、语法分析、语义分析、字节码生成器。</p>
</blockquote>
<h4 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h4><blockquote>
<p>借助一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lexer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> jump;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后的内容</span></span><br><span class="line">Compiled from <span class="string">&quot;Lexer.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">doug</span>.<span class="title">wilson</span>.<span class="title">javac</span>.<span class="title">Lexer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> jump;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.doug.wilson.javac.Lexer();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: aload_0</span><br><span class="line">       <span class="number">5</span>: iconst_3</span><br><span class="line">       <span class="number">6</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field num:I</span></span><br><span class="line">       <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>词法分析的类结构(忽略一些内容)：</p>
<p><img src="/images/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%BB%84%E4%BB%B6.png"></p>
<p>接口为Lexer和Parser</p>
<p>Lexer的默认实现为Scanner，Parser的默认实现为JavaParser。JavaParser规定了哪些词是符合Java语言规范规定的，而具体读取和归类不同语法的操作由Scanner完成。Scanner会逐个读取源码的单个字符，然后解析出符合Java语言规范的Token序列。图中还有两个比较重要的没有画出来，一个为枚举类Token，规定了所有Java语法关键词。一个为Names，存储和表示解析后的语法。</p>
<p>词法分析的结果就是一个类的所有关键词都要匹配到Token中的关键词，如果没有匹配成功说明类不符合Java语法规范，而且通常匹配还是具有顺序的：</p>
<ol>
<li>Token.PACKAGE  Name: package</li>
<li>Token.IDENTIFIER  Name: compile</li>
<li>Token.SEMI Name: ;</li>
<li>Token.PUBLIC  Name: public</li>
<li>Token.CLASS  Name: class</li>
<li>Token.IDENTIFIER  Name:Lexer</li>
<li>Token.LBRACE  Name: {</li>
<li>Token.BOOLEAN  Name: boolean</li>
<li>Token.IDENTIFIER   Name: jump</li>
<li>Token.SEMI  Name: ;</li>
<li>Token.INT  Name: int</li>
<li>Token.IDENTIFIER  Name: num</li>
<li>Token.EQ  Name: =</li>
<li>Token.INTLITERAL  stringVal: 3</li>
<li>Token.SEMI  Name: ;</li>
<li>Token.EBRACE  Name: }</li>
</ol>
<p>上面就是Token流，除了定义Java语言规范保留的关键字，Token.IDENTIFIER可以用于表示用户自定义名称，如包名，类名，变量名，方法名等。</p>
<p>接下来就是探究词法分析是怎么得到上面的Token流的。比如Javac怎么区分关键字和用户自定义变量?Javac是如何分辨一个词，它怎么知道是compiler而不是com或者piler?如何知道一个词是Token的关键字?如何对字符流进行划分，得到Token?</p>
<ul>
<li><p>如何读取Token关键词？这主要通过Java语言规范得到实现。比如在编写类的时候，要求要有class关键字，class关键字后需要跟一个自定义名称，然后是{括号。定义变量时，要求先给出变量类型，然后给出变量名。定义方法时，先定义方法返回类型，然后定义方法名称，接着是括号内的形参，由形参类型和形参名构成，多个形参间用逗号,隔开。词法分析就是根据Java语法规范来区分关键字和自定义名称。</p>
</li>
<li><p>如何读取下一个Token关键字？这也是通过语法规范。比如，当读取完{括号时，下一个词一定是关键词或者是用户自定义的名称；当读取完分号; 道理也是同前一条；以及类的定义，方法定义，变量定义，都可以得到下一个Token关键词的线索。</p>
</li>
<li><p>源码和Token关键字的转换？比如package是如何转换到Token.PACKAGE的。首先我们知道了Token是一个Enum枚举类，保存所有的Java关键字。而源码转换成关键字这个任务是在一个名为Keywords类中完成，Keywords负责将所有字符集合对应到Token集合中。具体过程为：</p>
<p>在Keywords中，源码中每个字符集合都是一个Name对象，存储在Name.Table内部类中，Keywords会将Token中所有关键字转换成Name对象，然后建立起Name对象和Token对象的对应关系，并将建立起的联系存储在Keywords类的key数组中。当联系建立完成，剩下的字符集合都会对应到Token.IDENTIFIER类型。如此，一个类的源码的所有字符集合才算完全转化成Token。(简而言之就是Keywords会把要编译的类的每个词视为一个字符集合，比如public class Lexer就会视为3各字符集合。然后将其分别存储为Name对象。接着，Keywords将Token中的关键字也转换成Name对象，然后在字符集合中除了Token.IDENTIFIER以外，一一寻找对应关系。当所有关系寻找完以后，剩下的一定是用户自定义的名称，那么就都视为是Token.IDENTIFIER类型。)</p>
</li>
</ul>
</blockquote>
<h4 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h4><blockquote>
<p>在将Java源文件的字符流转化为Token流后，就可以进行语法分析。语法分析是将得到的Token流组件成更加结构化的语法树，将一个个单词组装成一个完整的语句。</p>
<p>语法分析类结构：</p>
<p><img src="/images/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E7%B1%BB%E7%BB%93%E6%9E%84.png"></p>
<p>如图所示，每个语法节点都会实现一个接口××Tree，而××Tree接口又会继承Tree接口。在图中，继承IfTree语法接口表示一个if类型的表达式，继承BinaryTree语法接口表示一个二元操作表达式。并且所有语法节点，都要继承JCTree。</p>
<p>JCTree类有3各重要的属性项：</p>
<ul>
<li>Tree tag：每个语法节点都会用一个整型常数表示，并且每个节点类型的数值在前一个基础上加1。这是为了表示层级关系，比如根节点算顶层节点，它的Tree tag是1。根节点的子节点算次级节点，其Tree tage是2，以此类推。</li>
<li>pos：一个整数，存储的是语法节点在源码中的起始位置。</li>
<li>type：表示这个节点是什么Java类型，int/float/String等</li>
</ul>
<p>JCTree有几个常用子节点：</p>
<ul>
<li>JCIdent语法节点  </li>
<li>JCFieldAccess语法节点  </li>
<li>JCImport语法节点  </li>
</ul>
<p>通常而言，语法分析会分几步进行：</p>
<ol>
<li><p>package节点解析</p>
</li>
<li><p>import节点解析并构造import语法树。构造import语法树的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">JCTree <span class="title">importDeclaration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = S.pos(); <span class="comment">//获取节点在源码中的起始位置</span></span><br><span class="line">    S.nextToken();  </span><br><span class="line">    <span class="keyword">boolean</span> importStatic = <span class="keyword">false</span>;  <span class="comment">//是否为静态导入</span></span><br><span class="line">    <span class="keyword">if</span> (S.token() == STATIC) &#123;</span><br><span class="line">        <span class="comment">//如果为import static ...的情况</span></span><br><span class="line">        <span class="comment">//则由checkStaticImports()方法进行处理</span></span><br><span class="line">        checkStaticImports();</span><br><span class="line">        importStatic = <span class="keyword">true</span>;</span><br><span class="line">        S.nextToken();</span><br><span class="line">    &#125;</span><br><span class="line">    JCExpression pid = toP(F.at(S.pos()).Ident(ident()));</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> pos1 = S.pos(); <span class="comment">//在源码文件中起始位置</span></span><br><span class="line">        accept(DOT);  <span class="comment">//消耗一个.</span></span><br><span class="line">        <span class="keyword">if</span> (S.token() == STAR) &#123;</span><br><span class="line">            <span class="comment">//如果读取到尾部，例如import java.util.* 则将*构造成节点加入</span></span><br><span class="line">            pid = to(F.at(pos1).Select(pid, names.asterisk));</span><br><span class="line">            S.nextToken();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果没有读取到尾部，则正常读取字符串</span></span><br><span class="line">            pid = toP(F.at(pos1).Select(pid, ident()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (S.token() == DOT);  <span class="comment">//如果为.说明一个import语句还未结束</span></span><br><span class="line">    accept(SEMI);  <span class="comment">//一个import结束，消耗一个;</span></span><br><span class="line">    <span class="keyword">return</span> toP(F.at(pos).Import(pid, importStatic));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JCImport节点语法树：(import java.util.*;)</p>
<p><img src="/images/import%E8%AF%AD%E6%B3%95%E6%A0%91.png"></p>
</li>
<li><p>类的解析并构造成语法树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">JCClassDecl <span class="title">classDeclaration</span><span class="params">(JCModifiers mods, String dc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = S.pos();  <span class="comment">//获取在源码文件中的起始位置</span></span><br><span class="line">    accept(CLASS);  <span class="comment">//消耗掉class关键字</span></span><br><span class="line">    Name name = ident();  <span class="comment">//获取类名</span></span><br><span class="line">    List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();</span><br><span class="line">    JCTree extending = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (S.token() == EXTENDS) &#123;</span><br><span class="line">        <span class="comment">//存在类的继承或接口间的继承</span></span><br><span class="line">        S.nextToken();</span><br><span class="line">        extending = parseType()</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;JCExpression&gt; implementing = List.nil();</span><br><span class="line">    <span class="keyword">if</span> (S.token() == IMPLEMENTS) &#123;</span><br><span class="line">        <span class="comment">//存在继承接口</span></span><br><span class="line">        S.nextToken();</span><br><span class="line">        implementing = typeList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始分析类的主体部分</span></span><br><span class="line">    List&lt;JCTree&gt; defs = classOrInterfaceBody(name, <span class="keyword">false</span>);</span><br><span class="line">    JCClassDecl result = toP(F.at(pos).ClassDef(mods, name, typarams, extending, implementing, defs));</span><br><span class="line">    attach(result, dc);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的主体部分分析比较复杂，没有看的很明白，但是通过其语法树还是能够对其分析过程有个具体了解。比如有下面这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Doug</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight = height / <span class="number">3</span>;</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么可以得到其语法树：</p>
<p><img src="/images/class%E7%B1%BB%E8%AF%AD%E6%B3%95%E6%A0%91.png"></p>
</li>
</ol>
</blockquote>
<h4 id="语义分析器"><a href="#语义分析器" class="headerlink" title="语义分析器"></a>语义分析器</h4><blockquote>
<p>在通过词法分析器解析成Token流，语法分析器将Token流结构化形成语法树，一个类的基本语法树已经基本完成。但是还不够，还没有对其语义的正确性进行检查。比如final修饰的变量是否经过初始化，一个类是否继承接口的全部方法，类是否定义了构造器方法，方法是否有返回值，返回值的类型是否正确等等都需要进一步检查。这些需要通过语义分析器完成。一般有以下几个步骤：</p>
<ol>
<li><p>将类中的符号输入到未处理符号表中，并为类创建一个默认构造器(如果需要的话)</p>
<ul>
<li><p>将类中出现的符号输入到类自身的符号表中，内容有：类符号、参数类型符号(包括泛型参数类型)、超类符号、继承的接口类型符号</p>
</li>
<li><p>对上一步进一步处理，对符号表中所有的类再各自解析到各自的类符号表中</p>
</li>
<li><p>为类创建默认构造器并加入到语法树中(如果需要的话)</p>
<p>对第二步的解释，因为一个类中除了类本身会定义一些符号变量外，还会引用其他类的符号，这些符号会调用其他类的方法或变量，并且其他类还可能会继承超类或接口。这些符号都是在其它类中定义的，因此需要将这些类的符号也解析到符号表中</p>
</li>
</ul>
</li>
<li><p>处理注解</p>
</li>
<li><p>标注阶段。检查语义的合法性并进行逻辑判断，有如下几点：</p>
<ul>
<li>变量的类型是否匹配。由com.sun.tools.javac.comp.Check类完成</li>
<li>变量在使用前是否已经初始化。由com.sun.tools.javac.comp.Resolve类完成</li>
<li>能否推导出泛型方法的参数类型。由com.sun.tools.javac.comp.Infer类完成</li>
<li>字符串常量的合并。由com.sun.tools.javac.comp.ConstFold类完成，将多个字符串合并成一个字符串，比如：”hello” + “world”会合并成”helloworld”</li>
</ul>
</li>
<li><p>由com.sun.tools.javac.comp.Flow类完成数据流分析。主要内容如下：</p>
<ul>
<li>检查变量在使用前是否均被正确赋值</li>
<li>保证final修饰的变量不会被重复赋值</li>
<li>确定方法的返回类型</li>
<li>检查异常是否被捕获，或向上抛出</li>
<li>所有语句都要被执行到，比如return方法后面的语句永远也不会被执行</li>
<li>执行语义分析，消除无用代码；去除永不为真的条件判断；解除语法糖；将foreach语法形式解析成标准的for循环形式；自动装箱和自动拆箱</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h4><blockquote>
<p>经过语义分析后，Javac编译器就会调用com.sun.tools.javac.jvm.Gen类遍历语法树，生成最终的Java字节码。步骤如下：</p>
<ol>
<li>将Java方法中的代码转换成符合JVM语法的命令形式。</li>
<li>按照JVM文件组织格式将字节码输出到class扩展名的文件中。</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>javac, 编译器</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的流</title>
    <url>/2020/05/14/Java%E4%B8%AD%E7%9A%84%E6%B5%81/</url>
    <content><![CDATA[<p>Java中的 Stream 称为流，它和 java.io 包中的 InputStream 和 OutputStream 是完全不同的概念。Stream 用于对集合对象进行各种非常遍历、高效的聚合操作，或者大批量数据操作。Stream API借助于 Lambda表达式，极大提高编程效率和程序可读性。同时，Stream 提高串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势。</p>
<span id="more"></span>

<h2 id="Stream概述"><a href="#Stream概述" class="headerlink" title="Stream概述"></a>Stream概述</h2><p>下面有一个列表List，现在要从中筛选出以 <code>J </code>开头的元素，然后转换为大写，最后输出结果。如果不使用流我们是这样做的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;python&quot;</span>, <span class="string">&quot;PHP&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>);</span><br><span class="line">List&lt;String&gt; filterList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.startsWith(<span class="string">&quot;J&quot;</span>)) &#123;</span><br><span class="line">        filterList.add(str.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String str : filterList) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果使用 Stream ，则是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;python&quot;</span>, <span class="string">&quot;PHP&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">&quot;J&quot;</span>))</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>上面的例子中，集合使用 <code>stream()</code> 方法创建了一个流，然后使用 <code>filter</code> 进而 <code>map</code> 方法处理这个集合，他们都称为 <strong>中间操作</strong> 。中间操作会返回处理过后的流，以便将各种对集合的操作连接起来形成一条流水线。最后，使用了 <code>forEach</code> 方迭代筛选结果，这种位于流的末端，对流进行处理并且生成结果的方法称为 <strong>终端操作</strong>。</p>
<p>从上面的过程我们可以总结出，流的使用需要做3件事情：</p>
<ol>
<li>一个 <strong>数据源</strong> 来执行一次查询</li>
<li>一个 <strong>中间操作</strong> 链，形成一条流的流水线</li>
<li>一个 <strong>终端操作</strong> ，执行流水线，并能生成结果</li>
</ol>
<p>常用的中间操作和终端操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>操作类型</th>
<th>返回类型</th>
<th>使用的类型/函数式接口</th>
<th>描述符</th>
</tr>
</thead>
<tbody><tr>
<td>filter</td>
<td>中间操作</td>
<td>Stream&lt;T&gt;</td>
<td>Predicate&lt;T&gt;</td>
<td>T -&gt; boolean</td>
</tr>
<tr>
<td>distinct</td>
<td>中间操作</td>
<td>Stream&lt;T&gt;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>skip</td>
<td>中间操作</td>
<td>Stream&lt;T&gt;</td>
<td>long</td>
<td></td>
</tr>
<tr>
<td>limit</td>
<td>中间操作</td>
<td>Stream&lt;T&gt;</td>
<td>long</td>
<td></td>
</tr>
<tr>
<td>map</td>
<td>中间操作</td>
<td>Stream&lt;R&gt;</td>
<td>Function&lt;T, R&gt;</td>
<td>T -&gt; R</td>
</tr>
<tr>
<td>flatMap</td>
<td>中间操作</td>
<td>Stream&lt;R&gt;</td>
<td>Function&lt;T, Stream&lt;R&gt;&gt;</td>
<td>T -&gt; Stream&lt;R&gt;</td>
</tr>
<tr>
<td>sorted</td>
<td>中间操作</td>
<td>Stream&lt;T&gt;</td>
<td>Comparator&lt;T&gt;</td>
<td>(T, T) -&gt; int</td>
</tr>
<tr>
<td>anyMatch</td>
<td>终端操作</td>
<td>boolean</td>
<td>Predicate&lt;T&gt;</td>
<td>T -&gt; boolean</td>
</tr>
<tr>
<td>noneMatch</td>
<td>终端操作</td>
<td>boolean</td>
<td>Predicate&lt;T&gt;</td>
<td>T -&gt; boolean</td>
</tr>
<tr>
<td>findAny</td>
<td>终端操作</td>
<td>Optional&lt;T&gt;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>findFirst</td>
<td>终端操作</td>
<td>Optional&lt;T&gt;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>forEach</td>
<td>终端操作</td>
<td>void</td>
<td>Consumer&lt;T&gt;</td>
<td>T -&gt; void</td>
</tr>
<tr>
<td>collect</td>
<td>终端操作</td>
<td>R</td>
<td>Collector&lt;T, A, R&gt;</td>
<td></td>
</tr>
<tr>
<td>reduce</td>
<td>终端操作</td>
<td>Optional&lt;T&gt;</td>
<td>BinaryOperator&lt;T&gt;</td>
<td>(T, T) -&gt; T</td>
</tr>
<tr>
<td>count</td>
<td>终端操作</td>
<td>long</td>
<td></td>
<td></td>
</tr>
<tr>
<td>allMatch</td>
<td>终端操作</td>
<td>boolean</td>
<td>Predicate&lt;T&gt;</td>
<td>T -&gt; boolean</td>
</tr>
</tbody></table>
<p>很蒙，光看这些符号完全不知什么意思，写一些演示表示其功能，日后使用。</p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>由表可知，filter是个中间操作，该方法接收一个 <code>Predicate&lt;T&gt;</code> , 函数描述符为 <code>T -&gt; boolean</code> ,功能是对集合进行筛选，返回集合中符合要求的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">		.filter(s -&gt; s.contains(<span class="string">&quot;#&quot;</span>))<span class="comment">// 也就是说，filter方法返回值为boolean，筛选出为true的元素</span></span><br><span class="line">		.forEach(System.out::println);</span><br><span class="line"><span class="comment">// 结果输出： C#</span></span><br></pre></td></tr></table></figure>

<h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p>distinct方法用于排除流中重复的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 筛选集合中的所有偶数，并排除重复结果</span></span><br><span class="line">numbers.stream()</span><br><span class="line">    	.filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    	.distinct()</span><br><span class="line">    	.forEach(System.out::println);</span><br><span class="line"><span class="comment">// 结果输出：2 4</span></span><br></pre></td></tr></table></figure>

<h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p>skip方法用于跳过流的前n个元素，如果集合元素小于n，则返回空流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line"><span class="comment">// 筛选出以J开头的元素并排除第一个</span></span><br><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">&quot;J&quot;</span>))</span><br><span class="line">    .skip(<span class="number">1</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"><span class="comment">// 结果输出：JavaScript</span></span><br></pre></td></tr></table></figure>

<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>limit方法返回一个长度不超过n的流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .limit(<span class="number">3</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"><span class="comment">// 结果输出：Java JavaScript Python</span></span><br></pre></td></tr></table></figure>

<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map方法接收一个函数作为参数，这个函数会被用到每个元素上，并将其映射成一个新的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .map(String :: length)</span><br><span class="line">	.forEach(System.out::println);</span><br><span class="line"><span class="comment">// 结果输出：4 10 6 3 2 6 5 3 4</span></span><br></pre></td></tr></table></figure>

<p><code>map</code> 还支持将流转化为原始类型的流，比如通过 <code>mapToInt, mapToDouble, mapToLong</code> 方法，可以将流转化为 <code>IntStream, DoubleStream, LongStream</code> 。转化后的流支持一些方法，如 <code>sum, min, max</code> 方法来对流中的元素进行计算。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">IntStream intStream = numbers.stream().mapToInt(a -&gt; a);</span><br><span class="line">System.out.println(intStream.sum()); </span><br><span class="line"><span class="comment">// 结果输出为：16</span></span><br></pre></td></tr></table></figure>

<h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><p>flatMap用于将多个流合并成一个流，俗称流的扁平化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .map(s -&gt; s.split(<span class="string">&quot;&quot;</span>))</span><br><span class="line">    .map(Arrays :: stream)</span><br><span class="line">    .distinct()</span><br><span class="line">    .forEach(s -&gt; System.out.print(s + <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="comment">// 结果输出：J a v S c r i p t y h o n P H C # G l g w f + R u b</span></span><br></pre></td></tr></table></figure>

<h4 id="anyMatch"><a href="#anyMatch" class="headerlink" title="anyMatch"></a>anyMatch</h4><p>anyMatch方法用于判断流中是否有符合判断条件的元素，返回值为boolean类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line"><span class="comment">// 判断list中是否含有SQL元素</span></span><br><span class="line">list.stream()</span><br><span class="line">    .anyMatch(s -&gt; <span class="string">&quot;SQL&quot;</span>.equals(s));</span><br><span class="line"><span class="comment">// 输出结果：false</span></span><br></pre></td></tr></table></figure>

<h4 id="allMatch"><a href="#allMatch" class="headerlink" title="allMatch"></a>allMatch</h4><p>allMatch方法用于判断流中是否所有元素都满足给定的判断条件，返回值为boolean类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line"><span class="comment">// 判断list中收费所有元素长度都小于等于10</span></span><br><span class="line">list.stream()</span><br><span class="line">    .allMatch(s -&gt; s.length() &lt;= <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 结果输出：true</span></span><br></pre></td></tr></table></figure>

<h4 id="noneMatch"><a href="#noneMatch" class="headerlink" title="noneMatch"></a>noneMatch</h4><p>noneMatch方法用于判断流中是否所有元素都不满足给定的判断条件，返回值为boolean类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .noneMatch(s -&gt; s.length() &gt; <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 结果输出：true</span></span><br></pre></td></tr></table></figure>

<h4 id="findAny"><a href="#findAny" class="headerlink" title="findAny"></a>findAny</h4><p>findAny方法用于返回流中任意元素的Optional类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line"><span class="comment">// 筛选出list中任意一个以J开头的元素，如果存在，则输出它</span></span><br><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">&quot;J&quot;</span>))</span><br><span class="line">    .findAny()</span><br><span class="line">    .ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// 结果输出：Java</span></span><br></pre></td></tr></table></figure>

<h4 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h4><p>findFirst方法用于返回流中第一个元素的Optional类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line"><span class="comment">// 筛选出list中长度大于5的元素，如果存在，输出第一个</span></span><br><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.length() &gt; <span class="number">5</span>)</span><br><span class="line">    .findFirst()</span><br><span class="line">    .ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// 结果输出：JavaScript</span></span><br></pre></td></tr></table></figure>

<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>reduce方用于数字类型流的求和，求最大值，最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">numbers.stream()</span><br><span class="line">    	.reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"><span class="comment">// 结果输出：16</span></span><br><span class="line">numbers.stream()</span><br><span class="line">    	.reduce(Integer::max)</span><br><span class="line">    	.ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// 结果输出：4</span></span><br><span class="line">numbers.stream()</span><br><span class="line">    	.reduce(Integer::min)</span><br><span class="line">    	.ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// 结果输出：1</span></span><br></pre></td></tr></table></figure>

<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>forEach用于迭代流中的每个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"><span class="comment">// 结果输出：Java JavaScript Python C# Golang Swift C++ Ruby</span></span><br></pre></td></tr></table></figure>

<h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><p>count方法用于统计流中元素的个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .count();</span><br><span class="line"><span class="comment">// 结果输出：9</span></span><br></pre></td></tr></table></figure>

<h4 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h4><p>collect方法用于收集流中的元素，并放到不同类型的结果中，比如 <code>List, Set,Map </code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Ruby&quot;</span>);</span><br><span class="line">List&lt;String&gt; filterList = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;J&quot;</span>)).collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 如果要用Set或Map,只需要修改方法为toSet() toMap</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>流</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数字签名算法</title>
    <url>/2020/08/03/Java%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>数字签名算法可以看成是带秘钥的消息摘要算法，用于验证数据完整性、认证数据来源，并起到抗否认的作用。遵循私钥加签，公钥验签的规则，数字签名算法是非对称加密算法和消息摘要算法的结合体。数字签名算法主要包括RSA和DSA。本文主要记录下这两种算法在Java中的实现。</p>
<p>数字签名加签验签流程分为以下几步：</p>
<ol>
<li>A在本地构建秘钥对，并将公钥发布给B；</li>
<li>A使用私钥对数据进行签名；</li>
<li>A发送签名和数据给B；</li>
<li>B使用公钥对签名和数据进行验签。</li>
</ol>
<span id="more"></span>

<h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>RSA数字签名算法主要分为MD系列和SHA系列两大类。MD系列主要包括MD2withRSA和MD5withRSA共2种数字签名算法；SHA系列主要包括SHA1withRSA、SHA224withRSA、SHA256withRSA、SHA384withRSA和SHA512withRSA共5种数字签名算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RsaSignatureDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String value = <span class="string">&quot;Doug Wilson&quot;</span>;</span><br><span class="line">        <span class="comment">// 非对称加密算法</span></span><br><span class="line">        String algorithm = <span class="string">&quot;RSA&quot;</span>;</span><br><span class="line">        <span class="comment">// 签名算法，RSA+SHA</span></span><br><span class="line">        String signAlgorithm = <span class="string">&quot;SHA256withRSA&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ----- 公私钥生成 --------</span></span><br><span class="line">        <span class="comment">// 实例化秘钥对生成器</span></span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化，秘钥长度512~16384位，64倍数</span></span><br><span class="line">        keyPairGenerator.initialize(<span class="number">512</span>);</span><br><span class="line">        <span class="comment">// 生成秘钥对</span></span><br><span class="line">        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        <span class="comment">// 公钥</span></span><br><span class="line">        PublicKey publicKey = keyPair.getPublic();</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA公钥: &quot;</span> + Base64.getEncoder().encodeToString(publicKey.getEncoded()));</span><br><span class="line">        <span class="comment">// 私钥</span></span><br><span class="line">        PrivateKey privateKey = keyPair.getPrivate();</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA私钥: &quot;</span> + Base64.getEncoder().encodeToString(privateKey.getEncoded()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ----- 私钥加签 ---------</span></span><br><span class="line">        <span class="comment">// 获取签名对象</span></span><br><span class="line">        Signature signature = Signature.getInstance(signAlgorithm);</span><br><span class="line">        signature.initSign(privateKey);</span><br><span class="line">        signature.update(value.getBytes());</span><br><span class="line">        <span class="keyword">byte</span>[] sign = signature.sign();</span><br><span class="line">        System.out.println(<span class="string">&quot;签名值: &quot;</span> + Base64.getEncoder().encodeToString(sign));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ----- 公钥验签 ---------</span></span><br><span class="line">        signature.initVerify(publicKey);</span><br><span class="line">        signature.update(value.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;验签结果: &quot;</span> + signature.verify(sign));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">RSA公钥: MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAIAdlGVnjHPrQgrXiCaBOCHN1UmD9VVyE3qYprM3Ggds7Xiw7rnCyYluQu6AwLHxw3VQ3zndd9GsLIa4MmPpz/<span class="number">0</span>CAwEAAQ==</span><br><span class="line">RSA私钥: MIIBVQIBADANBgkqhkiG9w0BAQEFAASCAT8wggE7AgEAAkEAgB2UZWeMc+tCCteIJoE4Ic3VSYP1VXITepimszcaB2zteLDuucLJiW5C7oDAsfHDdVDfOd130awshrgyY+nP<span class="regexp">/QIDAQABAkBhj6T5D8CqaaXyQa2BvPd07p0UjbOe7O8ede7EHRrqOZpLFlf6i4FAzAeFOwUY6kHBZgJE3wlmp3x6k5YwgbMVAiEAttPcPwhg58gc1B3H4iWLtI8yftgVrbEioe49HYmNYWcCIQCzZAlLZpNl+k+cOc7rZ0TsTUpSrnsbTb1G+kpgrrgw+wIgQ8Ok98wANwjJ/</span>qkHJEAsVwFYgwFOj7F<span class="regexp">/F6v5BRCt0XMCIQCXMF5s/</span><span class="number">9</span>yGe<span class="regexp">/oQjuAHoheCmHllScxTbKdzZIq/</span>BUITdQIhAK/XnRymiY6mckZhIeCmHXV5tipnD0cRr78AYunQrLal</span><br><span class="line">签名值: eCg6+<span class="number">1</span>ziXVBRSoPYFb7Bb0NwGbVB69glB558krDHnQL6oXugKgLe0iyZUCjGd27AvwWiDzdfI7KRWvR39WJFBw==</span><br><span class="line">验签结果: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是不同签名算法需要的秘钥长度最小值不同</p>
<h2 id="DSA"><a href="#DSA" class="headerlink" title="DSA"></a>DSA</h2><p>DSA算法与RSA算法都是数字证书中不可或缺的两种算法。两者不同的是，DSA算法仅包含数字签名算法，使用DSA算法的数字证书无法进行加密通信，而RSA算法既包含加密/解密算法，同时兼有数字签名算法。</p>
<p>JDK8支持SHA1withDSA、SHA224withDSA、SHA256withDSA、SHA384withDSA和SHA512withDSA这五种DSA数字签名算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DsaSignatureDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String value = <span class="string">&quot;Doug Wilson&quot;</span>;</span><br><span class="line">        <span class="comment">// 非对称加密算法</span></span><br><span class="line">        String algorithm = <span class="string">&quot;DSA&quot;</span>;</span><br><span class="line">        <span class="comment">// 签名算法，DSA+SHA</span></span><br><span class="line">        String signAlgorithm = <span class="string">&quot;SHA224withDSA&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ----- 公私钥生成 --------</span></span><br><span class="line">        <span class="comment">// 实例化秘钥对生成器</span></span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化，秘钥长度512~1024位，64倍数</span></span><br><span class="line">        keyPairGenerator.initialize(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 生成秘钥对</span></span><br><span class="line">        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        <span class="comment">// 公钥</span></span><br><span class="line">        PublicKey publicKey = keyPair.getPublic();</span><br><span class="line">        System.out.println(<span class="string">&quot;DSA公钥: &quot;</span> + Base64.getEncoder().encodeToString(publicKey.getEncoded()));</span><br><span class="line">        <span class="comment">// 私钥</span></span><br><span class="line">        PrivateKey privateKey = keyPair.getPrivate();</span><br><span class="line">        System.out.println(<span class="string">&quot;DSA私钥: &quot;</span> + Base64.getEncoder().encodeToString(privateKey.getEncoded()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ----- 私钥加签 ---------</span></span><br><span class="line">        <span class="comment">// 获取签名对象</span></span><br><span class="line">        Signature signature = Signature.getInstance(signAlgorithm);</span><br><span class="line">        signature.initSign(privateKey);</span><br><span class="line">        signature.update(value.getBytes());</span><br><span class="line">        <span class="keyword">byte</span>[] sign = signature.sign();</span><br><span class="line">        System.out.println(<span class="string">&quot;签名值: &quot;</span> + Base64.getEncoder().encodeToString(sign));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ----- 公钥验签 ---------</span></span><br><span class="line">        signature.initVerify(publicKey);</span><br><span class="line">        signature.update(value.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;验签结果: &quot;</span> + signature.verify(sign));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">DSA公钥: MIIBtzCCASwGByqGSM44BAEwggEfAoGBAP1<span class="regexp">/U4EddRIpUt9KnC7s5Of2EbdSPO9EAMMeP4C2USZpRV1AIlH7WT2NWPq/</span>xfW6MPbLm1Vs14E7gB00b<span class="regexp">/JmYLdrmVClpJ+f6AR7ECLCT7up1/</span><span class="number">63</span>xhv4O1fnxqimFQ8E+<span class="number">4</span>P208UewwI1VBNaFpEy9nXzrith1yrv8iIDGZ3RSAHHAhUAl2BQjxUjC8yykrmCouuEC<span class="regexp">/BYHPUCgYEA9+GghdabPd7LvKtcNrhXuXmUr7v6OuqC+VdMCz0HgmdRWVeOutRZT+ZxBxCBgLRJFnEj6EwoFhO3zwkyjMim4TwWeotUfI0o4KOuHiuzpnWRbqN/</span>C<span class="regexp">/ohNWLx+2J6ASQ7zKTxvqhRkImog9/</span>hWuWfBpKLZl6Ae1UlZAFMO<span class="regexp">/7PSSoDgYQAAoGAZgGsjZjO3p24cR37gPFXfxwcL8sR2dinWMDMZMCT/</span>R4EuwvFyQYzKBE/rTPT14ffalfpAbutD+FGOCxiQt18wuglU6Pm9PjkmD2B573Jp7dJTEL4x5RcaSnSl8GKhPvtk17TbwfBEePCRz17DqM8T034Fm4pGjhGDcWh3zPwx8g=</span><br><span class="line">DSA私钥: MIIBTAIBADCCASwGByqGSM44BAEwggEfAoGBAP1<span class="regexp">/U4EddRIpUt9KnC7s5Of2EbdSPO9EAMMeP4C2USZpRV1AIlH7WT2NWPq/</span>xfW6MPbLm1Vs14E7gB00b<span class="regexp">/JmYLdrmVClpJ+f6AR7ECLCT7up1/</span><span class="number">63</span>xhv4O1fnxqimFQ8E+<span class="number">4</span>P208UewwI1VBNaFpEy9nXzrith1yrv8iIDGZ3RSAHHAhUAl2BQjxUjC8yykrmCouuEC<span class="regexp">/BYHPUCgYEA9+GghdabPd7LvKtcNrhXuXmUr7v6OuqC+VdMCz0HgmdRWVeOutRZT+ZxBxCBgLRJFnEj6EwoFhO3zwkyjMim4TwWeotUfI0o4KOuHiuzpnWRbqN/</span>C<span class="regexp">/ohNWLx+2J6ASQ7zKTxvqhRkImog9/</span>hWuWfBpKLZl6Ae1UlZAFMO/<span class="number">7</span>PSSoEFwIVAJH8km7u6HjEejjeHdyqhQ5SwFqi</span><br><span class="line">签名值: MCwCFBijyn5WxOug7e/<span class="number">9</span>jcJgZbud8mGUAhRzvLqvwprJQ7m5TpU50IFzM2k9og==</span><br><span class="line">验签结果: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数字签名, 算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型数组的创建及底层原理</title>
    <url>/2020/01/09/Java%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>今天在写数据结构的时候，碰到了泛型数组的创建。因为在Java中，泛型在编译过程会被擦除到边界(比如<strong>List&lt;T extends Number&gt; 泛型参数T在编译时会被擦除成Number</strong>)，你无法通过反射获取到泛型参数的有关信息，你唯一知道的就是你在使用一个对象。因此，对于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T array = <span class="keyword">new</span> T[size];</span><br></pre></td></tr></table></figure>

<p>是无法创建成功的。</p>
<span id="more"></span>

<h2 id="泛型的概述"><a href="#泛型的概述" class="headerlink" title="泛型的概述"></a>泛型的概述</h2><blockquote>
<p>一般的类和方法，只能使用具体的类型：要么是基本的类型，要么是自定义类，如果要编写可以应用于多种类型的代码，这种刻板的限制就会对代码的束缚很大——Java编程思想</p>
</blockquote>
<p>在Java中，解除这种限制的一个思想为多态，具体手段为面向接口编程。但是这种束缚依然存在，依然需要通过继承接口创建一个新的类来做到这一点。是否有一个手段“不受限于某种具体类型”，这便是泛型的概念。</p>
<p>泛型的概念普遍存在于容器的实现过程，这也是泛型的主要目的之一，通过泛型的使用，使得容器能够使用于不同类型对象中，达成代码的复用。而通常，指定容器持有什么类型对象由编译器保证类型的正确性，这么做的意义在于，我们经常只将容器存储于某一种类型的对象。</p>
<p>泛型的两个局限性：一是基本类型无法作为泛型的类型参数，类型参数必须为对象，而这可以通过自动拆装箱弥补。二是，在泛型代码内部，无法获取关于具体类型参数的任何信息，具体类型参数在通过检查并被编译后都将被擦除为边界类型，比如List&lt;T extends Person&gt; T将擦除到边界Person，而如果没有具体定义边界，则将被擦除到Object，例如List&lt;String&gt;和List&lt;Integer&gt; ，在编译后都将被擦除为原生List，即List&lt;Integer&gt;和List&lt;String&gt;在运行时事实上是相同的类型。</p>
<p>理解Java泛型的擦除应该从其历史的发展来进行。因为在一开始Java并没有出现泛型，而是在发展过程中将泛型作为一种技术加入到Java类库中，因此Java开发团队必须采用一种折中的处理方式，向前兼容之前的类库，不破坏原来类库中的代码，使泛型与非泛型代码共存。</p>
<p><strong>在编写泛型代码时，你要时刻告诉自己——这是一个Object!</strong></p>
<h2 id="Java泛型数组创建方法及实现原理"><a href="#Java泛型数组创建方法及实现原理" class="headerlink" title="Java泛型数组创建方法及实现原理"></a>Java泛型数组创建方法及实现原理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T[] array = <span class="keyword">new</span> T[size];</span><br></pre></td></tr></table></figure>

<p>此时上面这个代码也便好理解。我们想通过创建一个泛型数组来满足T在不同类型参数下的实现，但是Java泛型擦除告诉我们，上面这段代码等同于</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">Object[]<span class="built_in"> array </span>=<span class="built_in"> new </span>Object[size];</span><br></pre></td></tr></table></figure>

<p>我们无法在编译后获取到任何关于具体类型T的任何有关信息，也就无法创建一个具体类型T的数组。因此，要创建泛型数组，就必须在创建数组时，显示地指定类型T的具体参数信息。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">T[]<span class="built_in"> array </span>= (T[])new Object[size];</span><br></pre></td></tr></table></figure>

<p>这是一种创建数组的办法，你要问了？泛型不是会被擦除到边界吗，那上面这行代码的意义在于何处？从最终结果来看，</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">T[]<span class="built_in"> array </span>= (T[])new Object[size];  //等同于Object[]<span class="built_in"> array </span>= (T[])new Object[size];</span><br></pre></td></tr></table></figure>

<p>但是，不要忘了，在编译期间T还是一个有信息的类型参数，可以用于检查具体T参数是否符合期望。比如当你希望T是一个<code>Integer</code>时，<code>T[] array = (T[])new Object[size];</code>显然能在编译器进行检查，当检查到T的具体参数不是Integer类型时，编译不通过。</p>
<p>因此 <code>T[] array = (T[])new Object[size];</code>是一种创建泛型数组的手段。</p>
<p>另一种创建泛型数组的手段也是推荐的方式，通过<code>Array.newInstance</code>来创建一个泛型数组：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"> JDK中<span class="module-access"><span class="module"><span class="identifier">Array</span>.</span></span>newInstance源码</span><br><span class="line"> public static Object <span class="keyword">new</span><span class="constructor">Instance(Class&lt;?&gt; <span class="params">componentType</span>, <span class="params">int</span> <span class="params">length</span>)</span></span><br><span class="line">        throws NegativeArraySizeException &#123;</span><br><span class="line">        return <span class="keyword">new</span><span class="constructor">Array(<span class="params">componentType</span>, <span class="params">length</span>)</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// ComponentType为具体参数类型的class对象，length为希望创建的数组大小</span></span><br><span class="line"><span class="comment">//我们需要对其进行二次封装</span></span><br><span class="line">public static &lt;T&gt; T<span class="literal">[]</span> get<span class="constructor">Array(Class&lt;T&gt; <span class="params">componentType</span>, <span class="params">int</span> <span class="params">length</span>)</span> &#123;</span><br><span class="line">	return (T<span class="literal">[]</span>) <span class="module-access"><span class="module"><span class="identifier">Array</span>.</span></span><span class="keyword">new</span><span class="constructor">Instance(<span class="params">componentType</span>, <span class="params">length</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这道理和T[] array = (T[])new Object[size];相同，但是更加规范</span></span><br></pre></td></tr></table></figure>

<p>这里补充一个泛型使用技巧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortWithTopDown</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> E[] aux; <span class="comment">//辅助数组</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(E[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = array.length;</span><br><span class="line">        aux = (E[]) <span class="keyword">new</span> Object[n];</span><br><span class="line">        sort(array, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码在编译的时候，会报错：<code>java.lang.Object cannot be cast to Comparable...</code>，我想了很久，也没有找到解决办法，但是回过头来看资料“泛型可以定义多个边界，只会被擦除到第一个边界”，就想说通过定义第一个边界来消除这个错误，于是上面的代码变成了下面这样，将Object作为第一个边界，这确实可行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortWithTopDown</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Object</span> &amp; <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> E[] aux; <span class="comment">//辅助数组</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(E[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = array.length;</span><br><span class="line">        aux = (E[]) <span class="keyword">new</span> Object[n]; </span><br><span class="line">        sort(array, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Java泛型数组, Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda(一)</title>
    <url>/2020/05/13/Lambda(%E4%B8%80)/</url>
    <content><![CDATA[<p>Java中的Lambda表达式借鉴了其他语言的类似特性，简化了匿名函数的表达方式。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p>使用Lambda表达式后为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p>功能相同，但是更加简洁。Lambda表达式这种直接以内联的形式为函数式接口的抽象方法提供实现，并将整个表达式作为函数式接口的实例。（函数式接口简单来说就是只包含一个抽象方法的接口）</p>
<span id="more"></span>

<h2 id="Lambda表达式解析"><a href="#Lambda表达式解析" class="headerlink" title="Lambda表达式解析"></a>Lambda表达式解析</h2><p>Lambda表达式基本语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt; <span class="function">expression</span></span><br><span class="line"><span class="function">    <span class="title">or</span></span></span><br><span class="line"><span class="function"><span class="params">(Parameters)</span> -&gt; </span>&#123; statements; &#125;</span><br></pre></td></tr></table></figure>

<p>由三部分构成：</p>
<ol>
<li>参数列表</li>
<li><code>-&gt;</code> 将参数列表和Lambda表达式主体分隔开</li>
<li>Lambda主体，只有一行代码时才可以省略大括号和return关键字</li>
</ol>
<p>合法的Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(String str) -&gt; str.length()</span><br><span class="line">(String str) -&gt; &#123; <span class="keyword">return</span> str.length(); &#125; <span class="comment">// 和上面的功能一样</span></span><br><span class="line"></span><br><span class="line">() -&gt; Systm.out.println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">() -&gt; &#123;&#125;</span><br><span class="line">() -&gt; <span class="number">17</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lambda表达式使用场合"><a href="#Lambda表达式使用场合" class="headerlink" title="Lambda表达式使用场合"></a>Lambda表达式使用场合</h2><p>使用条件：</p>
<ol>
<li>实现的对象是函数式接口的抽象方法，比如Runnable的run方法</li>
<li>函数式接口的抽象方法的函数描述和Lambda表达式函数描述符一致</li>
</ol>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>常见的函数式接口有：<code>java.util.Comparator</code> ，<code>java.lang.Runnable</code> 等</p>
<p>比如 <code>java.lang.Runnable</code> 其源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口只有一个抽象方法，并使用 <code>@FunctionalInterface</code> 注解标注</p>
<p>接口可以有默认方法，而且可以有多个，这不影响接口是否为函数式接口，但是抽象方法只能有一个。</p>
<h3 id="函数描述符"><a href="#函数描述符" class="headerlink" title="函数描述符"></a>函数描述符</h3><p>函数描述符也可以理解为方法的签名。比如上述的Runnable抽象方法不接受参数，并且返回void，所以其函数描述符为 <code>() -&gt; void</code> 。而 <code>() -&gt; System.out.println(&quot;hello&quot;)</code> Lambda表达式也是不接受参数，并且返回void，所以其函数描述符也是 <code>() -&gt; void</code> 。所以代码 <code>Runnable r = () -&gt; System.out.println(&quot;hello&quot;);</code> 是合法的。</p>
<h2 id="更简洁的Lambda表达式"><a href="#更简洁的Lambda表达式" class="headerlink" title="更简洁的Lambda表达式"></a>更简洁的Lambda表达式</h2><p>自定义一个类型转化的函数式接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transform</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">transform</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未简化的Lambda表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transform&lt;String, Integer&gt; t = (String str) -&gt; Integer.valueOf(str);</span><br><span class="line">System.out.println(t.transform(<span class="string">&quot;123&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>简化后的Lambda表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transform&lt;String, Integer&gt; t = (str) -&gt; Integer.valueOf(str);</span><br><span class="line">System.out.println(t.transform(<span class="string">&quot;123&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>简化和的表达式不需要写出参数的类型，因为Java编译器会从上下文推断出用什么函数式接口来配合Lambda表达式，这意味着它可以推断出合适Lambda的签名。比如在上面这个例子中，Transform的抽象方法transform的函数描述符为 <code>(String) -&gt; Integer</code>  ，所以对应的Lambda的签名也是如此，即使Lambda的参数不声明类型，Java编译器可以知道其参数实际上为String类型。</p>
<p>上面的还不是最简的Lambda表达式，还可以优化成：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Transform</span>&lt;String, <span class="type">Integer</span>&gt; t = <span class="type">Integer</span>::valueOf;</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(t.<span class="keyword">transform</span>(&quot;123&quot;));</span><br></pre></td></tr></table></figure>

<p>虽然好像和Lambda表达式的3个结构不同，这种写法也有它的名称：<strong>方法的引用</strong></p>
<p>方法引用可以被看作仅仅调用特定方法的Lambda的一种快捷写法。它的基本思想是，如果一个Lambda代表的只是“直接调用这个方法”，那最好还是用名称来调用它，而不是去描述如何调用它，这样代码可读性更好。</p>
<p>方法引用格式为：<code>目标引用::方法名称</code></p>
<p>常见的方法引用：</p>
<table>
<thead>
<tr>
<th>Lambda表达式</th>
<th>等效方法引用</th>
</tr>
</thead>
<tbody><tr>
<td>(String s) -&gt; System.out.println(s)</td>
<td>System.out::println</td>
</tr>
<tr>
<td>(str, i) -&gt; str.substring(i)</td>
<td>String::substring</td>
</tr>
<tr>
<td>() -&gt; Thread.currentThread().dumpStack()</td>
<td>Thread.currentThread()::dumpStack</td>
</tr>
</tbody></table>
<h2 id="Lambda表达式访问遍历"><a href="#Lambda表达式访问遍历" class="headerlink" title="Lambda表达式访问遍历"></a>Lambda表达式访问遍历</h2><p>Lambda表达式可以访问 <code>局部final变量, 成员变量, 静态变量</code></p>
<p>这里主要说明局部final变量，有没有final关键字不重要，重要的是要确保该变量的值不会改变，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String hello = <span class="string">&quot;hello lambda&quot;</span>;</span><br><span class="line">Runnable r = () -&gt; System.out.println(hello);</span><br><span class="line"><span class="comment">// 该例子可以编译通过</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String hello = <span class="string">&quot;hello lambda&quot;</span>;</span><br><span class="line">Runnable r = () -&gt; System.out.println(hello);</span><br><span class="line">hello = <span class="string">&quot;change hello&quot;</span>;</span><br><span class="line"><span class="comment">// 该例子可以编译不通过</span></span><br></pre></td></tr></table></figure>

<h2 id="不使用Lambda表达式和使用Lambda表达式的对比"><a href="#不使用Lambda表达式和使用Lambda表达式的对比" class="headerlink" title="不使用Lambda表达式和使用Lambda表达式的对比"></a>不使用Lambda表达式和使用Lambda表达式的对比</h2><p>假设有如下需求：有一个包含了各种颜色不同重量的苹果框（假设为List），编写一个方法，从中筛选出：红色的苹果；红色的苹果并且重量大于1kg；绿色苹果并且重量小于0.5kg；红色的苹果并且重量大于0.5kg。</p>
<p>首先定义一个筛选接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppleFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据不同条件编写不同实现类：</p>
<h4 id="不使用Lambda表达式"><a href="#不使用Lambda表达式" class="headerlink" title="不使用Lambda表达式"></a>不使用Lambda表达式</h4><p>红色的苹果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedApple</span> <span class="keyword">implements</span> <span class="title">AppleFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;red&quot;</span>.equalsIgnoreCase(apple.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>红色的苹果并且重量大于1kg：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedAndMoreThan1kgApple</span> <span class="keyword">implements</span> <span class="title">AppleFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;red&quot;</span>.equalsIgnoreCase(apple.getColor()) &amp;&amp; apple.getWeight() &gt; <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>绿色苹果并且重量小于0.5kg，红色的苹果并且重量大于0.5kg：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenAndLessThan05OrRedAndMoreThan05Apple</span> <span class="keyword">implements</span> <span class="title">AppleFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;green&quot;</span>.equalsIgnoreCase(apple.getColor()) &amp;&amp; apple.getWeight() &lt; <span class="number">0.5</span>)</span><br><span class="line">                || (<span class="string">&quot;red&quot;</span>.equalsIgnoreCase(apple.getColor()) &amp;&amp; apple.getWeight() &gt; <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>筛选苹果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFilterMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterApple</span><span class="params">(List&lt;Apple&gt; list, AppleFilter filter)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; filterList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Apple apple : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (filter.test(apple)) &#123;</span><br><span class="line">                filterList.add(apple);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> filterList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; appleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;red&quot;</span>, <span class="number">0.4</span>));</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;red&quot;</span>, <span class="number">0.6</span>));</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;red&quot;</span>, <span class="number">1.3</span>));</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;green&quot;</span>, <span class="number">0.2</span>));</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;green&quot;</span>, <span class="number">0.35</span>));</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;green&quot;</span>, <span class="number">1.1</span>));</span><br><span class="line"></span><br><span class="line">		List&lt;Apple&gt; appleFilterList = filterApple(appleList, <span class="keyword">new</span> RedApple());</span><br><span class="line">		<span class="keyword">for</span> (Apple apple : appleFilterList) &#123;</span><br><span class="line">    		System.out.println(apple.getColor() + <span class="string">&quot; apple,weight:&quot;</span> + 					apple.getWeight());</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">red apple,weight:0.4</span><br><span class="line">red apple,weight:0.6</span><br><span class="line">red apple,weight:1.3</span><br></pre></td></tr></table></figure>

<h4 id="使用Lambda表达式"><a href="#使用Lambda表达式" class="headerlink" title="使用Lambda表达式"></a>使用Lambda表达式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFilterMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterApple</span><span class="params">(List&lt;Apple&gt; list, AppleFilter filter)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; filterList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Apple apple : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (filter.test(apple)) &#123;</span><br><span class="line">                filterList.add(apple);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> filterList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; appleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;red&quot;</span>, <span class="number">0.4</span>));</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;red&quot;</span>, <span class="number">0.6</span>));</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;red&quot;</span>, <span class="number">1.3</span>));</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;green&quot;</span>, <span class="number">0.2</span>));</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;green&quot;</span>, <span class="number">0.35</span>));</span><br><span class="line">		appleList.add(<span class="keyword">new</span> Apple(<span class="string">&quot;green&quot;</span>, <span class="number">1.1</span>));</span><br><span class="line"></span><br><span class="line">		List&lt;Apple&gt; appleFilterList = filterApple(appleList, (apple) -&gt; <span class="string">&quot;red&quot;</span>.equalsIgnoreCase(apple.getColor()));</span><br><span class="line">		<span class="keyword">for</span> (Apple apple : appleFilterList) &#123;</span><br><span class="line">    		System.out.println(apple.getColor() + <span class="string">&quot; apple,weight:&quot;</span> + 					apple.getWeight());</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="keyword">red</span> apple,weigh<span class="variable">t:0</span>.<span class="number">4</span></span><br><span class="line"><span class="keyword">red</span> apple,weigh<span class="variable">t:0</span>.<span class="number">6</span></span><br><span class="line"><span class="keyword">red</span> apple,weigh<span class="variable">t:1</span>.<span class="number">3</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>lamda</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用组合键</title>
    <url>/2020/03/27/Linux%E5%B8%B8%E7%94%A8%E7%BB%84%E5%90%88%E9%94%AE/</url>
    <content><![CDATA[<h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><blockquote>
<ul>
<li><kbd>Ctrl</kbd>+<kbd>A</kbd>  移动到光标到行首</li>
<li><kbd>Ctrl</kbd>+<kbd>E</kbd>  移动光标到行尾</li>
<li><kbd>Ctrl</kbd>+<kbd>F</kbd>  光标向前移动一个字符 和 <kbd>←</kbd> 作用一样</li>
<li><kbd>Ctrl</kbd>+<kbd>B</kbd> 光标向后移动一个字符 和<kbd>→</kbd>作用一样</li>
<li><kbd>Ctrl</kbd>+<kbd>L</kbd> 清屏</li>
</ul>
<span id="more"></span>
</blockquote>
<h2 id="修改文本"><a href="#修改文本" class="headerlink" title="修改文本"></a>修改文本</h2><blockquote>
<ul>
<li><kbd>Ctrl</kbd>+<kbd>D</kbd>  删除光标处的字符</li>
<li><kbd>Ctrl</kbd>+<kbd>T</kbd>  使光标处的字符和其前面的字符交换位置</li>
<li><kbd>Alt</kbd>+<kbd>L</kbd>   从光标到字尾的字符转换成小写字母形式</li>
<li><kbd>Alt</kbd>+<kbd>U</kbd>  从光标到字尾的字符转换成大写字母形式</li>
</ul>
</blockquote>
<h2 id="自动补齐"><a href="#自动补齐" class="headerlink" title="自动补齐"></a>自动补齐</h2><blockquote>
<p>输入命令时，按下Tab键将触发自动补齐功能。但需要注意的是，只有输入的内容不模棱两可，没有多个匹配的内容，是确定性的匹配时，才会自动补齐。比如在当前目录：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">目录下有Desktop  Downloads  Documents文件目录</span><br><span class="line">当在命令行输入：</span><br><span class="line"><span class="keyword">ls</span> <span class="keyword">D</span></span><br><span class="line">按下<span class="keyword">Tab</span>键不会自动补齐，因为此时匹配结果有3个。继续输入：</span><br><span class="line"><span class="keyword">ls</span> <span class="keyword">Do</span></span><br><span class="line">按下<span class="keyword">Tab</span>键不会自动补齐，因为此时匹配结果有2个。继续输入：</span><br><span class="line"><span class="keyword">ls</span> Dow</span><br><span class="line">按下<span class="keyword">Tab</span>键会自动补齐，此时匹配结果唯一：</span><br><span class="line"><span class="keyword">ls</span> Downloads/</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="历史命令记录"><a href="#历史命令记录" class="headerlink" title="历史命令记录"></a>历史命令记录</h2><blockquote>
<ul>
<li><kbd>Ctrl</kbd>+<kbd>P</kbd>   移动到前一条历史记录，相当于向上键</li>
<li><kbd>Ctrl</kbd>+<kbd>N</kbd>  移动到后一条历史记录，相当于向下键</li>
<li><kbd>Alt</kbd>+<kbd><</kbd>   移动到历史记录列表的开始处</li>
<li><kbd>Alt</kbd>+<kbd>></kbd>  移动到历史记录列表结尾处</li>
<li><kbd>Ctrl</kbd>+<kbd>R</kbd>  从当前命令行向前递增搜索</li>
<li><kbd>Ctrl</kbd>+<kbd>O</kbd>  执行历史记录当前项，执行完跳到下一项</li>
<li><kbd>Alt</kbd>+<kbd>P</kbd>  逆向非递增搜索</li>
<li><kbd>Alt</kbd>+<kbd>N</kbd>  向前非递增搜索</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>linux, 组合键</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2020/01/09/MarkDown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>主要为平时更好地写博客，省去网上查找资料的麻烦，自己对Markdown常用语法做了一个总结，并做了一些排版，便于查看。</p>
<span id="more"></span>

<h1 id="Markdown标题，使用-创建标题"><a href="#Markdown标题，使用-创建标题" class="headerlink" title="Markdown标题，使用 # 创建标题"></a>Markdown标题，使用 # 创建标题</h1><blockquote>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p><code># 一级标题</code></p>
<blockquote>
<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p><code>## 二级标题</code></p>
</blockquote>
<blockquote>
<blockquote>
<h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p><code>### 三级标题</code></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p><code>#### 四级标题</code></p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><p><code>##### 五级标题</code></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p><code>###### 六级标题</code></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h1 id="Markdown段落格式"><a href="#Markdown段落格式" class="headerlink" title="Markdown段落格式"></a>Markdown段落格式</h1><blockquote>
<blockquote>
<p>段落的换行：两个空格+回车</p>
</blockquote>
<blockquote>
<p>字体：</p>
</blockquote>
<blockquote>
<p>​            <em>斜体</em>        <code>*斜体文本*</code></p>
</blockquote>
<blockquote>
<p>​            <em>斜体</em>         <code>_斜体文本_</code></p>
</blockquote>
<blockquote>
<p>​            <strong>粗体</strong>         <code>**粗体文本**</code></p>
</blockquote>
<blockquote>
<p>​            <strong>粗体</strong>         <code>__粗体文本__</code> </p>
</blockquote>
<blockquote>
<p>​            <em><strong>斜粗体</strong></em>      <code>***斜粗体文本***</code></p>
</blockquote>
<blockquote>
<p>​            <em><strong>斜粗体</strong></em>      <code>___斜粗体文本___</code></p>
</blockquote>
<blockquote>
<p>分隔线：在一行中用三个以上的 星号 * 或者 减号 -  或者 下划线 _ 来建立一个分隔线。注意，行内不能有其他东西，但你可以在每个符号间插入空格。比如：***    或者   *  *  *  或者 ---  或者 -  -  -   或者 ___    或者 _  _  _  都是允许的，效果如下：</p>
</blockquote>
<blockquote>
<hr>
</blockquote>
<blockquote>
<p>删除线：</p>
<p>​            <del>Doug Wilson</del>     <code>~~Doug Wilson~~</code></p>
</blockquote>
<blockquote>
<p>下划线：</p>
<p>​            <u>Doug Wilson</u>       <code>&lt;u&gt;Doug Wilson&lt;/u&gt;</code></p>
</blockquote>
<blockquote>
<p>脚注：</p>
<p>​        脚注格式：<a href="%E9%BC%A0%E6%A0%87%E7%A7%BB%E5%8A%A8%E5%88%B0%E8%84%9A%E6%B3%A8%E4%B8%8A%E5%B0%B1%E4%BC%9A%E6%98%BE%E7%A4%BA%E5%86%85%E5%AE%B9">^我是脚注</a></p>
</blockquote>
<blockquote>
<p>​        <code>脚注格式：[^我是脚注]</code></p>
<p>​    <code>[^我是脚注]:鼠标移动到脚注上就会显示内容</code></p>
</blockquote>
</blockquote>
<h1 id="Markdown列表"><a href="#Markdown列表" class="headerlink" title="Markdown列表"></a>Markdown列表</h1><blockquote>
<p>无序列表：</p>
</blockquote>
<ul>
<li><p>第一项               <code>* 第一项</code></p>
</li>
<li><p>第二项               <code>* 第二项</code></p>
</li>
<li><p>第三项               <code>* 第三项</code></p>
<p>或者 用 + 或者 - 代替 * 也可以实现无序列表</p>
</li>
</ul>
<blockquote>
<p>有序列表：</p>
</blockquote>
<ol>
<li><p>第一项               <code>1. 第一项</code></p>
</li>
<li><p>第二项               <code>2. 第二项</code></p>
</li>
<li><p>第三项               <code>3. 第三项</code></p>
<p> 即采用  数字.空格 列名称</p>
</li>
</ol>
<blockquote>
<p>列表嵌套：在子列表的选项前面添加4个空格即可</p>
</blockquote>
<ol>
<li>第一项<ul>
<li>子第一项</li>
<li>子第二项</li>
</ul>
</li>
<li>第二项<ul>
<li>子第一项</li>
<li>子第二项</li>
</ul>
</li>
</ol>
<h1 id="Markdown区块"><a href="#Markdown区块" class="headerlink" title="Markdown区块"></a>Markdown区块</h1><p>区块：</p>
<blockquote>
<p>区块第一行           <code>&gt; 区块第一行</code></p>
<p>区块第二行           <code>&gt; 区块第二行</code></p>
<p>区块第三行           <code>&gt; 区块第三行</code></p>
</blockquote>
<p>区块嵌套：</p>
<blockquote>
<p>区块最外层                                 <code>&gt;区块最外层</code></p>
<blockquote>
<p>区块第二层                            <code>&gt;&gt;区块第二层</code></p>
<blockquote>
<p>区块第三层                       <code>&gt;&gt;&gt;区块第三层</code></p>
</blockquote>
</blockquote>
</blockquote>
<p>区块中要使用别的内容，只需要在对应的符号 &gt; 后面加上需要的内容即可，比如我想加一个粗体：</p>
<blockquote>
<p><strong>粗体</strong> </p>
<p><code>&gt;**粗体**</code></p>
</blockquote>
<h1 id="Markdown代码"><a href="#Markdown代码" class="headerlink" title="Markdown代码"></a>Markdown代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Java代码块&quot;</span>);</span><br><span class="line"><span class="comment">//使用Ctrl+Shift+K</span></span><br></pre></td></tr></table></figure>

<h1 id="Markdown链接"><a href="#Markdown链接" class="headerlink" title="Markdown链接"></a>Markdown链接</h1><p><a href="https://gitee.com/doug-wilson">我的作品地址：</a></p>
<p>​        <code>[我的作品地址：](链接地址)</code></p>
<p>这可以和脚注配合使用，具体用法自己尝试</p>
<h1 id="Markdown图片"><a href="#Markdown图片" class="headerlink" title="Markdown图片"></a>Markdown图片</h1><img src="/C:/Users\HMY-computer\Pictures\timg76C2063E.jpg" alt="图片介绍" style="zoom:50%;">

<p>语法格式：</p>
<p>​            <code>![alt 图片文本](图片地址)</code></p>
<h1 id="Markdown表格"><a href="#Markdown表格" class="headerlink" title="Markdown表格"></a>Markdown表格</h1><table>
<thead>
<tr>
<th>表头1</th>
<th>表头2</th>
<th>表头3</th>
</tr>
</thead>
<tbody><tr>
<td>单元1</td>
<td>单元2</td>
<td>单元3</td>
</tr>
</tbody></table>
<p>语法格式：</p>
<p>​            |表头1|表头2|表头3|</p>
<p>​            |----|----|----|</p>
<p>​            |单元1|单元2|单元3|</p>
<p>设置对齐：</p>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="center">居中对齐</th>
<th align="right">右对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元1</td>
<td align="center">单元2</td>
<td align="right">单元3</td>
</tr>
</tbody></table>
<p>​        语法格式：</p>
<p>​            |左对齐|居中对齐|右对齐|</p>
<p>​            | :—- | :—-: | —-: |</p>
<p>​            |单元1|单元2|单元3|</p>
<h1 id="Markdown转义字符"><a href="#Markdown转义字符" class="headerlink" title="Markdown转义字符"></a>Markdown转义字符</h1><p>反斜线  <br>反引号  `<br>星号    *<br>下划线  _<br>花括号  {}<br>方括号  []<br>小括号  ()<br>井号    #<br>加号    +<br>减号      -<br>英文句点  .<br>感叹号   !</p>
<p>通过在转义字符前加反斜杠\来获取字符，取消其特殊含义</p>
<h1 id="Markdown支持的HTML元素"><a href="#Markdown支持的HTML元素" class="headerlink" title="Markdown支持的HTML元素"></a>Markdown支持的HTML元素</h1><p>&lt;kbd&gt; &lt;b&gt;  &lt;i&gt;  &lt;em&gt;  &lt;sup&gt;  &lt;sub&gt;  &lt;br&gt;</p>
<p>如：使用<kbd>Ctrl</kbd>+<kbd>Shift</kbd>回到行首</p>
<p>​    语法格式：使用&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;回到行首</p>
<h1 id="Markdown数学公式"><a href="#Markdown数学公式" class="headerlink" title="Markdown数学公式"></a>Markdown数学公式</h1><p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}<br>$$</p>
<p>语法格式：</p>
<p>$$</p>
<p>\mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}</p>
<p>$$</p>
<p>通过两个美元符号$$包裹由TeX或LaTeX格式的数学公式进行实现</p>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis映射器</title>
    <url>/2020/12/17/MyBatis%E6%98%A0%E5%B0%84%E5%99%A8/</url>
    <content><![CDATA[<p>映射器的配置：</p>
<table>
<thead>
<tr>
<th><strong>元素名称</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>select</td>
<td>查询语句</td>
</tr>
<tr>
<td>insert</td>
<td>插入语句</td>
</tr>
<tr>
<td>update</td>
<td>更新语句</td>
</tr>
<tr>
<td>delete</td>
<td>删除语句</td>
</tr>
<tr>
<td>sql</td>
<td>允许定义一部分SQL，然后各个地方引用</td>
</tr>
<tr>
<td>resultMap</td>
<td>用于定义结果集</td>
</tr>
<tr>
<td>cache</td>
<td>给定命名控件的缓存配置</td>
</tr>
<tr>
<td>cache-ref</td>
<td>其它命名控件缓存配置的引用</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h3 id="mapUnderscoreToCamelCase"><a href="#mapUnderscoreToCamelCase" class="headerlink" title="mapUnderscoreToCamelCase"></a>mapUnderscoreToCamelCase</h3><p>数据库字段名一般采用下划线命名规则，而java中的字段名用的是驼峰命名规则：</p>
<table>
<thead>
<tr>
<th>JavaBean</th>
<th>数据库</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>id</td>
</tr>
<tr>
<td>roleName</td>
<td>role_name</td>
</tr>
<tr>
<td>note</td>
<td>note</td>
</tr>
<tr>
<td>isGirl</td>
<td>is_girl</td>
</tr>
</tbody></table>
<p>如果数据库字段命名规范，我们可以在settins中配置mapUnderscoreToCamelCase为true：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>MyBatis就会自动将数据库字段名转换为JavaBean的字段名，比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;role&quot;</span>&gt;</span></span><br><span class="line">	&lt;![CDATA[select * from t_role where id = #&#123;id&#125;]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果不将mapUnderscoreToCamelCase设置为true，则select元素必须指明字段别名：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;role&quot;</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[select id,role_name as roleName,</span><br><span class="line">        note,is_girl as isGirl from t_role where id = #&#123;id&#125;]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>否则没有对应上的字段值为null。</p>
<h3 id="传递多个参数"><a href="#传递多个参数" class="headerlink" title="传递多个参数"></a>传递多个参数</h3><ol>
<li><p>使用Map传参</p>
<p>定义一个抽象方法：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Role&gt; <span class="title">getRole</span><span class="params">(Map&lt;String,String&gt; params)</span></span>;</span><br></pre></td></tr></table></figure>

<p>映射文件中配置select：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;role&quot;</span> <span class="attr">id</span>=<span class="string">&quot;roleList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;role_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;roleName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;note&quot;</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;is_girl&quot;</span> <span class="attr">property</span>=<span class="string">&quot;isGirl&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">javaType</span>=<span class="string">&quot;Boolean&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getRole&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;roleList&quot;</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[select * from t_role where role_name like </span><br><span class="line">        concat(&#x27;%&#x27;,#&#123;roleName&#125;,&#x27;%&#x27;) and note like </span><br><span class="line">        concat(&#x27;%&#x27;,#&#123;note&#125;,&#x27;%&#x27;)</span><br><span class="line">    ]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = <span class="module-access"><span class="module"><span class="identifier">SqlSessionFactoryUtil</span>.</span></span><span class="keyword">open</span><span class="constructor">SqlSession()</span>;</span><br><span class="line">RoleMapper mapper = sqlSession.get<span class="constructor">Mapper(RoleMapper.<span class="params">class</span>)</span>;</span><br><span class="line">Map&lt;String,String&gt; params = <span class="keyword">new</span> HashMap&lt;String,String&gt;<span class="literal">()</span>;</span><br><span class="line">params.put(<span class="string">&quot;roleName&quot;</span>, <span class="string">&quot;雏田&quot;</span>);</span><br><span class="line">params.put(<span class="string">&quot;note&quot;</span>, <span class="string">&quot;日向&quot;</span>);</span><br><span class="line">List&lt;Role&gt; roleList = mapper.get<span class="constructor">Role(<span class="params">params</span>)</span>;</span><br><span class="line"><span class="keyword">for</span>(Role r : roleList)&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(r.get<span class="constructor">RoleName()</span>+<span class="string">&quot; is a girl:&quot;</span>+r.get<span class="constructor">IsGirl()</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">雏田 <span class="keyword">is</span> a girl:<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用注解传参</li>
</ol>
<p>修改抽象方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Role&gt; getRole(<span class="meta">@Param(<span class="meta-string">&quot;roleName&quot;</span>)</span>String roleName,</span><br><span class="line">    <span class="meta">@Param(<span class="meta-string">&quot;note&quot;</span>)</span>String note);</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = <span class="module-access"><span class="module"><span class="identifier">SqlSessionFactoryUtil</span>.</span></span><span class="keyword">open</span><span class="constructor">SqlSession()</span>;</span><br><span class="line">RoleMapper mapper = sqlSession.get<span class="constructor">Mapper(RoleMapper.<span class="params">class</span>)</span>;</span><br><span class="line">List&lt;Role&gt; roleList = mapper.get<span class="constructor">Role(<span class="string">&quot;雏田&quot;</span>, <span class="string">&quot;日向&quot;</span>)</span>;</span><br><span class="line"><span class="keyword">for</span>(Role r : roleList)&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(r.get<span class="constructor">RoleName()</span>+<span class="string">&quot; is a girl:&quot;</span>+r.get<span class="constructor">IsGirl()</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">雏田 <span class="keyword">is</span> a girl:<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用JavaBean传参</li>
</ol>
<p>定义一个传递参数JavaBean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleParams</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoleName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> roleName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoleName</span><span class="params">(String roleName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roleName = roleName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNote</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> note;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNote</span><span class="params">(String note)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.note = note;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Role&gt; <span class="title">getRole</span><span class="params">(RoleParams params)</span></span>;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = <span class="module-access"><span class="module"><span class="identifier">SqlSessionFactoryUtil</span>.</span></span><span class="keyword">open</span><span class="constructor">SqlSession()</span>;</span><br><span class="line">RoleMapper mapper = sqlSession.get<span class="constructor">Mapper(RoleMapper.<span class="params">class</span>)</span>;</span><br><span class="line">RoleParams params = <span class="keyword">new</span> <span class="constructor">RoleParams()</span>;</span><br><span class="line">params.set<span class="constructor">RoleName(<span class="string">&quot;鸣人&quot;</span>)</span>;</span><br><span class="line">params.set<span class="constructor">Note(<span class="string">&quot;旋涡&quot;</span>)</span>;</span><br><span class="line">List&lt;Role&gt; roleList = mapper.get<span class="constructor">Role(<span class="params">params</span>)</span>;</span><br><span class="line"><span class="keyword">for</span>(Role r : roleList)&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(r.get<span class="constructor">RoleName()</span>+<span class="string">&quot; is a girl:&quot;</span>+r.get<span class="constructor">IsGirl()</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">鸣人 <span class="keyword">is</span> a girl:<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><h3 id="主键回填和自定义"><a href="#主键回填和自定义" class="headerlink" title="主键回填和自定义"></a>主键回填和自定义</h3><p>开发中有时候需要获取到插入行的主键值，MyBatis的主键回填可以完成这个功能。</p>
<p>定义一个createRole抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">createRole</span><span class="params">(Role role)</span></span>;</span><br></pre></td></tr></table></figure>

<p>映射：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;createRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;role&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">        insert into t_role(role_name,note,is_girl) values (#&#123;roleName&#125;,#&#123;note&#125;,</span><br><span class="line">        #&#123;isGirl,typeHandler=mrbird.leanote.typehandler.BooleanTypeHandler&#125;)</span><br><span class="line">    ]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>useGeneratedKeys会使MyBatis使用JDBC的getGeneratedKeys方法来获取出由数据库内部生成的主键，keyProperty表示以哪个列为属性的主键。</p>
<p>测试获取主键：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = <span class="module-access"><span class="module"><span class="identifier">SqlSessionFactoryUtil</span>.</span></span><span class="keyword">open</span><span class="constructor">SqlSession()</span>;</span><br><span class="line">RoleMapper mapper = sqlSession.get<span class="constructor">Mapper(RoleMapper.<span class="params">class</span>)</span>;</span><br><span class="line">Role role = <span class="keyword">new</span> <span class="constructor">Role()</span>;</span><br><span class="line">role.set<span class="constructor">RoleName(<span class="string">&quot;佐助&quot;</span>)</span>;</span><br><span class="line">role.set<span class="constructor">Note(<span class="string">&quot;宇智波&quot;</span>)</span>;</span><br><span class="line">role.set<span class="constructor">IsGirl(Boolean.FALSE)</span>;</span><br><span class="line">mapper.create<span class="constructor">Role(<span class="params">role</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(role.get<span class="constructor">Id()</span>); <span class="comment">//7</span></span><br><span class="line">sqlSession.commit<span class="literal">()</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>页面输出 7，查询数据库：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="section">mysql&gt; select * from t_role;</span></span><br><span class="line"><span class="section">+----+-----------+----------+---------+</span></span><br><span class="line"><span class="section">| id | role_name | note     | is_girl |</span></span><br><span class="line"><span class="section">+----+-----------+----------+---------+</span></span><br><span class="line">|  1 | 雏田      | 日向雏田  | Y       |</span><br><span class="line">|  2 | 鸣人      | 旋涡鸣人  | N       |</span><br><span class="line"><span class="section">|  7 | 佐助      | 宇智波    | N       |</span></span><br><span class="line"><span class="section">+----+-----------+----------+---------+</span></span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>假如数据库主键没有设置自增，我们的要求是：如果表t_role没有记录，则id设置为1，否则我们取最大id加2。这时候我们可以对映射文件的insert标签稍作修改：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;createRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;role&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- resultType必须和POJO里id的类型一致 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span>&gt;</span></span><br><span class="line">        &lt;![CDATA[</span><br><span class="line">            select if(max(id) is null,1,max(id)+2) as id from t_role</span><br><span class="line">        ]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">        insert into t_role(id,role_name,note,is_girl) values (#&#123;id&#125;,#&#123;roleName&#125;,</span><br><span class="line">        #&#123;note&#125;,</span><br><span class="line">        #&#123;isGirl,typeHandler=mrbird.leanote.typehandler.BooleanTypeHandler&#125;)</span><br><span class="line">    ]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = <span class="module-access"><span class="module"><span class="identifier">SqlSessionFactoryUtil</span>.</span></span><span class="keyword">open</span><span class="constructor">SqlSession()</span>;</span><br><span class="line">RoleMapper mapper = sqlSession.get<span class="constructor">Mapper(RoleMapper.<span class="params">class</span>)</span>;</span><br><span class="line">Role role = <span class="keyword">new</span> <span class="constructor">Role()</span>;</span><br><span class="line">role.set<span class="constructor">RoleName(<span class="string">&quot;小樱&quot;</span>)</span>;</span><br><span class="line">role.set<span class="constructor">Note(<span class="string">&quot;春野樱&quot;</span>)</span>;</span><br><span class="line">role.set<span class="constructor">IsGirl(Boolean.TRUE)</span>;</span><br><span class="line">mapper.create<span class="constructor">Role(<span class="params">role</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(role.get<span class="constructor">Id()</span>); <span class="comment">//9</span></span><br><span class="line">sqlSession.commit<span class="literal">()</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>输出9和我们预期的一致，查询数据库：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="section">mysql&gt; select * from t_role;</span></span><br><span class="line"><span class="section">+----+-----------+----------+---------+</span></span><br><span class="line"><span class="section">| id | role_name | note     | is_girl |</span></span><br><span class="line"><span class="section">+----+-----------+----------+---------+</span></span><br><span class="line">|  1 | 雏田      | 日向雏田  | Y       |</span><br><span class="line">|  2 | 鸣人      | 旋涡鸣人  | N       |</span><br><span class="line">|  7 | 佐助      | 宇智波    | N       |</span><br><span class="line"><span class="section">|  9 | 小樱      | 春野樱    | Y       |</span></span><br><span class="line"><span class="section">+----+-----------+----------+---------+</span></span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="update-amp-delete"><a href="#update-amp-delete" class="headerlink" title="update &amp; delete"></a>update &amp; delete</h2><p>update和delete较为简单，一个简单的更新和删除例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;role&quot;</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">        update t_role set role_name = #&#123;roleName&#125;,</span><br><span class="line">        note = #&#123;note&#125; where id = #&#123;id&#125;</span><br><span class="line">    ]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">        delete from t_role where id = #&#123;id&#125;</span><br><span class="line">    ]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>参数除了可以指定javaType，jdbcType和typeHandler外，还可以对数值类型的参数设置精度：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">#&#123;price,javaType=<span class="type">double</span>,jdbcType=<span class="type">NUMERIC</span>,numericScale=<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="与"><a href="#与" class="headerlink" title="$与#"></a>$与#</h3><p>#{}的值被作为sql的参数，而${}则会被当作sql的一部分。</p>
<h2 id="sql元素"><a href="#sql元素" class="headerlink" title="sql元素"></a>sql元素</h2><p>sql元素的作用是可以定义sql语句的一部分，然后导出引用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;t_role_column&quot;</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[id,role_name as roleName,note,is_girl as isGirl]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getRole&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;roleList&quot;</span>&gt;</span></span><br><span class="line">    select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;t_role_column&quot;</span>/&gt;</span></span><br><span class="line">    from t_role where role_name like </span><br><span class="line">    concat(&#x27;%&#x27;,#&#123;roleName&#125;,&#x27;%&#x27;) and note like </span><br><span class="line">    concat(&#x27;%&#x27;,#&#123;note&#125;,&#x27;%&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码定义了一个id为t_role_column的sql，然后在select元素中使用include元素引用了它，从而达到了重用的功能。</p>
<p>还可以在sql元素中指定标签：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;t_role_column&quot;</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[$&#123;prefix&#125;.id,$&#123;prefix&#125;.role_name as roleName,</span><br><span class="line">    $&#123;prefix&#125;.note,$&#123;prefix&#125;.is_girl as isGirl]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getRole&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;roleList&quot;</span>&gt;</span></span><br><span class="line">    select </span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;t_role_column&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;t&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    from t_role t where t.role_name like </span><br><span class="line">    concat(&#x27;%&#x27;,#&#123;roleName&#125;,&#x27;%&#x27;) and t.note like </span><br><span class="line">    concat(&#x27;%&#x27;,#&#123;note&#125;,&#x27;%&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis架构及映射原理</title>
    <url>/2020/12/13/MyBatis%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>MyBtis通过SQL Map将Java对象映射成SQL语句，将结果集转换成Java对象。与其他的ORM框架相比，解决了Java对象与查询结果集的映射，又能方便地编写SQL语句。</p>
<span id="more"></span>

<h2 id="MyBatis类核心组件"><a href="#MyBatis类核心组件" class="headerlink" title="MyBatis类核心组件"></a>MyBatis类核心组件</h2><blockquote>
<p>MyBatis总的来说，主要完成两件事：</p>
<ol>
<li>根据JDBC规范建立与数据库的连接</li>
<li>通过反射完成Java对象与数据库参数间相互转化的关系</li>
</ol>
</blockquote>
<p>MyBatis的核心组件分为4个部分：</p>
<ul>
<li>SqlSessionFactoryBuilder（构造器）：根据配置或者代码生成 <code>SqlSessionFactory</code> ，采用的设计模式是建造者模式，分布构建</li>
<li>SqlSessionFactory（工厂接口）： <code>SqlSessionFactory</code> 生成 <code>SqlSession</code>，使用的是工厂模式</li>
<li>SqlSession（会话）：既可以发送SQL语句执行并返回结果，也可以获取Mapper的接口。</li>
<li>SQL Mapper（映射器）：一个组件，由一个Java接口和XML文件（或注解）构成。需要给出相应接口方法的SQL和映射规则。负责发送SQL执行并返回接口。</li>
</ul>
<p><img src="/images/MyBatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6.png"></p>
<h3 id="SqlSessionFactory（工厂接口）"><a href="#SqlSessionFactory（工厂接口）" class="headerlink" title="SqlSessionFactory（工厂接口）"></a>SqlSessionFactory（工厂接口）</h3><p>MyBatis可以通过XML配置或者代码区生产 <code>SqlSessionFactory</code> 。<code>SqlSessionFactoryBuilder</code> 提供一个类 <code>org.apache.ibatis.session.Configuration</code> 作为引导，采用建造者模式，分步完成整个MyBatis上下文的构建。</p>
<p><code>SqlSessionFactory</code> 是一个接口，在MyBatis中有两个实现类：<code>SqlSessionManager</code> 和 <code>DefaultSqlSessionFactory</code> 。一般而言，具体实现为 <code>DefaultSqlSessionFactory</code> ，只不过 <code>SqlSessionManager</code> 用在多线程环境中，它的具体实现依靠 <code>DefaultSqlSessionFactory</code> 。</p>
<p><img src="/images/SqlSessionFactory%E7%9A%84%E7%94%9F%E6%88%90.png"></p>
<p>如上图所示，基于MyBatis的应用都是以 <code>SqlSessionFactory</code> 为中心，而 <code>SqlSessionFactory</code> 唯一的作用就是生产 <code>MyBatis</code> 的核心接口对象 <code>SqlSession</code> ，所以它的责任是唯一的，可以采用单例模式生成 <code>SqlSessionFactory</code> 。下面讨论基于XML构建和基于Java代码构建 <code>SqlSessionFactory</code> 。</p>
<h4 id="使用XML构建-SqlSessionFactory"><a href="#使用XML构建-SqlSessionFactory" class="headerlink" title="使用XML构建 SqlSessionFactory"></a>使用XML构建 SqlSessionFactory</h4><p>在MyBatis中的XML文件分为两类：</p>
<ol>
<li>基础配置文件。通常只有一个并且命名为 <code>mybatis-config.xml</code>，主要用于配置一些最基本的上下文参数和运行环境</li>
<li>映射文件。配置映射关系、SQL、参数等信息，通常和接口名称有关。</li>
</ol>
<p>这里介绍的是基础配置文件，下面是一个简易的基础配置文件，将其命名为 <code>mybatis-config.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> </span></span><br><span class="line"><span class="meta">	<span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;httP://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--别名，配置成功后可以用别名代替全限定名--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;role&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.dougWilson.ssm.pojo.role&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--环境变量的配置，这里配置的是数据库--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">               	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/ssm&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;090900&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--映射器配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/dougWilson/ssm/mapper/RoleMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过Java代码生成 <code>SqlSessionFactory</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">null</span>;</span><br><span class="line">String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">InputStream inStream = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    inStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inStream);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用代码创建SqlSessionFactory"><a href="#使用代码创建SqlSessionFactory" class="headerlink" title="使用代码创建SqlSessionFactory"></a>使用代码创建SqlSessionFactory</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据库连接池信息</span></span><br><span class="line">PooledDataSource dataSource = <span class="keyword">new</span> PooledDataSource();</span><br><span class="line">dataSource.setDriver(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">dataSource.setPassword(<span class="string">&quot;090900&quot;</span>);</span><br><span class="line">dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/ssm&quot;</span>);</span><br><span class="line">dataSource.setDefaultAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 采用MyBatis的JDBC事务方式</span></span><br><span class="line">TransactionFactory transactionFactory = <span class="keyword">new</span> JdbcTransactionFactory();</span><br><span class="line">Environment environment = <span class="keyword">new</span> Environment(<span class="string">&quot;development&quot;</span>, transactionFactory, dataSource);</span><br><span class="line"><span class="comment">// 创建Configuration对象</span></span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration(environment);</span><br><span class="line"><span class="comment">// 注册一个MyBatis上下文别名</span></span><br><span class="line">configuration.getTypeAliasRegistry().registerAlias(<span class="string">&quot;role&quot;</span>, Role.class);</span><br><span class="line"><span class="comment">// 加入一个映射器</span></span><br><span class="line">configuration.addMapper(RoleMapper.class);</span><br><span class="line"><span class="comment">// 使用SqlSessionFactoryBuilder 构建 SqlSessionFactory</span></span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(configuration);</span><br><span class="line"><span class="keyword">return</span> sqlSessionFactory;</span><br></pre></td></tr></table></figure>

<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p><code>SqlSession</code> 是MyBatis的核心接口，有两个实现类：<code>DefaultSqlSession</code> 和 <code>SqlSessionManager</code> 。在MyBatis中， <code>SqlSession</code> 作用就类似于一个JDBC中的 Connection 对象，代表一个连接资源的启用，具体来说，其作用有以下3个方面：</p>
<ol>
<li>获取 Mapper 接口</li>
<li>发送SQL给数据库</li>
<li>控制数据库事务</li>
</ol>
<p>创建一个 <code>SqlSession</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession sqlSession = SqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure>

<p>获取到 <code>SqlSession</code> 后，调用其方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sqlSession.commit(); <span class="comment">// 提交事务</span></span><br><span class="line">sqlSession.rollback(); <span class="comment">// 回滚事务</span></span><br><span class="line">sqlSession.close(); <span class="comment">// 关闭资源</span></span><br></pre></td></tr></table></figure>

<h3 id="SQL-Mapper（映射器）"><a href="#SQL-Mapper（映射器）" class="headerlink" title="SQL Mapper（映射器）"></a>SQL Mapper（映射器）</h3><p>映射器是 <code>MyBatis</code> 中最重要、最复杂的组件，由一个接口和对应的XML文件组曾。可以配置如下内容：</p>
<ol>
<li>描述映射规则</li>
<li>提供SQL语句，并可以配置SQL参数类型、返回类型、缓存刷新等信息</li>
<li>配置缓存</li>
<li>提供动态SQL</li>
</ol>
<p>映射器常用的方式有两种，基于XML文件的形式和基于注解的形式。下面用一个实例具体介绍：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    <span class="comment">// 省略getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>映射器的主要作用就是将SQL查询到的结果映射为一个POJO，或者将POJO的数据插入到数据库中，并定义一些关于缓存等的重要内容。</p>
<h4 id="基于XML定义的映射器"><a href="#基于XML定义的映射器" class="headerlink" title="基于XML定义的映射器"></a>基于XML定义的映射器</h4><p>用XML定义映射器分为两个部分：接口和XML。</p>
<p>映射器接口 <code>RoleMapper</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RoleMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Role <span class="title">getRole</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XML文件 <code>RoleMapper.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">	<span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.dougWilson.ssm.mapper.RoleMapper&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getRole&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;role&quot;</span>&gt;</span></span><br><span class="line">    	SELECT id, role_name as roleName, note FROM t_role WHERE id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有了这两个文件，就完成了一个映射器的定义。MyBatis默认提供自动映射，只要SQL返回的列名能和POJO类的属性对应即可。</p>
<h4 id="基于注解定义的映射器"><a href="#基于注解定义的映射器" class="headerlink" title="基于注解定义的映射器"></a>基于注解定义的映射器</h4><p>只需要一个接口就可以通过MyBatis的注解来注入SQL：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RoleMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select id, role_name as roleName, note from t_role where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Role <span class="title">getRole</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这完全等同于XML方式创建映射器。如果基于注解定义的映射器和基于XML方式定义的映射器同时定义，基于XML方式将覆盖掉基于注解的方式，说明官方推荐使用基于XML文件定义的映射器，为什么这样，下面讨论这个问题。</p>
<p>虽然看起来基于注解定义的映射器方式要简单许多，但这是因为上面例子的SQL语句比较简单。在工作和学习中，SQL的复杂度远远超过现在看到的SQL语句。比如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user u</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_user_role ur <span class="keyword">ON</span> ur.user_id<span class="operator">=</span>u.id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_role r <span class="keyword">ON</span> ur.role_id<span class="operator">=</span>r.id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_female_health fh <span class="keyword">ON</span> fh.user_id<span class="operator">=</span>u.id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t_male_health mh <span class="keyword">ON</span> u.id<span class="operator">=</span>mh.user_id</span><br><span class="line"><span class="keyword">WHERE</span> u.user_name <span class="keyword">LIKE</span> concat(<span class="string">&#x27;%&#x27;</span>, $&#123;userName&#125;, <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> r.role_name <span class="keyword">LIKE</span> concat(<span class="string">&#x27;%&#x27;</span>, $&#123;roleName&#125;,<span class="string">&#x27;%&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> u.sex <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">AND</span> ui.head_image <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>

<p>很显然，这条SQL语句比较复杂，如果放入@Select中会明显增加注解的内容。如果把大量的SQL放入Java代码中，代码的可读性也会下降。如果同时还要考虑使用动态SQL，比如当参数 userName 为空，则不使用 <code>u.user_name LIKE concat(&#39;%&#39;, $&#123;userName&#125;, &#39;%&#39;)</code> 作为查询条件，这样就使得这个注解更加复杂，不利于日后的维护和修改。</p>
<p>此外，基于XML文件的映射器还可以相互引入，而注解则不可以，所以在一些比较复杂的场景下，使用XML方式会更加方便和灵活。</p>
<h3 id="发送SQL"><a href="#发送SQL" class="headerlink" title="发送SQL"></a>发送SQL</h3><h4 id="SqlSession发送SQL"><a href="#SqlSession发送SQL" class="headerlink" title="SqlSession发送SQL"></a>SqlSession发送SQL</h4><p>以上述例子为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Role role = (Role)sqlSession.selectOne(<span class="string">&quot;com.dougWilson.ssm.mapper.RoleMapper.getRole&quot;</span>, <span class="number">1L</span>);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// Role role = (Role)sqlSession.selectOne(&quot;getRole&quot;, 1L);</span></span><br></pre></td></tr></table></figure>

<p><code>selectOne</code> 方法标识使用查询并且只返回一个对象，而参数是一个String对象和一个Object对象，这里是一个long类型的参数，long参数是它的主键。</p>
<h4 id="Mapper接口发送SQL"><a href="#Mapper接口发送SQL" class="headerlink" title="Mapper接口发送SQL"></a>Mapper接口发送SQL</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);</span><br><span class="line">Role role = roleMapper.getRole(<span class="number">1L</span>);</span><br></pre></td></tr></table></figure>

<p>通过 <code>SqlSession</code> 的 <code>getMapper</code> 方法获取一个Mapper接口，就可以调用它的方法。因为XML文件或者接口注解定义的SQL都可以通过“类的全限定名+方法名” 查找，所以MyBatis会启用对应的SQL进行运行，并返回结果。</p>
<h4 id="两种发送SQL方式对比"><a href="#两种发送SQL方式对比" class="headerlink" title="两种发送SQL方式对比"></a>两种发送SQL方式对比</h4><p>两种方式都是依靠 <code>SqlSession</code> ，一种为直接发送，另一种通过 <code>SqlSession</code> 获取 <code>Mapper</code> 接口后再发送。建议采用 SqlSession 获取 Mapper 的方式，理由如下：</p>
<ol>
<li>使用Mapper接口编程可以消除 SqlSession 带来的功能性代码，提高可读性。而SqlSession发送SQL，需要一个SQL id去匹配SQL</li>
<li>使用Mapper接口，类似于 <code>roleMapper.getRole(1L)</code> 是完全面向对象的语言，更能体现业务逻辑</li>
<li>使用Mapper接口，编译的时候会提示错误和校验，而使用 <code>sqlSession.selectOne(...)</code> 的语法，只有再运行中才能知道是否会产生错误</li>
</ol>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h4><p><code>SqlSessionFactoryBuilder</code> 的作用在于创建 <code>SqlSessionFactory</code> ，创建成功后， <code>SqlSessionFactoryBuilder</code> 便失去了作用，所以它只存在于创建 <code>SqlSessionFactory</code> 的方法中，而不要让其长期存在。</p>
<h4 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h4><p><code>SqlSessionFactory</code>可以被认为是一个数据库连接池，作用是创建 <code>SqlSession</code> 接口对象。因为 MyBatis 的本质是对数据库的操作，所以 <code>SqlSessionFactory</code> 的生命周期存在于整个 MyBatis 的应用之中，所以一旦创建了 <code>SqlSessionFactory</code>，就要长期保持它，知道不再使用 MyBatis 应用，所以可以认为 <code>SqlSessionFactory</code> 的生命周期等同于 MyBatis 的应用周期。</p>
<p>由于 <code>SqlSessionFactory</code> 是一个对数据库的连接池，所以它占据着数据库的连接资源。如果创建多个 <code>SqlSessionFactory</code>，那么就存在多个数据库连接池，这样不利于对数据库资源的控制，也会导致数据库连接资源被耗光，出现宕机的情况。因此，在一般的应用中，都将 <code>SqlSessionFactory</code> 作为一个单例，让它在应用中被共享。</p>
<h4 id="SqlSession-1"><a href="#SqlSession-1" class="headerlink" title="SqlSession"></a>SqlSession</h4><p><code>SqlSession</code> 相当于一个数据库连接（Connection对象），可以在一个事务里执行多条SQL，然后通过一些方法，提交或回滚事务。所以 <code>SqlSession</code> 的生命周期为一个业务请求，处理完一个请求后，就该关闭该连接，将其归还于 <code>SqlSessionFactory</code> ，否则数据库资源很快就会被耗费光。</p>
<h4 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h4><p>Mapper是一个接口，由 <code>SqlSession</code> 创建，由于 <code>SqlSession</code> 的关闭，它的数据库连接资源也会小时，所以其生命周期应小于等于 <code>SqlSession</code> 的生命周期，一旦处理完相关的业务，就该废弃它。</p>
<h2 id="MyBatis配置"><a href="#MyBatis配置" class="headerlink" title="MyBatis配置"></a>MyBatis配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>		<span class="comment">&lt;!--配置--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span> /&gt;</span>	<span class="comment">&lt;!--属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span> /&gt;</span>	<span class="comment">&lt;!--设置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span> /&gt;</span>		<span class="comment">&lt;!--类型命名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandlers</span> /&gt;</span>	<span class="comment">&lt;!--类型处理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">objectFactory</span> /&gt;</span>	<span class="comment">&lt;!--对象工厂--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span> /&gt;</span>			<span class="comment">&lt;!--插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span>&gt;</span>		<span class="comment">&lt;!--配置环境--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">environment</span>&gt;</span>	<span class="comment">&lt;!--环境变量--&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">transactionManager</span> /&gt;</span>		<span class="comment">&lt;!--事务管理器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> /&gt;</span>		<span class="comment">&lt;!--数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">databaseIdProvider</span> /&gt;</span>		<span class="comment">&lt;!--数据库厂商标识--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span> /&gt;</span>			<span class="comment">&lt;!--映射器--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要注意，MyBatis配置项的顺序不能颠倒，如果颠倒了顺序，在MyBatis启动阶段就会发生异常，导致程序无法运行。下面讨论常用配置项：</p>
<h3 id="properties设置"><a href="#properties设置" class="headerlink" title="properties设置"></a>properties设置</h3><p><code>properties</code> 属性可以给系统配置一些运行参数，放在XML文件或者 <code>properties</code> 文件中，而不是放在Java代码中，这样的好处在于方便参数修改，而不会引起代码的重新编译。</p>
<p>MyBatis提供了3种方式使用 <code>properties</code>，分别为：</p>
<ul>
<li>property子元素</li>
<li>properties文件</li>
<li>Java代码</li>
</ul>
<h4 id="property子元素"><a href="#property子元素" class="headerlink" title="property子元素"></a>property子元素</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">	<span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;database.driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;database.url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/ssm&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;database.username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;database.password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;090900&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;role&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.dougWilson.ssm.pojo.role&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;database.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">               	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;database.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;database.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;database.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/dougWilson/ssm/mapper/RoleMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 property 子元素的好处就是，定义一次就可以在文件中到处引用。缺点是，如果属性参数有许多个，使用这样的方式就不是一个好选择，这时候可以使用 properties 文件</p>
<h4 id="使用properties文件"><a href="#使用properties文件" class="headerlink" title="使用properties文件"></a>使用properties文件</h4><p>将多个键值对放在一个properties文件中，比如 <code>jdbc.properties</code> ，然后在需要相应键值对的地方引入文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">database.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">database.url=jdbc:mysql://localhost:3306/ssm</span><br><span class="line">database.username=root</span><br><span class="line">database.password=090900</span><br></pre></td></tr></table></figure>

<p>在MyBatis中通过 <code>&lt;properties&gt;</code> 属性resource来引入 <code>properties</code> 文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>$&#123;database.username&#125;</code> 的方法引入properties文件的属性参数到 MyBatis 配置文件中。 </p>
<h4 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line"></span><br><span class="line">InputSream in = Resources.getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">pros.load(in);</span><br><span class="line"></span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in, pros);</span><br></pre></td></tr></table></figure>

<h3 id="settings设置"><a href="#settings设置" class="headerlink" title="settings设置"></a>settings设置</h3><p><code>settings</code> 是MyBatis中最复杂的配置，能够深刻影响 MyBatis 底层的运行。大部分情况下使用默认配置的默认值就可以运行，只需要修改一些常用的规则，比如 自动映射、驼峰命名映射、级联规则、是否启动缓存、执行器类型。下面是使用方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>settings配置项：</p>
<table>
<thead>
<tr>
<th>配置项</th>
<th>作用</th>
<th>配置选项说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>cacheEnabled</td>
<td>所有映射器中配置缓存的全局开关</td>
<td>true|false</td>
<td>true</td>
</tr>
<tr>
<td>lazyLoadingEnabled</td>
<td>延迟加载的全局开关。开启时，所有关联对象都会延迟加载。在特定关联关系中可以通过设置 fetchType属性来覆盖该项的开关状态</td>
<td>true|false</td>
<td>false</td>
</tr>
<tr>
<td>aggressiveLazyLoading</td>
<td>当启用时，对任意延迟属性的调用会使带有延迟加载属性的对象完整加载；繁殖，每种属性会按需加载</td>
<td>true|false</td>
<td>版本3.4.1之前为true，之后为false</td>
</tr>
<tr>
<td>multipleResultSetsEnabled</td>
<td>是否允许单一语句返回多结果集（需要兼容驱动）</td>
<td>true|false</td>
<td>true</td>
</tr>
<tr>
<td>useColumnLabel</td>
<td>使用列标签代替列名。不同的驱动会有不同的表项，具体可以参考相关驱动文档或者通过测试这两种不同的模式来观察所用驱动的结果</td>
<td>true|false</td>
<td>true</td>
</tr>
<tr>
<td>useGeneratedKeys</td>
<td>允许JDBC支持自动生成主键，需要驱动兼容。如果设置为true，则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍然可以正常工作</td>
<td>true|false</td>
<td>false</td>
</tr>
<tr>
<td>autoMappingBehavior</td>
<td>指定MyBatis应该如何自动映射列到字段或者属性。NONE标识取消自动映射；PARTIAL标识只会自动映射，没有定义嵌套结果集和映射结果集；FULL会自动映射任意复杂的结果集</td>
<td>NONE、PARTIAL、FULL</td>
<td>PARTIAL</td>
</tr>
<tr>
<td>autoMappingUnknownColumnBehavior</td>
<td>指定自动映射中未知列的行为。默认是不处理，只要当日志级别达到WARN级别或者以下，才会显式相关日志，如果失败会抛出SqlSessionException异常</td>
<td>NONE、WARNING、FAILING</td>
<td>NONE</td>
</tr>
<tr>
<td>defaultExecutorType</td>
<td>配置默认的执行器。SIMPLE是普通的执行器；REUSE会重用预处理语句；BATCH执行器将重用语句并执行批量更新</td>
<td>SIMPLE、REUSE、BATCH</td>
<td>SIMPLE</td>
</tr>
<tr>
<td>defaultStatementTimeout</td>
<td>设置超时事件，它决定驱动等待数据库响应的描述</td>
<td>任何正整数</td>
<td>Not Set(null)</td>
</tr>
<tr>
<td>defaultFetchSize</td>
<td>设置数据库驱动程序默认返回的条数限制，此参数可以重新设置</td>
<td>任何正整数</td>
<td>Not Set(null</td>
</tr>
<tr>
<td>safeRowBoundsEnabled</td>
<td>允许在嵌套语句中使用分页（RowBounds）。如果允许，设置false</td>
<td>true|false</td>
<td>false</td>
</tr>
<tr>
<td>safeResultHandlerEnabled</td>
<td>允许在嵌套语句中使用分页（ResultHandler）。如果允许，设置false</td>
<td>true|false</td>
<td>false</td>
</tr>
<tr>
<td>mapUnderscoreToCamelCase</td>
<td>是否开启自动驼峰命名规则映射，即从经典数据库列名 a_column 到属性名 aColumn的类似映射</td>
<td>true|false</td>
<td>false</td>
</tr>
<tr>
<td>localCacheScope</td>
<td>MyBatis利用本地缓存机制防止循环引用和加速重复嵌套查询。默认值为SESSION，这种情况下会缓存一个会话中执行的所有查询。若设置值为STATEMENT，本地会话仅用在语句执行上，对相同的SqlSession的不同调用将不会共享数据</td>
<td>SESSION|STATEMENT</td>
<td>SESSION</td>
</tr>
<tr>
<td>jdbcTypeForNull</td>
<td>当没有为参数提供特定的JDBC类型时，为空值指定JDBC类型。某些驱动需要指定列的JDBC类型，多数情况直接用一般类型即可，比如NULL、VARCHAR、OTHER</td>
<td>NULL、VARCHAR、OTHER</td>
<td>OTHER</td>
</tr>
<tr>
<td>lazyLoadTriggerMethods</td>
<td>指定那个对象的方法触发一次延迟加载</td>
<td></td>
<td>equals、clone、hashCode、toString</td>
</tr>
<tr>
<td>defaultScriptingLanguage</td>
<td>指定动态SQL生成的默认语言</td>
<td></td>
<td>org.apache.ibatis.scripting.xmltags.XMLDynamicLanguageDriver</td>
</tr>
<tr>
<td>callSettersOnNulls</td>
<td>指定当结果集中的值为null时，是否调用映射对象的setter方法，这对于有Map.keySet()依赖或者null值初始化时是有用的。注意，基本类型不能设置成null</td>
<td>true|false</td>
<td>false</td>
</tr>
<tr>
<td>logPrefix</td>
<td>指定MyBatis增加到日志名称的前缀</td>
<td>任何字符串</td>
<td>Not set</td>
</tr>
<tr>
<td>logImpl</td>
<td>指定MyBatis所用日志的记忆体实现，未指定时将自动查找</td>
<td>SLF4J、LOG4J、LOG4J2、JDK_LOGGING、COMMONS_LOGGING、STDOUT_LOGGING、NO_LOGGING</td>
<td>Not set</td>
</tr>
<tr>
<td>proxyFactory</td>
<td>指定MyBatis创建具有延迟加载能力的对象所用到的代理工具</td>
<td>CGLIB、JAVASSIST</td>
<td>JAVASSIST</td>
</tr>
<tr>
<td>vfsImpl</td>
<td>指定VFS的实现类</td>
<td>提供VFS类的权限定名，如果存在多个，可以用逗号分隔</td>
<td>Not set</td>
</tr>
<tr>
<td>useActualParamName</td>
<td>允许用方法参数中声明的实际名称引用参数</td>
<td>true|false</td>
<td>true</td>
</tr>
</tbody></table>
<h3 id="typeAliases设置"><a href="#typeAliases设置" class="headerlink" title="typeAliases设置"></a>typeAliases设置</h3><p>由于类的全限定名称很长，需要大量使用的时候，总写那么长的名称不方便，因此，允许用一个简写来代表这个类，这个简写就是别名。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;role&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.dougWilson.ssm.pojo.Role&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过上面的配置，就定义了一个别名。如果有许多类需要定义别名，则可以通过扫描别名。类似于Spring中的自动扫描，指定包，就会将包下的所有类，将其第一个字母变为小写作为其别名，比如Role的别名会变为role，而User的别名会变成user。但是，使用这样的规则，有时候会出现重名，比如扫描两个包，两个包中都有User类，那就会出现异常，这时候可以使用MyBatis提供的注解 <code>@Alias(&quot;user3&quot;)</code> 进行区分。这样可以避免因为别名重名而导致的扫描失败的问题。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.dougWilson.ssm.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.dougWilson.ssm.entity&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dougWilson.ssm.entity;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Alias(&quot;user3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="typeHandler设置"><a href="#typeHandler设置" class="headerlink" title="typeHandler设置"></a>typeHandler设置</h3><p>typeHandler称为类型转换器。在JDBC中，需要在 <code>PreparedStatement</code> 对象中设置那些已经预编译过的SQL语句的参数。执行SQL后，会通过 <code>ResultSet</code> 对象获取得到数据库的数据，而这些 MyBatis 是根据数据的类型通过 typeHandler 来实现的。在 typeHandler中，分为 jdbcType 和 javaType，其中 jdbcType用于定义数据库类型，而 javaType 用于定义 Java 类型，那么typeHandler的作用就是承担 jdbcType 和 javaType 间的相互转换。</p>
<p>在多数情况下，并不需要去配置 typeHandler、jdbcType、javaType，因为 MyBatis会探测应该使用什么类型的typeHandler进行处理，但是有些场景无法探测到。对于那些需要使用自定义枚举的场景，或者数据库使用特殊数据类型的场景，可以使用自定义的typeHandler去处理类型间的转换问题。</p>
<p>系统定义的typeHandler:</p>
<table>
<thead>
<tr>
<th>类型处理器</th>
<th>Java类型</th>
<th>JDBC类型</th>
</tr>
</thead>
<tbody><tr>
<td>BooleanTypeHandler</td>
<td>java.lang.Boolean|boolean</td>
<td>数据库兼容的BOOLEAN</td>
</tr>
<tr>
<td>ByteTypeHandler</td>
<td>Byte|byte</td>
<td>数据库兼容的NUMERIC或BYTE</td>
</tr>
<tr>
<td>ShortTypeHandler</td>
<td>Short|short</td>
<td>数据库兼容的NUMERIC或SHORT INTEGER</td>
</tr>
<tr>
<td>IntegerTypeHandler</td>
<td>Integer|int</td>
<td>数据库兼容的NUMERIC或INTEGER</td>
</tr>
<tr>
<td>LongTypeHandler</td>
<td>Long|long</td>
<td>数据库兼容的NUMERIC或LONG INTEGER</td>
</tr>
<tr>
<td>FloatTypeHandler</td>
<td>Float|float</td>
<td>数据库兼容的NUMERIC或FLOAT</td>
</tr>
<tr>
<td>DoubleTypeHandler</td>
<td>Double|double</td>
<td>数据库兼容的NUMERIC或DOUBLE</td>
</tr>
<tr>
<td>BigDecimalTypeHandler</td>
<td>BigDecimal</td>
<td>数据库兼容的NUMERIC或DECIMAL</td>
</tr>
<tr>
<td>StringTypeHandler</td>
<td>String</td>
<td>CHAR、VARCHAR</td>
</tr>
<tr>
<td>ClobReaderTypeHandler</td>
<td>java.io.Reader</td>
<td></td>
</tr>
<tr>
<td>ClobTypeHandler</td>
<td>String</td>
<td>CLOB、LONGVARCHAR</td>
</tr>
<tr>
<td>NStringTypeHandler</td>
<td>String</td>
<td>NVARCHAR、NCHAR</td>
</tr>
<tr>
<td>NClobTypeHandler</td>
<td>String</td>
<td>NCLOB</td>
</tr>
<tr>
<td>BlobInputStreamTypeHandler</td>
<td>java.io.InputStream</td>
<td></td>
</tr>
<tr>
<td>ByteArrayTypeHandler</td>
<td>byte[]</td>
<td>数据库兼容的字节流类型</td>
</tr>
<tr>
<td>BlobTypeHandler</td>
<td>byte[]</td>
<td>BLOB、LONGVARBINARY</td>
</tr>
<tr>
<td>DateTypeHandler</td>
<td>java.util.Date</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>DateOnlyTypeHandler</td>
<td>java.uti.Date</td>
<td>DATE</td>
</tr>
<tr>
<td>TimeOnlyTypeHandler</td>
<td>java.util.Time</td>
<td>TIME</td>
</tr>
<tr>
<td>SqlTimestampTypeHandler</td>
<td>java.sql.Timestamp</td>
<td>TIMESTAMP</td>
</tr>
<tr>
<td>SqlDateTypeHandler</td>
<td>java.sql.Date</td>
<td>DATE</td>
</tr>
<tr>
<td>SqlTimeTypeHandler</td>
<td>java.sql.Time</td>
<td>TIME</td>
</tr>
<tr>
<td>ObjectTypeHandler</td>
<td>Any</td>
<td>OTHER或未指定类型</td>
</tr>
<tr>
<td>EnumTypeHandler</td>
<td>Enumeration Type</td>
<td>VARCHAR任何兼容的字符串类型，存储枚举的名称</td>
</tr>
<tr>
<td>EnumOrdinalTypeHandler</td>
<td>Enumeration Type</td>
<td>任何兼容的NUMERIC或DOUBLE类型，存储枚举的索引</td>
</tr>
</tbody></table>
<h3 id="ObjectFactory（对象工厂）"><a href="#ObjectFactory（对象工厂）" class="headerlink" title="ObjectFactory（对象工厂）"></a>ObjectFactory（对象工厂）</h3><p>当创建结果集时，MyBatis会使用一个对象工厂来完成创建这个结果集实例。在默认情况下，MyBatis会使用其自定义的对象工厂—— <code>org.apache.ibatis.reflection.factory.DefaultObjectFactory</code> 来完成对应的工作。</p>
<p>MyBatis允许注册自定义的 ObjectFactory。 如果自定义，则需要实现接口 <code>org.apache.ibatis.reflection.factory.ObjectFactory</code> 并给予配置。大部分情况下，都不需要自定义返回规则，因为这些比较复杂并且容易出错，在更多情况下，会考虑基础系统已经实现好的 <code>DefaultObjectFactory</code>，通过一定的改写来完成所需要的工作。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObjectFactory</span> <span class="keyword">extends</span> <span class="title">DefaultObjectFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8855122346740914948L</span>;</span><br><span class="line">    Long log = Logger.getLogger(MyObjectFactory.class);</span><br><span class="line">    privaet Object temp = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setProperties(properties);</span><br><span class="line">        log.info(<span class="string">&quot;初始化参数：[&quot;</span> + properties.toString() + <span class="string">&quot;]&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        T result = <span class="keyword">super</span>.create(type);</span><br><span class="line">        log.info(<span class="string">&quot;创建对象：&quot;</span> + result.toString());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">        T result = <span class="keyword">super</span>.create(type, constructorArgTypes, constructorArgs);</span><br><span class="line">        log.info(<span class="string">&quot;创建对象：&quot;</span> + result.toString());</span><br><span class="line">        temp = result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.isCollection(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后对它进行配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">objectFactory</span> <span class="attr">type</span>=<span class="string">&quot;com.dougWilson.ssm.objectFactory.MyObjectFactory&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prop1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">objectFactory</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，MyBatis就会采用配置的 <code>MyObjectFactory</code> 来生成结果集对象。</p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>先放在这，后面回来学习</p>
<h3 id="environments（运行环境）"><a href="#environments（运行环境）" class="headerlink" title="environments（运行环境）"></a>environments（运行环境）</h3><p>运行环境的主要作用是配置数据库信息，一般而言，它下面又会分为两个可配置的元素：事务管理器（transactionManager）、数据源（dataSource）。在实际的工作中，大部分情况下会采用 Spring 对数据源和数据库的事务进行管理。</p>
<h4 id="transactionManager"><a href="#transactionManager" class="headerlink" title="transactionManager"></a>transactionManager</h4><p>在MyBatis中，transactionManager提供两个实现类，需要实现接口 <code>org.apache.ibatis,transaction.Transaction</code>，该接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">    <span class="function">Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Integer <span class="title">getTimeout</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个实现类为：<code>JdbcTransaction</code> 和 <code>ManagedTransaction</code> 。这两个实现类对应着两种工厂：JdbcTransactionFactory 和 ManagedTransactionFactory， 这个工厂需要实现 TransactionFactory 接口，通过它们会生成对应的 Transaction 对象。因此可以将事务管理器配置成以下两种方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;MANAGED&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>JDBC 使用 JdbcTransactionFactory 生成的 JdbcTransaction 对象实现。它是以 JDBC 的方式对数据库的提交和回滚进行操作</li>
<li>MANAGED 使用 ManagedTransactionFactory 生成的 ManagedTransaction 对象实现。它的提交和回滚方法不用任何操作，而是把事务交给容器处理。在默认情况下，它会关闭连接，然而一些容器并不希望这样，因此，需要将 closeConnection属性设置为 false 来阻止它的默认关闭行为</li>
</ul>
<h4 id="dataSource"><a href="#dataSource" class="headerlink" title="dataSource"></a>dataSource</h4><p>dataSource用于配置数据库。在MyBatis中，数据库通过 <code>PooledDataSourceFactory</code>、<code>UnpooledDataSourceFactory</code>、<code>JndiDataSourceFactory</code> 三个工厂类来提供，前两者对应产生 <code>PooledDataSource</code> 、<code>UnpooledDataSource</code> 类对象，而 <code>JndiDataSourceFactory</code> 则会根据 JNDI 的信息拿到外部容器实现的数据库连接对象。但是，无论如何，这三个工厂类，最后都会生成一个实现了DataSource接口的数据库连接对象。可以按照下面的方式配置它们：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;UNPOOLED&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;JNDI&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>UNPOOLED</p>
<p>UNPOOLED采用非数据库池的管理方式，每次请求都会打开一个新的数据库连接，所以创建会比较慢。UNPOOLED类型的数据源可以配置如下几种属性：</p>
<ul>
<li>driver 数据库驱动名</li>
<li>url 连接数据库的URL</li>
<li>username 用户名</li>
<li>password 密码</li>
<li>defaultTransactionIsolationLevel 默认的连接事务隔离级别</li>
</ul>
</li>
<li><p>POOLED</p>
<p>POOLED采用数据库连接池的管理方式，它开始会有一些空置并且连接好的数据库连接，所以请求时，无需再建立和验证，省去创建连接实例时所需要的初始化和认证时间。</p>
<p>它具备UPOOLED的属性，此外，还有以下属性：</p>
<ul>
<li>poolMaximumActiveConnections 在任意时间都存在的活动的连接数量，默认为10</li>
<li>poolMaximumIdleConnections 在任意时间可能存在的空闲连接数</li>
<li>poolMaximumCheckoutTime 在被强制返回前，连接池中被检出的时间，默认值为20秒</li>
<li>poolTimeToWait 如果获取连接花费相当长的时间，会给连接池打印默认状态并重新尝试获取一个连接，默认为20秒</li>
<li>poolPingQuery 检验连接是否处于正常的工作秩序中，并准备接收请求。默认为 “NO PING QUERY SET”，这会导致多数数据库驱动失败时带有一个恰当的错误消息</li>
<li>poolPingEnabled 是否启用侦测查询</li>
<li>poolPingConnectionsNotUsedFor 为配置poolPingQuery的使用频度，默认值为0，即所有连接的每一时刻都被侦测</li>
</ul>
</li>
<li><p>JNDI</p>
<p>数据源 JNDI 的实现是为了能在如EJB或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。这种数据源配置只需要两个属性：</p>
<ul>
<li>initial_context 在InitialContext中寻找上下文</li>
<li>data_source 引用数据源实例位置上下文的路径</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Quarz定时任务框架</title>
    <url>/2020/01/12/Quarz%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>Quarz为一个开源项目，可以用于执行定时任务。因为今天后台需要用到一个周期性线程来处理任务，就去网上看了看，觉得Quarz还不错，试试用用看。</p>
<span id="more"></span>

<blockquote>
<p>Quarz主要由以下部分组成：</p>
<p><strong>Job：执行任务。JobDetail</strong></p>
<p><strong>Trigger：触发条件。SimpleTrigger或CronTrigger</strong></p>
<p><strong>Schedule：调度器，用于协调Job和Trigger。Scheduler</strong></p>
</blockquote>
<h3 id="常用Cron表达式"><a href="#常用Cron表达式" class="headerlink" title="常用Cron表达式"></a>常用Cron表达式</h3><blockquote>
<p>10 * * * * ?  每分钟的10秒执行一次任务。比如   10:08:10  10:09:10   10:10:10</p>
<p>30 10 * * * ? 每小时的10分30秒执行一次任务。比如 10:10:30  11:10:30 12:10:30</p>
<p>30 10 1 * * ? 每天的1点10分30秒执行任务</p>
<p>30 10 1 20 * ? 每月20号的1点10分30秒执行任务</p>
<p>30 10 1 20 10? * 每年的10月20号1点10分30秒触发任务</p>
</blockquote>
]]></content>
      <tags>
        <tag>Quarz, 定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet工作原理解析</title>
    <url>/2020/02/13/Servlet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>Java Web技术是当今主流的互联网Web应用技术之一，而核心基础就是Servlet。Servlet如何工作？Servlet容器如何工作？一个Web工程在Servlet容器中如何启动？Servlet容器如何解析web.xml文件？用户的请求如何找到对应的Servlet类进行处理？Servlet容器如何管理Servlet生命周期？等等问题，都需要自己慢慢探究。</p>
<span id="more"></span>

<blockquote>
<p>首先要解释Servlet和Servlet容器的关系。Servlet是一个由Java语言编写的组件，运行在服务器端。而Servlet容器也称为Servlet引擎，是服务器的一部分，用于在Servlet生命周期内管理Servlet。</p>
<p>看起来Servlet容器和Servlet相互依赖，虽然从结果上确实如此。但是，从技术上来说，Servlet和Servlet容器是相互独立发展，通过标准化接口来进行相互协作。</p>
<p>Servlet容器随着发展，大体上有两类Servlet容器较为流行。一种为以Jetty为代表，在定制化和移动领域发展较好。一种以Tomcat的Servlet容器为代表，广泛应用于Web领域。</p>
</blockquote>
<h3 id="Tomcat的Servlet容器"><a href="#Tomcat的Servlet容器" class="headerlink" title="Tomcat的Servlet容器"></a>Tomcat的Servlet容器</h3><blockquote>
<p><img src="/images/Tomcat%E5%AE%B9%E5%99%A8%E6%A8%A1%E5%9E%8B.png"></p>
<p>Tomcat容器分为4个等级：Container容器、Engine、Host、Context。为什么没有Servlet容器？在Tomcat中，Servlet容器实际上就是Context容器。</p>
<p>从图中我们可以看出，在Tomcat中，Context容器直接管理Servlet在容器中的包装类Wrapper（为什么不直接管理Servlet类，而是要管理包装类，问题先放在这里）。所以，Context容器如何运行则会影响Servlet的工作方式。</p>
<p>通常，一个web工程对应一个context容器，不同的web工程属于不同的context容器，这在图中可以体现。</p>
<p>因此，从上面这些知识可知，在Tomcat中创建web工程，它会被context容器管理，而context容器会将servlet类构建成包装类Wrapper然后进行管理。</p>
<p>所以，如何构建Servlet类？如何解析Context容器？就是接下来的内容。</p>
<h4 id="如何解析Context容器"><a href="#如何解析Context容器" class="headerlink" title="如何解析Context容器"></a>如何解析Context容器</h4><p>先看两段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加一个web工程到一个Context容器</span></span><br><span class="line"><span class="comment">//以webapp目录下examples为例</span></span><br><span class="line">Tomcat tomcat = getTomcatInstance();</span><br><span class="line"><span class="comment">//工程url</span></span><br><span class="line">File appDir = <span class="keyword">new</span> File(getBuildDirectory(), <span class="string">&quot;webapps/examples&quot;</span>);</span><br><span class="line"><span class="comment">//将工程添加到Context容器中</span></span><br><span class="line">tomcat.addWebapp(<span class="keyword">null</span>, <span class="string">&quot;/examples&quot;</span>, appDir.getAbsolutePath());</span><br><span class="line"><span class="comment">//启动tomcat服务器</span></span><br><span class="line">tomcat.start();</span><br><span class="line">ByteChunk res = getUrl(<span class="string">&quot;http://localhost:&quot;</span> + getPort() + <span class="string">&quot;/examples/servlets/servlet/HelloWorldExample&quot;</span>);</span><br><span class="line">assertTrue(res.toString().indexOf(<span class="string">&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;</span>) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>主要就是addWebapp方法，得到添加web工程后的Context容器：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Context <span class="title">addWebapp</span><span class="params">(Host host, String url, String path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    silence(url);</span><br><span class="line">    Context ctx = <span class="keyword">new</span> StandardContext();</span><br><span class="line">    ctx.setPath(url);</span><br><span class="line">    ctx.setDocBase(path);</span><br><span class="line">    <span class="keyword">if</span> (defaultRealm == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//Context容器的默认作用范围</span></span><br><span class="line">        initSimpleAuth();</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.setRealm(defaultRealm);</span><br><span class="line">    <span class="comment">//添加解析配置文件的对象</span></span><br><span class="line">    ctx.addLifecycleListener(<span class="keyword">new</span> DefaultWebXmlListener());</span><br><span class="line">    <span class="comment">//ContextConfig，负责整个web工程配置的解析工作</span></span><br><span class="line">    ContextConfig ctxCfg = <span class="keyword">new</span> ContextConfig();</span><br><span class="line">    <span class="comment">//添加ContextConfig对象</span></span><br><span class="line">    ctx.addLifecycleListener(ctxCfg);</span><br><span class="line">   	<span class="comment">//设置配置文件</span></span><br><span class="line">  ctxCfg.setDefaultWebXml(<span class="string">&quot;org/apache/catalin/startup/NO_DEFAULT_XML&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (host == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//将Context容器添加到父容器Host中</span></span><br><span class="line">        getHost().addChild(ctx);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        host.addChild(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可知，一个web工程部署到Tomcat服务器并运行大体上有以下三步：</p>
<ol>
<li><p>获取web工程的实际的路径</p>
</li>
<li><p>将web工程添加到Context容器，并将Context容器添加到父容器Host中</p>
</li>
<li><p>调用Tomcat的start方法启动Tomcat服务器。Tomcat的启动逻辑是基于观察者模式设计的，所有的容器都会继承至Lifecycle接口。它管理容器的整个生命周期，所有容器的修改和状态的改变都会由它去通知注册的观察者(Listener)。这一点，也很明显可以从第二段代码中看出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ctx.addLifecycleListener(<span class="keyword">new</span> DefaultWebXmlListener());</span><br><span class="line">ctx.addLifecycleListener(ctxCfg);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>Tomcat启动大体过程如下(4个层级的容器依次启动)</p>
<ol>
<li>Tomcat的start方法被调用</li>
<li>StandardServer启动并初始化</li>
<li>StandardService根据配置初始化，然后启动</li>
<li>StandardEngine根据配置初始化，然后启动</li>
<li>StandardHost根据配置初始化，然后启动</li>
<li>StandardContext初始化，由ContextConfig配置类完成web工程初始化工作</li>
<li>启动后台线程，进行一些定时操作和监控</li>
<li>初始化HTTP服务并启动，这时候服务器启动完毕，处于运行状态</li>
</ol>
<p>在Context初始化步骤中，ContextConfig类至关重要，负责整个web应用的配置文件的解析工作。主要步骤如下：</p>
<p>第一步，init方法进行初始化。其init方法主要完成以下工作：</p>
<ul>
<li>创建解析xml配置文件的contextDigester对象</li>
<li>读取默认的context.xml配置文件，存在则解析</li>
<li>读取默认的host配置文件，存在则解析</li>
<li>读取context自身的配置文件，存在则解析</li>
<li>设置Context的DocBase</li>
</ul>
<p>第二步，执行startInternal方法。主要完成以下工作：</p>
<ul>
<li>创建读取资源文件的对象</li>
<li>创建ClassLoader对象</li>
<li>设置应用的工作目录</li>
<li>启动相关的辅助类，如logger/realm/resources等</li>
<li>子容器的初始化</li>
<li>获取ServletContext并设置必要参数</li>
<li>初始化”load on startup”的Servlet</li>
</ul>
<p>第三步，执行configureStart方法完成web应用的初始化工作，主要是解析web.xml文件，将web.xml文件中的各个配置项解析成相应的属性保存在WebXml对象中</p>
<p>第四步，将WebXml对象中的属性设置到Context容器中，参考下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (ServletDef servlet : servlets.values()) &#123;</span><br><span class="line">    <span class="comment">//Servlet的包装类</span></span><br><span class="line">    Wrapper wrapper = context.createWrapper();</span><br><span class="line">    <span class="comment">//JSP也是一个Servlet，这里会首先判断当前的对象是否为jsp文件</span></span><br><span class="line">    String jspFile = servlet.getJspFile();</span><br><span class="line">    <span class="keyword">if</span> (jspFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        wrapper.setJspFile(jspFile);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (servlet.getLoadOnStartup() != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//是否设置启动顺序</span></span><br><span class="line">        wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue());</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.setName(servlet.getServletName());</span><br><span class="line">    Map&lt;String, String&gt; params = servlet.getParameterMap();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : params.entrySet()) &#123;</span><br><span class="line">        <span class="comment">//设置Servlet配置的参数</span></span><br><span class="line">        <span class="comment">//通常是&lt;init-param&gt;中的</span></span><br><span class="line">        wrapper.addInitParameter(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.setRunAs(servlet.getRunAs());</span><br><span class="line">    <span class="comment">//角色权限及安全设置</span></span><br><span class="line">    Set&lt;SecurityRoleRef&gt; roleRefs = servlet.getSecurityRoleRefs();</span><br><span class="line">    <span class="keyword">for</span> (SecurityRoleRef roleRef : roleRefs) &#123;</span><br><span class="line">        wrapper.addSecurityReference(roleRef.getName(), roleRef.getLink());</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.setServletClass(servlet.getServletClass());</span><br><span class="line">    </span><br><span class="line">    MultipartDef multipartdef = servlet.getMultipartDef();</span><br><span class="line">    <span class="keyword">if</span> (multipartdef != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (multipartdef.getMaxFileSize() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           multipartdef.getMaxRequestSize() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           multipartdef.getFileSizeThreshold() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//添加注解</span></span><br><span class="line">            wrapper.setMultipartConfigElement(<span class="keyword">new</span> MultipartConfigElement(</span><br><span class="line">            	multipartdef.getLocation(), Long.parseLong(multipartdef.getMaxFileSize()), Long.parseLong(multipartdef.getMaxRequestSize()),</span><br><span class="line">           Integer.parseInt(multipartdef.getFileSizeThreshold())));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否支持同步</span></span><br><span class="line">    <span class="keyword">if</span> (servlet.getAsyncSupported() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        wrapper.setAsyncSupported(servlet.getAsyncSupported().booleanValue());</span><br><span class="line">    &#125;</span><br><span class="line">    context.addChild(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以回答前面遗留的问题：<strong>为什么要将Servlet包装成StandardWrapper而不直接使用Servlet对象？</strong>这是因为StandardWrapper是Tomcat容器的一部分，具有容器的特征。如果直接使用Servlet对象，则会将容器与Servlet对象强耦合。而Servlet作为一个独立的web开发标准，不应该强耦合在Tomcat中。</p>
<p>从以上过程可知道，Servlet被包装成StandardWrapper并作为子容器并添加到Context中，并且web.xml属性也都会被解析到Context中，因此web.xml的作用就是配置context容器的属性并配置servlet。回到第一个容器框架图中，现在更能理解Context容器才是真正运行Servlet的Servlet容器，一个web工程对应一个Context容器。</p>
<h4 id="如何构建Servlet类"><a href="#如何构建Servlet类" class="headerlink" title="如何构建Servlet类"></a>如何构建Servlet类</h4><p>如果Servlet的load-on-startup配置项大于0，那么在Context容器启动的时候Servlet就会被实例化。另外有两个默认的Servlet，分别为 <code>org.apache.catalina.servlets.DefaultServlet</code> 和</p>
<p><code>org.apache.jasper.servlet.JspServlet</code>，它们的load-on-startup分别是1和3，当Tomcat启动时，这两个Servlet就会被启动。</p>
<p>构建Servlet实例从Wrapper.loadServlet()方法开始。loadServlet()方法主要获取servletClass，然后将class类交给InstanceManager去创建一个基于servletClass.class的对象。如果这个Servlet配置了jsp-file，那么这个servletClass就是在conf/web.xml中定义的org.apache.jasper.servlet.JspServlet。</p>
<p>构建完成后，就会对Servlet进行初始化。</p>
</blockquote>
<h3 id="Servlet体系结构"><a href="#Servlet体系结构" class="headerlink" title="Servlet体系结构"></a>Servlet体系结构</h3><blockquote>
<p>Servlet的体系结构涉及到几个接口：</p>
<ul>
<li>Servlet</li>
<li>ServletContext</li>
<li>ServletConfig</li>
<li>ServletRequest</li>
<li>ServletResponse</li>
</ul>
<p>ServletRequest和ServletResponse接口的重要性和功能不需要过多介绍，这是平时中运用最多的。</p>
<p>ServletConfig接口主要是为了获取这个Servlet的一些配置属性。</p>
<p>ServletContext则是用于获取和配置全局参数，作用于整个context容器中的web工程。</p>
<p><img src="/images/Servlet%E9%A1%B6%E5%B1%82%E7%B1%BB%E5%85%B3%E8%81%94%E5%9B%BE.png"></p>
<p>从图中可以看出，与Servlet主动关联的是三个类，分别是ServletConfig/ServletRequest/ServletResponse。其中，ServletConfig在Servlet初始化时就已经和Servlet主动关联(用于初始化web工程)。而ServletRequest和ServletResponse是在用户请求时才会传递给Servlet。</p>
<p><img src="/images/ServletConfig%E5%92%8CServletContext%E4%B8%8EServlet%E5%85%B3%E7%B3%BB.png"></p>
<p>可以从图中看出，Servlet的包装类StandardWrapper和StandardWrapperFacade实现了ServletConfig接口，其中StandardWrapperFacade是StandardWrapper的外观类，也是实际传递给Servlet的对象，用于保证从StandardWrapper中拿到ServletConfig的数据，而不暴露ServletConfig不需要的数据给Servlet。</p>
<p>同理，ServletContext与ServletConfig具有类似的结构。ApplicationContextFacade也是实际传递给Sevlet的对象，保证从ApplicationContext拿到ServletContext数据而不暴露ServletContext不需要的数据给Servlet。</p>
<p><strong>对于ServletRequest和ServletResponse</strong>。通常我们使用的时候都是HttpServletRequest和HttpServletResponse对象，它们继承了ServletRequest和ServletResponse，也就是说我们实际使用的是HttpServletRequest和HttpServletResponse而不是ServletRequest和ServletResponse。那么这个转换过程是如何进行的？</p>
<ol>
<li><p>Tomcat接收到用户请求后，首先会创建org.apache.coyote.Request和org.apache.coyote.Response，这两个类是轻量级的类，作用就是在服务器接收到请求后，经过简单解析后将这个请求快速分配给后续线程处理。</p>
</li>
<li><p>当一个后续用户线程处理请求时，又会创建org.apache.catalina.connector.Request和org.apache.catalina.connector.Response两个对象，存在于Servlet容器中。</p>
</li>
<li><p>当要将值传递给Servlet时，传递给Servlet的是RequestFacade和ResponseFacade，目的也是一样，封装数据，不暴露不需要的数据</p>
</li>
</ol>
</blockquote>
<h3 id="Servlet的工作过程"><a href="#Servlet的工作过程" class="headerlink" title="Servlet的工作过程"></a>Servlet的工作过程</h3><blockquote>
<p>用户的一个请求通常会包含如下信息：</p>
<p><code>HTTP://hostname:port/contextpath/servletpath</code></p>
<p>那么服务器要做的就是根据请求找到相应的servlet处理请求，然后响应用户。关键就在于如何根据这个URL找到对应的Servlet容器中的Servlet类。</p>
<p>在Tomcat服务器中，这个映射工作由一个专门的类org.apache.tomcat.util.http.mapper完成，这个类保存了Tomcat的Container容器的所有子容器信息。当一个org.apache.catalina.connector.Request类要进入Container容器前，mapper会根据Request请求的hostname和conextpath将对应的host容器和context容器设置到Request对象的mappingData属性中，然后Request根据这个属性寻找对应的Context容器，根据Context容器配置文件的映射路径对应关系，找到对应的Servlet进行处理。</p>
</blockquote>
<h3 id="Filter如何工作"><a href="#Filter如何工作" class="headerlink" title="Filter如何工作"></a>Filter如何工作</h3><blockquote>
<p>Filter是在web.xml中一个常用的配置项，通过&lt;filter&gt;和&lt;filter-mapping&gt;组合来使用Filter。</p>
<p>实际上，Filter可以完成和Servlet同样的工作，甚至使用起来比Servlet更加灵活，因为它除了提供ServletRequest和ServletResponse对象以外，还提供了一个FilterChain对象控制请求的流转与拦截，如下图所示：</p>
<p><img src="/images/Filter%E7%B1%BB%E5%85%B3%E7%B3%BB.png"></p>
<p>在Tomcat中，FilterConfig和FilterChain的实现类分别是ApplicationFilterConfig和ApplicationFilterChain，而Filter的实现类由用户自定义，只要实现Filter接口中定义的3个方法：</p>
<ul>
<li>init(FilterConfig) 在用户自定义的Filter初始化时被调用</li>
<li>doFilter(ServletRequest, ServletResponse, FilterChain) 在用户的请求进来时，该方法都会被调用，并在Servlet的service方法之前调用。其中，FilterChain代表当前的整个请求链，通过FilterChain.doFilter方法可以将请求继续传递下去，如果想拦截请求，不调用该方法即可，那么请求就会直接返回</li>
<li>destroy() 当Filter对象被销毁时这个方法被调用</li>
</ul>
<p>Filter类的核心方法是FilterChain对象，这个对象保存了最终Servlet对象的所有Filter对象，这些对象都保存在ApplicationFilterChain对象的filters数组中。在FilterChain调用链上每执行一个Filter对象，数组的当前计数都会加1，直到计数等于数组长度并且FilterChain上的所有Filter对象执行完后，就会执行最终的Servlet。</p>
</blockquote>
]]></content>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet相关知识</title>
    <url>/2020/03/01/Servlet%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>Servlet是sun公司制订的一种用于扩展web服务器功能的组件规范。其运行原理如下：</p>
<p><img src="/images/servlet%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p>
<ol>
<li>浏览器根据IP地址和端口号port建立与服务器Servlet容器（Connection和Container）的连接</li>
<li>浏览器将请求数据打包（包含请求资源路径）</li>
<li>向容器发送请求数据包</li>
<li>容器解析请求数据包</li>
<li>容器将解析结果封装到request对象，同时创建一个response对象</li>
<li>容器根据请求资源的url地址找到servlet配置（web.xml）</li>
<li>创建servlet对象，调用servlet对象的service方法，在service方法中，通过request对象获取请求数据并进行相应处理，然后将要输出的结果输入的response对象中</li>
<li>容器从response对象上获取结果及数据，打包</li>
<li>将包发送给浏览器</li>
<li>浏览器从响应数据包中取出处理结果，生成相应的页面</li>
</ol>
<span id="more"></span>

<h2 id="重定向和请求转发"><a href="#重定向和请求转发" class="headerlink" title="重定向和请求转发"></a>重定向和请求转发</h2><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><blockquote>
<p>重定向时，服务器向浏览器发送一个302状态码以及一个Location响应头消息（该消息头是一个重定向地址），浏览器收到后会立即向重定向地址发送请求。</p>
<p>特点：</p>
<ol>
<li>重定向地址可以是任意的地址</li>
<li>重定向之后，地址栏地址会变</li>
</ol>
</blockquote>
<h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><blockquote>
<p>一个web组件（通常是servlet/jsp）将问完成的处理通过容器转交给另一个web组件继续完成。常见的情况是：一个servlet获得数据之后，讲过这些数据转发给一个jsp，由这个jsp来展现这些数据。</p>
<p>请求转发特点：</p>
<ol>
<li>转发之后浏览器地址栏地址不变</li>
<li>转发的目的地必须是同一个应用内部的某个地址</li>
<li>转发所涉及的各个web组件会共享同一个request对象和response对象</li>
</ol>
<p>请求转发过程：</p>
<p><img src="/images/%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E8%BF%87%E7%A8%8B.png"></p>
</blockquote>
<h3 id="请求转发和重定向的区别"><a href="#请求转发和重定向的区别" class="headerlink" title="请求转发和重定向的区别"></a>请求转发和重定向的区别</h3><ol>
<li>转发所涉及的各个web组件会共享同一个request对象和response对象，而重定向不行。说明：当请求到达容器，容器会创建request对象和response对象，当响应发送完毕，容器会立即删除request对象和response对象。即request对象和response对象的生存时间是一次请求与响应期间。</li>
<li>转发之后，浏览器地址栏的地址不变，重定向会变。</li>
<li>转发的地址必须是同一个应用内部某个地址，而重定向没有这个限制。</li>
<li>转发是一件事情未做完，调用另外一个组件继续做；而重定向是一件事情已经做完，再调用一个组件做另外一件事情。</li>
</ol>
<h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><p>Servlet生命周期过程主要包括以下内容：Servlet容器（Wrapper）如何创建Servlet对象，如何为Servlet对象分配、准备资源、如何调用对应的方法来处理请求以及如何销毁Servlet对象。</p>
<ol>
<li>实例化，容器调用Servlet类的构造器，创建一个Servlet对象。容器在默认情况下，对某个类型的Servlet，只会创建一个实例</li>
<li>初始化，容器在创建号Servlet对象后，会立即调用该对象的init方法。一般情况下，不需要写init方法，因为GenericServlet以及提供了init方法的实现（将容器传递过来的ServletConfig对象保存下来，并且提供getServletConfig方法获取ServletConfig对象）</li>
<li>就绪，容器收到请求后，调用Servlet对象的service方法处理请求</li>
<li>销毁，容器根据自身的算法删除Servlet对象，被删除的Servlet对象被垃圾回收器收集。容器在销毁Servlet对象前会调用该对象的destroy方法（只执行一次）。可以在该方法中定义一些处理逻辑。</li>
</ol>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.Tomcat会自动调用默认构造器创建Servlet</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifeServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建LifeServlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 2.Tomcat会自动为当前的Servlet创建一个ServletConfig，用来给它预置一些数据；</span></span><br><span class="line">    <span class="comment">// 3.Tomcat会自动调用init方法，来为此Servlet初始化一些数据；</span></span><br><span class="line">    <span class="comment">// 注意，ServletConfig中预置的数据，可以在init时使用，也可以在service时使用。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化Servlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 4.当请求传入时，Tomcat会自动调用该方法来处理本次请求。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse res)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    	</span><br><span class="line">        System.out.println(<span class="string">&quot;调用service()&quot;</span>);</span><br><span class="line">        res.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        PrintWriter w = res.getWriter();</span><br><span class="line">        w.println(<span class="string">&quot;&lt;h1&gt;LifeServlet&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        w.close();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 5.Tomcat在关闭前，会自动调用该方法来销毁该Servlet。通常是将此Servlet所依赖的数据释放（=null）。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与LifeServlet相关的几个类结构图：</p>
<p><img src="/images/LifeCycle%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><p>JSP（Java Server Page）是sun公司制订的一种服务器端动态页面技术的组件规范。JSP页面中既包含HTML静态标记用于表现页面，也包含Java代码，用于生成动态内容。</p>
<p>JSP作为简化Servlet开发的一种技术，实质上依然要转变为Servlet才能运行，这个转变过程由Servlet容器完成。</p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p><img src="/images/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p>
<p>更多关于过滤器知识，参考另一篇文章《Servlet工作原理解析》</p>
]]></content>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Bean的生命周期</title>
    <url>/2020/05/11/Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>传统的Java应用，Bean的生命周期很简单。使用Java关键字new进行Bean的实例化，然后该Bean就可以使用了。一旦该Bean不再被使用，则有GC选择回收。</p>
<p>相比之下，在Spring容器中，Bean的生命周期要细腻的多。</p>
<span id="more"></span>

<p>大致过程如下：</p>
<p><img src="/images/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p>
<ol>
<li>Spring对Bean进行实例化</li>
<li>Spring将值和对Bean的引用注入到Bean对应的属性中</li>
<li>如果Bean实现了BeanNameAware接口，Spring将Bean的ID传递给setBeanName()接口方法</li>
<li>如果Bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()接口方法，将BeanFactory容器实例传入</li>
<li>如果Bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()接口方法，将应用上下文的引用传入</li>
<li>如果Bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessBeforeInitialization()接口方法</li>
<li>如果Bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet()接口方法。类似的，如果Bean使用init-method声明了初始化方法，该方法也会被调用</li>
<li>如果Bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessAfterInitialization()方法</li>
<li>Bean已经准备就绪，可以被使用了。它们将一直驻留在Spring容器中，直到容器被销毁</li>
<li>如果Bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果Bean使用destroy-method声明了销毁方法，该方法也会被调用</li>
</ol>
]]></content>
      <tags>
        <tag>spring, bean</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot Shiro用户认证</title>
    <url>/2020/09/24/Spring-Boot-Shiro%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<p>在Spring Boot中集成Shiro进行用户的认证过程主要可以归纳为以下三点：</p>
<ol>
<li><p>定义一个ShiroConfig，然后配置SecurityManager Bean，SecurityManager为Shiro的安全管理器，管理着所有Subject；</p>
</li>
<li><p>在ShiroConfig中配置ShiroFilterFactoryBean，其为Shiro过滤器工厂类，依赖于SecurityManager；</p>
</li>
<li><p>自定义Realm实现，Realm包含<code>doGetAuthorizationInfo()</code>和<code>doGetAuthenticationInfo()</code>方法，因为本文只涉及用户认证，所以只实现<code>doGetAuthenticationInfo()</code>方法。</p>
</li>
</ol>
<span id="more"></span>

<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MyBatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- thymeleaf --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- shiro-spring --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- oracle驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.oracle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ojdbc6<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- druid数据源驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="ShiroConfig"><a href="#ShiroConfig" class="headerlink" title="ShiroConfig"></a>ShiroConfig</h2><p>定义一个Shiro配置类，名称为ShiroConfig：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilterFactoryBean</span><span class="params">(SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        <span class="comment">// 设置securityManager</span></span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">// 登录的url</span></span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">        <span class="comment">// 登录成功后跳转的url</span></span><br><span class="line">        shiroFilterFactoryBean.setSuccessUrl(<span class="string">&quot;/index&quot;</span>);</span><br><span class="line">        <span class="comment">// 未授权url</span></span><br><span class="line">        shiroFilterFactoryBean.setUnauthorizedUrl(<span class="string">&quot;/403&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        LinkedHashMap&lt;String, String&gt; filterChainDefinitionMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义filterChain，静态资源不拦截</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/css/**&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/js/**&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/fonts/**&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/img/**&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        <span class="comment">// druid数据源监控页面不拦截</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/druid/**&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        <span class="comment">// 配置退出过滤器，其中具体的退出代码Shiro已经替我们实现了 </span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/logout&quot;</span>, <span class="string">&quot;logout&quot;</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        <span class="comment">// 除上以外所有url都必须认证通过才可以访问，未通过认证自动访问LoginUrl</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="comment">// 配置SecurityManager，并注入shiroRealm</span></span><br><span class="line">        DefaultWebSecurityManager securityManager =  <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        securityManager.setRealm(shiroRealm());</span><br><span class="line">        <span class="keyword">return</span> securityManager;  </span><br><span class="line">    &#125; </span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroRealm <span class="title">shiroRealm</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="comment">// 配置Realm，需自己实现</span></span><br><span class="line">        ShiroRealm shiroRealm = <span class="keyword">new</span> ShiroRealm();  </span><br><span class="line">        <span class="keyword">return</span> shiroRealm;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是filterChain基于短路机制，即最先匹配原则，如：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/user/</span>**=anon</span><br><span class="line"><span class="regexp">/user/</span>aa=authc 永远不会执行</span><br></pre></td></tr></table></figure>

<p>其中<code>anon</code>、<code>authc</code>等为Shiro为我们实现的过滤器，具体如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">Filter Name</th>
<th align="left">Class</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">anon</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/AnonymousFilter.html">org.apache.shiro.web.filter.authc.AnonymousFilter</a></td>
<td align="left">匿名拦截器，即不需要登录即可访问；一般用于静态资源过滤；示例<code>/static/**=anon</code></td>
</tr>
<tr>
<td align="left">authc</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/FormAuthenticationFilter.html">org.apache.shiro.web.filter.authc.FormAuthenticationFilter</a></td>
<td align="left">基于表单的拦截器；如<code>/**=authc</code>，如果没有登录会跳到相应的登录页面登录</td>
</tr>
<tr>
<td align="left">authcBasic</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/BasicHttpAuthenticationFilter.html">org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</a></td>
<td align="left">Basic HTTP身份验证拦截器</td>
</tr>
<tr>
<td align="left">logout</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/LogoutFilter.html">org.apache.shiro.web.filter.authc.LogoutFilter</a></td>
<td align="left">退出拦截器，主要属性：redirectUrl：退出成功后重定向的地址（/），示例<code>/logout=logout</code></td>
</tr>
<tr>
<td align="left">noSessionCreation</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/session/NoSessionCreationFilter.html">org.apache.shiro.web.filter.session.NoSessionCreationFilter</a></td>
<td align="left">不创建会话拦截器，调用<code>subject.getSession(false)</code>不会有什么问题，但是如果<code>subject.getSession(true)</code>将抛出<code>DisabledSessionException</code>异常</td>
</tr>
<tr>
<td align="left">perms</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/PermissionsAuthorizationFilter.html">org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter</a></td>
<td align="left">权限授权拦截器，验证用户是否拥有所有权限；属性和roles一样；示例<code>/user/**=perms[&quot;user:create&quot;]</code></td>
</tr>
<tr>
<td align="left">port</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/PortFilter.html">org.apache.shiro.web.filter.authz.PortFilter</a></td>
<td align="left">端口拦截器，主要属性<code>port(80)</code>：可以通过的端口；示例<code>/test= port[80]</code>，如果用户访问该页面是非80，将自动将请求端口改为80并重定向到该80端口，其他路径/参数等都一样</td>
</tr>
<tr>
<td align="left">rest</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/HttpMethodPermissionFilter.html">org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter</a></td>
<td align="left">rest风格拦截器，自动根据请求方法构建权限字符串；示例<code>/users=rest[user]</code>，会自动拼出user:read,user:create,user:update,user:delete权限字符串进行权限匹配（所有都得匹配，isPermittedAll）</td>
</tr>
<tr>
<td align="left">roles</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/RolesAuthorizationFilter.html">org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</a></td>
<td align="left">角色授权拦截器，验证用户是否拥有所有角色；示例<code>/admin/**=roles[admin]</code></td>
</tr>
<tr>
<td align="left">ssl</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/SslFilter.html">org.apache.shiro.web.filter.authz.SslFilter</a></td>
<td align="left">SSL拦截器，只有请求协议是https才能通过；否则自动跳转会https端口443；其他和port拦截器一样；</td>
</tr>
<tr>
<td align="left">user</td>
<td align="left"><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/UserFilter.html">org.apache.shiro.web.filter.authc.UserFilter</a></td>
<td align="left">用户拦截器，用户已经身份验证/记住我登录的都可；示例<code>/**=user</code></td>
</tr>
</tbody></table>
<p>配置完ShiroConfig后，接下来对Realm进行实现，然后注入到SecurityManager中。</p>
<h2 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h2><p>自定义Realm实现只需继承AuthorizingRealm类，然后实现doGetAuthorizationInfo()和doGetAuthenticationInfo()方法即可。这两个方法名乍看有点像，authorization发音[ˌɔ:θəraɪˈzeɪʃn]，为授权，批准的意思，即获取用户的角色和权限等信息；authentication发音[ɔ:ˌθentɪ’keɪʃn]，认证，身份验证的意思，即登录时验证用户的合法性，比如验证用户名和密码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取用户角色和权限</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录认证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 获取用户输入的用户名和密码</span></span><br><span class="line">        String userName = (String) token.getPrincipal();</span><br><span class="line">        String password = <span class="keyword">new</span> String((<span class="keyword">char</span>[]) token.getCredentials());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;用户&quot;</span> + userName + <span class="string">&quot;认证-----ShiroRealm.doGetAuthenticationInfo&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过用户名到数据库查询用户信息</span></span><br><span class="line">        User user = userMapper.findByUserName(userName);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException(<span class="string">&quot;用户名或密码错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!password.equals(user.getPassword())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IncorrectCredentialsException(<span class="string">&quot;用户名或密码错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (user.getStatus().equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockedAccountException(<span class="string">&quot;账号已被锁定,请联系管理员！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleAuthenticationInfo info = <span class="keyword">new</span> SimpleAuthenticationInfo(user, password, getName());</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只讲述用户认证，所以<code>doGetAuthorizationInfo()</code>方法先不进行实现。</p>
<p>其中<code>UnknownAccountException</code>等异常为Shiro自带异常，Shiro具有丰富的运行时<code>AuthenticationException</code>层次结构，可以准确指出尝试失败的原因。你可以包装在一个<code>try/catch</code>块，并捕捉任何你希望的异常，并作出相应的反应。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    currentUser.login(token);</span><br><span class="line">&#125; <span class="keyword">catch</span> ( UnknownAccountException uae ) &#123; ...</span><br><span class="line">&#125; <span class="keyword">catch</span> ( IncorrectCredentialsException ice ) &#123; ...</span><br><span class="line">&#125; <span class="keyword">catch</span> ( LockedAccountException lae ) &#123; ...</span><br><span class="line">&#125; <span class="keyword">catch</span> ( ExcessiveAttemptsException eae ) &#123; ...</span><br><span class="line">&#125; ... <span class="keyword">catch</span> your own ...</span><br><span class="line">&#125; <span class="keyword">catch</span> ( AuthenticationException ae ) &#123;</span><br><span class="line">    <span class="comment">//unexpected error?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然我们可以准确的获取异常信息，并根据这些信息给用户提示具体错误，但最安全的做法是在登录失败时仅向用户显示通用错误提示信息，例如“用户名或密码错误”。这样可以防止数据库被恶意扫描。</p>
<p>另外需要注意的是，在Realm中UserMapper为Dao层，标准的做法应该还有Service层，但这里为了方便就不再定义Service层了。</p>
<h2 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h2><p>库表对应的实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5440372534300871944L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get,set略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义接口UserMapper：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">findByUserName</span><span class="params">(String userName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xml实现：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.springboot.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.springboot.pojo.User&quot;</span> <span class="attr">id</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;java.lang.Integer&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;NUMERIC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;passwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;create_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createTime&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;java.util.Date&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;DATE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;status&quot;</span> <span class="attr">property</span>=<span class="string">&quot;status&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByUserName&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from t_user where username = #&#123;userName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要配置的就差不多是以上这些。</p>
]]></content>
      <tags>
        <tag>shiro, spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring JPA</title>
    <url>/2020/04/29/Spring-JPA/</url>
    <content><![CDATA[<p>Spring JPA是一个持久层框架，用于与数据库交互。JPA （Java Persistence API 称为java持久层API ）底层使用Hibernate的JPA技术实现，引用JPQL查询语言，是对JPA规范的再次封装。一般而言，Spring JPA和Spring Boot、Spring Cloud一起使用，组成有机整体。JPA上手简单，开发效率高，具有较大的灵活性（根据接口中的方法或者自定义方法就可以完成查询，十分灵活）</p>
<span id="more"></span>

<h2 id="Spring-JPA内容"><a href="#Spring-JPA内容" class="headerlink" title="Spring JPA内容"></a>Spring JPA内容</h2><ol>
<li><p>一套API标准。根据接口中的方法即可完成CRUD操作，框架代替我们完成所有事情，开发者不用再去写繁琐的SQL和JDBC语句。</p>
</li>
<li><p>面对对象查询语言 JPQL java persistence query language 用于定义自定义方法名，JPA会根据JPQL解析方法签名完成CRUD操作</p>
</li>
<li><p>ORM object/relational metadata 元数据映射 JPA的注解威力强大</p>
</li>
</ol>
<h2 id="Spring-JPA类结构"><a href="#Spring-JPA类结构" class="headerlink" title="Spring JPA类结构"></a>Spring JPA类结构</h2><p><img src="/images/JPA%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<ul>
<li><p>Repository接口：最顶层的父类，一个空接口。仅仅起到表示的作用，定义操作所需要的实体和唯一的主键</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>CrudRepository接口：继承Repository接口，定义11个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CrudRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 保存实体到数据库表中</span></span><br><span class="line">    &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S var1)</span></span>;</span><br><span class="line">    &lt;S extends T&gt; <span class="function">Iterable&lt;S&gt; <span class="title">saveAll</span><span class="params">(Iterable&lt;S&gt; var1)</span></span>;</span><br><span class="line">    <span class="comment">// 根据主键查询实体</span></span><br><span class="line">    <span class="function">Optional&lt;T&gt; <span class="title">findById</span><span class="params">(ID var1)</span></span>;</span><br><span class="line">    <span class="comment">// 根据主键查询实体再数据库表中是否存在</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">existsById</span><span class="params">(ID var1)</span></span>;</span><br><span class="line">    <span class="comment">// 在数据库表中查询实体，并返回</span></span><br><span class="line">    <span class="function">Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Iterable&lt;T&gt; <span class="title">findAllByID</span><span class="params">(Iterable&lt;ID&gt; var1)</span></span>;</span><br><span class="line">    <span class="comment">// 查询总数</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 根据某些条件从数据库表中删除实体</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(ID var1)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(T var1)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">(Iterable&lt;? extends T&gt; var1)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>PagingAndSortingRepository接口：继承CrudRepository接口所有方法，并新增两个方法，支持对查询结果的排序和分页</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PagingAndSortingRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 对查询结果进行排序</span></span><br><span class="line">    <span class="function">Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">(Sort var1)</span></span>;</span><br><span class="line">    <span class="comment">// Pageable对象包含分页和Sort对象，该方法的作用是对查询结果进行排序和分页</span></span><br><span class="line">    <span class="function">Page&lt;T&gt; <span class="title">findAll</span><span class="params">(Pageable var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>QueryByExampleExecutor接口：新功能接口，增加一些方法，但较少用到，一般使用其子接口 JpaRepositroy</p>
</li>
<li><p>JpaRepositroy接口：继承QueryByExampleExecutor接口和PagingAndSortingRepository接口的所有方法，并且，从这里开始，基本上接口新增的方法都是对关系型数据库操作的具体封装，而之前的接口方法基本都是兼容NoSQL和关系型数据库</p>
</li>
<li><p>JpaRepositoryImplementation和JpaSpecificationExecutor接口，增加一些方法，可用于自定义CRUD操作的方法，JPA根据方法签名进行相应操作</p>
</li>
<li><p>2个实现类：SimpleJpaRepository和QuerydslJpaRepository 。SimpleJpaRepository是JPA整个关联数据库的所有Repository接口的实现类，QuerydslJpaRepository是SimpleJpaRepository的扩展类，增添了一部分实现功能。</p>
</li>
</ul>
<h2 id="JPA基本开发流程"><a href="#JPA基本开发流程" class="headerlink" title="JPA基本开发流程"></a>JPA基本开发流程</h2><ol>
<li><p>创建JPA工程，添加WEB/JPA/对应关系数据库(如MYSQL)的依赖</p>
</li>
<li><p>修改工程中application.properties文件，添加如下内容spring.datasource.url=jdbc:mysql://localhost:3306/db_example？serverTimezone=GTM&amp;rewriteBatchedStatements</p>
<p>spring.datasource.username=springuser</p>
<p>spring.datasource.password=090900</p>
</li>
<li><p>创建实体类@Entity，并且该实体类有且仅有一个主键@ID@GeneratedValue(strategy=Generation.AUTO 或者别的策略)</p>
</li>
<li><p>创建一个实体类的Repository，继承某一个接口，该接口通常为CrudRepository&lt;实体类, ID&gt; 或者PagingAndSortingRepository 或者JpaRepository等接口</p>
</li>
<li><p>创建一个Controller @Controller,用于请求和数据库打交道</p>
</li>
</ol>
<h2 id="JPA自定义查询方法"><a href="#JPA自定义查询方法" class="headerlink" title="JPA自定义查询方法"></a>JPA自定义查询方法</h2><p>两种方式：</p>
<ol>
<li><p>根据方法名称查询</p>
</li>
<li><p>使用@Query手动定义查询语句</p>
</li>
</ol>
<p><strong>要求：</strong></p>
<p>自定义查询方法所在的接口必须继承Repository或者其子接口，并选择性地暴露一些CRUD方法或暴露全部的CRUD方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴露全部方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择性暴露一些方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function">T <span class="title">findOne</span><span class="params">(ID id)</span></span>;</span><br><span class="line">	<span class="function">T <span class="title">save</span><span class="params">(T entity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="根据方法名称查询"><a href="#根据方法名称查询" class="headerlink" title="根据方法名称查询"></a>根据方法名称查询</h3><p>这种查询方法一定要注意，实体类中一定要有对应的属性名称，并且必须一致，否则无法编译成功，至于方法中的参数名称可以不同。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function">User <span class="title">findByEmail</span><span class="params">(String emailAddress)</span></span>;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findByEmailAndName</span><span class="params">(String emailAddress, String name)</span></span>;</span><br><span class="line">    <span class="comment">// 实体类中一定要有属性名为email和name的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般而言，根据方法名称查询的格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">前缀+连接符+驼峰属性名+连接符+驼峰属性名...+驼峰属性名</span><br></pre></td></tr></table></figure>

<p>常用前缀：find/exists/delete  </p>
<p>常用连接符：And/Or/Between/LessThan/LessThanEqual/GreaterThan/GreaterThanEqual/IsNull/IsNotNull/IgnoreCase</p>
<p>替代过程：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">List<span class="operator">&lt;</span><span class="keyword">User</span><span class="operator">&gt;</span> findByEmailAndName(String emailAddress, String name);</span><br><span class="line">相当于 <span class="keyword">where</span> x.email<span class="operator">=</span>?<span class="number">1</span> <span class="keyword">and</span> x.name<span class="operator">=</span>?<span class="number">2</span></span><br><span class="line">占位符由括号的参数填充： <span class="keyword">where</span> x.email<span class="operator">=</span>emailAddress <span class="keyword">and</span> x.name<span class="operator">=</span>name</span><br><span class="line"></span><br><span class="line">List<span class="operator">&lt;</span><span class="keyword">User</span><span class="operator">&gt;</span> findByStartDateBetween(<span class="type">int</span> <span class="keyword">one</span>, <span class="type">int</span> two);</span><br><span class="line">相当于 <span class="keyword">where</span> x.startDate <span class="keyword">between</span> ?<span class="number">1</span> <span class="keyword">and</span> ?<span class="number">2</span></span><br><span class="line">占位符由括号的参数填充： <span class="keyword">where</span> x.startDate <span class="keyword">between</span> <span class="keyword">one</span> <span class="keyword">and</span> two</span><br></pre></td></tr></table></figure>

<h3 id="注解式查询-Query"><a href="#注解式查询-Query" class="headerlink" title="注解式查询@Query"></a>注解式查询@Query</h3><p>主要关注@Query注解中的两个参数：value和nativeQuery</p>
<ul>
<li>value用于保存编写的查询语句，默认值为空；nativeQuery用于设定value保存查询语句的类别，默认值为false</li>
<li>nativeQuery=false 则value中的查询语句为JPQL查询语句</li>
<li>nativeQuery=true 则value中的查询语句为SQL原生语句</li>
</ul>
<p>JPQL与SQL区别，请看下面两个例子：</p>
<ul>
<li>JPQL查询语句：SELECT u FROM User u WHERE u.name=?1</li>
<li>SQL查询语句：SELECT * FROM user WHERE name=?1</li>
</ul>
<p>JPQL与实体类关联，SQL则与实体类对应的库表关联。上面两个查询语句在@Query中可以写成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Query</span>(<span class="keyword">value</span><span class="operator">=</span>”<span class="keyword">SELECT</span> u <span class="keyword">FROM</span> <span class="keyword">User</span> u <span class="keyword">WHERE</span> u.name<span class="operator">=</span>?<span class="number">1</span>”)</span><br><span class="line"></span><br><span class="line"><span class="variable">@Query</span>(nativeQuery<span class="operator">=</span><span class="literal">true</span>,<span class="keyword">value</span><span class="operator">=</span>”<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> name<span class="operator">=</span>?<span class="number">1</span>”)</span><br></pre></td></tr></table></figure>

<h4 id="Query与-Param"><a href="#Query与-Param" class="headerlink" title="@Query与@Param"></a>@Query与@Param</h4><p>默认情况下，如果没有@Param，方法的参数是按顺序绑定到@Qeury中的占位符？  例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">@(nativeQuery<span class="operator">=</span><span class="literal">true</span>, <span class="keyword">value</span><span class="operator">=</span>”<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> name<span class="operator">=</span>?<span class="number">1</span> <span class="keyword">AND</span> email<span class="operator">=</span>?<span class="number">2</span>”)</span><br><span class="line">List<span class="operator">&lt;</span><span class="keyword">User</span><span class="operator">&gt;</span> findByNameAndEmail(String name, String email);</span><br></pre></td></tr></table></figure>

<p>如果方法中的参数顺序错乱，就会导致查询结果的不同。为此，可以使用@Param注解，来指定占位符对应的方法参数具体名称：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Query</span>(nativeQuery<span class="operator">=</span><span class="literal">true</span>, <span class="keyword">value</span><span class="operator">=</span>”<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> name<span class="operator">=</span>:name <span class="keyword">AND</span> email<span class="operator">=</span>:email”)</span><br><span class="line">List<span class="operator">&lt;</span><span class="keyword">User</span><span class="operator">&gt;</span> findByNameAndEmail(<span class="variable">@Param</span>(“email”)String email, <span class="variable">@Param</span>(“name”)String name);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>spring, jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC工作机制</title>
    <url>/2020/02/26/Spring-MVC%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Spring MVC的M、V、C是什么？Spring MVC用于帮助我们处理什么工作？Spring MVC如何允许？Spring MVC和Spring有什么关系？我希望自己能掌握明白。</p>
<span id="more"></span>

<h2 id="Spring-MVC概述"><a href="#Spring-MVC概述" class="headerlink" title="Spring MVC概述"></a>Spring MVC概述</h2><blockquote>
<p>Spring MVC含有三个模块：模型(Model)、视图(View)、控制器(Controller)。模型封装了应用的数据和业务逻辑，视图负责应用的展示，控制器负责接收用户的请求，用于改变模型和调整视图的显示。</p>
<p>Spring MVC中，DispatcherServlet用于负责接收并处理所有web请求，并根据具体的处理逻辑，委派给下一控制器实现。</p>
<p>Spring MVC作用就是处理web请求，将请求分派给对应的业务逻辑处理。其处理请求过程如下：</p>
<ol>
<li>web请求到达DispatcherServlet后，DispatcherServlet将寻求HandlerMapping的具体实现类，HandlerMapping根据web请求返回具体的Controller处理类</li>
<li>Controller根据web请求参数进行逻辑处理，并返回一个ModelAndView实例，该实例包含两部分信息：视图的逻辑名称和模型数据</li>
<li>DispatcherServlet根据Controller返回的视图逻辑名称，通过ViewResolver找到逻辑视图名称对应的View实现类，并将查找结构返回到DispatcherServlet</li>
<li>DispatcherServlet会将ModelAndView中模型数据交给具体的View实现类，委派该View实现类将模型数据渲染到对应的视图中，完成最终的视图渲染工作</li>
<li>DispatcherServlet将最终的视图结构通过HttpServletResponse输出到客户端</li>
</ol>
<p>时序图如下：</p>
<p>![](/images/Spring MVC请求时序图.png)</p>
<p>组件图如下：</p>
<p><img src="/images/spring-MVC%E7%BB%84%E4%BB%B6%E5%9B%BE.png"></p>
</blockquote>
<h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><blockquote>
<p>实际上Spring MVC的使用十分简单，只需要扩展一个路径映射关系，定义一个视图解析器，再定义一个业务逻辑的处理流程规则，剩余的事情就可以让Spring MVC帮你完成。</p>
<p>要搞清楚Spring MVC如何工作，主要看DispatcherServlet代码。先查看其类结构图：</p>
<p><img src="/images/DispatcherServlet%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<p>DispatcherServlet类继承了HttpServlet，在Servlet的init方法调用时，DispatcherServlet就会执行Spring MVC的初始化工作。DispatcherServlet的初始化内容，在initStrategies方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化MultipartResolver，用于处理文件上传服务，如果有文件上传，那么会将当前的HttpServletRequest包装成DefaultMultipartHttpServletRequest，并且将每个上传的内容封装成CommonsMultipartFile对象</span></span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理应用的国际化问题，通过解析请求的Locale和设置响应的Locale来控制应用中的字符编码问题</span></span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个主题，设置访问页面的样式，将样式作为一个Theme Name保存，保存在用于请求的Cookie中或者保存在服务端的Session中，以后每次请求根据这个Theme Name 返回特定内容</span></span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义设置的请求映射关系，用于将用户请求的URL映射成一个个Handler实例。对HandlerMapping如果没有定义，则会使用默认的两个HandlerMapping：BeanNameUrlHandlerMapping和DefaultAnnotationHandlerMapping</span></span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据Handler类型定义不同的处理规则。比如SimpleControllerHandlerAdapter处理所有的Controller实例对象，则在HandlerMapping中会将URL映射成一个Controller实例，Spring MVC在解析时，SimpleControllerHandlerAdapter就会调用这个Controller实例。如果HandlerAdapters没有自定义，也会获取DispatcherServlet.properties文件中默认的4个HandlerAdapters：HttpRequestHandlerAdapter/SimpleControllerAdapter/ThrowawayControllerHandlerAdapter/AnnotationMethodHandlerAdapter</span></span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当Handler处理出错，就会通过这个Handler来统一处理，默认实现类是SimpleMappingExceptionResolver，将错误日志记录在log文件中，并转到默认的错误页面</span></span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将指定的ViewName按照定义的RequestToViewNameTranslator替换成想要的格式，如加上前缀或者后缀</span></span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于将View解析成页面，在ViewResolvers中可以设置多个解析策略，如按照JSP解析，按照Velocity模板解析。默认的解析策略是InternalResourceViewResolver，按照JSP页面来解析</span></span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>DispatcherServlet启动时的工作：</strong></p>
<p><strong>HttpServlet初始化时会调用HttpServletBean的init方法，以获取Servlet中的init参数，并创建一个BeanWrapper对象，然后由HttpServletBean的子类执行BeanWrapper的初始化工作。但是HttpServletBean的子类FrameworkServlet和DispatcherServlet都没有覆盖initBeanWrapper方法，因此无法对BeanWrapper执行初始化工作，所以创建的BeanWrapper对象没有任何作用，Spring容器Context也不是通过BeanWrapper来创建的。</strong></p>
<p><strong>Spring容器的创建是在FrameworkServlet的initServletBean方法中完成，initServletBean方法会创建WebApplicationContext对象，并调用refresh方法完成配置文件的加载。配置文件的加载会先查找Servlet的init-param参数中设置的路径，如果没有，则会根据namespace+Servlet的名称查找XML文件。</strong></p>
<p><strong>Spring容器创建完成后，在加载时会调用DispatcherServlet的initStrategies方法完成DispatcherServlet中定义的初始化工作。在initStrategies方法中会初始化Spring MVC框架需要的8个组件，这8个组件对应的8个Bean对象保存在DispatcherServlet类中。</strong></p>
<p>至此，Spring MVC初始化完成，可以接受HTTP请求</p>
</blockquote>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><blockquote>
<p>Spring MVC中的Controller是处理请求的核心，主要由HandlerMapping和HandlerAdapters两个组件提供。HandlerMapping负责映射用户的请求和对应的处理类。类似于Servlet中Filter的FilterChain，HandlerMapping接口也定义了一个由HandlerExecutionChain代表的处理链，通过在这个处理链添加HandlerAdapters实例来处理用户请求。</p>
<h4 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h4><p>HandlerMapping的作用就是帮助我们管理请求URL和处理类Controller的映射关系，默认的HandlerMapping为BeanNameUrlHandlerMapping。比如我们定义这样一个Bean：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">name</span>=<span class="string">&quot;/test&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.doug.wilson.controller.Test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewPage&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">value</span>&gt;</span>/test.html<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果没有定义其他HandlerMapping，那么Spring MVC就会将/test.html映射到com.doug.wilson.controller.Test处理类。也就是说，如果需要映射的URL很多，那么所有的URL的匹配规则都需要在配置文件中定义。</p>
<p>HandlerMapping的初始化工作主要有两个比较重要的部分：</p>
<ol>
<li>将URL于Handler的对应关系保存在handlerMap集合中</li>
<li>将所有的实现HandlerInterceptor接口的interceptor对象保存在adaptedInterceptors数组中，等请求到来时执行adaptedInterceptors数组中所有的interceptor对象</li>
</ol>
<h4 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h4><p>HandlerMapping定义URL与Handler关系，HandlerAdapter则用于定义Handler，并且该Handler必定得符合某种规则，才能被Spring MVC识别，常见的就是继承一个接口。大部分框架都是采用这种方法，Spring MVC也不例外。下面是HandlerAdapter相关的类结构图：</p>
<p><img src="/images/HandlerAdapter%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<ul>
<li>HttpRequestHandlerAdapter。通过继承HttpRequestHandler接口，并重写void handleRequest(HttpServletRequest request，HttpServletResponse response)方法</li>
<li>SimpleControllerHandlerAdapter。通过继承Controller接口，并重写 ModelAndView handle(HttpServletRequest request，HttpServletResponse response，Object handler)方法</li>
<li>SimpleServletHandlerAdapter。通过继承Servlet接口，将一个Servlet作为一个Handler来处理请求</li>
</ul>
<p>HandlerAdapter的初始化过程为：创建一个HandlerAdapter对象，将这个对象保存在DispatcherServlet的handlerAdapters集合中。当Spring MVC将某个URL对应到某个Handler时，在handlerAdapters集合中查询到对应的handler，然后将该handler对应的handlerAdapter对象返回，并调用handlerAdapter相应类型对应的方法。</p>
</blockquote>
<h3 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><blockquote>
<p>ModelAndView对象是连接业务逻辑层和View展示层的桥梁，对于Spring MVC具体来说，则是连接Handler与View的桥梁。</p>
<p>ModelAndView对象会持有一个ModelMap对象和一个View对象(也可以是View名称)。ModelMap就是执行模板渲染时所需要的变量，Handler会将模板所需要的数据存在这个Map中，然后传递到View对象对应的ViewResolvers中。不同的ViewResolvers对ModelMap的处理方式不同，如Velocity将该ModelMap保存到org.apache.velocity.VelocityContext中，JSP则将ModelMap中的元素设置到request.setAttribute(modelName, modelValue)中。</p>
</blockquote>
<h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><blockquote>
<p>View主要由两个组件支持：RequestToViewNameTranslator和ViewResolver。</p>
<p>RequestToViewNameTranslator顾名思义就是对ViewName的解析，比如在请求的ViewName加上前缀或后缀，替换相应的字符串等。</p>
<p>ViewResolver则是根据请求的ViewName创建合适的模板引擎来渲染最终的页面。ViewResolver会根据ViewName创建一个View对象，调用View对象的void render(Map model, HttpRequest request, HttpServletResponse response)方法渲染页面。</p>
</blockquote>
]]></content>
      <tags>
        <tag>spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring声明式事务原理</title>
    <url>/2020/06/03/Spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="事务回顾"><a href="#事务回顾" class="headerlink" title="事务回顾"></a>事务回顾</h2><p>通过一个实例回顾事务的使用：</p>
<p>创建实体类实体类User：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略构造器和getter，setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建UserMapper：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into user(user_id,username,age) values(#&#123;userId&#125;,#&#123;username&#125;,#&#123;age&#125;)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建Service接口UserService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实现类UserServiceImpl：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserMapper userMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userMapper.save(user);</span><br><span class="line">        <span class="comment">// 测试事务回滚</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(user.getUsername())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;username不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Spring入口类上加上<code>@EnableTransactionManagement</code>注解，以开启事务，并简单写一些测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(TransactionApplication.class, args);</span><br><span class="line">        UserService userService = context.getBean(UserService.class);</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;1&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;18&quot;</span>);</span><br><span class="line">        userService.saveUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<ol>
<li>事务生效，数据将没有被插入到数据库中</li>
<li>注释掉UserServiceImpl的saveUser方法上的<code>@Transactional</code>注解，重新运行程序，事务没有生效，数据被插入到数据库中</li>
</ol>
<h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><h3 id="EnableTransactionManagement"><a href="#EnableTransactionManagement" class="headerlink" title="@EnableTransactionManagement"></a>@EnableTransactionManagement</h3><p>上面例子中，通过注解<code>@EnableTransactionManagement</code>开启了事务管理功能，查看其源码：</p>
<p><img src="/images/EnableTransactionManagement%E6%BA%90%E7%A0%81.png"></p>
<p>接着查看TransactionManagementConfigurationSelector的源码：</p>
<p><img src="/images/TransactionManagementConfigurationSelector%E6%BA%90%E7%A0%81.png"></p>
<p>重点关注AutoProxyRegistrar和ProxyTransactionManagementConfiguration的逻辑</p>
<h4 id="AutoProxyRegistrar"><a href="#AutoProxyRegistrar" class="headerlink" title="AutoProxyRegistrar"></a>AutoProxyRegistrar</h4><p>AutoProxyRegistrar的源码：</p>
<p><img src="/images/AutoProxyRegistrar%E6%BA%90%E7%A0%81.png"></p>
<p>查看<code>AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)</code>源码：</p>
<p><img src="/images/AopConfigUtils.registerAutoProxyCreatorIfNecessary%E6%BA%90%E7%A0%81.png"></p>
<p>查看<code>InfrastructureAdvisorAutoProxyCreator</code>的层级关系图：</p>
<p><img src="/images/infrastructureAdvisorAutoProxyCreator%E7%9A%84%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.png"></p>
<p>这和AOP原理中的AnnotationAwareAspectJAutoProxyCreator的层级关系图一致，由此可以推断出InfrastructureAdvisorAutoProxyCreator的作用为：为目标Service创建代理对象，增强目标Service方法，用于事务控制</p>
<h4 id="ProxyTransactionManagementConfiguration"><a href="#ProxyTransactionManagementConfiguration" class="headerlink" title="ProxyTransactionManagementConfiguration"></a>ProxyTransactionManagementConfiguration</h4><p>查看ProxyTransactionManagementConfiguration源码：</p>
<p><img src="/images/ProxyTransactionManagementConfiguration%E6%BA%90%E7%A0%81.png"></p>
<p>分析上述步骤：</p>
<ol>
<li><p>注册BeanFactoryTransactionAttributeSourceAdvisor增强器，该增强器需要如下两个Bean：</p>
<ul>
<li>TransactionAttributeSource</li>
<li>TransactionInterceptor</li>
</ul>
</li>
<li><p>注册TransactionAttributeSource</p>
<p><img src="/images/%E6%B3%A8%E5%86%8CTransactionAttributeSource.png"></p>
<p>方法体内部创建了一个类型为AnnotationTransactionAttributeSource的Bean，查看其源码：</p>
<p><img src="/images/AnnotationTransactionAttributeSource%E7%9A%84Bean.png"></p>
<p>查看SpringTransactionAnnotationParser源码：</p>
<p><img src="/images/SpringTransactionAnnotationParser%E6%BA%90%E7%A0%81.png"></p>
</li>
<li><p>注册TransactionInterceptor事务拦截器：</p>
<p><img src="/images/TransactionInterceptor%E4%BA%8B%E5%8A%A1%E6%8B%A6%E6%88%AA%E5%99%A8.png"></p>
<p>查看TransactionInterceptor源码，其实现了MethodInterceptor方法拦截器接口，MethodBeforeAdviceInterceptor、AspectJAfterAdvice、AfterReturningAdviceInterceptor和AspectJAfterThrowingAdvice等增强器都是MethodInterceptor的实现类，目标方法执行的时候，对应拦截器的invoke方法会被执行，所以重点关注TransactionInterceptor实现的invoke方法：</p>
<p><img src="/images/TransactionInterceptor%E5%AE%9E%E7%8E%B0%E7%9A%84invoke%E6%96%B9%E6%B3%95.png"></p>
<p>查看invokeWithinTransaction方法源码：</p>
<p><img src="/images/invokeWithinTransaction%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png"></p>
<p>completeTransactionAfterThrowing源码如下：</p>
<p><img src="/images/completeTransactionAfterThrowing%E6%BA%90%E7%A0%81.png"></p>
<p>这里，假如没有在@Transactional注解上指定回滚的异常类型的话，默认只对RunTimeExcetion和Error类型异常进行回滚：</p>
<p><img src="/images/%E9%BB%98%E8%AE%A4%E5%8F%AA%E5%AF%B9RunTimeExcetion%E5%92%8CError%E7%B1%BB%E5%9E%8B%E5%BC%82%E5%B8%B8%E8%BF%9B%E8%A1%8C%E5%9B%9E%E6%BB%9A.png"></p>
<p>commitTransactionAfterReturning源码如下：</p>
<p><img src="/images/commitTransactionAfterReturning%E6%BA%90%E7%A0%81.png"></p>
</li>
</ol>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>打开UserServiceImpl的saveUser方法上的<code>@Transactional</code>注解，然后在如下所示位置打个断点：</p>
<p><img src="/images/saveUser%E6%96%B9%E6%B3%95%E6%89%93%E6%96%AD%E7%82%B9.png"></p>
<p>以debug的方式启动程序：</p>
<p><img src="/images/%E4%BB%A5debug%E7%9A%84%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F.png"></p>
<p>可以看到目标对象已经被JDK代理（目标对象实现了接口，默认走JDK动态代理。可以通过spring.aop.proxy-target-class=true配置来强制使用cglib代理，需要额外引入AOP自动装配依赖）。</p>
<p>在断点处执行Step Into，程序跳转到JdkDynamicAopProxy的invoke方法：</p>
<p><img src="/images/JdkDynamicAopProxy%E7%9A%84invoke%E6%96%B9%E6%B3%95.png"></p>
<p><img src="/images/JdkDynamicAopProxy%E7%9A%84invoke%E6%96%B9%E6%B3%952.png"></p>
<p>程序跳转到TransactionInterceptor的invoke方法：</p>
<p><img src="/images/%E7%A8%8B%E5%BA%8F%E8%B7%B3%E8%BD%AC%E5%88%B0TransactionInterceptor%E7%9A%84invoke%E6%96%B9%E6%B3%95.png"></p>
<p><img src="/images/TransactionInterceptor%E7%9A%84invoke%E6%96%B9%E6%B3%952.png"></p>
<h2 id="事务不生效场景"><a href="#事务不生效场景" class="headerlink" title="事务不生效场景"></a>事务不生效场景</h2><p>对Spring事务机制不熟悉时，经常会遇到事务不生效的场景，这里列举两个最为常见的场景，并给出对应的解决方案</p>
<h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><p>Service方法抛出的异常不是RuntimeException或者Error类型，并且@Transactional注解上没有指定回滚异常类型。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserMapper userMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        userMapper.save(user);</span><br><span class="line">        <span class="comment">// 测试事务回滚</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(user.getUsername())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;username不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，Spring并不会进行事务回滚操作。</p>
<p><strong>默认情况下，Spring事务只对RuntimeException或者Error类型异常（错误）进行回滚，检查异常（通常为业务类异常）不会导致事务回滚。</strong>。</p>
<p>所以要解决上面这个事务不生效的问题，我们主要有以下两种方式：</p>
<ol>
<li><p>手动在@Transactional注解上声明回滚的异常类型（方法抛出该异常及其所有子类型异常都能触发事务回滚）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserMapper userMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        userMapper.save(user);</span><br><span class="line">        <span class="comment">// 测试事务回滚</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(user.getUsername())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;username不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法内手动抛出的检查异常类型改为RuntimeException子类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamInvalidException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParamInvalidException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserMapper userMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userMapper.save(user);</span><br><span class="line">        <span class="comment">// 测试事务回滚</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(user.getUsername())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ParamInvalidException(<span class="string">&quot;username不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><p>非事务方法直接通过this调用本类事务方法</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserMapper userMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUserTest</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.saveUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userMapper.save(user);</span><br><span class="line">        <span class="comment">// 测试事务回滚</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(user.getUsername())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ParamInvalidException(<span class="string">&quot;username不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在UserServiceImpl中，我们新增了saveUserTest方法，该方法没有使用@Transactional注解标注，为非事务方法，内部直接调用了saveUser事务方法</p>
<p><strong>这种情况下事务失效的原因为：Spring事务控制使用AOP代理实现，通过对目标对象的代理来增强目标方法。而上面例子直接通过this调用本类的方法的时候，this的指向并非代理类，而是该类本身。</strong></p>
<p>使用debug来验证this是否为代理对象：</p>
<p><img src="/images/%E9%AA%8C%E8%AF%81this%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1.png"></p>
<p>这种情况下要让事务生效主要有如下两种解决方式（原理都是使用代理对象来替代this）：</p>
<ol>
<li><p>从IOC容器中获取UserService Bean，然后调用它的saveUser方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserMapper userMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUserTest</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        UserService userService = context.getBean(UserService.class);</span><br><span class="line">        userService.saveUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userMapper.save(user);</span><br><span class="line">        <span class="comment">// 测试事务回滚</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(user.getUsername())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ParamInvalidException(<span class="string">&quot;username不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过实现ApplicationContextAware接口注入了应用上下文ApplicationContext，然后从中取出UserService Bean来代替this。</p>
</li>
<li><p>从AOP上下文中取出当前代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserMapper userMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUserTest</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        UserService userService = (UserService) AopContext.currentProxy();</span><br><span class="line">        userService.saveUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userMapper.save(user);</span><br><span class="line">        <span class="comment">// 测试事务回滚</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(user.getUsername())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ParamInvalidException(<span class="string">&quot;username不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>spring, 事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat服务器简析</title>
    <url>/2020/11/08/Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>Tomcat服务器目录：</p>
<ul>
<li>bin   存放服务器可执行程序</li>
<li>conf  存放服务器配置文件</li>
<li>lib  存放服务器的jar包</li>
<li>logs  存放服务器的运行日志</li>
<li>temp  存放服务器运行时产生的临时数据</li>
<li>webapps  存放部署在服务器上的web工程</li>
<li>work  服务器工作时的目录</li>
</ul>
</blockquote>
<span id="more"></span>

<h2 id="文件的上传与下载"><a href="#文件的上传与下载" class="headerlink" title="文件的上传与下载"></a>文件的上传与下载</h2><h3 id="文件的上传"><a href="#文件的上传" class="headerlink" title="文件的上传"></a>文件的上传</h3><blockquote>
<ol>
<li>form标签的设置</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;url&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">encType</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义file标签</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;上传文件名&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>通常，请求正文如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">----AbDAcb134</span><br><span class="line">Content-Disposition:form-data;</span><br><span class="line">name=&quot;username&quot;</span><br><span class="line"></span><br><span class="line">doug</span><br><span class="line">----AbDacb134</span><br><span class="line">Content-Disposition:form-data;</span><br><span class="line">name=&quot;password&quot;</span><br><span class="line"></span><br><span class="line">090900</span><br><span class="line">----AbDacb134</span><br><span class="line">Content-Disposition:form-data;</span><br><span class="line">name=&quot;photo&quot;;filename=&quot;a.jpg&quot;</span><br><span class="line">Content-Type:image/jpeg</span><br><span class="line"></span><br><span class="line">文件数据</span><br><span class="line">----AbDacb134--</span><br><span class="line"></span><br><span class="line">需要说明的就是AbDacb134是浏览器随机生成的分隔字符串，用于分隔请求数据，生成后会放在请求头中。当服务器收到请求后，就会从请求头中查找该分隔字符串，对请求数据进行解析。更重要的是最后一个分隔字符串还多了两个--，表示结束。</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编写服务器代码接收数据，这里需要用到第三方jar包</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第三方jar包：commons-fileupload.jar  和  commons-io.jar</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ServletFileUpload.isMultipartContent(request)) &#123;</span><br><span class="line">        <span class="comment">//检查请求是否包含上传文件</span></span><br><span class="line">        <span class="comment">//是则创建FileItemFactory工厂实现类</span></span><br><span class="line">        FileItemFactory fileItemFactory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">        <span class="comment">//创建解析上传数据的工具类</span></span><br><span class="line">        ServletFileUpload servletFileUpload = <span class="keyword">new</span> ServletFileUpload(fileItemFactory);</span><br><span class="line">        <span class="comment">//解析请求中的上传文件</span></span><br><span class="line">        List&lt;FileItem&gt; files = servletFileUpload.parseRequest(request);</span><br><span class="line">        <span class="comment">//解析的FileItem中包含普通表单项，需要对其进行剔除</span></span><br><span class="line">        <span class="keyword">for</span> (FileItem item : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.isFormField) &#123;</span><br><span class="line">                <span class="comment">//处理普通表单项</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//处理上传的文件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="文件的下载"><a href="#文件的下载" class="headerlink" title="文件的下载"></a>文件的下载</h3><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取用户要下载的文件名</span></span><br><span class="line">    String fileName = <span class="string">&quot;2.jpg&quot;</span>;  <span class="comment">//假设是这样的</span></span><br><span class="line">    <span class="comment">//2. 创建读取文件的输入流</span></span><br><span class="line">    ServletContex application = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">    InputStream inStream = application.getResourceAsStream(<span class="string">&quot;/url/&quot;</span> + fileName);</span><br><span class="line">    <span class="comment">//3. 文件类型设置</span></span><br><span class="line">    String fileType = application.getMimeType(<span class="string">&quot;/url/&quot;</span> + fileName);</span><br><span class="line">    response.setContentType(fileType);</span><br><span class="line">    <span class="comment">//4. 创建响应的输出流</span></span><br><span class="line">    OutputStream outStream = response.getOutputStream();</span><br><span class="line">    IOUtils.copy(inStream, outStream);</span><br><span class="line">    <span class="comment">//5. 告知浏览器如何处理文件，下载还是显示在页面中</span></span><br><span class="line">    <span class="comment">//如果是显示在页面中，这是默认行为，第5步可以省略</span></span><br><span class="line">    <span class="comment">//如果是下载，则进行如下设置</span></span><br><span class="line">    response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + <span class="string">&quot;文件下载后的名字&quot;</span>);</span><br><span class="line">    <span class="comment">//如果文件名只有英文，以下情况忽略</span></span><br><span class="line">    <span class="comment">//如果文件名包含中文，则还要根据不同浏览器进行处理</span></span><br><span class="line">    <span class="comment">//谷歌浏览器和IE浏览器：</span></span><br><span class="line">    <span class="comment">//response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + URLEncoder.encode(&quot;包含中文的文件名.jpg&quot;, &quot;UTF-8&quot;));</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//火狐浏览器：</span></span><br><span class="line">    <span class="comment">//response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename==?UTF-8?B?&quot; + </span></span><br><span class="line">    <span class="keyword">new</span> BASE64Encoder().encode(<span class="string">&quot;包含中文的文件名.jpg&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)) + <span class="string">&quot;?=&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="网页请求流程"><a href="#网页请求流程" class="headerlink" title="网页请求流程"></a>网页请求流程</h2><blockquote>
<p><img src="/images/%E7%BD%91%E9%A1%B5%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B.png"></p>
<p>从图中，可知，服务器和客户端的基本交互流程如下：</p>
<ol>
<li>用户端通过浏览器发起请求和附带请求数据</li>
<li>服务器接收并解析请求，交给相应的Servlet类处理</li>
<li>Servlet处理完毕后，将相应的响应数据和响应页面返回给客户端</li>
<li>客户端浏览器解析响应数据和响应页面，并显示给用户</li>
</ol>
</blockquote>
<h2 id="GET和POST请求格式及响应数据格式"><a href="#GET和POST请求格式及响应数据格式" class="headerlink" title="GET和POST请求格式及响应数据格式"></a>GET和POST请求格式及响应数据格式</h2><blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&gt;POST请求：</span><br><span class="line">&gt;请求行  POST url HTTP协议版本</span><br><span class="line">&gt;请求头  key1=value1</span><br><span class="line">   key2=value2</span><br><span class="line">&gt;空行</span><br><span class="line">&gt;请求正文 name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt;GET请求：</span><br><span class="line">&gt;请求行  <span class="builtin-name">GET</span> url&amp;<span class="attribute">name1</span>=value1&amp;name2=value2 HTTP协议版本</span><br><span class="line">&gt;请求头  <span class="attribute">key1</span>=value1</span><br><span class="line">   <span class="attribute">key2</span>=value2</span><br><span class="line">&gt;空行</span><br><span class="line">&gt;请求正文 空</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">响应数据格式：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">响应行   HTTP协议版本 状态码 状态字符</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">响应头   key1=value1</span></span><br><span class="line">	key2=value2</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">空行</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">响应正文 响应数据+响应页面</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="服务器如何解析请求"><a href="#服务器如何解析请求" class="headerlink" title="服务器如何解析请求"></a>服务器如何解析请求</h2><blockquote>
<p>服务器接收到用户请求后，先会知道该次请求是GET请求还是POST请求，然后以对应请求的方式解析请求数据。比如对于url为<code>http://主机地址:端口号/工程名/映射路径或文件</code>如果为文件，则服务器会直接将文件以响应数据格式传回给用户，通常文件为.html或.jsp。而如果为映射路径的话，yin那么服务器就会解析web.xml文件，根据映射路径找到对应的Servlet类。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--web.xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.doug.wilson.servlet.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/my<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>服务器在解析用户请求时，会将请求数据以键值对的方式读取和保存，并将数据封装成HttpServletRequest对象供程序使用，并提供方法获取该对象中的数据。同时也会提供HttpServletResponse对象，用于设置相应数据和响应内容。</p>
</blockquote>
<h2 id="请求转发和重定向"><a href="#请求转发和重定向" class="headerlink" title="请求转发和重定向"></a>请求转发和重定向</h2><blockquote>
<p><strong>请求转发：由服务器内部多个servlet进行请求处理，共有同一个请求对象，并可以通过请求对象中的setAttribute添加信息，方便下一个servlet处理。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">&quot;url&quot;</span>).forward(request, response);</span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line">&lt;jsp:forward:<span class="string">&quot;url&quot;</span>&gt;&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure>

<p><strong>重定向：接收请求的servlet处理不了用户请求，但知道哪一个资源可以处理请求，通过设置请求头，并将该资源url返回给客户端，让客户端重新发一次新的请求到资源地址，完成请求处理。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line">response.setStatus(<span class="string">&quot;302&quot;</span>);</span><br><span class="line">response.setHeader(<span class="string">&quot;Location&quot;</span>, <span class="string">&quot;url&quot;</span>);</span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line">response.sendRedirect(<span class="string">&quot;url&quot;</span>); <span class="comment">//等同于方式1，只不过进行了封装，简便使用</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%8F%8A%E9%87%8D%E5%AE%9A%E5%90%91.png"></p>
</blockquote>
<h2 id="Session和Cookie"><a href="#Session和Cookie" class="headerlink" title="Session和Cookie"></a>Session和Cookie</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><blockquote>
<p>Cookie为服务器通知客户端浏览器保存键值对的一种技术，主要是由于HTTP为无状态协议，每次请求不能够主动携带数据，影响用户某些功能的体验，比如购物车。</p>
<ol>
<li><p>Cookie的创建和回传给浏览器保存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">response.addCookie(c);</span><br></pre></td></tr></table></figure></li>
<li><p>服务器端Cookie的获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="comment">//如果要获取某个特定的Cookie，只能通过遍历进行获取</span></span><br></pre></td></tr></table></figure></li>
<li><p>Cookie常用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比如获取到了一个Cookie  cookie</span></span><br><span class="line">cookie.getDomain();  <span class="comment">//获取域名</span></span><br><span class="line">cookie.getMaxAge();  <span class="comment">//获取cookie的存活时间</span></span><br><span class="line">cookie.getName();    <span class="comment">//cookie的key</span></span><br><span class="line">cookie.getValue();   <span class="comment">//cookie的value</span></span><br></pre></td></tr></table></figure></li>
<li><p>Cookie的有效路径path。通过path可以过滤Cookie，哪些需要发送给浏览器，哪些不发</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">现假设有两个Cookie，path设置成</span><br><span class="line">Cookie cookieA  path=/工程路径</span><br><span class="line">Cookie cookieB  path=/工程路径/abc</span><br><span class="line">当请求地址为：</span><br><span class="line">http://localhost:8888/工程路径 cookieA发送，cookieB不发送</span><br><span class="line">http://localhost:8888/工程路径/abc  cookieA和cookieB都发送</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><blockquote>
<p>客户端和服务器间的会话，一次会话的结束为客户端关闭浏览器。服务器会为每个客户端创建一个会话，并分配一个唯一的id，用于标识存储的用户信息。</p>
<ol>
<li><p>创建或获取HttpSession </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpSession session = request.getSession(); <span class="comment">//没有则创建，有则获取</span></span><br><span class="line"><span class="comment">//可以通过下面的方法判断session是否是刚创建的</span></span><br><span class="line">session.isNew(); <span class="comment">//为true说明是刚创建的</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取session唯一标识符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.getId();</span><br></pre></td></tr></table></figure></li>
<li><p>往session中存储数据或者从session中读取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.setAttribute(String key, Object value);</span><br><span class="line">session.getAttribute(<span class="string">&quot;key&quot;</span>);  <span class="comment">//得到Object</span></span><br></pre></td></tr></table></figure></li>
<li><p>session的生命周期设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.setMaxInactiveInterval(<span class="keyword">int</span>);  <span class="comment">//单位为秒，超过时长，session自动销毁</span></span><br><span class="line"><span class="comment">//默认时长为1800秒——30分钟</span></span><br><span class="line"><span class="comment">//如果设置为负数，则session永远不会被销毁</span></span><br><span class="line"><span class="comment">//没有0</span></span><br><span class="line">         </span><br><span class="line"><span class="comment">//强制销毁</span></span><br><span class="line">session.invalidate();</span><br><span class="line">         </span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h3 id="Cookie和Session的关联，以及Session如何工作"><a href="#Cookie和Session的关联，以及Session如何工作" class="headerlink" title="Cookie和Session的关联，以及Session如何工作"></a>Cookie和Session的关联，以及Session如何工作</h3><blockquote>
<p><img src="/images/session%E5%92%8Ccookie.png"></p>
<p>大体步骤如下：</p>
<ol>
<li>解析Request中的Parameters，拿到Session ID并设置到Request对象中</li>
<li>如果支持Cookie，则从Cookie中拿到Session ID并覆盖第一步中的ID</li>
<li>根据Session ID在sessions集合中查找已经存在的Session对象，如果存在则返回，不存在则创建一个新的Session对象(Session失效)并添加到sessions集合中</li>
<li>根据返回的Session对象新增一个Cookie，并将这个Cookie设置到响应头中</li>
<li>对Session对象进行操作，如修改和删除等</li>
</ol>
<p>从Request中获取的Session对象保存在org.apache.catalina.Manager类中，其实现类为org.apache.catalina.session.StandardManager。我们可以通过SessionId从StandardManager的sessions集合中取出StandardSession对象。综上，我们可以知道，StandardManager是帮助我们管理StandardSession对象的一个类。</p>
<p><img src="/images/Manager%E4%B8%8ESession%E5%85%B3%E7%B3%BB.png"></p>
<p>StandardManager类负责Servlet容器中所有StandardSession对象生命周期的管理。当Servlet容器重启或关闭时，StandardManager负责持久化没有过期的StandardSession对象，将对象保存到”SESSIONS.ser”为文件名的文件中。当Servlet容器重启时，它会重新读取这个文件并解析出所有的Session对象，重新保存在StandardManager的sessions集合中。</p>
</blockquote>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><blockquote>
<p>Filter常用于：<strong>拦截请求，过滤响应，权限检查</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> </span>&#123;</span><br><span class="line">     	<span class="comment">//逻辑代码，进行拦截请求或过滤响应、或权限检查</span></span><br><span class="line">        <span class="comment">//符合权限时，执行</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/filter%E8%BF%87%E6%BB%A4%E5%99%A8.png"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--过滤器配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.doug.wilson.MyFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>拦截请求的方式<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="拦截请求的方式"><a href="#拦截请求的方式" class="headerlink" title="拦截请求的方式"></a>拦截请求的方式</h4><blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&gt;精确匹配：<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/admin/a.jpg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> 具体到文件</span><br><span class="line">&gt;目录匹配：<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/admin/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> 匹配某个目录下的所有内容</span><br><span class="line">&gt;后缀名匹配：<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> 拦截以.html结尾的请求</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><blockquote>
<p><strong>异步请求：Asynchronous Javascript and XML 通过js异步发起请求，局部更新页面或者获取数据的技术</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 创建XMLHttpRequest对象</span></span><br><span class="line"><span class="keyword">var</span> ajaxObj;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    <span class="comment">//通用浏览器</span></span><br><span class="line">    ajaxObj = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ajaxObj = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 调用open方法设置请求参数</span></span><br><span class="line">ajaxObj.open(<span class="string">&quot;method&quot;</span>, <span class="string">&quot;url&quot;</span>, <span class="literal">true</span>); <span class="comment">//true为异步，false为同步</span></span><br><span class="line"><span class="comment">//3. 在send方法前绑定onreadystatechange事件</span></span><br><span class="line">ajaxObj.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ajaxObj.readyState == <span class="number">4</span> &amp;&amp; ajaxObj.status == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">//成功响应</span></span><br><span class="line">        ajaxObj.responseText(); <span class="comment">//获取响应数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果请求为POST请求，还需要加上下面这行代码</span></span><br><span class="line"><span class="comment">//ajaxObj.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span></span><br><span class="line"><span class="comment">//4. 调用send发送请求</span></span><br><span class="line">ajaxObj.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面是底层代码，jQuery封装了该部分，简化了使用</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;请求地址&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: <span class="string">&quot;请求数据&quot;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;GET OR POST&quot;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//data为响应数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">dataType</span>:<span class="string">&quot;text XML JSON 根据响应内容进行设置&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">readyState:</span><br><span class="line">0: 请求未初始化——还没有调用open()</span><br><span class="line">1: 请求已经建立，但是还没有发送——还没有调用send()</span><br><span class="line">2: 请求已经发送，正在处理中，可以获取响应头</span><br><span class="line">3: 请求正在处理中，响应已经有部分数据可用，但是服务器还没有完成响应的生成</span><br><span class="line">4: 响应已经完成，可以获取并使用服务器响应</span><br><span class="line">status:</span><br><span class="line">即HTTP响应码</span><br></pre></td></tr></table></figure>

</blockquote>
]]></content>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat系统架构</title>
    <url>/2020/11/05/Tomcat%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>了解Tomcat组件、Tomcat如何分发请求、Tomcat多级容器的关系以及如何协调工作。目前先了解这么多，后面再回来补。</p>
<span id="more"></span>

<h3 id="Tomcat总体结构"><a href="#Tomcat总体结构" class="headerlink" title="Tomcat总体结构"></a>Tomcat总体结构</h3><blockquote>
<p><img src="/images/Tomcat%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png"></p>
<p>总的来说，Tomcat有两个核心组件：Connector和Container。一个Container对应多个Connector，并且<strong>一个Container和多个Connector就形成了一个Service</strong>。有了Service就可以对外提供服务了。但是这还不够，我们需要给Service提供一个运行环境，并控制Service的生命周期，所以，所有的Service还必须由Server进行控制，作用就是Server为每个Service提供运行环境和控制其生命周期。</p>
<p>在Tomcat中，Service接口的标准实现类是StandardService，并且StandardService也实现了Lifycycle接口，这样它就可以控制下面组件的生命周期。和结构图中的一样，StandardService中核心的方法也是和Container、Connector以及Service有关：<strong>setContainer方法、addConnector方法以及addService方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContainer</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//清空父类容器Engine中原来的内容，然后进行container设置</span></span><br><span class="line">    Container oldContainer = <span class="keyword">this</span>.container;</span><br><span class="line">    <span class="keyword">if</span> ((oldContainer != <span class="keyword">null</span>) &amp;&amp; (oldContainer <span class="keyword">instanceof</span> Engine)) &#123;</span><br><span class="line">        ((Engine) oldContainer).setService(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对传入的container的父类容器(如果存在的话)进行清空</span></span><br><span class="line">    <span class="keyword">this</span>.container = container;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">this</span>.container != <span class="keyword">null</span>) &amp;&amp; (<span class="keyword">this</span>.container <span class="keyword">instanceof</span> Engine)) &#123;</span><br><span class="line">        ((Engine) <span class="keyword">this</span>.container).setService(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//启动新的Container的生命周期</span></span><br><span class="line">    <span class="keyword">if</span> (started &amp;&amp; (<span class="keyword">this</span>.container != <span class="keyword">null</span>) &amp;&amp; (<span class="keyword">this</span>.container <span class="keyword">instanceof</span> Lifecycle)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((Lifecycle) <span class="keyword">this</span>.container).start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifycycleException e) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectors) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connectors.length; i++) &#123;</span><br><span class="line">            <span class="comment">//将Connector和Container进行关联</span></span><br><span class="line">            connectors[i].setContainer(<span class="keyword">this</span>.container);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束oldContainer的生命周期</span></span><br><span class="line">    <span class="keyword">if</span> (started &amp;&amp; (oldContainer != <span class="keyword">null</span>) &amp;&amp; (oldContainer <span class="keyword">instanceof</span> Lifecycle)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//停止oldContainer运行</span></span><br><span class="line">            ((Lifecycle) oldContainer).stop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    support.firePropertyChange(<span class="string">&quot;container&quot;</span>, oldContainer, <span class="keyword">this</span>.container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总体来说，setContainer主要就是首先判断当前这个Service有没有以及关联Container，如果关联了就去掉这个关联关系。如果oldContainer已经启动了，则结束它的生命周期，然后再替换新的关联，初始化并开始新的Container的生命周期。最后将结果通知给相关事件的监听程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addConnector</span><span class="params">(Connector connector)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加一个新connector组件</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectors) &#123;</span><br><span class="line">        <span class="comment">//设置关联</span></span><br><span class="line">        connector.setContainer(<span class="keyword">this</span>.container);</span><br><span class="line">        connector.setService(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//新Connector数组，拷贝，加入新Connector组件，更改引用</span></span><br><span class="line">        Connector[] results = <span class="keyword">new</span> Connector[connectors.length + <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(connectors, <span class="number">0</span>, results, <span class="number">0</span>, connectors.length);</span><br><span class="line">        results[connectors.length] = connector;</span><br><span class="line">        connectors = results;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connector.initialize();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">                e.printStackTrace(System.err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始生命周期</span></span><br><span class="line">        <span class="keyword">if</span> (started &amp;&amp; (connector <span class="keyword">instanceof</span> Lifecycle)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((Lifecycle) connector).start();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通知相关组件</span></span><br><span class="line">        support.firePropertyChange(<span class="string">&quot;connector&quot;</span>, <span class="keyword">null</span>, connector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addConnector方法首先先设置关联关系，然后进行初始化，开始生命周期。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置关联关系</span></span><br><span class="line">    service.setServer(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (services) &#123;</span><br><span class="line">        <span class="comment">//采用和connector一样的添加，创建新数组，然后插入，修改引用</span></span><br><span class="line">        Service[] results = <span class="keyword">new</span> Service[services.length + <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(services, <span class="number">0</span>, results, <span class="number">0</span>, services.length);</span><br><span class="line">        results[services.length] = service;</span><br><span class="line">        services = results;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">            service.initialize();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始新的生命周期</span></span><br><span class="line">    <span class="keyword">if</span> (started &amp;&amp; (service <span class="keyword">instanceof</span> Lifecycle)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((Lifecycle) service).start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    support.firePropertyChange(<span class="string">&quot;service&quot;</span>, <span class="keyword">null</span>, service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Connector组件"><a href="#Connector组件" class="headerlink" title="Connector组件"></a>Connector组件</h3><blockquote>
<p>Connector组件主要任务就是负责接收浏览器的TCP连接请求，创建一个Request和Response对象分别用于请求和响应数据。然后产生一个线程来处理请求，并将产生的Request和Response对象传给处理这个请求的线程，线程如何执行就是Container组件要做的事情。</p>
<p>Connector处理一次请求大概流程如下：</p>
<ol>
<li>初始化一个ServerSocket</li>
<li>初始化一个线程，等待新的连接请求</li>
<li>创建一定大小的线程池，构建request和response对象</li>
<li>所有线程进入await()，等待请求到来被激活</li>
<li>当请求到来，将socket分配给HttpProcessor</li>
<li>HttpProcessor激活一个线程，并执行线程run方法</li>
<li>创建SocketInputStream和OutputStream为input和output对象，并解析请求，将请求中的内容都组装到request和response对象中。</li>
<li>将request和response两个对象传给Container组件执行，由对应的servlet处理，处理完成后，将处理结果装入request和response对象中返回</li>
<li>调用output对象，output.flush()将结果返回给客户端</li>
<li>request和response对象生命周期结束，关闭当前socket。</li>
</ol>
<p>由这个过程可知，Connector内部必然是多线程的，那么它是如何处理多线程的连接请求？就是接下来的内容：</p>
<p>该多线程的连接请求涉及到两个类：HttpConnector和HttpProcessor。主要代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HttpConnector的start方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> throws LifecycleException </span>&#123;</span><br><span class="line">    <span class="comment">//如果连接已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (started) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">LifecycleException</span>(sm.<span class="built_in">getString</span>(<span class="string">&quot;httpConnector.alreadyStarted&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新的连接</span></span><br><span class="line">    threadName = <span class="string">&quot;HttpConnector[&quot;</span> + port + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    lifecycle.<span class="built_in">fireLifecycleEvent</span>(START_EVENT, null);</span><br><span class="line">    started = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">threadStart</span>();  <span class="comment">//到这里，start()方法就会处于等待被激活状态，直到有请求进来</span></span><br><span class="line">    <span class="keyword">while</span> (curProcessors &lt; minProcessors) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((maxProcessors &gt; <span class="number">0</span>) &amp;&amp; (curProcessors &gt;= maxProcessors)) &#123;</span><br><span class="line">            <span class="comment">//处理连接的处理对象达到上限</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有达到上限则创建处理对象处理连接</span></span><br><span class="line">        HttpProcessor processor = <span class="built_in">newProcessor</span>();</span><br><span class="line">        <span class="built_in">recycle</span>(processor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>theadStart()方法的激活是在HttpProcessor的assign方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建HttpProcessor时，available为false，当请求到来时不会进入到循环中</span></span><br><span class="line">    <span class="comment">//只有将socket赋值给当前的HttpProcessor，available才会为true，阻止其他请求获取当前</span></span><br><span class="line">    <span class="comment">//的HttpProcessor</span></span><br><span class="line">    <span class="keyword">while</span> (available) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InnterruptedException e) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    available = <span class="keyword">true</span>;</span><br><span class="line">    notifyAll(); <span class="comment">//激活线程处理请求</span></span><br><span class="line">    <span class="keyword">if</span> ((debug &gt;= <span class="number">1</span>) &amp;&amp; (socket != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        log(<span class="string">&quot;An incoming request is beging assigned&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过上面的步骤后，处理请求的线程就会被激活来执行请求处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!stopped) &#123;</span><br><span class="line">        Socket socket = await(); <span class="comment">//等待notifyAll()</span></span><br><span class="line">        <span class="comment">//被激活</span></span><br><span class="line">        <span class="keyword">if</span> (socket == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//解析Socket，处理请求线程的核心方法</span></span><br><span class="line">            process(socket);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            log(<span class="string">&quot;process.invoke&quot;</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">        connector.recycle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (threadSync) &#123;</span><br><span class="line">        threadSync.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理请求线程的核心方法process:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化一些过程变量</span></span><br><span class="line">    <span class="keyword">boolean</span> ok = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishResponse = <span class="keyword">true</span>;</span><br><span class="line">    SocketInputStream input = <span class="keyword">null</span>;</span><br><span class="line">    OutputStream output = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//开始解析socket</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取socket信息</span></span><br><span class="line">        input = <span class="keyword">new</span> SocketInputStream(socket.getInputStream(), connector.getBufferSize());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log(<span class="string">&quot;process.create&quot;</span>, e);</span><br><span class="line">        <span class="comment">//ok为false，说明没有获取到socket信息，解析过程无法进行</span></span><br><span class="line">        ok = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    keepAlive = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stopped &amp;&amp; ok &amp;&amp; keepAlive) &#123;</span><br><span class="line">        <span class="comment">//解析sokect核心过程</span></span><br><span class="line">        finishResponse = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//必要初始化设置</span></span><br><span class="line">            request.setStream(input);</span><br><span class="line">            request.setResponse(response);</span><br><span class="line">            output = socket.getOutputStream();</span><br><span class="line">            response.setStream(output);</span><br><span class="line">            response.setRequest(request);</span><br><span class="line">            ((HttpServletResponse) response.getResponse())</span><br><span class="line">            	.setHeader(<span class="string">&quot;Server&quot;</span>, SERVER_INFO);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log(<span class="string">&quot;process.create&quot;</span>, e);</span><br><span class="line">            ok = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始解析</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                parseConnection(socket);</span><br><span class="line">                parseRequest(input, output);</span><br><span class="line">                <span class="keyword">if</span> (!request.getRequest().getProtocol.startsWith(<span class="string">&quot;HTTP/0&quot;</span>)) &#123;</span><br><span class="line">                    parseHeaders(input);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (httpll) &#123;</span><br><span class="line">                    ackRequest(output);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (connector.isChunkingAllowed()) &#123;</span><br><span class="line">                    response.setAllowChunking(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//省略部分内容</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将request对象和response对象交给container容器</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((HttpServletResponse) response).setHeader(<span class="string">&quot;Date&quot;</span>, FastHttpDateFormat.getCurrentDate());</span><br><span class="line">            <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                connector.getContainer().invoke(request, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//省略部分内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//后续处理</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        shutdownInput(input);</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        log(<span class="string">&quot;process.invoke&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    socket = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Container组件"><a href="#Container组件" class="headerlink" title="Container组件"></a>Container组件</h3><blockquote>
<p>Container容器是四个子容器的父接口，四个子容器Engine/Host/Context/Wrapper必须实现该接口。</p>
<p>另一篇文章学过，这四个子容器也是父子关系：Engine包含Host，Host包含Context，Context包含Wrapper。并且一个Servlet.class对应一个Wrapper，一个Context对应多个Wrapper。</p>
<p>当一个请求交给Container，Container如何处理这个请求？四个子容器组件如何分工？如何把请求交给特定子容器？又如何将请求交给Servlet？</p>
<p>Tomcat采用一个Pipeline+Valve（管道+阀门）的组合来实现请求的处理。从Engine/Host/Context/Wrapper开始，每个容器都会执行Pipeline并有自己的Valve集合</p>
<ul>
<li>StandardEngine  StandardEngineValve</li>
<li>StandardHost  StandardHostValve</li>
<li>StandardContext  StandardContextValve</li>
<li>StandardWrapper  StandardWrapperValve</li>
</ul>
<p>通过激活每个容器的Valve将请求在管道Pipeline中依次传递，传递过程如下：</p>
<ol>
<li>在StandardEngine激活自己的Valve并激活Host容器的Valve，将请求传递到Host容器中</li>
<li>在StandardHost激活Context容器的Valve，将请求传递到Context容器中</li>
<li>在StandardContext激活Wrapper容器的Valve，将请求传递到Wrapper容器中</li>
<li>在StandardWrapperValve中加载servlet，执行init方法。并创建filter链，执行Servlet的service方法，将请求交给Servlet类处理</li>
</ol>
<p>到这里，请求就执行完成，容器会释放所有资源，结束事件的监听。</p>
</blockquote>
]]></content>
      <tags>
        <tag>tomcat, 系统架构</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora快捷键</title>
    <url>/2020/01/09/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h6 id="保存：Ctrl-S"><a href="#保存：Ctrl-S" class="headerlink" title="保存：Ctrl+S"></a>保存：<kbd>Ctrl</kbd>+<kbd>S</kbd></h6><h6 id="关闭：Ctrl-W"><a href="#关闭：Ctrl-W" class="headerlink" title="关闭：Ctrl+W"></a>关闭：<kbd>Ctrl</kbd>+<kbd>W</kbd></h6><h6 id="撤销：Ctrl-Z"><a href="#撤销：Ctrl-Z" class="headerlink" title="撤销：Ctrl+Z"></a>撤销：<kbd>Ctrl</kbd>+<kbd>Z</kbd></h6><h6 id="复制：Ctrl-C"><a href="#复制：Ctrl-C" class="headerlink" title="复制：Ctrl+C"></a>复制：<kbd>Ctrl</kbd>+<kbd>C</kbd></h6><span id="more"></span>

<h6 id="粘贴：Ctrl-V"><a href="#粘贴：Ctrl-V" class="headerlink" title="粘贴：Ctrl+V"></a>粘贴：<kbd>Ctrl</kbd>+<kbd>V</kbd></h6><h6 id="剪切：Ctrl-X"><a href="#剪切：Ctrl-X" class="headerlink" title="剪切：Ctrl+X"></a>剪切：<kbd>Ctrl</kbd>+<kbd>X</kbd></h6><h6 id="全选：Ctrl-A"><a href="#全选：Ctrl-A" class="headerlink" title="全选：Ctrl+A"></a>全选：<kbd>Ctrl</kbd>+<kbd>A</kbd></h6><h6 id="选中当前行：Ctrl-L"><a href="#选中当前行：Ctrl-L" class="headerlink" title="选中当前行：Ctrl+L"></a>选中当前行：<kbd>Ctrl</kbd>+<kbd>L</kbd></h6><h6 id="选中当前格式文本：Ctrl-E"><a href="#选中当前格式文本：Ctrl-E" class="headerlink" title="选中当前格式文本：Ctrl+E"></a>选中当前格式文本：<kbd>Ctrl</kbd>+<kbd>E</kbd></h6><h6 id="选中当前词：Ctrl-D"><a href="#选中当前词：Ctrl-D" class="headerlink" title="选中当前词：Ctrl+D"></a>选中当前词：<kbd>Ctrl</kbd>+<kbd>D</kbd></h6><h6 id="提升标题级别：Ctrl"><a href="#提升标题级别：Ctrl" class="headerlink" title="提升标题级别：Ctrl++="></a>提升标题级别：<kbd>Ctrl</kbd>+<kbd>+=</kbd></h6><h6 id="降低标题级别：Ctrl"><a href="#降低标题级别：Ctrl" class="headerlink" title="降低标题级别：Ctrl+_-"></a>降低标题级别：<kbd>Ctrl</kbd>+<kbd>_-</kbd></h6><h6 id="表格：Ctrl-T"><a href="#表格：Ctrl-T" class="headerlink" title="表格：Ctrl+T"></a>表格：<kbd>Ctrl</kbd>+<kbd>T</kbd></h6><h6 id="删除缩进：Ctrl"><a href="#删除缩进：Ctrl" class="headerlink" title="删除缩进：Ctrl+["></a>删除缩进：<kbd>Ctrl</kbd>+<kbd>[</kbd></h6><h6 id="代码块：Ctrl-Shift-K"><a href="#代码块：Ctrl-Shift-K" class="headerlink" title="代码块：Ctrl+Shift+K"></a>代码块：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>K</kbd></h6><p>数学公式：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>M</kbd></p>
<p>引用：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Q</kbd></p>
<p>有序列表：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>[</kbd></p>
<p>无序列表：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>]</kbd></p>
<p>代码：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>`</kbd></p>
<p>删除线：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>5</kbd></p>
<p>大纲视图：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>1</kbd></p>
<p>搜索：<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>F</kbd></p>
]]></content>
      <tags>
        <tag>typora</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/05/15/~$mcat%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<p>������                                                ĞOeZ  iSO  T i m e ptqN% �        �            }pjqZ&amp; �p&lt;W�  p&lt;W�   t h E dsphq ’ ��&lt;W�  �&lt;W</p>
]]></content>
  </entry>
  <entry>
    <title>了解Linux</title>
    <url>/2020/03/20/%E4%BA%86%E8%A7%A3Linux/</url>
    <content><![CDATA[<p>我喜欢一段比喻，用于说明Windows和Linux的区别(引用自 《Linux命令行大全》)：</p>
<blockquote>
<p>Windows就像Game Boy游戏机。你去商店买了一个全新的游戏机。你把它带回家，启动，玩游戏机中的游戏，漂亮的画面，优美的声音，人性化的操作。但是，不久，你对这款游戏玩腻了，于是你回到商店，买了另一款游戏机。就这样一遍一遍重复着，然后当你想玩一个不一样的游戏时，你回到商店，对柜台的售货员说：“我想要这样这样的游戏”，但却被告知没有这样的游戏。然后你对售货员说：“只需要更换游戏中的某个东西就可以了”。售货员对你说：“你不能更换它，这个游戏机盒子是密封好的”。你很沮丧，你只能由别人决定你可以玩的游戏，并没有更多的选项可以选择。</p>
<p>而Linux就像是世界上最大的拼装玩具。你打开它，它是一个零件集，螺丝钉，齿轮，马达，等等。你可以拼装成任何基于你想象的内容，拼装完一个参考样式后，再拼装另一种。你不再需要回到商店，因为你已经有了拼装所需要的所有东西。</p>
</blockquote>
<span id="more"></span>

<h2 id="Linux软件包系统"><a href="#Linux软件包系统" class="headerlink" title="Linux软件包系统"></a>Linux软件包系统</h2><blockquote>
<p>不同的Linux用不同的软件包系统，并且原则上，适用于一种发行版的软件包和其他版本是不兼容的。多数Linux发行版采用两种软件包，**Debian的 .deb 和Red Hat的 .rpm ** </p>
<table>
<thead>
<tr>
<th>软件包系统</th>
<th>发行版本</th>
</tr>
</thead>
<tbody><tr>
<td>.deb</td>
<td>Debian/Ubuntu/Xandros/Linspire</td>
</tr>
<tr>
<td>.rpm</td>
<td>Fedora/CentOS/Red Hat/openSUSE/Mandriva/PCLinuxOS</td>
</tr>
</tbody></table>
<p>包文件是组成软件包系统的基本软件单元。是由组成软件包的文件压缩而成的文件集。</p>
<p>一个包可能含有大量的程序以及支持这些程序的数据文件。此外，许多软件包中还包含了安装软件包前后执行配置任务的安装脚本。</p>
<p>包文件通常由软件包维护者创建。包维护者从程序的作者处或供应商获得软件源码，然后进行编译，并创建包的元数据及其他所必须的安装脚本。</p>
<h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><p>Linux用户可以从其所使用的Linux版本的中心库获得软件包。所谓的中心库，一般包含了成千上万个软件包，每个软件包都是为相应的发行版本建立和维护的。</p>
<p>用户必须充分了解每个软件包的信息，然后手动将其加入到软件包文件管理系统的配置文件中，才能使用它们。</p>
<h3 id="高级和低级软件包工具"><a href="#高级和低级软件包工具" class="headerlink" title="高级和低级软件包工具"></a>高级和低级软件包工具</h3><p>软件包管理系统通常包含两类工具——执行安装、删除软件包文件等任务的低级工具。以及进行元数据搜索和提供依赖性解决的高级工具。</p>
<table>
<thead>
<tr>
<th>发行版本</th>
<th>低级工具</th>
<th>高级工具</th>
</tr>
</thead>
<tbody><tr>
<td>Debian系统</td>
<td>dpkg</td>
<td>apt-get/aptitude</td>
</tr>
<tr>
<td>Red Hat系统</td>
<td>rpm</td>
<td>yum</td>
</tr>
</tbody></table>
<h3 id="在库中查找软件包，安装软件包"><a href="#在库中查找软件包，安装软件包" class="headerlink" title="在库中查找软件包，安装软件包"></a>在库中查找软件包，安装软件包</h3><p>通过使用高级工具来搜索库元数据时，可以根据包文件名来查找对应的包文件：</p>
<table>
<thead>
<tr>
<th>系统类型</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>Debian系统</td>
<td>apt-get update/apt-cache search package-name</td>
</tr>
<tr>
<td>Red Hat系统</td>
<td>yum search package-name</td>
</tr>
</tbody></table>
<p>安装包文件：</p>
<table>
<thead>
<tr>
<th>系统类型</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>Debian系统</td>
<td>apt-get update/apt-get install package-name</td>
</tr>
<tr>
<td>Red Hat系统</td>
<td>yum install package-name</td>
</tr>
</tbody></table>
<h3 id="卸载软件包和更新软件包"><a href="#卸载软件包和更新软件包" class="headerlink" title="卸载软件包和更新软件包"></a>卸载软件包和更新软件包</h3><p>卸载软件包：</p>
<table>
<thead>
<tr>
<th>系统类型</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>Debian系统</td>
<td>apt-get remove package-name</td>
</tr>
<tr>
<td>Red Hat系统</td>
<td>yum erase package-name</td>
</tr>
</tbody></table>
<p>更新软件包：</p>
<table>
<thead>
<tr>
<th>系统类型</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>Debian系统</td>
<td>apt-get update;apt-get upgrade</td>
</tr>
<tr>
<td>Red Hat系统</td>
<td>yum update</td>
</tr>
</tbody></table>
<h3 id="列出已安装的软件包列表"><a href="#列出已安装的软件包列表" class="headerlink" title="列出已安装的软件包列表"></a>列出已安装的软件包列表</h3><table>
<thead>
<tr>
<th>系统类型</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>Debian系统</td>
<td>dpkg –list</td>
</tr>
<tr>
<td>Red Hat系统</td>
<td>rpm -qa</td>
</tr>
</tbody></table>
</blockquote>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用dom4j</title>
    <url>/2020/04/21/%E4%BD%BF%E7%94%A8dom4j/</url>
    <content><![CDATA[<p>今天看书的时候看到dom4j可以解析和生成xml文件，因此想记录一下，供之后需要的时候使用。</p>
<span id="more"></span>

<h2 id="dom4j解析xml文件大致步骤"><a href="#dom4j解析xml文件大致步骤" class="headerlink" title="dom4j解析xml文件大致步骤"></a>dom4j解析xml文件大致步骤</h2><ol>
<li>创建SAXReader</li>
<li>使用SAXReader解析指定的XML文档信息，并返回对应的Document对象。Document对象包含该xml文件所有信息及结构</li>
<li>根据document文档结构，读取信息</li>
</ol>
<p>举例说明：现有一个xml文件：player.xml文件，一个实体类 Player ，一个解析类ParseXml</p>
<p><strong>player.xml文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">players</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">player</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>乔丹<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">number</span>&gt;</span>23<span class="tag">&lt;/<span class="name">number</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">salary</span>&gt;</span>30000000<span class="tag">&lt;/<span class="name">salary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">player</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">player</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>科比<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">number</span>&gt;</span>24<span class="tag">&lt;/<span class="name">number</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">salary</span>&gt;</span>27000000<span class="tag">&lt;/<span class="name">salary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">player</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">player</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>詹姆斯<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">number</span>&gt;</span>23<span class="tag">&lt;/<span class="name">number</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">salary</span>&gt;</span>27000000<span class="tag">&lt;/<span class="name">salary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">player</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">player</span> <span class="attr">id</span>=<span class="string">&quot;4&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>库里<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">number</span>&gt;</span>30<span class="tag">&lt;/<span class="name">number</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">salary</span>&gt;</span>25000000<span class="tag">&lt;/<span class="name">salary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">player</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">player</span> <span class="attr">id</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>冬基奇<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">number</span>&gt;</span>77<span class="tag">&lt;/<span class="name">number</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">salary</span>&gt;</span>23000000<span class="tag">&lt;/<span class="name">salary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">player</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">players</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>实体类 Player</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> number, String gender, <span class="keyword">long</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析类 ParseXml</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseXml</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Player&gt; <span class="title">parsePlayerXml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">            Document document = reader.read(<span class="keyword">new</span> File(<span class="string">&quot;F:/GitTool/repository/DougCoding/pratice/src/com/doug/wilson/dom4j/player.xml&quot;</span>));</span><br><span class="line">            List&lt;Player&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 第一步，获取根标签元素 &lt;players&gt;...&lt;/players&gt;</span></span><br><span class="line">            Element root = document.getRootElement();</span><br><span class="line">            <span class="comment">// 获取子标签&lt;player&gt;...&lt;/player&gt;中的内容</span></span><br><span class="line">            List&lt;Element&gt; elementList = root.elements(<span class="string">&quot;player&quot;</span>);</span><br><span class="line">            <span class="comment">// 遍历获取每个子标签&lt;player&gt;...&lt;/player&gt;中的内容</span></span><br><span class="line">            <span class="keyword">for</span> (Element e : elementList) &#123;</span><br><span class="line">                <span class="comment">// 将字符串转换为对应类型</span></span><br><span class="line">                <span class="keyword">int</span> id = Integer.parseInt(e.attribute(<span class="string">&quot;id&quot;</span>).getValue());</span><br><span class="line">                String name = e.elementText(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> number = Integer.parseInt(e.elementText(<span class="string">&quot;number&quot;</span>));</span><br><span class="line">                String gender = e.elementText(<span class="string">&quot;gender&quot;</span>);</span><br><span class="line">                <span class="keyword">long</span> salary = Long.parseLong(e.elementText(<span class="string">&quot;salary&quot;</span>));</span><br><span class="line">                list.add(<span class="keyword">new</span> Player(id, name, number, gender, salary));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到这里，说明解析过程错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Player&gt; players = parsePlayerXml();</span><br><span class="line">        <span class="keyword">for</span> (Player player : players) &#123;</span><br><span class="line">            System.out.println(player);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析结果</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Player&#123;<span class="attribute">id</span>=1, <span class="attribute">name</span>=<span class="string">&#x27;乔丹&#x27;</span>, <span class="attribute">number</span>=23, <span class="attribute">gender</span>=<span class="string">&#x27;男&#x27;</span>, <span class="attribute">salary</span>=30000000&#125;</span><br><span class="line">Player&#123;<span class="attribute">id</span>=2, <span class="attribute">name</span>=<span class="string">&#x27;科比&#x27;</span>, <span class="attribute">number</span>=24, <span class="attribute">gender</span>=<span class="string">&#x27;男&#x27;</span>, <span class="attribute">salary</span>=27000000&#125;</span><br><span class="line">Player&#123;<span class="attribute">id</span>=3, <span class="attribute">name</span>=<span class="string">&#x27;詹姆斯&#x27;</span>, <span class="attribute">number</span>=23, <span class="attribute">gender</span>=<span class="string">&#x27;男&#x27;</span>, <span class="attribute">salary</span>=27000000&#125;</span><br><span class="line">Player&#123;<span class="attribute">id</span>=4, <span class="attribute">name</span>=<span class="string">&#x27;库里&#x27;</span>, <span class="attribute">number</span>=30, <span class="attribute">gender</span>=<span class="string">&#x27;男&#x27;</span>, <span class="attribute">salary</span>=25000000&#125;</span><br><span class="line">Player&#123;<span class="attribute">id</span>=5, <span class="attribute">name</span>=<span class="string">&#x27;冬基奇&#x27;</span>, <span class="attribute">number</span>=77, <span class="attribute">gender</span>=<span class="string">&#x27;男&#x27;</span>, <span class="attribute">salary</span>=23000000&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dom4j生成xml文件大致步骤"><a href="#dom4j生成xml文件大致步骤" class="headerlink" title="dom4j生成xml文件大致步骤"></a>dom4j生成xml文件大致步骤</h2><ol>
<li>创建一个Document对象，表示生成一个xml文档</li>
<li>向Document中添加根标签元素</li>
<li>根据目标xml文档结构向根标签中添加子标签及内容，完成结构的创建</li>
<li>创建XMLWriter及输出流FileOutputStream</li>
<li>设置文件路径及文件名</li>
<li>使用XMLWriter将Document生成xml文档</li>
</ol>
<p>举例说明：</p>
<p><strong>生成XML文档类：CreateXmlFile</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateXmlFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createXmlFile</span><span class="params">(List&lt;Player&gt; playerList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建文件</span></span><br><span class="line">        Document document = DocumentHelper.createDocument();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 生成根标签元素</span></span><br><span class="line">            Element root = document.addElement(<span class="string">&quot;players&quot;</span>);</span><br><span class="line">            <span class="comment">// 添加子标签及其内容</span></span><br><span class="line">            <span class="keyword">for</span> (Player player : playerList) &#123;</span><br><span class="line">                Element element = root.addElement(<span class="string">&quot;player&quot;</span>);</span><br><span class="line">                <span class="comment">// 添加子子标签并设置内容</span></span><br><span class="line">                element.addAttribute(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;&quot;</span> + player.getId());</span><br><span class="line">                <span class="comment">// name</span></span><br><span class="line">                Element nameEle = element.addElement(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                nameEle.addText(player.getName());</span><br><span class="line">                <span class="comment">// number</span></span><br><span class="line">                Element numberEle = element.addElement(<span class="string">&quot;number&quot;</span>);</span><br><span class="line">                numberEle.addText(player.getNumber() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                <span class="comment">// gender</span></span><br><span class="line">                Element genderEle = element.addElement(<span class="string">&quot;gender&quot;</span>);</span><br><span class="line">                genderEle.addText(player.getGender());</span><br><span class="line">                <span class="comment">// salary</span></span><br><span class="line">                Element salaryEle = element.addElement(<span class="string">&quot;salary&quot;</span>);</span><br><span class="line">                salaryEle.addText(player.getSalary() + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 输出</span></span><br><span class="line">            XMLWriter writer = <span class="keyword">new</span> XMLWriter(OutputFormat.createPrettyPrint());</span><br><span class="line">            FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;F:/GitTool/repository/DougCoding/pratice/src/com/doug/wilson/dom4j/myPlayer.xml&quot;</span>);</span><br><span class="line">            writer.setOutputStream(outputStream);</span><br><span class="line">            writer.write(document);</span><br><span class="line">            writer.flush();</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException | FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Player&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Player(<span class="number">1</span>, <span class="string">&quot;康利&quot;</span>, <span class="number">33</span>, <span class="string">&quot;男&quot;</span>, <span class="number">1000000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Player(<span class="number">2</span>, <span class="string">&quot;戴维斯&quot;</span>, <span class="number">9</span>, <span class="string">&quot;男&quot;</span>, <span class="number">2000000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Player(<span class="number">3</span>, <span class="string">&quot;汤神&quot;</span>, <span class="number">11</span>, <span class="string">&quot;男&quot;</span>, <span class="number">3000000</span>));</span><br><span class="line"></span><br><span class="line">        createXmlFile(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：myPlayer.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">players</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">player</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>康利<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">number</span>&gt;</span>33<span class="tag">&lt;/<span class="name">number</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">salary</span>&gt;</span>1000000<span class="tag">&lt;/<span class="name">salary</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">player</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">player</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>戴维斯<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">number</span>&gt;</span>9<span class="tag">&lt;/<span class="name">number</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">salary</span>&gt;</span>2000000<span class="tag">&lt;/<span class="name">salary</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">player</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">player</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>汤神<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">number</span>&gt;</span>11<span class="tag">&lt;/<span class="name">number</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">salary</span>&gt;</span>3000000<span class="tag">&lt;/<span class="name">salary</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">player</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">players</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>dom4j</tag>
      </tags>
  </entry>
  <entry>
    <title>内容分布网络CDN</title>
    <url>/2020/02/05/%E5%86%85%E5%AE%B9%E5%88%86%E5%B8%83%E7%BD%91%E7%BB%9CCDN/</url>
    <content><![CDATA[<p>CDN，全称Content Delivery Network，内容分布网络，构筑在现有Internet上的一种流量分配网络。主要过程为：<strong>通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到离用户最近的的网络“边缘”，使用户可以就近取得所需内容，提高用户访问网站的响应速度</strong>。</p>
<span id="more"></span>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>CDN有别于镜像，它可以明显提高网络中信息流动的效率。相当于如下公式：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">CDN</span>=镜像+缓存+负载均衡</span><br></pre></td></tr></table></figure>

<p>目前CDN均以缓存网站中的静态数据为主，比如CSS/JS/图片/静态页面等数据。用户在从主站服务器请求到动态内容后，再从CDN上下载这些静态数据，从而加速网页数据内容的下载速度。</p>
<p>请求流程如下：</p>
<ol>
<li><p>基本的DNS解析流程完成后，LDNS向CND域名解析服务器发起请求</p>
</li>
<li><p>CND域名解析服务器将解析请求解析到另外一个域名，这个域名会最终指向CDN全局中的DNS负载均衡服务器，由该GTM(Global Traffic Manager全局流量管理)将离用户最近的CDN节点返回给LDNS，LDNS再将该CDN节点返回给用户主机</p>
</li>
<li><p>用户主机拿到该CDN节点后，就可以去这个CDN节点访问静态文件，如果用户请求的静态文件该CDN节点不存在，则会再到源站去获取这个文件，然后再返回给用户。</p>
<p><img src="/images/CDN%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B.png"></p>
</li>
</ol>
</blockquote>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><blockquote>
<p><strong>负载均衡(Load Balance)就是对工作任务进行平衡、分摊到多个操作单元上指向，如图片服务器、应用服务器等共同完成任务。</strong> <em>负载均衡可以提高服务器响应速度及利用效率，避免软件或硬件出现单点失效，解决网络拥塞问题。</em></p>
</blockquote>
<h3 id="链路负载均衡、集群负载均衡、操作系统负载均衡"><a href="#链路负载均衡、集群负载均衡、操作系统负载均衡" class="headerlink" title="链路负载均衡、集群负载均衡、操作系统负载均衡"></a>链路负载均衡、集群负载均衡、操作系统负载均衡</h3><h4 id="链路负载均衡"><a href="#链路负载均衡" class="headerlink" title="链路负载均衡"></a>链路负载均衡</h4><blockquote>
<p>链路负载均衡通过DNS解析成不同的IP，然后用户根据IP来访问不同的目标服务器。</p>
<p><img src="/images/%E9%93%BE%E8%B7%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png"></p>
<p>链路负载均衡其核心依然是DNS，在图中，该DNS服务器就是Global DNS Server。DNS解析的优点是用户可以直接访问目标服务器，而不需要经过其它代理服务器，一般而言，访问速度还不错。缺点是，当目标服务器挂掉，而用户的浏览器缓存或操作系统缓存还缓存有目标服务器的IP地址，那么在缓存时间内，用户将无法访问目标服务器的资源，即使挂掉的目标服务器在挂掉后更换了IP地址。</p>
</blockquote>
<h4 id="集群负载均衡"><a href="#集群负载均衡" class="headerlink" title="集群负载均衡"></a>集群负载均衡</h4><blockquote>
<p>目前最为常用的负载均衡手段。集群负载均衡一般还分为硬件负载均衡和软件负载均衡。</p>
<p>硬件负载均衡一般会有一台专门的硬件来转发请求。</p>
<p><img src="/images/%E7%A1%AC%E4%BB%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png"></p>
<p>软件负载均衡是通过软件处理，一次访问通过多次代理服务器，虽然成本比较低，但是网络时延是增加的。</p>
<p><img src="/images/%E8%BD%AF%E4%BB%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png"></p>
<p>LVS Linux Virtual Server 通过在网络层进行IP地址转发</p>
<p>HAProxy 用C语言编写的软件，根据访问用户的HTTP请求头来进行负载均衡，比如可以根据不同的URL来将请求转发到特定机器</p>
</blockquote>
<h4 id="操作系统负载均衡"><a href="#操作系统负载均衡" class="headerlink" title="操作系统负载均衡"></a>操作系统负载均衡</h4><blockquote>
<p>利用操作系统基本的软中断或者硬件中断来达到负载均衡</p>
</blockquote>
<h2 id="CDN动态加速"><a href="#CDN动态加速" class="headerlink" title="CDN动态加速"></a>CDN动态加速</h2><blockquote>
<p>在CDN的DNS解析中，动态地进行链路探测来寻找回源最好的一条路径，然后通过DNS调度将所有请求调度到选定的这条路径上进行回源，从而加速用户访问的效率。</p>
<p><img src="/images/CDN%E5%8A%A8%E6%80%81%E5%8A%A0%E9%80%9F.png"></p>
</blockquote>
]]></content>
      <tags>
        <tag>CND</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划探究及例题分析</title>
    <url>/2020/01/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%8E%A2%E7%A9%B6%E5%8F%8A%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>分治算法是将问题划分成一些独立的子问题，递归求解各子问题，然后合并子问题的解而得到原问题的解。这种情况很多，如自顶向下的归并排序，图的深度遍历等等。</p>
<p>动态规划与此不同，适用于子问题不是独立的情况，即子问题包含公共子问题。如果在这种情况下采用分治算法，则分治算法会做许多不必要的工作——重复求解公共子问题。而动态规划算法只对每个子子问题求解一次，将其结果存放到一张表中，避免每次遇到各个子问题时重新计算答案。</p>
<span id="more"></span>

<h2 id="动态规划算法的设计步骤总结"><a href="#动态规划算法的设计步骤总结" class="headerlink" title="动态规划算法的设计步骤总结"></a>动态规划算法的设计步骤总结</h2><blockquote>
<ol>
<li>描述最优解的结构</li>
<li>递归定义最优解的值</li>
<li>按自底向上的方式计算最优解的值(非递归，通常为循环)</li>
<li>由计算出的结果构造一个最优解</li>
</ol>
</blockquote>
<h4 id="参考例题：算法导论——装配最短时间计算"><a href="#参考例题：算法导论——装配最短时间计算" class="headerlink" title="参考例题：算法导论——装配最短时间计算"></a>参考例题：算法导论——装配最短时间计算</h4><blockquote>
<p>问题描述：</p>
<p>某工厂内有两条装配产品的流水线：</p>
<p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%97%AE%E9%A2%98.png"></p>
<p>如果产品只在一条流水线上工作，则装配时间为：<br>$$<br>\sum_{i=1}^{n}a_{1i}+e_{1}+x_{1} 或 \sum_{i=1}^{n}a_{2i}+e_{2}+x_{2}<br>$$<br>如果从一条装配线的一个装配站<strong>i</strong>移动到另一个装配线<strong>i+1</strong>则需要加上额外的移动时间：<br>$$<br>t_{1i} 或t_{2i}<br>$$<br> 求产品装配的最短时间</p>
</blockquote>
<h4 id="按照求解步骤求解："><a href="#按照求解步骤求解：" class="headerlink" title="按照求解步骤求解："></a>按照求解步骤求解：</h4><h5 id="1-描述最优解的结构"><a href="#1-描述最优解的结构" class="headerlink" title="1 描述最优解的结构"></a>1 描述最优解的结构</h5><blockquote>
<p><img src="/images/%E6%8F%8F%E8%BF%B0%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%9C%80%E4%BC%98%E8%A7%A3%E7%BB%93%E6%9E%84.png"></p>
<p>假设目前要通过的装配站为S1j ，那么最快的路线只能是以下情况：</p>
<ol>
<li>通过了S1j-1装配站，然后直接到S1j装配站</li>
<li>通过了S2j-1装配站，然后花费t2j-1时间到S1j</li>
</ol>
<p>同理，如果通过的装配站为S2j，那么最快的路线只能是以下情况：</p>
<ol>
<li>通过了S2j-1装配站，然后直接到S2j装配站</li>
<li>通过了S1j-1装配站，然后花费时间t1j-1时间到S2j</li>
</ol>
</blockquote>
<h5 id="2-递归定义最优解的值"><a href="#2-递归定义最优解的值" class="headerlink" title="2 递归定义最优解的值"></a>2 递归定义最优解的值</h5><blockquote>
<p>由第一步可知，最优解可以由如下公式代替：<br>$$<br>f_{1}(n)=min(f_{1}(n-1), {f_{2}(n-1)+t_{2}(n-1)})+a_{1n} \<br>f_{2}(n)=min(f_{2}(n-1), {f_{1}(n-1)+t_{1}(n-1)})+a_{2n} \<br>f_{min}=min(f_{1}(n)+x_{1},f_{2}(n)+x_{2})\<br>考虑条件后，可以得到：\<br>f_{1}(j)=\left{\begin{matrix}<br>e_{1}+a_{11} \quad\quad  j=1\<br>min(f_{1}(j-1)+a_{1j},\quad f_{2}(j-1)+t_{2j-1}+a_{1j}) \quad j&gt;=2<br>\end{matrix}\right.  \<br>f_{2}(j)=\left{\begin{matrix}<br>e_{2}+a_{21} \quad\quad  j=1\<br>min(f_{2}(j-1)+a_{2j},\quad f_{1}(j-1)+t_{1j-1}+a_{2j}) \quad j&gt;=2<br>\end{matrix}\right. \<br>f_{min}=min(f_{1}(n)+x_{1},\quad f_{2}(n)+x_{2}) \quad 即最优解方程组<br>$$</p>
</blockquote>
<h5 id="3-将递归定义转化为从自底向上计算最优解的值"><a href="#3-将递归定义转化为从自底向上计算最优解的值" class="headerlink" title="3 将递归定义转化为从自底向上计算最优解的值"></a>3 将递归定义转化为从自底向上计算最优解的值</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算e1+a11和e2+a21的值，将值存入fmin，并记录</span></span><br><span class="line"><span class="comment">//定义标识符flag，flag为true时表示当前装配在流水线1，flag为false表示当前装配在流水线2  </span></span><br><span class="line"><span class="comment">//循环直到最后一个装配站</span></span><br><span class="line"><span class="comment">//当前装配站为i，</span></span><br><span class="line"><span class="comment">//计算fmin+ati和fmin+tti-1+afi的大小并比较哪一个时间较少</span></span><br><span class="line"><span class="comment">//记录并将值存入fmin</span></span><br><span class="line"><span class="comment">//如此，直到循环结束</span></span><br></pre></td></tr></table></figure>

<h5 id="4-计算最优解"><a href="#4-计算最优解" class="headerlink" title="4 计算最优解"></a>4 计算最优解</h5><blockquote>
<p>将第三步的伪代码转化成代码运行，并测试</p>
</blockquote>
]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>在js中对后台传送的时间进行格式化</title>
    <url>/2021/05/25/%E5%9C%A8js%E4%B8%AD%E5%AF%B9%E5%90%8E%E5%8F%B0%E4%BC%A0%E9%80%81%E7%9A%84%E6%97%B6%E9%97%B4%E8%BF%9B%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<span id="more"></span>

<p>最近在前端显示时间的时候，发现后台传送的时间格式要么是：1861447200000，或者是：Tue Apr 18 2020 10:39:23 。但是这往往不是想要的时间格式，js中也没有类似于java的SimpleDareFormat()函数，因此，自己写了一个js的function进行时间格式的转换：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">调用方式：</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().Format(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Date</span>.prototype.Format = <span class="function"><span class="keyword">function</span>(<span class="params">fmt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dateVar = &#123;</span><br><span class="line">        <span class="string">&quot;M+&quot;</span>: <span class="built_in">this</span>.getMonth() + <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;d+&quot;</span>: <span class="built_in">this</span>.getDate(),</span><br><span class="line">        <span class="string">&quot;h+&quot;</span>: <span class="built_in">this</span>.getHours(),</span><br><span class="line">        <span class="string">&quot;m+&quot;</span>: <span class="built_in">this</span>.getMinutes(),</span><br><span class="line">        <span class="string">&quot;s+&quot;</span>: <span class="built_in">this</span>.getSeconds(),</span><br><span class="line">        <span class="string">&quot;q+&quot;</span>: <span class="built_in">Math</span>.floor((<span class="built_in">this</span>.getMonth() + <span class="number">3</span>) / <span class="number">3</span>),</span><br><span class="line">        <span class="string">&quot;S&quot;</span>： <span class="built_in">this</span>.getMilliseconds()</span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="keyword">if</span> (<span class="regexp">/(y+)/</span>.test(fmt)) &#123;</span><br><span class="line">        fmt = fmt.replace(<span class="built_in">RegExp</span>.$1, (<span class="built_in">this</span>.getFullYear() + <span class="string">&quot;&quot;</span>)</span><br><span class="line">                          .substr(<span class="number">4</span> - <span class="built_in">RegExp</span>.$1.length));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> dateVar)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;(&quot;</span> + k + <span class="string">&quot;)&quot;</span>).test(fmt))&#123;</span><br><span class="line">            fmt = fmt.replace(<span class="built_in">RegExp</span>.$1, (<span class="built_in">RegExp</span>.$1.length == <span class="number">1</span>) ?</span><br><span class="line">             (dateVar[k]) : ((<span class="string">&quot;00&quot;</span> + dateVar[k]).substr((<span class="string">&quot;&quot;</span> + dateVar[k]).length)));</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>时间格式化</tag>
      </tags>
  </entry>
  <entry>
    <title>对java文件File类的操作</title>
    <url>/2020/04/25/%E5%AF%B9java%E6%96%87%E4%BB%B6File%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><code>java.io.File</code> 的每一个实例用于表示硬盘上的一个文件或者目录，通过File，我们可以进行如下操作：</p>
<ol>
<li>访问一个文件或目录的属性信息，文件名，大小，修改日期，访问权限</li>
<li>创建文件，删除文件，创建目录，删除目录</li>
<li>访问目录中的文件或者子目录</li>
<li>不可以访问文件的数据，这点要特别注意。只能通过IO来访问文件数据</li>
</ol>
<span id="more"></span>

<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">baseFileOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     File file = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>+File.separator+<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//获取文件名</span></span><br><span class="line">        String name = file.getName();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取文件大小。返回值为一个long值，表示占用的字节量</span></span><br><span class="line"><span class="comment">         * 中文以及中文状态下的标点符号都占用两个字节</span></span><br><span class="line"><span class="comment">         * 英文及英文状态下的标点符号占用一个字节</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> length = file.length();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取文件最后修改时间</span></span><br><span class="line">        <span class="keyword">long</span> time = file.lastModified();</span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 查看文件是否具有可运行，可读，可写的权限</span></span><br><span class="line">        file.canExecute();</span><br><span class="line">        file.canRead();</span><br><span class="line">        file.canWrite();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断当前File对象表示的是否为一个文件</span></span><br><span class="line">        <span class="keyword">boolean</span> isFile = file.isFile();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断当前File对象表示的是否为一个目录</span></span><br><span class="line">        <span class="keyword">boolean</span> isDir = file.isDirectory();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//是否为一个隐藏文件</span></span><br><span class="line">        <span class="keyword">boolean</span> isHidden = file.isHidden());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 在当前目录下创建一个文件demo.txt </span></span><br><span class="line">     File file = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>+File.separator+<span class="string">&quot;demo.txt&quot;</span>);</span><br><span class="line">   	 <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">         file.createNewFile();</span><br><span class="line">         System.out.println(<span class="string">&quot;创建完毕!&quot;</span>);	</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     File file = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>+File.separator+<span class="string">&quot;demo.txt&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">         file.delete();</span><br><span class="line">         System.out.println(<span class="string">&quot;删除完毕!&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 当前目录下创建一个目录demo</span></span><br><span class="line">     File dir = <span class="keyword">new</span> File(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span>(!dir.exists())&#123;</span><br><span class="line">         <span class="comment">// 创建目录</span></span><br><span class="line">         dir.mkdir();</span><br><span class="line">         System.out.println(<span class="string">&quot;创建完毕!&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建多级目录"><a href="#创建多级目录" class="headerlink" title="创建多级目录"></a>创建多级目录</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createMultipleDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在当前目录下创建目录a/b/c/d/e/f</span></span><br><span class="line">    File dir = <span class="keyword">new</span> File(</span><br><span class="line">    	<span class="string">&quot;a&quot;</span>+File.separator +</span><br><span class="line">    	<span class="string">&quot;b&quot;</span>+File.separator +</span><br><span class="line">    	<span class="string">&quot;c&quot;</span>+File.separator +</span><br><span class="line">    	<span class="string">&quot;d&quot;</span>+File.separator +</span><br><span class="line">    	<span class="string">&quot;e&quot;</span>+File.separator +</span><br><span class="line">    	<span class="string">&quot;f&quot;</span></span><br><span class="line">    );	</span><br><span class="line">    <span class="keyword">if</span>(!dir.exists())&#123;</span><br><span class="line">    	 <span class="comment">// mkdirs方法在创建当前目录的同时会将所有不存在的父目录</span></span><br><span class="line">    	 <span class="comment">// 自动创建出来。</span></span><br><span class="line">    	dir.mkdirs();</span><br><span class="line">    	System.out.println(<span class="string">&quot;创建完毕！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除目录（只能删除空目录）"><a href="#删除目录（只能删除空目录）" class="headerlink" title="删除目录（只能删除空目录）"></a>删除目录（只能删除空目录）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File dir = <span class="keyword">new</span> File(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(dir.exists())&#123;</span><br><span class="line">        <span class="comment">// 删除目录，只能删除空目录，即: 目录中不能含有任何子项。</span></span><br><span class="line">        dir.delete();</span><br><span class="line">        System.out.println(<span class="string">&quot;删除完毕!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取一个目录下的所有子项"><a href="#获取一个目录下的所有子项" class="headerlink" title="获取一个目录下的所有子项"></a>获取一个目录下的所有子项</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getSubitem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     File dir = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">     File[] subs = dir.listFiles();</span><br><span class="line">     <span class="keyword">for</span>(File sub : subs)&#123;</span><br><span class="line">        System.out.println((sub.isFile() ? <span class="string">&quot;文件:&quot;</span> : <span class="string">&quot;目录:&quot;</span>) + sub.getName());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取一个目录下符合条件的子项（文件过滤器）"><a href="#获取一个目录下符合条件的子项（文件过滤器）" class="headerlink" title="获取一个目录下符合条件的子项（文件过滤器）"></a>获取一个目录下符合条件的子项（文件过滤器）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getSubitemOnCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取当前目录下所有名字是以&quot;.&quot;开头的子项</span></span><br><span class="line"><span class="comment">         * 使用匿名内部类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        FileFilter filter = <span class="keyword">new</span> FileFilter()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">                String name = file.getName();</span><br><span class="line">                System.out.println(<span class="string">&quot;正在过滤:&quot;</span>+name);</span><br><span class="line">                <span class="keyword">return</span> name.startsWith(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 该重载的listFiles方法会将当前目录中的每</span></span><br><span class="line"><span class="comment">         * 一个子项都交给过滤器，然后只保留满足过滤器</span></span><br><span class="line"><span class="comment">         * 要求(为true)的子项</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        File[] subs = dir.listFiles(filter);</span><br><span class="line">        <span class="keyword">for</span>(File sub : subs)&#123;</span><br><span class="line">            System.out.println(sub.getName());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">正在过滤:.classpath</span></span><br><span class="line"><span class="section">正在过滤:.project</span></span><br><span class="line"><span class="section">正在过滤:.settings</span></span><br><span class="line"><span class="section">正在过滤:a</span></span><br><span class="line"><span class="section">正在过滤:build</span></span><br><span class="line"><span class="section">正在过滤:src</span></span><br><span class="line"><span class="section">正在过滤:test.txt</span></span><br><span class="line"><span class="section">正在过滤:WebContent</span></span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br></pre></td></tr></table></figure>

<h3 id="删除含有子项的目录"><a href="#删除含有子项的目录" class="headerlink" title="删除含有子项的目录"></a>删除含有子项的目录</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteDirHasSubitem</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">         <span class="comment">//先将其所有子项删除</span></span><br><span class="line">         File[] subs = file.listFiles();</span><br><span class="line">         <span class="keyword">for</span>(File sub:subs)&#123;</span><br><span class="line">             <span class="comment">//递归</span></span><br><span class="line">             deleteFile(sub);</span><br><span class="line">         &#125;			</span><br><span class="line">     &#125;</span><br><span class="line">     file.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   	 RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;demo.dat&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * int read()</span></span><br><span class="line"><span class="comment">      * 读取一个字节，并以int(低八位)形式返回</span></span><br><span class="line"><span class="comment">      * 若读取到文件末尾则返回值为-1</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">int</span> d = raf.read();</span><br><span class="line">     System.out.println(d); <span class="comment">// 27</span></span><br><span class="line">     raf.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   	 <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * RandomAccessFile创建支持很多模式</span></span><br><span class="line"><span class="comment">     * 常用的有:</span></span><br><span class="line"><span class="comment">     * &quot;r&quot;:只读</span></span><br><span class="line"><span class="comment">     * &quot;rw&quot;:读写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     RandomAccessFile raf= <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;demo.dat&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * void write(int d)</span></span><br><span class="line"><span class="comment">     * 向文件中写入一个字节，写的是该int值对应的2进制内容中的&quot;低八位&quot;,</span></span><br><span class="line"><span class="comment">     * 范围255</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     raf.write(<span class="number">27</span>);</span><br><span class="line">     raf.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="批量读写文件"><a href="#批量读写文件" class="headerlink" title="批量读写文件"></a>批量读写文件</h3><p>批量读取： <code>int read(byte[] data)</code> 一次性读取给定字节数组长度的字节量，并存入数组中，返回值为实际读取到的字节数，如果返回值为-1，则表示没有读到任何数据，到文件末尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readBath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;demo.dat&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> len = raf.read(data);<span class="comment">//每次read的长度，不写默认为1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;读到了&quot;</span>+len+<span class="string">&quot;个字节&quot;</span>);<span class="comment">//读到了22个字节</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 该构造方法允许我们将给定的字节数组</span></span><br><span class="line"><span class="comment">    * 中指定范围内的字节转换为对应的字符串</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    String str = <span class="keyword">new</span> String(data,<span class="number">0</span>,len,<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    System.out.println(str);<span class="comment">//摩擦摩擦，是魔鬼的步伐</span></span><br><span class="line">    raf.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>批量写入： <code>void write(byte[] data)</code> 批量写出字节，一次性将给定字节数组中的所有字节写出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeBatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;demo.dat&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">     String str = <span class="string">&quot;摩擦摩擦，是魔鬼的步伐&quot;</span>;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * byte[] getBytes()</span></span><br><span class="line"><span class="comment">      * String提供的该方法可以将当前字符串</span></span><br><span class="line"><span class="comment">      * 按照系统默认的字符集转换为对应的一组字节</span></span><br><span class="line"><span class="comment">      * </span></span><br><span class="line"><span class="comment">      * byte[] getBytes(String charset)</span></span><br><span class="line"><span class="comment">      * 按照给定的字符集将字符串转换为一组字节</span></span><br><span class="line"><span class="comment">      * 字符集名称:</span></span><br><span class="line"><span class="comment">      * GBK:国标编码  中文2字节</span></span><br><span class="line"><span class="comment">      * UTF-8:变长编码集，1-4个字节，中文3字节</span></span><br><span class="line"><span class="comment">      * ISO8859-1:欧洲编码，不支持中文</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">byte</span>[] data = str.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">     raf.write(data);</span><br><span class="line">     System.out.println(<span class="string">&quot;写出完毕&quot;</span>);</span><br><span class="line">     raf.close();	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>File类</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习CAS</title>
    <url>/2020/08/26/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0CAS/</url>
    <content><![CDATA[<p>CAS是Compare-And-Swap的缩写，意思为比较并交换。以AtomicInteger为例，其提供了<code>compareAndSet(int expect, int update)</code>方法，<code>expect</code>为期望值（被修改的值在主内存中的期望值），<code>update</code>为修改后的值。<code>compareAndSet</code>方法返回值类型为布尔类型，修改成功则返回true，修改失败返回false。</p>
<span id="more"></span>

<p>举个<code>compareAndSet</code>方法的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomticIntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> result = atomicInteger.compareAndSet(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中，通过<code>AtomicInteger(int initialValue)</code>构造方法指定了<code>AtomicInteger</code>类成员变量<code>value</code>的初始值为0：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicInteger with the given initial value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">(<span class="keyword">int</span> initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着执行<code>compareAndSet</code>方法，main线程从主内存中拷贝了<code>value</code>的副本到工作线程，值为0，并将这个值修改为1。如果此时主内存中value的值还是为0的话（言外之意就是没有被其他线程修改过），则将修改后的副本值刷回主内存更新value的值。所以上面的例子运行结果应该是true和1：</p>
<p><img src="/images/AtomicInteger%E7%BB%93%E6%9E%9C.png"></p>
<p>将上面的例子修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomticIntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> firstResult = atomicInteger.compareAndSet(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">boolean</span> secondResult = atomicInteger.compareAndSet(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(firstResult);</span><br><span class="line">        System.out.println(secondResult);</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中，main线程第二次调用<code>compareAndSet</code>方法的时候，value的值已经被修改为1了，不符合其expect的值，所以修改将失败。上面例子输出如下：</p>
<p><img src="/images/AtomicInteger%E7%BB%93%E6%9E%9C1.png"></p>
<h2 id="CAS底层原理"><a href="#CAS底层原理" class="headerlink" title="CAS底层原理"></a>CAS底层原理</h2><p>查看<code>compareAndSet</code>方法源码：</p>
<p><img src="/images/compareAndSet%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81.png"></p>
<ol>
<li><p><code>this</code>，当前对象；</p>
</li>
<li><p><code>valueOffset</code>，<code>value</code>成员变量的内存偏移量（也就是内存地址）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>expect</code>，期待值；</p>
</li>
<li><p><code>update</code>，更新值。</p>
</li>
</ol>
<p>所以这个方法的含义为：获取当前对象<code>value</code>成员变量在主内存中的值，和传入的期待值相比，如果相等则说明这个值没有被别的线程修改过，然后将其修改为更新值。</p>
<p>那么<code>unsafe</code>又是什么？它的<code>compareAndSwapInt</code>方法是原子性的么？查看该方法的源码：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法并没有具体Java代码实现，方法通过<code>native</code>关键字修饰。由于Java方法无法直接访问底层系统，<code>Unsafe</code>类相当于一个后门，可以通过该类的方法直接操作特定内存的数据。<code>Unsafe</code>类存在于<code>sun.msic</code>包中，JVM会帮我们实现出相应的<strong>汇编指令</strong>。<code>Unsafe</code>类中的CAS方法是一条CPU并发原语，由若干条指令组成，用于完成某个功能的一个过程。<strong>原语的执行必须是连续的，在执行过程中不允许被中断，不会存在数据不一致的问题</strong>。</p>
<h2 id="getAndIncrement方法剖析"><a href="#getAndIncrement方法剖析" class="headerlink" title="getAndIncrement方法剖析"></a>getAndIncrement方法剖析</h2><p>了解了CAS原理后，我们回头看下<code>AtomicInteger</code>的<code>getAndIncrement</code>方法源码：</p>
<p><img src="/images/getAndIncrement%E6%BA%90%E7%A0%811.png"></p>
<p>该方法通过调用<code>unsafe</code>类的<code>getAndAddInt</code>方法实现相关功能。继续查看<code>getAndAddInt</code>方法的源码：</p>
<p><img src="/images/getAndIncrement%E6%BA%90%E7%A0%812.png"></p>
<p>结合这两张图，我们便可以很直观地看出为什么<code>AtomicInteger</code>的<code>getAndIncrement</code>方法是线程安全的了：</p>
<p>上图中，<code>var1</code>是<code>AtomicInteger</code>对象本身；<code>var2</code>是<code>AtomicInteger</code>对象的成员变量<code>value</code>的内存地址；<code>var4</code>是需要变更的数量；<code>var5</code>是通过<code>unsafe</code>的<code>getIntVolatile</code>方法获得<code>AtomicInteger</code>对象的成员变量<code>value</code>在主内存中的值。do while循环中的逻辑为：用当前对象的值和<code>var5</code>比较，如果相同，说明该值没有被别的线程修改过，更新为<code>var5+var4</code>，并返回true（CAS）；否则继续获取值并比较，直到更新完成。</p>
<h2 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h2><p>CAS并不是完美的，其存在以下这些缺点：</p>
<ol>
<li>如果刚好while里的CAS操作一直不成功，那么对CPU的开销大；</li>
<li>只能确保一个共享变量的原子操作；</li>
<li>存在ABA问题。</li>
</ol>
<p>CAS实现的一个重要前提是需要取出某一时刻的数据并在当下时刻比较交换，这之间的时间差会导致数据的变化。比如：thread1线程从主内存中取出了变量a的值为A，thread2页从主内存中取出了变量a的值为A。由于线程调度的不确定性，这时候thread1可能被短暂挂起了，thread2进行了一些操作将值修改为了B，然后又进行了一些操作将值修改回了A，这时候当thread1重新获取CPU时间片重新执行CAS操作时，会发现变量a在主内存中的值仍然是A，所以CAS操作成功。</p>
<h2 id="解决CAS的ABA问题"><a href="#解决CAS的ABA问题" class="headerlink" title="解决CAS的ABA问题"></a>解决CAS的ABA问题</h2><p>那么如何解决CAS的ABA问题呢？由上面的阐述课件，光通过判断值是否相等并不能确保在一定时间差内值没有变更过，所以我们需要一个额外的指标来辅助判断，类似于时间戳，版本号等。</p>
<p>JUC为我们提供了一个<code>AtomicStampedReference</code>类，通过查看它的构造方法就可以看出，除了指定初始值外，还需指定一个版本号（戳）：</p>
<p><img src="/images/ABA%E9%97%AE%E9%A2%98%E7%89%88%E6%9C%AC%E5%8F%B7.png"></p>
<p>我们就用这个类来解决ABA问题，首先模拟一个ABA问题场景：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomticIntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AtomicReference&lt;String&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟一次ABA操作</span></span><br><span class="line">            atomicReference.compareAndSet(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程完成了一次ABA操作&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 让thread2先睡眠2秒钟，确保thread1的ABA操作完成</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> result = atomicReference.compareAndSet(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程修改值成功，当前值为：&quot;</span> + atomicReference.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，输出如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">thread1线程完成了一次ABA操作</span><br><span class="line">thread2线程修改值成功，当前值为：<span class="selector-tag">B</span></span><br></pre></td></tr></table></figure>

<p>使用<code>AtomicStampedReference</code>解决ABA问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomticIntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始值为A，版本号为1</span></span><br><span class="line">        AtomicStampedReference&lt;String&gt; reference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="string">&quot;A&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = reference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;当前版本号为：&quot;</span> + stamp);</span><br><span class="line">            <span class="comment">// 休眠1秒，让thread2也拿到初始的版本号</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟一次ABA操作</span></span><br><span class="line">            reference.compareAndSet(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, reference.getStamp(), reference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            reference.compareAndSet(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>, reference.getStamp(), reference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程完成了一次ABA操作&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = reference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;当前版本号为：&quot;</span> + stamp);</span><br><span class="line">            <span class="comment">// 让thread2先睡眠2秒钟，确保thread1的ABA操作完成</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> result = reference.compareAndSet(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程修改值成功，当前值为：&quot;</span> + reference.getReference());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程修改值失败，当前值为：&quot;</span> + reference.getReference() + <span class="string">&quot;，版本号为：&quot;</span> + reference.getStamp());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下：</p>
<p><img src="/images/ABA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%952.png"></p>
]]></content>
      <tags>
        <tag>cas</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习Spring Bean的生命周期</title>
    <url>/2020/05/19/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>前面有稍微了解一下Spring Bean的生命周期的大致流程，知道Spring Bean的生命周期是指Bean从创建到初始化再到销毁的过程，这个过程由IOC容器管理。</p>
<span id="more"></span>

<h2 id="Bean的初始化和销毁"><a href="#Bean的初始化和销毁" class="headerlink" title="Bean的初始化和销毁"></a>Bean的初始化和销毁</h2><p>在整个生命周期过程中，我们可以自定义Bean的初始化和销毁钩子函数，当Bean的生命周期到达相应的阶段的时候，Spring会调用我们自定义的Bean的初始化和销毁方法。自定义Bean初始化和销毁方法有多种方式，下面逐一介绍。</p>
<h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><p>在配置类中通过<code>@Bean</code>注解来注册Bean，我们也可以通过它来指定Bean的初始化和方法。下面举个例子说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用无参构造器创建User&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化User&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;销毁User&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>initMethod = &quot;init&quot;</code>和<code>destroyMethod = &quot;destory&quot;</code>与User类里的<code>init</code>，<code>destory</code>方法相对应。测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 IOC 容器，使用注解配置，传入配置类</span></span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">System.out.println(<span class="string">&quot;容器创建完毕&quot;</span>);</span><br><span class="line">User user = context.getBean(User.class);</span><br><span class="line"><span class="comment">// 关闭 IOC 容器</span></span><br><span class="line">context.close();</span><br></pre></td></tr></table></figure>

<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">控制台输出：</span><br><span class="line">调用无参构造器创建<span class="keyword">User</span></span><br><span class="line"><span class="title">初始化User</span></span><br><span class="line">容器创建完毕</span><br><span class="line">销毁User</span><br></pre></td></tr></table></figure>

<p>从上面的输出我们看出在容器启动之前，先调用对象的无参构造器创建对象，然后调用初始化方法，在容器关闭的时候调用销毁方法。</p>
<p>上面的情况是对于单例而言的，如果组件是多例模式又是什么情况呢？我们把上面的组件注册配置改为多例，然后再次启动项目，观察控制台：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">容器创建完毕</span><br><span class="line">调用无参构造器创建<span class="keyword">User</span></span><br><span class="line"><span class="title">初始化User</span></span><br></pre></td></tr></table></figure>

<p>可见，在多例模式下，IOC容器启动的时候并不会去创建对象，而是在每次获取的时候才会去调用方法创建对象，创建完对象后再调用初始化方法。但在容器关闭后，Spring并没有调用相应的销毁方法，这是因为在多例模式下，容器不会管理这个组件（只负责在你需要的时候创建这个组件），所以容器在关闭的时候并不会调用相应的销毁方法。</p>
<h3 id="InitializingBean-amp-DisposableBean"><a href="#InitializingBean-amp-DisposableBean" class="headerlink" title="InitializingBean&amp;DisposableBean"></a>InitializingBean&amp;DisposableBean</h3><p>除了上面这种方式指定初始化和销毁方法外，Spring还为我们提供了和初始化，销毁相对应的接口：</p>
<ul>
<li><code>InitializingBean</code>接口包含一个<code>afterPropertiesSet</code>方法，我们可以通过实现该接口，然后在这个方法中编写初始化逻辑。</li>
<li><code>DisposableBean</code>接口包含一个<code>destory</code>方法，我们可以通过实现该接口，然后再这个方法中编写销毁逻辑。</li>
</ul>
<p>重写之前的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用无参构造器创建User&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;销毁User&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化User&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 IOC 容器，使用注解配置，传入配置类</span></span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">System.out.println(<span class="string">&quot;容器创建完毕&quot;</span>);</span><br><span class="line">User user = context.getBean(User.class);</span><br><span class="line"><span class="comment">// 关闭 IOC 容器</span></span><br><span class="line">context.close();</span><br></pre></td></tr></table></figure>

<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">调用无参构造器创建Use</span><br><span class="line">初始化<span class="keyword">User</span></span><br><span class="line"><span class="title">容器创建完毕</span></span><br><span class="line"><span class="title">销毁User</span></span><br></pre></td></tr></table></figure>

<h3 id="PostConstrict-amp-PreDestroy"><a href="#PostConstrict-amp-PreDestroy" class="headerlink" title="@PostConstrict&amp;@PreDestroy"></a>@PostConstrict&amp;@PreDestroy</h3><p>除了上面两种指定初始化和销毁方法的方式外，我们还可以使用<code>@PostConstruct</code>和<code>@PreDestroy</code>注解修饰方法来指定相应的初始化和销毁方法。</p>
<p>依然重写之前的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用无参构造器创建User&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化User&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;销毁User&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 IOC 容器，使用注解配置，传入配置类</span></span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">System.out.println(<span class="string">&quot;容器创建完毕&quot;</span>);</span><br><span class="line">User user = context.getBean(User.class);</span><br><span class="line"><span class="comment">// 关闭 IOC 容器</span></span><br><span class="line">context.close();</span><br></pre></td></tr></table></figure>

<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">调用无参构造器创建Use</span><br><span class="line">初始化<span class="keyword">User</span></span><br><span class="line"><span class="title">容器创建完毕</span></span><br><span class="line"><span class="title">销毁User</span></span><br></pre></td></tr></table></figure>

<p>和之前的结果一致</p>
<h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>Spring提供了一个<code>BeanPostProcessor</code>接口，俗称<strong>Bean后置通知处理器</strong>，它提供了两个方法<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>。其中<code>postProcessBeforeInitialization</code>在组件的初始化方法调用之前执行，<code>postProcessAfterInitialization</code>在组件的初始化方法调用之后执行。它们都包含两个方法参数：</p>
<ol>
<li>bean：当前组件对象</li>
<li>beanName：当前组件在容器中的名称</li>
</ol>
<p>两个方法都返回一个Object类型，我们可以直接返回当前组件对象，或者包装后返回。</p>
<p>定义一个<code>BeanPostProcessor</code>接口的实现类<code>MyBeanPostProcessor</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(beanName + <span class="string">&quot; 初始化之前调用&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(beanName + <span class="string">&quot; 初始化之后调用&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在配置类中注册组件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyBeanPostProcessor <span class="title">myBeanPostProcessor</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyBeanPostProcessor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<p><img src="/images/%E8%87%AA%E5%AE%9A%E4%B9%89BeanPostProcessor.png"></p>
]]></content>
      <tags>
        <tag>spring, bean, 生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习Spring Bean组件注册</title>
    <url>/2020/05/20/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Spring-Bean%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<p>在传统的Java编程中，当需要用到某个对象的时候，我们都是主动显式创建一个对象实例（new）。使用Spring后就不需要这样做了，因为Spring会帮我们在需要用到某些对象的地方自动注入该对象，而无须我们自己去创建。这种模式俗称控制反转，即IOC（Inversion of Control）。那么Spring是从什么地方获取到我们所需要的对象呢？其实Spring给我们提供了一个IOC容器，里面管理着所有我们需要的对象，组件注册就是我们去告诉Spring哪些类需要交给IOC容器管理。</p>
<span id="more"></span>

<h2 id="通过-Bean注册组件"><a href="#通过-Bean注册组件" class="headerlink" title="通过@Bean注册组件"></a>通过@Bean注册组件</h2><p>创建一个User类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">// 省略构造器和getter, setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个配置类，通过@Bean注册User类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;DougWilson&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>@Bean</code>注解，我们向IOC容器注册了一个名称为<code>user</code>（Bean名称默认为方法名，我们也可以通过<code>@Bean(&quot;myUser&quot;)</code>方式来将组件名称指定为<code>myUser</code>）。下面进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 IOC 容器，使用注解配置，传入配置类</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">User user = context.getBean(User.class);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">User(<span class="attribute">name</span>=DougWilson, <span class="attribute">age</span>=18)</span><br></pre></td></tr></table></figure>

<h2 id="使用-ComponentScan扫描"><a href="#使用-ComponentScan扫描" class="headerlink" title="使用@ComponentScan扫描"></a>使用@ComponentScan扫描</h2><p>在使用XML配置组件扫描的时候，我们都是这样配置的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中<code>base-package</code>指定了扫描的路径。路径下所有被<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>和<code>@Component</code>注解标注的类都会被纳入IOC容器中。</p>
<p>现在我们脱离XML配置后，可以使用<code>@ComponentScan</code>注解来扫描组件并注册。通过举例子来说明：创建一个Controller，一个Service，一个Dao，并标注上相应的注解，然后创建一个配置类，配置类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.dougWilson.demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line"><span class="comment">// 查看基于注解的 IOC容器中所有组件名称</span></span><br><span class="line">String[] beanNames = context.getBeanDefinitionNames();</span><br><span class="line">Arrays.stream(beanNames).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">WebConfig</span><br><span class="line"><span class="keyword">user</span>Controller</span><br><span class="line"><span class="keyword">user</span>Mapper</span><br><span class="line"><span class="keyword">user</span></span><br><span class="line"><span class="keyword">user</span>Service</span><br></pre></td></tr></table></figure>

<p>可见，组件已经成功被扫描进去了，并且名称默认为类名首字母小写。</p>
<h3 id="指定扫描策略"><a href="#指定扫描策略" class="headerlink" title="指定扫描策略"></a>指定扫描策略</h3><p><code>@ComponentScan</code>注解允许我们指定扫描策略，即指定哪些被扫描，哪些不被扫描，查看其源码可发现这两个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specifies which types are eligible for component scanning.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Further narrows the set of candidate components from everything in &#123;<span class="doctag">@link</span> #basePackages&#125;</span></span><br><span class="line"><span class="comment"> * to everything in the base packages that matches the given filter or filters.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that these filters will be applied in addition to the default filters, if specified.</span></span><br><span class="line"><span class="comment"> * Any type under the specified base packages which matches a given filter will be included,</span></span><br><span class="line"><span class="comment"> * even if it does not match the default filters (i.e. is not annotated with &#123;<span class="doctag">@code</span> <span class="doctag">@Component</span>&#125;).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #resourcePattern()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #useDefaultFilters()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Filter[] includeFilters() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specifies which types are not eligible for component scanning.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #resourcePattern</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Filter[] excludeFilters() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>而Filter则是一个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> Filter &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">FilterType <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> FilterType.ANNOTATION</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;classes&quot;)</span></span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    Class&lt;?&gt;[] classes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] pattern() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据名称的含义可知：excludeFilters是用于指定排除扫描的规则，includeFilters则是用于定义扫描的规则。</p>
<p>常用的排除扫描规则有两种：</p>
<ol>
<li>根据注解来排除（<code>type = FilterType.ANNOTATION</code>）。比如，注解的类型为<code>classes = &#123;Controller.class, Repository.class&#125;</code>。即<code>Controller</code>和<code>Repository</code>注解标注的类不再被纳入到IOC容器中。</li>
<li>根据指定类型类排除（<code>type = FilterType.ASSIGNABLE_TYPE</code>），排除类型为对应类、其子类，实现类都会被排除。</li>
</ol>
<p>比如将这些排除规则加入前面例子的扫描策略中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;cc.mrbird.demo&quot;,</span></span><br><span class="line"><span class="meta">        excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">                @Filter(type = FilterType.ANNOTATION,</span></span><br><span class="line"><span class="meta">                        classes = &#123;Controller.class, Repository.class&#125;),</span></span><br><span class="line"><span class="meta">                @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = User.class)</span></span><br><span class="line"><span class="meta">        &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义扫描策略配置"><a href="#自定义扫描策略配置" class="headerlink" title="自定义扫描策略配置"></a>自定义扫描策略配置</h3><p>自定义扫描策略需要我们实现<code>org.springframework.core.type.filter.TypeFilter</code>接口，创建<code>MyTypeFilter</code>实现该接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口包含<code>match</code>方法，其两个入参<code>MetadataReader</code>和<code>MetadataReaderFactory</code>含义如下：</p>
<ol>
<li><code>MetadataReader</code>：当前正在扫描的类的信息；</li>
<li><code>MetadataReaderFactory</code>：可以通过它来获取其他类的信息。</li>
</ol>
<p>当<code>match</code>方法返回true时说明匹配成功，false则说明匹配失败。继续完善这个过滤规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前正在扫描的类的注解信息</span></span><br><span class="line">        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">        <span class="comment">// 获取当前正在扫描的类的类信息</span></span><br><span class="line">        ClassMetadata classMetadata = metadataReader.getClassMetadata();</span><br><span class="line">        <span class="comment">// 获取当前正在扫描的类的路径等信息</span></span><br><span class="line">        Resource resource = metadataReader.getResource();</span><br><span class="line"></span><br><span class="line">        String className = classMetadata.getClassName();</span><br><span class="line">        <span class="keyword">return</span> StringUtils.hasText(<span class="string">&quot;er&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面指定了当被扫描的类名包含<code>er</code>时候，匹配成功，配合<code>excludeFilters</code>使用意指当被扫描的类名包含<code>er</code>时，该类不被纳入IOC容器中。我们在<code>@ComponentScan</code>中使用这个自定义的过滤策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.dougWilson.demo&quot;,</span></span><br><span class="line"><span class="meta">        excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">            @Filter(type = FilterType.CUSTOM, classes = MyTypeFilter.class)</span></span><br><span class="line"><span class="meta">        &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">控制台输出：</span><br><span class="line">webConfig</span><br></pre></td></tr></table></figure>

<p>因为<code>User</code>，<code>UserMapper</code>，<code>UserService</code>和<code>UserController</code>等类的类名都包含<code>er</code>，所以它们都没有被纳入到IOC容器中。</p>
<h2 id="组件作用域-Scope"><a href="#组件作用域-Scope" class="headerlink" title="组件作用域@Scope"></a>组件作用域@Scope</h2><p>默认情况下，在Spring的IOC容器中每个组件都是单例的，即无论在任何地方注入多少次，这些对象都是同一个。在Spring中我们可以使用<code>@Scope</code>注解来改变组件的作用域：</p>
<ol>
<li><code>singleton</code>：单实例（默认）,在Spring IOC容器启动的时候会调用方法创建对象然后纳入到IOC容器中，以后每次获取都是直接从IOC容器中获取（<code>map.get()</code>）；</li>
<li><code>prototype</code>：多实例，IOC容器启动的时候并不会去创建对象，而是在每次获取的时候才会去调用方法创建对象；</li>
<li><code>request</code>：一个请求对应一个实例；</li>
<li><code>session</code>：同一个session对应一个实例</li>
</ol>
<h2 id="懒加载-Lazy"><a href="#懒加载-Lazy" class="headerlink" title="懒加载@Lazy"></a>懒加载@Lazy</h2><p>懒加载是针对单例模式而言的，正如前面所说，IOC容器中的组件默认是单例的，容器启动的时候会调用方法创建对象然后纳入到IOC容器中。在User Bean注册的地方加入一句话以观察：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;往IOC容器中注册user bean&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;dougWilson&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">System.out.println(<span class="string">&quot;容器创建完毕&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">往IOC容器中注册<span class="keyword">user</span> <span class="title">bean</span></span><br><span class="line">容器创建完毕</span><br></pre></td></tr></table></figure>

<p>可以看到，在IOC容器创建完毕之前，组件已经添加到容器中了。将User Bean改为懒加载的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;往IOC容器中注册user bean&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;dougWilson&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">容器创建完毕</span><br></pre></td></tr></table></figure>

<p>可看到，容器创建完的时候，User Bean这个组件并未添加到容器中。所以懒加载的功能是，在单例模式中，IOC容器创建的时候不会马上去调用方法创建对象并注册，只有当组件<strong>第一次</strong>被使用的时候才会调用方法创建对象并加入到容器中。</p>
<p>尝试调用一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">System.out.println(<span class="string">&quot;容器创建完毕&quot;</span>);</span><br><span class="line">Object user1 = context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">Object user2 = context.getBean(<span class="string">&quot;user&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">容器创建完毕</span><br><span class="line">往IOC容器中注册<span class="keyword">user</span> <span class="title">bean</span></span><br></pre></td></tr></table></figure>

<h2 id="条件注册-Conditional"><a href="#条件注册-Conditional" class="headerlink" title="条件注册@Conditional"></a>条件注册@Conditional</h2><p>使用<code>@Conditional</code>注解我们可以指定组件注册的条件，即满足特定条件才将组件纳入到IOC容器中。使用该注解之前，我们需要创建一个类，实现<code>Condition</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口包含一个<code>matches</code>方法，包含两个入参:</p>
<ol>
<li><code>ConditionContext</code>：上下文信息；</li>
<li><code>AnnotatedTypeMetadata</code>：注解信息。</li>
</ol>
<p>简单做个测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        String osName = context.getEnvironment().getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> osName != <span class="keyword">null</span> &amp;&amp; osName.contains(<span class="string">&quot;Windows&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着将这个条件添加到User Bean注册的地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Conditional(MyCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;往IOC容器中注册user bean&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;dougWilson&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果为：在Windows环境下，User这个组件将被成功注册，如果是别的操作系统，这个组件将不会被注册到IOC容器中。</p>
<h2 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h2><p><code>@Profile</code>可以根据不同的环境变量来注册不同的组件</p>
<h2 id="导入组件"><a href="#导入组件" class="headerlink" title="导入组件"></a>导入组件</h2><h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><p>到目前为止，可以使用包扫描和<code>@Bean</code>来实现组件注册。除此之外，还可以使用<code>@Import</code>来快速地往IOC容器中添加组件。创建一个新的类<code>Hello</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在配置类中导入这个组件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;Hello.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看IOC容器中所有组件的名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">String[] beanNames = context.getBeanDefinitionNames();</span><br><span class="line">Arrays.stream(beanNames).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">webConfig</span><br><span class="line">com<span class="selector-class">.dougWilson</span><span class="selector-class">.demo</span><span class="selector-class">.Hello</span></span><br><span class="line">user</span><br></pre></td></tr></table></figure>

<p>从测试结果可知，通过<code>@Import</code>可以快速地往IOC容器中添加组件，id默认为全类名。</p>
<h3 id="ImportSelector"><a href="#ImportSelector" class="headerlink" title="@ImportSelector"></a>@ImportSelector</h3><p>通过<code>@Import</code>已经实现了组件的导入，如果需要一次性导入较多组件，我们可以使用<code>ImportSelector</code>来实现。查看<code>ImportSelector</code>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Select and return the names of which class(es) should be imported based on</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125; of the importing @&#123;<span class="doctag">@link</span> Configuration&#125; class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ImportSelector</code>是一个接口，包含一个<code>selectImports</code>方法，方法返回类的全类名数组（即需要导入到IOC容器中组件的全类名数组），包含一个<code>AnnotationMetadata</code>类型入参，通过这个参数我们可以获取到使用<code>ImportSelector</code>的类的全部注解信息。</p>
<p>新增三个类<code>Apple</code>，<code>Banana</code>和<code>Watermelon</code>，代码略，并新建一个<code>ImportSelector</code>实现类<code>MyImportSelector</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;</span><br><span class="line">                <span class="string">&quot;com.dougWilson.demo.Apple&quot;</span>,</span><br><span class="line">                <span class="string">&quot;com.dougWilson.demo.Banana&quot;</span>,</span><br><span class="line">                <span class="string">&quot;com.dougWilson.demo.Watermelon&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法返回了新增的三个类的全类名数组，接着我们在配置类的<code>@Import</code>注解上使用<code>MyImportSelector</code>来把这三个组件快速地导入到IOC容器中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;MyImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看容器中是否已经有这三个组件:</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">String[] beanNames = context.getBeanDefinitionNames();</span><br><span class="line">Arrays.stream(beanNames).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">com<span class="selector-class">.dougWilson</span><span class="selector-class">.demo</span><span class="selector-class">.Apple</span></span><br><span class="line">com<span class="selector-class">.dougWilson</span><span class="selector-class">.demo</span><span class="selector-class">.Banana</span></span><br><span class="line">com<span class="selector-class">.dougWilson</span><span class="selector-class">.demo</span><span class="selector-class">.Watermelon</span></span><br><span class="line"><span class="comment">// 组件已成功导入</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>spring, bean, 注册</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Spring事件发布与监听</title>
    <url>/2020/05/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E4%B8%8E%E7%9B%91%E5%90%AC/</url>
    <content><![CDATA[<p>在使用Spring构建的应用程序中，适当使用事件发布与监听的机制可以使我们的代码灵活度更高，降低耦合度。Spring提供了完整的事件发布与监听模型，在该模型中，事件发布方只需将事件发布出去，无需关心有多少个对应的事件监听器；监听器无需关心是谁发布了事件，并且可以同时监听来自多个事件发布方发布的事件，通过这种机制，事件发布与监听是解耦的。本文将举例事件发布与监听的使用，并介绍内部实现原理。</p>
<span id="more"></span>

<h2 id="事件发布监听实例"><a href="#事件发布监听实例" class="headerlink" title="事件发布监听实例"></a>事件发布监听实例</h2><p>Spring中使用ApplicationEvent接口来表示一个事件，所以我们自定义事件MyEvent需要实现该接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 构造器source参数表示当前事件的事件源，一般传入Spring的context上下文对象即可。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事件发布通过事件发布器ApplicationEventPublisher完成，我们自定义一个事件发布器MyEventPublisher：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventPublisher</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;开始发布自定义事件MyEvent&quot;</span>);</span><br><span class="line">        MyEvent myEvent = <span class="keyword">new</span> MyEvent(applicationContext);</span><br><span class="line">        applicationEventPublisher.publishEvent(myEvent);</span><br><span class="line">        logger.info(<span class="string">&quot;发布自定义事件MyEvent结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在自定义事件发布器MyEventPublisher中，需要通过ApplicationEventPublisher来发布事件，所以需要实现ApplicationEventPublisherAware接口，通过回调方法setApplicationEventPublisher为MyEventPublisher的ApplicationEventPublisher属性赋值；同样的，自定义的事件MyEvent构造函数需要传入Spring上下文，所以MyEventPublisher还实现了ApplicationContextAware接口，注入了上下文对象ApplicationContext。</p>
<p>publishEvent方法发布了一个自定义事件MyEvent，当事件发布出去后，则需要编写相应的事件监听器：</p>
<p>通过@EventListener注解实现事件监听</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnotationEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMyEventPublished</span><span class="params">(MyEvent myEvent)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;收到自定义事件MyEvent -- MyAnnotationEventListener&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被@EventListener注解标注的方法入参为MyEvent类型，所以只要MyEvent事件被发布了，该监听器就会起作用，即该方法会被回调。</p>
<p>除了使用@EventListener注解实现事件的监听外，我们也可以手动实现ApplicationListener接口来实现事件的监听（泛型为监听的事件类型）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyEvent event)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;收到自定义事件MyEvent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(MyApplication.class, args);</span><br><span class="line">        MyEventPublisher publisher = context.getBean(MyEventPublisher.class);</span><br><span class="line">        publisher.publishEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"><span class="number">2020-06-22</span> <span class="number">16</span>:<span class="number">31:46.667</span>  INFO <span class="number">83600</span> --- [main] MyEventPublisher: 开始发布自定义事件MyEvent</span><br><span class="line"><span class="number">2020-06-22</span> <span class="number">16</span>:<span class="number">31:46.668</span>  INFO <span class="number">83600</span> --- [main] MyEventListener: 收到自定义事件MyEvent</span><br><span class="line"><span class="number">2020-06-22</span> <span class="number">16</span>:<span class="number">31:46.668</span>  INFO <span class="number">83600</span> --- [main] MyAnnotationEventListener: 收到自定义事件MyEvent -- MyAnnotationEventListener</span><br><span class="line"><span class="number">2020-06-22</span> <span class="number">16</span>:<span class="number">31:46.668</span>  INFO <span class="number">83600</span> --- [main] MyEventPublisher: 发布自定义事件MyEvent结束</span><br></pre></td></tr></table></figure>

<p>可以看到，两个监听器都监听到了事件的发布。此外还发现事件发布和事件监听是同一个线程完成的，过程为同步操作，只有当所有对应事件监听器的逻辑执行完毕后，事件发布方法才能出栈。后面进阶使用会介绍如何使用异步的方式进行事件监听。</p>
<h2 id="事件发布监听原理"><a href="#事件发布监听原理" class="headerlink" title="事件发布监听原理"></a>事件发布监听原理</h2><p>在事件发布方法上打个断点：</p>
<p><img src="/images/%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E6%96%B9%E6%B3%95%E4%B8%8A%E6%89%93%E4%B8%AA%E6%96%AD%E7%82%B9.png"></p>
<p>以debug的方式启动程序，程序执行到该断点后点击Step Into按钮，程序跳转到AbstractApplicationContext的publishEvent(ApplicationEvent event)方法：</p>
<p><img src="/images/publishEvent%E6%96%B9%E6%B3%95.png"></p>
<p>继续点击Step Into，程序跳转到AbstractApplicationContext的publishEvent(Object event, @Nullable ResolvableType eventType)方法：</p>
<p><img src="/images/AbstractApplicationContext%E7%9A%84publishEvent%E6%96%B9%E6%B3%95.png"></p>
<p>两个步骤解析如下：</p>
<ol>
<li><p>getApplicationEventMulticaster方法用于获取广播事件用的多播器，源码如下所示：</p>
<p><img src="/images/getApplicationEventMulticaster%E6%96%B9%E6%B3%95.png"></p>
</li>
<li><p>获取到事件多播器后，调用其multicastEvent方法广播事件，点击Step Into进入该方法内部查看具体逻辑：</p>
<p><img src="/images/multicastEvent%E6%96%B9%E6%B3%95.png"></p>
<p>查看invokeListener方法源码：</p>
<p><img src="/images/invokeListener%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%EF%BC%9A.png"></p>
<p>继续查看doInvokeListener方法源码：</p>
<p><img src="/images/doInvokeListener%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png"></p>
</li>
</ol>
<p>上述过程就是整个事件发布与监听的过程。</p>
<h3 id="多播器创建过程"><a href="#多播器创建过程" class="headerlink" title="多播器创建过程"></a>多播器创建过程</h3><p>为了弄清楚AbstractApplicationContext的applicationEventMulticaster属性是何时赋值的（即事件多播器是何时创建的），在AbstractApplicationContext的applicationEventMulticaster属性上打个断点：</p>
<p><img src="/images/applicationEventMulticaster%E5%B1%9E%E6%80%A7%E4%B8%8A%E6%89%93%E4%B8%AA%E6%96%AD%E7%82%B9.png"></p>
<p>以debug的方式启动程序，程序跳转到了AbstractApplicationContext的initApplicationEventMulticaster方法中：</p>
<p><img src="/images/AbstractApplicationContext%E7%9A%84initApplicationEventMulticaster%E6%96%B9%E6%B3%95.png"></p>
<p>通过跟踪方法调用栈，可以总结出程序执行到上述截图的过程：</p>
<ol>
<li><p>SpringBoot入口类的main方法执行SpringApplication.run(MyApplication.class, args)启动应用</p>
<p><img src="/images/%E8%B7%9F%E8%B8%AA%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%A0%881.png"></p>
</li>
<li><p>run方法内部包含refreshContext方法（刷新上下文）</p>
<p><img src="/images/%E8%B7%9F%E8%B8%AA%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%A0%882.png"></p>
</li>
<li><p>refresh方法内部包含initApplicationEventMulticaster方法</p>
<p><img src="/images/%E8%B7%9F%E8%B8%AA%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%A0%883.png"></p>
</li>
<li><p>initApplicationEventMulticaster方法创建多播器</p>
</li>
</ol>
<h3 id="监听器获取过程"><a href="#监听器获取过程" class="headerlink" title="监听器获取过程"></a>监听器获取过程</h3><p>在追踪事件发布与监听的过程中，我们知道事件对应的监听器是通过getApplicationListeners方法获取的：</p>
<p><img src="/images/%E7%9B%91%E5%90%AC%E5%99%A8%E9%80%9A%E8%BF%87getApplicationListeners%E6%96%B9%E6%B3%95%E8%8E%B7%E5%8F%96.png"></p>
<p>方法返回三个MyEvent事件对应的监听器，索引为0的监听器为DelegatingApplicationListener，它没有实质性的处理某事件，忽略；索引为1的监听器为通过实现ApplicationEventListener接口的监听器；索引为2的监听器为通过@EventListener实现的监听器。</p>
<h2 id="编程实现监听器注册过程"><a href="#编程实现监听器注册过程" class="headerlink" title="编程实现监听器注册过程"></a>编程实现监听器注册过程</h2><p>查看getApplicationListeners源码：</p>
<p><img src="/images/getApplicationListeners%E6%BA%90%E7%A0%81.png"></p>
<p>其中retrieverCache的定义为<code>final Map&lt;ListenerCacheKey, CachedListenerRetriever&gt; retrieverCache = new ConcurrentHashMap&lt;&gt;(64)</code>。</p>
<p>接着查看retrieveApplicationListeners方法（方法见名知意，程序第一次获取事件对应的监听器时，缓存中是空的，所以继续检索获取事件对应的监听器）：</p>
<p><img src="/images/retrieveApplicationListeners%E6%96%B9%E6%B3%95.png"></p>
<p>从上面这段代码知道，用于遍历的监听器集合对象listeners和listenerBeans的值是从this.defaultRetriever的applicationListeners和applicationListenerBeans属性获取的，所以需要关注这些属性是何时被赋值的。defaultRetriever的类型为DefaultListenerRetriever：</p>
<p><img src="/images/DefaultListenerRetriever%E6%BA%90%E7%A0%81.png"></p>
<p>在applicationListeners属性上右键选择Find Usages查看赋值相关操作：</p>
<p>![](/images/Find Usages查看赋值相关操作.png)</p>
<p>可以看到，赋值操作发生在AbstractApplicationEventMulticaster的addApplicationListener方法中，</p>
<p>继续在addApplicationListener方法上右键选择Find Usages查看调用源：</p>
<p><img src="/images/addApplicationListener%E6%96%B9%E6%B3%95%E6%9F%A5%E7%9C%8B%E8%B0%83%E7%94%A8%E6%BA%90.png"></p>
<p>在registerListeners方法上打个断点，重新启动程序，查看方法调用栈：</p>
<p><img src="/images/registerListeners%E6%96%B9%E6%B3%95%E6%9F%A5%E7%9C%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%A0%88.png"></p>
<p>从方法调用栈我们可以总结出this.defaultRetriever的applicationListeners和applicationListenerBeans属性值赋值的过程：</p>
<ol>
<li><p><code>SpringApplication.run(MyApplication.class, args)</code>启动Boot程序；</p>
</li>
<li><p><code>run</code>方法内部调用<code>refreshContext</code>刷新容器方法：</p>
<p><img src="/images/refreshContext%E5%88%B7%E6%96%B0%E5%AE%B9%E5%99%A8%E6%96%B9%E6%B3%95.png"></p>
</li>
<li><p><code>refresh</code>方法内部调用了<code>registerListener</code>方法注册监听器：</p>
<p><img src="/images/registerListener%E6%96%B9%E6%B3%95%E6%B3%A8%E5%86%8C%E7%9B%91%E5%90%AC%E5%99%A8.png"></p>
</li>
<li><p><code>registerListeners</code>方法内部从IOC容器获取所有ApplicationListener类型Bean，然后赋值给this.defaultRetriever的applicationListeners和applicationListenerBeans属性。</p>
</li>
</ol>
<h2 id="注解监听器注册过程"><a href="#注解监听器注册过程" class="headerlink" title="注解监听器注册过程"></a>注解监听器注册过程</h2><p>查看<code>@EventListener</code>注解源码：</p>
<p><img src="/images/%E6%9F%A5%E7%9C%8B@EventListener%E6%B3%A8%E8%A7%A3%E6%BA%90%E7%A0%81.png"></p>
<p>查看EventListenerMethodProcessor源码：</p>
<p><img src="/images/%E6%9F%A5%E7%9C%8BEventListenerMethodProcessor%E6%BA%90%E7%A0%81.png"></p>
<p>其实现了SmartInitializingSingleton接口，该接口包含afterSingletonsInstantiated方法：</p>
<p><img src="/images/afterSingletonsInstantiated%E6%96%B9%E6%B3%95.png"></p>
<p>通过注释可以看到这个方法的调用时机为：单实例Bean实例化后被调用，此时Bean已经被创建出来。</p>
<p>我们查看EventListenerMethodProcessor是如何实现该方法的：</p>
<p><img src="/images/EventListenerMethodProcessor%E5%AE%9E%E7%8E%B0.png"></p>
<p>继续查看processBean方法源码：</p>
<p><img src="/images/processBean%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png"></p>
<p>至此，两种方式注册监听器的原理都搞清楚了。</p>
<h2 id="事件监听异步化"><a href="#事件监听异步化" class="headerlink" title="事件监听异步化"></a>事件监听异步化</h2><p>通过前面的分析，我们知道事件广播和监听是一个线程完成的同步操作，有时候为了让广播更有效率，我们可以考虑将事件监听过程异步化</p>
<h3 id="单个异步"><a href="#单个异步" class="headerlink" title="单个异步"></a>单个异步</h3><p>首先需要在springboot入口类上通过<code>@EnableAsync</code>注解开启异步，然后在需要异步执行的监听器方法上使用<code>@Async</code>注解标注，以MyAnnotationEventListener为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnotationEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span> <span class="comment">// 异步</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMyEventPublished</span><span class="params">(MyEvent myEvent)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;收到自定义事件MyEvent -- MyAnnotationEventListener&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">INFO</span> 98747 --- [	  main] MyEventPublisher			: 开始发布自定义事件MyEvent</span><br><span class="line"><span class="builtin-name">INFO</span> 98747 --- [	  main] MyEventListener				: 收到自定义事件MyEvent</span><br><span class="line"><span class="builtin-name">INFO</span> 98747 --- [	  main] ThreadPoolTaskExecutor		: Initializing ExecutorService <span class="string">&#x27;applicationTaskExecutor&#x27;</span></span><br><span class="line"><span class="builtin-name">INFO</span> 98747 --- [	  main] MyEventPublisher			: 发布自定义事件MyEvent结束</span><br><span class="line"><span class="builtin-name">INFO</span> 98747 --- [	task-1] MyEventPublisher			: 收到自定义事件MyEvent -- MyAnnotationEventListener</span><br></pre></td></tr></table></figure>

<p>通过日志可以看出来，该监听器方法已经异步化，执行线程为task-1。</p>
<h3 id="整体异步"><a href="#整体异步" class="headerlink" title="整体异步"></a>整体异步</h3><p>通过前面源码分析，我们知道多播器在广播事件时，会先判断是否有指定executor，有的话通过executor执行监听器逻辑。所以我们可以通过指定executor的方式来让所有的监听方法都异步执行：</p>
<p><img src="/images/%E7%9B%91%E5%90%AC%E6%96%B9%E6%B3%95%E9%83%BD%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C.png"></p>
<p>新建一个配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncEventConfigure</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationEventMulticaster <span class="title">simpleApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleApplicationEventMulticaster eventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster();</span><br><span class="line">        eventMulticaster.setTaskExecutor(<span class="keyword">new</span> SimpleAsyncTaskExecutor());</span><br><span class="line">        <span class="keyword">return</span> eventMulticaster;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在配置类中，我们注册了一个名称为AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME（即applicationEventMulticaster）的Bean，用于覆盖默认的事件多播器，然后指定了TaskExecutor，SimpleAsyncTaskExecutor为Spring提供的异步任务executor。</p>
<p>在启动项目前，先把之前在springboot入口类添加的<code>@EnableAsync</code>注解去掉，然后启动项目，输出如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INFO</span> <span class="number">99778</span> <span class="comment">--- [	  	   main] MyEventPublisher			: 开始发布自定义事件MyEvent</span></span><br><span class="line"><span class="keyword">INFO</span> <span class="number">99778</span> <span class="comment">--- [	       main] MyEventPublisher			: 发布自定义事件MyEvent结束</span></span><br><span class="line"><span class="keyword">INFO</span> <span class="number">99778</span> <span class="comment">--- [TaskExecutor-15] MyEventListener			: 收到自定义事件MyEvent</span></span><br><span class="line"><span class="keyword">INFO</span> <span class="number">99778</span> <span class="comment">--- [TaskExecutor-15] MyAnnotationEventPublisher	: 收到自定义事件MyEvent -- MyAnnotationEventListener</span></span><br></pre></td></tr></table></figure>

<p>可以看到，监听器事件都异步化了。</p>
]]></content>
      <tags>
        <tag>spring, 事件, 监听</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解volatile关键字</title>
    <url>/2020/08/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>volatile关键字修饰的成员变量具有两大特性：保证了该成员变量在不同线程之间的可见性；禁止对该成员变量进行重排序，也就保证了其有序性。但是volatile修饰的成员变量并不具有原子性，在并发下对它的修改是线程不安全的。下面分别举例来演示这两个特性，并且分析为什么volatile不是线程安全的。</p>
<span id="more"></span>

<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>线程对主内存中共享变量的修改首先会从主内存获取值的拷贝，然后保存到线程的工作内存中。接着在工作内存中对值进行修改，最终刷回主内存。由于不同线程拥有各自的工作内存，所以它们对某个共享变量值的修改在没有刷回主内存的时候只对自己可见。</p>
<p>举个例子，假如有两个线程，其中一个线程用于修改共享变量value，另一个线程用于获取修改后的value：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> INIT_VALUE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> LIMIT = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> value = INIT_VALUE;</span><br><span class="line">            <span class="keyword">while</span> (value &lt; LIMIT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (value != INIT_VALUE) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;获取更新后的值：&quot;</span> + INIT_VALUE);</span><br><span class="line">                    value = INIT_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;reader&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> value = INIT_VALUE;</span><br><span class="line">            <span class="keyword">while</span> (INIT_VALUE &lt; LIMIT) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;将值更新为：&quot;</span> + ++value);</span><br><span class="line">                INIT_VALUE = value;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;writer&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>writer线程每隔0.5秒将INIT_VALUE值递增，直到INIT_VALUE大于等于5。而reader线程则是不停的去获取INIT_VALUE的值，直到INIT_VALUE的值大于等于5。程序执行结果如下：</p>
<p><img src="/images/volatile%E6%B5%8B%E8%AF%951.png"></p>
<p><img src="/images/volatile%E6%B5%8B%E8%AF%952.png"></p>
<p>多执行几次可能每次结果都不一样，但是可以确定的是，writer对值的修改reader并不能感知到（如果能感知到的话，reader线程就不会停不下来了）。</p>
<p>为什么会出现上面的结果呢？因为writer线程在工作内存中修改了INIT_VALUE的值，即使它刷回主内存了，但是reader线程在此之前已经从主内存获取了INIT_VALUE的值（因为线程获取CPU时间片不确定性，这个值可能是0，也可能是被writer修改后的值，但writer线程是每隔0.5毫秒才会去修改值，所以reader获取到的INIT_VALUE的值一般不会是writer修改的最终值5），并保存到了reader线程的工作内存中。reader线程通过while不断的轮询判断value和INIT_VALUE的值是否相等，但是由于reader线程工作内存中已经有INIT_VALUE的值的拷贝了，所以reader并不会重新从主内存中获取被writer修改后的INIT_VALUE的值，reader线程里while条件一直成立，这就是为什么reader线程不会正常停止并且没有输出修改后的值的原因。</p>
<p>修改上面的例子，将INIT_VALUE成员变量使用volatile关键字修饰：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> INIT_VALUE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> LIMIT = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> value = INIT_VALUE;</span><br><span class="line">            <span class="keyword">while</span> (value &lt; LIMIT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (value != INIT_VALUE) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;获取更新后的值：&quot;</span> + INIT_VALUE);</span><br><span class="line">                    value = INIT_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;reader&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> value = INIT_VALUE;</span><br><span class="line">            <span class="keyword">while</span> (INIT_VALUE &lt; LIMIT) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;将值更新为：&quot;</span> + ++value);</span><br><span class="line">                INIT_VALUE = value;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MICROSECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;writer&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/volatile%E6%B5%8B%E8%AF%953.png"></p>
<p>可以看到，reader线程已经可以正常停止了，因为最终INIT_VALUE的值肯定是5，并且reader可以感知到这个值被修改为5了。</p>
<p>为什么volatile修饰的成员变量在线程间具有可见性呢？因为通过volatile修饰，对此变量进行写操作时，汇编指令中会有一个LOCK前缀指令，加了这个指令后，会引发两件事情：</p>
<ol>
<li>将当前处理器缓存行的内容写回到系统内存，也就是强制将工作内存中的值刷回主内存；</li>
<li>这个写回到内存的操作会使得在其他CPU里缓存了该内存地址的数据失效。其他CPU缓存数据失效，则会重新去内存中读取值，也就是被修改的数据。</li>
</ol>
<p>通过上面这两个特性，我们可以确定的是，writer对值进行修改并刷回主内存后，reader里INIT_VALUE值的拷贝就失效了，所以reader线程会再次从主内存中获取INIT_VALUE的值，这时候这个值已经是被writer线程修改刷新后的值了。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>来看一个线程不安全的单例实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有化构造函数，让外部没办法直接通过new来创建</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonTest instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonTest <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双重检测</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonTest.class) &#123; <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonTest();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子虽然加了同步锁，但是在多线程下并不是线程安全的。第12行<code>instance = new SingletonTest()</code>在实际执行的时候会被拆分为以下三个步骤:</p>
<ol>
<li>分配存储SingletonTest对象的内存空间；</li>
<li>初始化SingletonTest对象；</li>
<li>将instance指向刚刚分配的内存空间。</li>
</ol>
<p>通过JMM的学习我们都知道，在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序，因为第2步和第3步并没有依赖关系，所以可能发生重排序，排序后的步骤为：</p>
<ol>
<li>分配存储SingletonTest对象的内存空间；</li>
<li>将instance指向刚刚分配的内存空间；</li>
<li>初始化SingletonTest对象。</li>
</ol>
<p>经过重排序后，上面的例子在多线程下就会出现问题。假如现在有两个线程A和B同时调用SingletonTest#getInstance，线程A执行到了代码的第12行<code>instance = new SingletonTest()</code>，已经完成了对象内存空间的分配并将instance指向了该内存空间，线程B执行到了第9行，发现instance并不是null（因为已经指向了内存空间），所以就直接返回instance了。但是线程A并还没有执行初始化SingletonTest操作，所以实际线程B拿到的SingletonTest实例是空的，那么线程B后续对SingletonTest操控将抛出空指针异常。</p>
<p>要让上面的例子是线程安全的，只需要用volatile修饰单例对象即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有化构造函数，让外部没办法直接通过new来创建</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonTest instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonTest <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双重检测</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonTest.class) &#123; <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonTest();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为通过volatile修饰的成员变量会添加内存屏障来阻止JVM进行指令重排优化。</p>
<h2 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h2><p>举个递增的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; IntStream.range(<span class="number">0</span>, <span class="number">500</span>).forEach(i -&gt; value += <span class="number">1</span>));</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; IntStream.range(<span class="number">0</span>, <span class="number">500</span>).forEach(i -&gt; value += <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多次运行上面的例子：</p>
<p><img src="/images/volatile%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8.gif"></p>
<p>可以看到最终的值有可能小于1000。</p>
<p>volatile可以保证修改的值能够马上更新到主内存，其他线程也会捕捉到被修改后的值，那么为什么不能保证原子性呢？</p>
<p>因为在Java中，只有对基本类型的赋值和修改才是原子性的，而对共享变量的修改并不是原子性的。通过<a href="https://mrbird.cc/Java-Memory-model.html">JMM</a>内存交互协议可以知道，一个线程修改共享变量的值需要经过下面这些步骤：</p>
<ol>
<li>线程从主内存中读取（read）共享变量的值，然后载入（load）到线程的工作内存中的变量；</li>
<li>使用（use）工作内存变量的值，执行加减操作，然后将修改后的值赋值（assign）给工作内存中的变量；</li>
<li>将工作内存中修改后的变量的值存储（store）到主内存中，并执行写入（write）操作。</li>
</ol>
<p>所以上面的例子中，可能出现下面这种情况：</p>
<p>thread1和thread2同时获取了value的值，比如为100。thread1执行了+1操作，然后写回主内存，这个时候thread2刚好执行完use操作（+1），准备执行assign（将+1后的值写回工作内存对应的变量中）操作。虽然这时候thread2工作内存中value值的拷贝无效了（因为volatile的特性），但是thread2已经执行完+1操作了，它并不需要再从主内存中获取value的值，所以thread2可以顺利地将+1后的值赋值给工作内存中的变量，然后刷回主存。这就是为什么上面的累加结果可能会小于1000的原因。</p>
<p>要让上面的例子是线程安全的话可以加同步锁，或者使用atomic类。</p>
]]></content>
      <tags>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>理解BeanFactoryPostProcessor&amp;BeanDefinitionRegistryPostProcessor</title>
    <url>/2020/05/20/%E7%90%86%E8%A7%A3BeanFactoryPostProcessor&amp;BeanDefinitionRegistryPostProcessor/</url>
    <content><![CDATA[<p>主要记录BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor的方法执行时机以及简单原理分析。</p>
<span id="more"></span>

<h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>查看BeanFactoryPostProcessor源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Modify the application context&#x27;s internal bean factory after its standard</span></span><br><span class="line"><span class="comment">	 * initialization. All bean definitions will have been loaded, but no beans</span></span><br><span class="line"><span class="comment">	 * will have been instantiated yet. This allows for overriding or adding</span></span><br><span class="line"><span class="comment">	 * properties even to eager-initializing beans.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据注释了解到postProcessBeanFactory方法的执行时机为：BeanFactory标准初始化之后，所有的Bean定义已经被加载，但Bean的实例还没被创建（不包括BeanFactoryPostProcessor类型）。该方法通常用于修改bean的定义，Bean的属性值等，甚至可以在此快速初始化Bean。</p>
<p>测试一下是否是这样：</p>
<p>新建MyBeanFactoryPostProcessor，实现BeanFactoryPostProcessor接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyBeanFactoryPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBeanFactoryPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;实例化MyBeanFactoryPostProcessor Bean&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> beanDefinitionCount = beanFactory.getBeanDefinitionCount();</span><br><span class="line">        logger.info(<span class="string">&quot;Bean定义个数: &quot;</span> + beanDefinitionCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TestBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;实例化TestBean&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在postProcessBeanFactory方法内，我们打印了当前已加载Bean定义的个数，并且在MyBeanFactoryPostProcessor类中，注册了TestBean。MyBeanFactoryPostProcessor和TestBean的构造函数输出的日志用于观察Bean实例化时机。</p>
<p>控制台输出结果如下：</p>
<p><img src="/images/BeanFactoryPostProcessor%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></p>
<p>上面的日志证实了方法的执行时机的确是在BeanFactory标准初始化之后，所有的Bean定义已经被加载，但Bean的实例还没被创建（此时TestBean还未被实例化，日志还没有输出”实例化TestBean”，但这不包括BeanFactoryPostProcessor类型Bean，该方法执行之前，日志就已经输出了”实例化MyBeanFactoryPostProcessor Bean”）。</p>
<p>在postProcessBeanFactory方法上打个断点，通过追踪方法调用栈，可以总结出BeanFactoryPostProcessor的postProcessBeanFactory方法执行时机和原理：</p>
<p><img src="/images/BeanFactory%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%951.png"></p>
<h4 id="1-run方法内部调用refreshContext方法刷新上下文"><a href="#1-run方法内部调用refreshContext方法刷新上下文" class="headerlink" title="1. run方法内部调用refreshContext方法刷新上下文"></a>1. <code>run</code>方法内部调用<code>refreshContext</code>方法刷新上下文</h4><p><img src="/images/BeanFactory%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%952.png"></p>
<h4 id="2-refresh方法内部调用invokeBeanFactoryPostProcessors方法："><a href="#2-refresh方法内部调用invokeBeanFactoryPostProcessors方法：" class="headerlink" title="2. refresh方法内部调用invokeBeanFactoryPostProcessors方法："></a>2. <code>refresh</code>方法内部调用<code>invokeBeanFactoryPostProcessors</code>方法：</h4><p><img src="/images/BeanFactory%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%953.png"></p>
<h4 id="3-PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法内部："><a href="#3-PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法内部：" class="headerlink" title="3. PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法内部："></a>3. PostProcessorRegistrationDelegate的<code>invokeBeanFactoryPostProcessors</code>方法内部：</h4><p><img src="/images/BeanFactory%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%954.png"></p>
<h3 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h3><p>BeanDefinitionRegistryPostProcessor继承自BeanFactoryPostProcessor，新增了一个postProcessBeanDefinitionRegistry方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Modify the application context&#x27;s internal bean definition registry after its</span></span><br><span class="line"><span class="comment">	 * standard initialization. All regular bean definitions will have been loaded,</span></span><br><span class="line"><span class="comment">	 * but no beans will have been instantiated yet. This allows for adding further</span></span><br><span class="line"><span class="comment">	 * bean definitions before the next post-processing phase kicks in.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registry the bean definition registry used by the application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过注释了解到postProcessBeanDefinitionRegistry方法的执行时机为：所有的Bean定义即将被加载，但Bean的实例还没被创建时。也就是说，BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法执行时机先于BeanFactoryPostProcessor的postProcessBeanFactory方法。这个方法通常用于给IOC容器添加额外的组件。</p>
<p>测试一下是否是这样，新建BeanDefinitionRegistryPostProcessor的实现类MyBeanDefinitionRegistryPostProcessor：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyBeanDefinitionRegistryPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> beanDefinitionCount = registry.getBeanDefinitionCount();</span><br><span class="line">        logger.info(<span class="string">&quot;Bean定义个数: &quot;</span> + beanDefinitionCount);</span><br><span class="line">        <span class="comment">// 添加一个新的Bean定义</span></span><br><span class="line">        RootBeanDefinition definition = <span class="keyword">new</span> RootBeanDefinition(Object.class);</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;hello&quot;</span>, definition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出如下：</p>
<p><img src="/images/BeanDefinitionRegistryPostProcessor%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></p>
<p>可以看到，BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法执行时机的确先于BeanFactoryPostProcessor的postProcessBeanFactory方法。</p>
<p>通过源码，这一点也可以看出：</p>
<p><img src="/images/BeanDefinitionRegistryPostProcessor%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89.png"></p>
]]></content>
      <tags>
        <tag>spring, BeanFactoryPostProcessor, BeanDefinitionRegistryPostProcessor</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Spring BeanPostProcessor &amp; InstantiationAwareBeanPostProcessor</title>
    <url>/2020/05/21/%E7%90%86%E8%A7%A3Spring-BeanPostProcessor-&amp;-InstantiationAwareBeanPostProcessor/</url>
    <content><![CDATA[<p>在前天写的文章《深入学习Spring Bean的生命周期》中，学习了Bean后置处理器BeanPostProcessor，用于在Bean初始化前后插入自己的逻辑（Bean增强，Bean代理等）。而BeanPostProcessor的子类InstantiationAwareBeanPostProcessor，用于Bean实例化前后处理，本文记录两者的区别以及简单原理分析</p>
<span id="more"></span>

<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>Initialization为初始化的意思，Instantiation为实例化的意思。在Spring Bean生命周期中，实例化指的是创建Bean的过程，初始化指的是Bean创建后，对其属性进行赋值（populate bean）、后置处理等操作的过程，所以Instantiation执行时机先于Initialization。</p>
<h4 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h4><p>BeanPostProcessor类结构图：</p>
<p><img src="/images/BeanPostProcessor%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<p>InstantiationAwareBeanPostProcessor为BeanPostProcessor的子类，新增了三个额外的方法：</p>
<p><img src="/images/BeanPostProcessor%E7%9A%84%E5%AD%90%E7%B1%BB.png"></p>
<p><img src="/images/BeanPostProcessor%E7%9A%84%E9%A2%9D%E5%A4%96%E6%96%B9%E6%B3%95.png"></p>
<h4 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h4><ol>
<li>BeanPostProcessor<ul>
<li><code>postProcessBeforeInitialization(Object bean, String beanName)</code>：bean：Bean实例；beanName：Bean名称。方法将在Bean实例的afterPropertiesSet方法或者自定义的init方法被调用前调用，此时Bean属性已经被赋值。方法返回原始Bean实例或者包装后的Bean实例，如果返回null，则后续的后置处理方法不再被调用。</li>
<li><code>postProcessAfterInitialization(Object bean, String beanName)</code>：bean：Bean实例；beanName：Bean名称。方法将在Bean实例的afterPropertiesSet方法或者自定义的init方法被调用后调用，此时Bean属性已经被赋值。方法返回原始Bean实例或者包装后的Bean实例，如果返回null，则后续的后置处理方法不再被调用。</li>
</ul>
</li>
<li>InstantiationAwareBeanPostProcessor<ul>
<li><code>postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)</code>：beanClass：待实例化的Bean类型；beanName：待实例化的Bean名称。方法作用为：在Bean实例化前调用该方法，返回值可以为代理后的Bean，以此代替Bean默认的实例化过程。返回值不为null时，后续只会调用BeanPostProcessor的 postProcessAfterInitialization方法，而不会调用别的后续后置处理方法（如postProcessAfterInitialization、postProcessBeforeInstantiation等方法）；返回值也可以为null，这时候Bean将按默认方式初始化。</li>
<li><code>postProcessAfterInstantiation(Object bean, String beanName)</code>：bean：实例化后的Bean，此时属性还没有被赋值；beanName：Bean名称。方法作用为：当Bean通过构造器或者工厂方法被实例化后，当属性还未被赋值前，该方法会被调用，一般用于自定义属性赋值。方法返回值为布尔类型，返回true时，表示Bean属性需要被赋值；返回false表示跳过Bean属性赋值，并且InstantiationAwareBeanPostProcessor的postProcessProperties方法不会被调用。</li>
</ul>
</li>
</ol>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>新建<code>MyBeanPostProcessor</code>实现BeanPostProcessor接口，因为对所有的Bean生效，所以为了方便观察输出，这里仅当Bean名称为<code>demoApplication</code>时才打印输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;demoApplication&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;post processor before &quot;</span> + beanName + <span class="string">&quot; initialization&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;demoApplication&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;post processor after &quot;</span> + beanName + <span class="string">&quot; initialization&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建<code>MyBeanInstantiationPostProcessor</code>实现InstantiationAwareBeanPostProcessor接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanInstantiationPostProcessor</span> <span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;demoApplication&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;post process before &quot;</span> + beanName + <span class="string">&quot; instantiation&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;demoApplication&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;post process after &quot;</span> + beanName + <span class="string">&quot; instantiation&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;demoApplication&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;post process &quot;</span> + beanName + <span class="string">&quot; properties&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="built_in">post</span> <span class="built_in">process</span> <span class="keyword">before</span> demoApplication instantiation</span><br><span class="line"><span class="built_in">post</span> <span class="built_in">process</span> <span class="keyword">after</span> demoApplication instantiation</span><br><span class="line"><span class="built_in">post</span> <span class="built_in">process</span> demoApplication properties</span><br><span class="line"><span class="built_in">post</span> processor <span class="keyword">before</span> demoApplication initialization</span><br><span class="line"><span class="built_in">post</span> processor <span class="keyword">after</span> demoApplication initialization</span><br></pre></td></tr></table></figure>

<p>如果将MyBeanInstantiationPostProcessor的postProcessAfterInstantiation方法返回值改为false，程序输出如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="built_in">post</span> <span class="built_in">process</span> <span class="keyword">before</span> demoApplication instantiation</span><br><span class="line"><span class="built_in">post</span> <span class="built_in">process</span> <span class="keyword">after</span> demoApplication instantiation</span><br><span class="line"><span class="built_in">post</span> processor <span class="keyword">before</span> demoApplication initialization</span><br><span class="line"><span class="built_in">post</span> processor <span class="keyword">after</span> demoApplication initialization</span><br></pre></td></tr></table></figure>

<h3 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h3><p>postProcessAfterInitialization和InstantiationAwareBeanPostProcessor的方法都和Bean生命周期有关，要分析它们的实现原理要从Bean的创建过程入手。Bean创建的入口为<code>AbstractAutowireCapableBeanFactory</code>的createBean方法，查看其源码：</p>
<p><img src="/images/postProcess%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901.png"></p>
<p><strong>resolveBeforeInstantiation方法源码如下所示：</strong></p>
<p><img src="/images/postProcess%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%902.png"></p>
<p><strong>上面方法返回的bean如果为空的话，<code>AbstractAutowireCapableBeanFactory</code>的createBean方法将继续往下执行doCreateBean方法：</strong></p>
<p><img src="/images/postProcess%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%903.png"></p>
<p><strong>查看doCreateBean方法源码：</strong></p>
<p><img src="/images/postProcess%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%904.png"></p>
<p><strong>重点关注populateBean和initializeBean方法。查看populateBean方法源码：</strong></p>
<p><img src="/images/postProcess%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%905.png"></p>
<p><strong>接着查看initializeBean方法源码：</strong></p>
<p><img src="/images/postProcess%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%906.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/postProcess%E6%80%BB%E7%BB%93.png"></p>
]]></content>
      <tags>
        <tag>Spring, BeanPostProcessor, InstantiationAwareBeanPostProcessor</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机程序运行基本知识</title>
    <url>/2020/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>这两天空闲时间比较多一些，打算把计算机一些基本知识再看一看，写一些总结，也当作复习。以下内容参考自书籍 ：</p>
<blockquote>
<p>《程序是怎样跑起来的》</p>
</blockquote>
<span id="more"></span>

<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>什么是程序？<strong>程序是指示计算机运行的一组指令</strong>。程序由什么组成？<strong>指令和数据</strong>？CPU能直接执行指令吗？不能，<strong>必须将指令解释成机器语言，CPU才能解释和执行</strong>。正在运行的程序存储在什么位置？<strong>内存，但是不绝对，需要运行的部分是在内存中，这一点确定</strong>。什么是内存地址？<strong>指令和数据在内存中存储位置的数值。</strong>程序执行的流程？<strong>高级语言编写的程序——&gt;编译后转换成机器语言文件——&gt;程序运行在内存中生成的机器语言文件副本——&gt;CPU解释和运行转换成机器语言的程序内容。一般而言，程序启动后，控制器就会根据时钟信号从内存中读取指令和数据，通过对这些指令加以解释和运行，运算器就会对数据进行运算，控制器根据运算结果来控制计算机</strong></p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><blockquote>
<p><strong>CPU作用：负责解释和运行转换成机器语言的程序内容</strong></p>
<p><strong>CPU硬件组成：CPU和内存都是由若干晶体管组成的电子部件，通常称为IC (Integrated Circuit)集成电路</strong></p>
<p><strong>CPU构成：寄存器、控制器、运算器、时钟。各部分间由电信号相互连通</strong></p>
</blockquote>
<h4 id="CPU构成"><a href="#CPU构成" class="headerlink" title="CPU构成"></a>CPU构成</h4><p><img src="/images/CPU%E6%9E%84%E6%88%90.png"></p>
<blockquote>
<p>控制器：将内存中的指令，数据读入寄存器，并根据指令的执行结果控制整个计算机</p>
</blockquote>
<blockquote>
<p>运算器：运算寄存器中的数据</p>
</blockquote>
<blockquote>
<p>时钟：负责CPU开始计时的时钟信号，一般CPU的时钟单位为GHz，比如2GHz表示时钟信号的频率为2GHz(1GHz=10亿次/秒)，也就是说时钟的频率越高，CPU运行速度越快</p>
</blockquote>
<blockquote>
<p>寄存器：暂存指令，数据等处理对象。因此，程序常常将寄存器当作对象进行描述，比如汇编语言：mov eax, dword ptr[ebp-8];  含义就是把寄存器ebp地址8的内容复制到eax寄存器中。而寄存器根据其保存的对象不同，将寄存器分成了以下几类：</p>
<p><img src="/images/%E5%AF%84%E5%AD%98%E5%99%A8.png"></p>
<p><strong>其中，基址寄存器、变址寄存器、通用寄存器可以有多个，其它寄存器只有一个</strong></p>
<p>标志寄存器：这是一个比较有意思的寄存器。条件分支和循环中的跳转指令都会参照当前标志寄存器中的数值来判断是否进行跳转。而标志寄存器中的数值由3个位表示，负位，零位，正位。如下图：</p>
<p><img src="/images/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%E7%8A%B6%E6%80%81.png"></p>
<p>当运算结果为负值，负位就会置为1；当运算结果为0，零位就会置为1；当运算结果为正值，正位就会置为1.</p>
<p>运算结果的计算过程：比如要比较累加寄存器中XXX值和通用寄存器中YYY值，执行比较指令后，CPU的运算会在内部进行XXX-YYY减法运算。而无论剑法运算的结果为正数，负数，还是零，都会保存到标志寄存器中。结果为正，表示XXX比YYY大，标志寄存器的正位置为1；结果为0，表示XXX和YYY相等，标志寄存器的零位置为1；结果为负值，表示XXX比YYY小，标志寄存器的负位置为1.</p>
<blockquote>
<p>基址寄存器和变址寄存器则定义程序指令在内存中的地址，其中，基址寄存器保存程序的起始地址，变址寄存器保存程序的指令地址。也正因这两类的寄存器的存在，程序的才能得到正确地执行。</p>
</blockquote>
</blockquote>
<h3 id="计算机的二进制"><a href="#计算机的二进制" class="headerlink" title="计算机的二进制"></a>计算机的二进制</h3><blockquote>
<p>前面说过，CPU是由IC集成电路组成的，而IC通常如下：</p>
<p><img src="/images/IC%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF.png"></p>
<p>所有引脚只有直流电压0V或5V两个状态，也就说一个引脚只能表示两个状态。IC的这个特性，决定了计算机的信息，只能通过二进制数来处理。</p>
<h4 id="二进制表示的数和运算"><a href="#二进制表示的数和运算" class="headerlink" title="二进制表示的数和运算"></a>二进制表示的数和运算</h4><p>正数用原码表示；负数用补码表示。这样做的原因是将计算机中的减法运算，转化成加法运算。比如1-1实际上为1+(-1) ：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">的二进制数：</span> <span class="number">0000 </span><span class="number">0001</span></span><br><span class="line"><span class="number">-1</span><span class="string">的二进制数：1111</span> <span class="number">1111   </span><span class="number">1000 </span><span class="number">0001</span><span class="string">取反加1</span></span><br><span class="line"><span class="number">1</span><span class="number">-1</span> <span class="string">变为</span> <span class="number">1</span><span class="string">+(-1):</span>   <span class="number">0000 </span><span class="number">0001</span></span><br><span class="line">                 <span class="string">+1111</span> <span class="number">1111</span></span><br><span class="line">                  <span class="number">0000 </span><span class="number">0000</span> <span class="string">等于0</span></span><br><span class="line"><span class="string">例2：2的二进制数</span>  <span class="number">0000 </span><span class="number">0010</span></span><br><span class="line">    <span class="number">-3</span><span class="string">的二进制数</span> <span class="number">1111 </span><span class="number">1101   </span><span class="number">1000 </span><span class="number">0011</span><span class="string">取反加1</span></span><br><span class="line"><span class="number">2</span><span class="number">-3</span> <span class="string">变为</span> <span class="number">2</span><span class="string">+(-3)：</span> <span class="number">0000 </span><span class="number">0010</span></span><br><span class="line">				<span class="string">+1111</span> <span class="number">1101</span></span><br><span class="line">				 <span class="number">1111 </span><span class="number">1111</span> <span class="string">等于-1</span></span><br></pre></td></tr></table></figure>

<h4 id="浮点数表示"><a href="#浮点数表示" class="headerlink" title="浮点数表示"></a>浮点数表示</h4><p>有些浮点数在计算机中是无法表示的，只能近似表示：比如十进制0.1无法用二进制表示，只能近似表示。如何规避浮点数错误？<strong>无视错误，或将小数转换成整数后计算</strong></p>
<p>那如何用二进制表示浮点数？</p>
<p><img src="/images/%E6%B5%AE%E7%82%B9%E6%95%B0.png"></p>
<img src="/F:/HexoBlog\blog\source\images\浮点数表示.png" style="zoom:75%;">
$$

<p>$$<br><strong>其中正负号为符号位，m为尾数，2为基数，e为指数</strong></p>
<p>举个例子进行求解，以单精度的浮点数为例，11.1875</p>
<blockquote>
<p>符号位求法：正数为0，负数为1 。因此11.1875 符号位为 0</p>
</blockquote>
<blockquote>
<p>尾数求法：11.1875用二进制数表示为 1011.0011 我们需要<strong>让其整数部分只有1</strong>，因此需要将其无符号位右移3位，变成1.011 0011，并确保小数点后长度为23位，变成 1.011 0011 0000 0000 0000 0000</p>
<p>那么尾数就确定了：011 0011 0000 0000 0000 0000</p>
</blockquote>
<blockquote>
<p>基数求法：不需要求，为2</p>
</blockquote>
<blockquote>
<p>指数求法：采用EXCESS系统进行求解。因为指数部分有正有负，因此采用中间基准来规避符号位。比如单精度的指数位数为8位，无符号数最大表示为1111 1111 = 255  因此采用中间基准 255 / 2 = 127  </p>
<p>0111 1111 作为中间基准。如果指数部分为 1111 1111 那么需要减去 0111 1111 表示为128 ，如果指数部分为0000 0000 那么需要减去0111 1111 表示为-127</p>
<p>比如上面的11.1875为了得到整数部分只有1，无符号向右移动了3位，那么其指数部分为 3 + 127 =</p>
<p>​       0000 0011</p>
<p>+     0111 1111 </p>
<p>​       1000 0010</p>
</blockquote>
<blockquote>
<p>综上，11.1875用二进制数表示为 <u>0</u> <u>1000 0010</u> <u>011 0011 0000 0000 0000 0000</u></p>
</blockquote>
</blockquote>
<h2 id="常用机器语言指令"><a href="#常用机器语言指令" class="headerlink" title="常用机器语言指令"></a>常用机器语言指令</h2><blockquote>
<table>
<thead>
<tr>
<th>MOV 复制</th>
<th>ADD 加法</th>
<th>ANL 与</th>
<th>JMP 跳转指令</th>
</tr>
</thead>
<tbody><tr>
<td>PUSH 压入</td>
<td>SUBB 减法</td>
<td>ORL 或</td>
<td>ACALL 短调用</td>
</tr>
<tr>
<td>POP 弹出</td>
<td>MUL 乘法</td>
<td>XRL 异或</td>
<td>LCALL 长调用</td>
</tr>
<tr>
<td>XCH 交换</td>
<td>DIV 除法</td>
<td></td>
<td>RET 返回</td>
</tr>
<tr>
<td>INC 加1</td>
<td></td>
<td></td>
<td>CALL 调用</td>
</tr>
<tr>
<td>DEC 减1</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>指令的跳转调用的是jump指令，一旦跳转后就不需要返回了，而函数的跳转调用的是CALL指令和RET指令的组合。当函数被调用时，调用CALL指令跳转到函数执行的起始地址，当函数执行完毕，需要调用RET指令返回到原来的调用点，执行调用点的下一条指令。</p>
<p><img src="/images/CALL%E5%92%8CRET%E6%8C%87%E4%BB%A4.png"></p>
</blockquote>
<h2 id="求余"><a href="#求余" class="headerlink" title="求余"></a>求余</h2><blockquote>
<p>这部分经常遇到，也经常忘记。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于同号的的，没有什么好说的： <span class="number">10</span> % <span class="number">3</span> = <span class="number">1</span>   -<span class="number">10</span> % (-<span class="number">3</span>) = -<span class="number">1</span></span><br><span class="line">而对于异号的，如 -<span class="number">10</span> % <span class="number">3</span>   <span class="number">10</span> % -<span class="number">3</span>  求余过程为：</span><br><span class="line">    两个操作取绝对值进行求余计算，如果能整除，则结果为<span class="number">0</span></span><br><span class="line">    如果不能整除，则要进行如下计算：a % b = (|a|/|b| + <span class="number">1</span>) × b + a 计算得到结果</span><br><span class="line">    比如 -<span class="number">10</span> % <span class="number">3</span> = (<span class="number">10</span> / <span class="number">3</span> + <span class="number">1</span>) × <span class="number">3</span> + (-<span class="number">10</span>) = <span class="number">2</span></span><br><span class="line">    <span class="number">10</span> % -<span class="number">3</span> = (<span class="number">10</span> / <span class="number">3</span> + <span class="number">1</span>)×(-<span class="number">3</span>) + <span class="number">10</span> = -<span class="number">2</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="内存，或者称为主存"><a href="#内存，或者称为主存" class="headerlink" title="内存，或者称为主存"></a>内存，或者称为主存</h2><blockquote>
<p>主存通过控制芯片等与CPU相连，主要负责存储指令和数据。在主存中，每个字节都有一个地址编号，CPU可以通过该地址读取主存中的指令和数据，或者写入数据。</p>
<p>前面说过，CPU和主存都是通过IC构成的，通常主存的IC引脚可以分为如下几部分：电源、地址引脚、数据引脚、控制引脚。</p>
<p><img src="/images/%E5%86%85%E5%AD%98IC.png"></p>
<p>VCC和GND为电源引脚：为内存IC提供电源</p>
<p>A0~A9为地址引脚(Address)：指定数据存储的场所</p>
<p>D0~D7为数据引脚：写入数据或读取数据</p>
<p>RD和WR为控制引脚：WR为写入信号，WR=1时有效；RD为读取信号，RD=1时有效；WR=0且RD=0时，读取和写入无法进行；WR=1且RD=1时，意味着可读可写。</p>
<p>内存存储的数据量计算：（数据信号引脚数量 / 8）× (地址信号引脚表示的地址数量)</p>
<p>例如上图的内存能存储的数据量：(8 / 8) × (2^10) = 1024B = 1KB </p>
<p>​                                                          (D0<del>D7)  (A0</del>A9)</p>
<p>因此要增大内存可存储数据量，可以增多引脚或者使用多个内存IC。</p>
<p><strong>通常而言，我们从内存中读取的为数据类型。比如byte, short, int, long, float, double等。数据类型是一个抽象的概念，其实内存并不知道数据类型，它只知道读取字节。而数据类型出现的原因是，程序中我们需要不同范围大小和不同类型的数据，因此，需要数据类型来满足需求。但也只是每次读取的字节数不同，byte每次读取1字节，int每次读取4字节，double每次读8字节。</strong></p>
<p><strong>指针也是一种变量，为4字节，保存内存的地址，我们可以通过内存地址读取出内存中该地址中的数据。为了区分数据类型和指针，需要再指针加一个*，变成这样：*pointer  然后还需要指定读取的数据类型，你是要取出内存地址中4个字节的数据还是1个字节的数据，你得指明，因此指针的最终写法为 ：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">数据类型 *p</span><br></pre></td></tr></table></figure>

<h4 id="内存与数组"><a href="#内存与数组" class="headerlink" title="内存与数组"></a>内存与数组</h4><p>如果数组为1字节的数据类型，它的构造和内存的物理构造完全一致。但为了方便读写内存，只能逐个读取字节，程序会变得比较繁琐。因此可以指定任意数据类型定义数组。</p>
</blockquote>
<h2 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h2><blockquote>
<p>磁盘的物理结构：磁盘是通过其物理表明划分成多个空间来使用。划分的方式有扇区方式和可变长方式两种。扇区方式将磁盘划分成固定长度的空间，而可变长方式则将磁盘划分成长度可变的空间。</p>
<p>大部分磁盘采用的是扇区的方式划分磁盘。扇区划分方式中，把磁盘表面分成若干个同心圆的空间就是磁道，而把磁道按照固定大小长度划分成的空间就是扇区。</p>
<p><img src="/images/%E7%A3%81%E7%9B%98%E5%88%92%E5%88%86.png"></p>
<p>一般而言，一个扇区大小为512字节，也就是说无论文件多小，只要文件有内容，且不超过512字节，那么它就会占据512字节的磁盘空间。</p>
<p>而且通过图我们可以很容易看出，外圈磁道拥有更多的扇区。</p>
</blockquote>
<h2 id="哈夫曼压缩算法"><a href="#哈夫曼压缩算法" class="headerlink" title="哈夫曼压缩算法"></a>哈夫曼压缩算法</h2><blockquote>
<p>压缩：压缩后的数据能复原的是可逆压缩，无法复原的是非可逆压缩</p>
<p>RLE(Run Length Encoding行程长度编码)压缩算法：数据 × 重复次数 。比如：</p>
<p>AAAAAA BB C DD EEEEE F 17个字符，经过RLE压缩后为：A6B2C1D2E5F1 12字符</p>
<p>压缩比为：12 / 17 × 100% = 70%</p>
<p>RLE压缩算法常用于压缩传真的图像，缺点是：当文件连续的重复字符较少时，压缩率不高，甚至可能增大文件大小，达成负的压缩率。</p>
<blockquote>
<p>哈夫曼压缩算法为：先将文件中字符出现的频率由高到低进行排序，然后从低频率的字符开始拼接成二叉树，位于左枝的边为0，位于右枝的边为1。</p>
<p>比如：AAAAAA BB C DD EEEEE F</p>
<p>统计后：A(6) E(5) B(2) D(2) C(1) F(1)，然后有如下过程：</p>
<p><img src="/images/%E5%93%88%E5%A4%AB%E6%9B%BC%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B.png"></p>
<p>从而得到字符的编码：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>E</td>
<td>01</td>
</tr>
<tr>
<td>B</td>
<td>100</td>
</tr>
<tr>
<td>D</td>
<td>101</td>
</tr>
<tr>
<td>C</td>
<td>110</td>
</tr>
<tr>
<td>F</td>
<td>111</td>
</tr>
</tbody></table>
<p>从而 AAAAAA BB C DD EEEEE F变为 000000 100100 110 101101 0101010101 111  34bit 5字节</p>
<p>假设一个字符为1字节，那么压缩率为：5 / 17 = 29.41% 贼小</p>
</blockquote>
</blockquote>
]]></content>
      <tags>
        <tag>计算机, 程序</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络之基本概述</title>
    <url>/2020/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>网络协议类似于人类协议，除了交换报文和采取动作的实体是通过设备的硬件或软件组件。在因特网中，凡是涉及到两个及两个以上远程通信实体的活动都要受到协议的制约。</p>
<p>比如，在两台物理上连接的计算机中，硬件实现的协议控制了两块网络接口卡间的比特流；在计算机端系统中，拥塞控制协议控制了发送方和接受方之间传输的分组发送的速率；在web应用中，HTTP协议控制了请求报文格式，响应报文格式，当客户端向web服务器发送一条连接请求报文，等待回答，而web服务器在收到连接请求报文后，要返回一条连接响应报文。</p>
<p>从上述例子可知，网络协议可定义成如下语句：</p>
<p><em>协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送或接收一条报文或其他事件所采取的动作。</em></p>
<span id="more"></span>

<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p>和因特网相连的计算机和其他设备都位于因特网中的“端点”，即因特网的边缘，所以也通常被称为端系统。因特网的端系统包括桌面计算机和移动计算机，以及越来越多的其他类型设备，比如共享单车等。</p>
<p>端系统也称为主机，因为它们容纳应用程序。所以，主机和端系统是两个相等的概念。而主机有时会被进一步划分成两类：<strong>客户(client)</strong> 和 <strong>服务器(server)</strong> 。客户大约等同于桌面PC、移动PC和智能手机等，而服务器则大约等同于强大的及其，用于存储和发布web页面、流视频等。</p>
<h2 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h2><p>接入网则是将端系统连接到<strong>边路由器</strong>的物理链路。边路由器是端系统到任何其他远程端系统路径上的第一台路由器。</p>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>网络核心，即由互联网端系统分组交换机和链路构成的网状网络。</p>
<p><img src="/images/%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83.png"></p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>在各种网络应用中，端系统彼此间交换**报文(message)**。报文能够包含协议设计者需要的任何东西。</p>
<p>为了从源端系统向目的端系统发送一个报文，源端系统会将报文划分成较小的数据块，称之为<strong>分组(packet)<strong>。在源端系统和目的端系统间，每个分组都会通过通信链路和</strong>分组交换机(packet switch) 主要包括路由器和链路层交换机</strong>进行传输。</p>
<p>因此，分组的传输速率和通信链路的传输速率有关，比如一个分组有 L 比特，链路的传输速率为 R比特/秒 ，则传输该分组的理论时间为 L/R 秒。</p>
<h4 id="存储转发"><a href="#存储转发" class="headerlink" title="存储转发"></a>存储转发</h4><p>多数分组交换机在链路的输入端使用**存储转发传输(store and forward transmission)**机制。存储转发机制是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。  </p>
<p><img src="/images/%E4%BC%A0%E8%BE%93%E7%AD%89%E5%BE%85%E6%9C%BA%E5%88%B6.png"></p>
<p>比如上述这个例子，源端系统要发送4个分组，该路由器（交换机）的任务就是将一个分组交换到一条出链路。当在某个时刻，源端系统传输了分组1的一部分（假设为分组1），分组1的前沿部分已经到达了路由器，但是因为该路由器应用了存储转发机制，所以这时候它还不能传输已经接收的比特，而是必须先缓存分组1已经达到路由器的比特，只有当路由器接收完分组1的所有比特，它才会向出链路传输该分组，目的端系统才能接收到分组数据。</p>
<p>由于存储转发机制的存在，该机制也会产生一定的时延，称该时延为存储转发时延。</p>
<h4 id="排队时延和分组丢失"><a href="#排队时延和分组丢失" class="headerlink" title="排队时延和分组丢失"></a>排队时延和分组丢失</h4><p>每个分组交换机有多条链路与之相连，而对于每条相连的链路，分组交换机具有一个**输出缓存(output buffer)**（也称为 **输出队列(output queue)**），用于存储路由器出链路的分组。</p>
<p>输出缓存在分组交换中有着重要的作用。如果到达的分组需要传输到某条链路，但是发现该链路正忙于传输其他分组，那么该到达的分组必须在该输出缓存中等待。因此，除了存储转发时延外，分组还会有输出缓存的**排队时延(queue delay)**。</p>
<p>因为缓存空间的大小是有限的，因此，一个分组到达路由器时，有可能缓存已经被其他等待传输的分组占满了。此情况下，就会出现**分组丢失(packet lost)**，到达的分组或者排队的分组之一就会被丢弃。</p>
<h4 id="转发表和路由选择协议"><a href="#转发表和路由选择协议" class="headerlink" title="转发表和路由选择协议"></a>转发表和路由选择协议</h4><p>路由器从与它相连的一条通信链路得到分组，向另一条与它相连的通信链路转发。路由器如何选择转发分组的链路？</p>
<p>分组的首部都会包含目的端系统的IP地址。当一个分组到达网络中的路由器时，路由器检查该分组的目的地址，根据该目的地址（或者目的地址一部分）搜索**转发表(forwarding table)**，以发现合适的出链路，然后将该分组导向该出链路。</p>
<p>而转发表的设置则是由**路由选择协议(routing protocol)**来完成。路由选择协议可以决定从每台路由器到每个目的地的最短路径，并使用这些最短路径结果来配置路由器的转发表。</p>
<h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><p>主要包括：**节点处理时延(nodal procession delay)、排队时延(queuing delay)、传输时延(transmission delay)、传播时延(propagation delay)**。</p>
<ol>
<li>处理时延。检查分组首部和决定将分组导向相应链路所需要的时间。</li>
<li>排队时延。分组在链路上等待传输时所需要的时间。该时延大小取决于正在排队等待向链路传输的分组数量。</li>
<li>传输时延。将分组所有的比特发送到链路所需要的时间。</li>
<li>传播时延。分组数据从链路起点到达下一个节点传播所需要的时间。</li>
</ol>
<h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>**电路交换(circuit switching)**在电路交换网络中，会预留端系统会话期间通信沿路径所需要的资源（缓存，链路传输速率）。在分组交换网络中，这些资源是不预留的。</p>
<p>传统的电话网络是电路交换网络的例子。考虑当一个人通过电话网向另一个人发送信息所发生的情况。在发送方能够发送信息之前，该网络必须在发送方和接收方间建立一条连接，并且沿着发送方和接收方上的交换机都会为该连接维护连接状态。用电话的术语来说，该连接被称为一条**电路(circuit)*<em>。当网络创建这种电路时，也会在连接期间在该网络链路上预留恒定的传输速率，因此，发送方能够以</em>确保*的恒定速率向接收方传送数据。</p>
<h4 id="电路交换网络中的复用"><a href="#电路交换网络中的复用" class="headerlink" title="电路交换网络中的复用"></a>电路交换网络中的复用</h4><p>链路中的电路通过<strong>频分复用(Frequency-Division Multiplexing FDM)</strong> 或 <strong>时分复用(Time-Division Multiplexing TDM)</strong> 实现。对于频分复用FDM，链路的频谱由跨越链路创建的所有连接所共享。特别是，在连接期间链路为每条连接专用一个频段，该频段的宽度称为**带宽(bandwidth)**。</p>
<p>对于时分复用TDM，链路的时间被划分为固定区间的帧，并且每帧又被划分成固定数量的间隙。当网络跨越一条链路创建一条连接时，网络在每个帧中为该连接指定一个时隙。这些时隙专门由该连接单独使用，连接在一个时隙（在每个帧内）可用于传输该连接的数据。</p>
<p><img src="/images/FDM%E5%92%8CTDM.png"></p>
<blockquote>
<p>假设从主机A到主机B经过一个电路交换网络发送一个64000比特的文件。加入在该网络中链路使用24时隙的TDM，具有1.536Mbps的比特速率。同时假定主机A在开始传输该文件时，需要500ms去创建一条端到端电路。那么传输文件的时间可以进行如下计算：</p>
<p>每条链路具有的传输速率是：1.536Mbps/24 = 64kbps</p>
<p>传输文件时间：640kb / 64kbps = 10s 再加上电路创建的时间，时间就变为10.5秒</p>
<p>该传输时间和链路数量无关：不管端到端的电路是一条链路还是100条链路，传输时间都是10秒</p>
</blockquote>
<h4 id="分组交换和电路交换的对比"><a href="#分组交换和电路交换的对比" class="headerlink" title="分组交换和电路交换的对比"></a>分组交换和电路交换的对比</h4><p>举一个例子：</p>
<p>假定多个用户共享一条1Mbps链路，用户时而以100kbps恒定速率产生数据，时而不产生数据，并且用户只有10%时间活跃。因此，对于电路交换而言，在所有时间内，必须为每个用户预留100kbps，比如对于TDM类型的电路交换，如果一个1s的帧被划分成10个时隙，每个时隙100ms，则每帧将为每个用户分配一个时隙。那么，该电路交换链路仅能支持10（1Mbps/100kbps）个并发用户。而对于分组交换而言，有11个或更多并发活跃用户的概率大概是0.0004，有10个或更少并发用户的概率是0.9996。因此，当有10个或更少活跃用户时，到达的聚合数据率小于等于该链路的输出速率1Mbps。当同时活跃用户超过10个时，分组的聚合到达率超过该链路的输出容量，输出队列将会开始变长，但是这个概率极小，所以，某种程度上，分组交换差不多提供了和电路交换相同的性能。</p>
<p>现考虑第二个简单例子。假定就只有10个用户，某个用户突然产生了1000个1000比特分组，而其他用户保持沉默，不产生分组。那么在每帧具有10个时隙并且每个时隙包含1000比特的TDM电路交换情况下，活跃用户仅能使用每帧中的一个时隙来传输数据，而剩余的9个时隙保持空闲。该活跃用户传输完10万个比特的数据需要10s的时间。而在分组交换情况下，活跃用户能够连续地以1Mbps的全部链路速率发送其分组，因为没有其他用户产生分组域该活跃用户的分组进行复用。在此情况下，该活跃用户的所有数据将在1s内发送完毕。</p>
<h2 id="网络协议层次"><a href="#网络协议层次" class="headerlink" title="网络协议层次"></a>网络协议层次</h2><p><img src="/images/%E5%8D%8F%E8%AE%AE%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.png"></p>
<ol>
<li><p>应用层。应用层是网络应用程序及它们的应用层协议存留的地方。应用层包括许多协议，如HTTP协议（提供web文档的请求和传送）、SMTP协议（提供电子邮件报文的传输）、FTP协议（提供端系统间的文件传送）</p>
<p>一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息的分组，我们称之为<strong>报文(message)</strong></p>
</li>
<li><p>传输层。传输层在应用程序断点之间传送应用层报文。非常重要的两个协议TCP和UDP协议都能够完成应用层报文的传输。TCP提供面向连接的服务，能够确保应用层报文向目的端系统的传递和流量控制，并且将长报文划分成短报文，提供拥塞控制机制，当网络拥塞时，控制器传输速率。UDP则提供无连接服务，没有可靠性，没有流量控制，也没有拥塞控制。传输层的分组一般称为<strong>报文段(segment)</strong></p>
</li>
<li><p>网络层。网络层的分组称为**数据报(datagram)**。网络层负责将数据报从一台主机移动到另一台主机。极其重要的一个网络层协议就是IP协议，该协议定义了数据报各个字段的含义，让端系统和路由器知道如何读取这些字段。</p>
</li>
<li><p>链路层。网络层通过源端系统和目的端系统之间的路由器将分组从一个节点移动到下一个节点，而这必须依靠链路层的服务。特别是在每个节点，网络层将数据报下传给链路层，链路层沿着庐江将数据报传递给下个节点。而在下个节点中，链路层又会将数据报上传给网络层。链路层的分组我们称之为<strong>帧(frame)</strong></p>
</li>
<li><p>物理层。物理层的任务就是将帧的一个一个比特从一个节点移动到另一个节点，和实际的链路有关（双绞铜线、光纤等）。</p>
</li>
</ol>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><img src="/images/%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png"></p>
]]></content>
      <tags>
        <tag>计算机网络, 基本概述</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络之网络层</title>
    <url>/2020/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<h2 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h2><h3 id="客户-服务器"><a href="#客户-服务器" class="headerlink" title="客户-服务器"></a>客户-服务器</h3><p>在<strong>客户-服务器体系结构(client-server architecture)<strong>中，有一个总是打开的主机称为</strong>服务器</strong>，它服务于数量庞大的称为<strong>客户</strong>的主机的请求。比如web服务器，当web服务器接收到来自某客户对某个资源的请求时，它就向该客户发送所请求的资源作为响应。</p>
<p>在客户-服务器体系结构中，有两个显著的特征：</p>
<ol>
<li>客户相互之间不直接通信</li>
<li>服务器具有固定的、为人所知的IP地址</li>
</ol>
<p>并且，服务器总是打开的，因此，客户总能通过向该服务器的IP地址发送分组来与其联系。</p>
<p>客户-服务器体系结构的另一个特点就是服务供应商需要支付带宽费用。通常服务器的体系结构通过会配备大量主机的数据中心，用于创建强大的虚拟服务器。一个数据中心需要有数十万台服务器，这些服务器必须要供电以及维护，还要有大量的带宽来发送和接收来自数据中心的数据。</p>
<span id="more"></span>

<h3 id="客户-客户"><a href="#客户-客户" class="headerlink" title="客户-客户"></a>客户-客户</h3><p><strong>客户-客户体系结构</strong>也称为**P2P(P2P architecture)*<em>。在P2P体系结构中，没有服务器依赖，应用程序在间断连接的主机对之间直接通信，这些主机对称为</em>对等方*。许多目前流行的、流量密集型的应用都是P2P体系结构，比如：对等方协助下载加速器（迅雷）、因特网电话（Skype）、IPTV（迅雷看看）等。需要注意的是，某些应用具有混合体系结构，结合了客户-服务器和P2P的元素。比如对于许多即时通讯应用而言，服务器被用于跟踪用户的IP地址，但用户到用户的报文在用户主机之间直接发送，没有经过服务器。</p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>网络层中，进行通信的实际上是**进程(process)**而不是程序。一个进程可以被认为是运行在端系统中的一个程序。当进程运行在相同的端系统上时，使用进程间的通信机制相互通信，通信的规则由端系统上的操作系统确定，这不是这里讨论的重点。这里只关注不同端系统上的进程间的通信。</p>
<p>在两个不同端系统上的进程，通过计算机网络交换报文而相互通信。发送进程生成并向网络中发送报文；接收进程接收这些报文并通过将报文发送回去进行响应。</p>
<h3 id="进程与计算机网络间的接口"><a href="#进程与计算机网络间的接口" class="headerlink" title="进程与计算机网络间的接口"></a>进程与计算机网络间的接口</h3><p>多数应用程序是由通信进程对组成，每对进程相互发送报文。从一个进程向另一个进程发送的报文必须通过底层的网络体系。进程通过一个称为**套接字(socket)**的软件接口向网络发送报文和从网络接收报文。</p>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6.png"></p>
<p>如图所示，由于套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络间的**应用程序编程接口(Application Programming Interface)**。应用程序开发者可以控制套接字在应用层中的表现，但是对该套接字的传输层端几乎没有控制权。应用程序开发者对传输层的控制仅限于：</p>
<ol>
<li>选择传输层协议</li>
<li>设定几个传输层参数，如最大缓存和最大报文段长度等</li>
</ol>
<h3 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h3><p>在一台主机上运行的进程为了向另一台主机上运行的进程发送分组，接收进程需要有一个地址，为了标识该接收进程，需要定义两种信息：</p>
<ol>
<li>主机的地址</li>
<li>定义在目的主机中的接收进程的标识符(端口号)</li>
</ol>
<h2 id="选择应用程序的传输服务"><a href="#选择应用程序的传输服务" class="headerlink" title="选择应用程序的传输服务"></a>选择应用程序的传输服务</h2><p>很多网络提供了不止一种的传输层协议。当开发一个应用时，必须选择一种可用的传输层协议。如何选择？这需要根据传输层协议提供的服务以及应用程序的功能来进行综合考虑。</p>
<h3 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h3><p>TCP服务模型包括面向连接服务和可靠数据传输服务。当某个应用程序调用TCP作为其传输层协议时，该应用程序就能获得来自TCP的这两种服务。</p>
<ol>
<li>面向连接的服务。在应用层数据报文开始流动之前，TCP让客户和服务器互相交换传输层控制信息。通过握手过程提示客户和服务器，使他们为分组的到来做好准备。握手阶段过后，一个TCP连接就在两个进程的套接字间建立了。这条连接是全双工的，即连接双方的进程可以在此连接上同时进行报文收发。当应用程序结束报文发送时，必须拆除该连接。</li>
<li>可靠的数据传送服务。通信进程能够依靠TCP，无差错、按顺序交付所有发送的数据，没有字节的丢失和冗余。</li>
</ol>
<p>TCP还拥有拥塞控制机制，这种服务不一定能为通信进程带来直接好吃，但能为整体互联网络带来整体好处。</p>
<h3 id="UDP服务"><a href="#UDP服务" class="headerlink" title="UDP服务"></a>UDP服务</h3><p>UDP是一种不提供不必要服务的轻量级传输协议，它仅提供最小服务。UDP是无连接的，因此在两个进程通信前没有握手过程；UDP提供尽最大努力交付的服务，不能够保证将报文按序、完整地传送到接收进程。</p>
<h2 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h2><p>**超文本传输协议(HyperText Transfer Protocol, HTTP)**协议，是web的核心。HTTP协议定义了客户与服务器间会话的报文结构以及进行报文交换的方式。</p>
<p><img src="/images/%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8.png"></p>
<p>HTTP使用TCP作为其传输层协议支持。HTTP客户首先发起一个与服务器的TCP连接，一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问TCP。客户向它的套接字接口发送HTTP请求报文，并从它的套接字接口接收HTTP响应报文。类似地，服务器从它的套接字接口接收HTTP请求报文和向它的套接字接口发送HTTP响应报文。一旦客户向它的套接字接口发送了一个请求报文，该报文就脱离了客户控制，并进入TCP的控制。而TCP提供可靠的数据传输服务，这意味着客户进程发送的每个HTTP请求报文都能最终完整地到达服务器。</p>
<p>需要注意的HTTP一个重要特点就是：**HTTP是一个无状态协议(stateless protocol)**。服务器向客户发送被请求的文件，而不会存储任何关于该客户的状态信息。</p>
<h3 id="非持续连接和持续连接的HTTP协议"><a href="#非持续连接和持续连接的HTTP协议" class="headerlink" title="非持续连接和持续连接的HTTP协议"></a>非持续连接和持续连接的HTTP协议</h3><p>**非持续连接(non-persistent connection)**：每个请求/响应对经过一个单独的TCP连接发送</p>
<p>**持续连接(persistent connection)**：所有请求/响应都经过相同的TCP连接发送</p>
]]></content>
      <tags>
        <tag>网络层, 计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList &amp; LinkedList源码解析</title>
    <url>/2020/08/31/ArrayList&amp;LinkedList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>ArrayList &amp; LinkedList源码解析，基于JDK1.8</p>
<span id="more"></span>

<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList实现了List接口的所有方法，可以看成是“长度可调节的数组”，可以包含任何类型数据（包括null，可重复）。ArrayList大体和Vector一致，唯一区别是ArrayList非线程安全，Vector线程安全，但Vector线程安全的代价较大，推荐使用CopyOnWriteArrayList，后面文章再做记录。</p>
<h3 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h3><p>ArrayList类层级关系如下图所示：</p>
<p><img src="/images/ArrayList%E7%B1%BB%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.png"></p>
<p>ArrayList额外实现了RandomAccess接口，关于RandomAccess接口的作用下面再做讨论。</p>
<p>ArrayList类主要包含如下两个成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>elementData为Object类型数组，用于存放ArrayList数据；size表示数组元素个数（并非数组容量）。</p>
<p>ArrayList类还包含了一些常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 数组默认初始化容量为10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 表示空数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 也是空数组，和EMPTY_ELEMENTDATA区分开</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h3><p>Arrays类的<code>copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType)</code>方法用于复制指定数组original到新数组，新数组的长度为newLength，新数组元素类型为newType。</p>
<ol>
<li>如果新数组的长度大于旧数组，那么多出的那部分用null填充；</li>
<li>如果新数组的长度小于旧数组，那么少的那部分直接截取掉。</li>
</ol>
<p>举两个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Long[] array1 = <span class="keyword">new</span> Long[]&#123;<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>&#125;;</span><br><span class="line">Object[] array2 = Arrays.copyOf(array1, <span class="number">5</span>, Object[].class);</span><br><span class="line">System.out.println(Arrays.toString(array2)); <span class="comment">// [1, 2, 3, null, null]</span></span><br><span class="line"></span><br><span class="line">Object[] array3 = Arrays.copyOf(array1, <span class="number">1</span>, Object[].class);</span><br><span class="line">System.out.println(Arrays.toString(array3)); <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>

<p>重载方法<code>copyOf(T[] original, int newLength)</code>用于复制指定数组original到新数组，新数组的长度为newLength，新数组元素类型和旧数组一致。</p>
<p><code>copyOf</code>方法内部调用System类的native方法<code>arraycopy(Object src, int srcPos,Object dest, int destPos, int length)</code>：</p>
<ol>
<li><code>src</code>：需要被拷贝的旧数组；</li>
<li><code>srcPos</code>：旧数组开始拷贝的起始位置；</li>
<li><code>dest</code>：拷贝目标数组；</li>
<li><code>destPos</code>：目标数组的起始拷贝位置；</li>
<li><code>length</code>：拷贝的长度。</li>
</ol>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Long[] array1 = <span class="keyword">new</span> Long[]&#123;<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>&#125;;</span><br><span class="line">Object[] array2 = <span class="keyword">new</span> Object[<span class="number">5</span>];</span><br><span class="line">System.arraycopy(array1, <span class="number">0</span>, array2, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(Arrays.toString(array2)); <span class="comment">// [1, 2, 3, null, null]</span></span><br></pre></td></tr></table></figure>

<p>指定位置插入元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Long[] array1 = <span class="keyword">new</span> Long[]&#123;<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">System.arraycopy(array1, index, array1, index + <span class="number">1</span>, <span class="number">3</span> - index);</span><br><span class="line">array1[index] = <span class="number">0L</span>;</span><br><span class="line">System.out.println(Arrays.toString(array1)); <span class="comment">// [1, 0, 2, 3, null, null]</span></span><br></pre></td></tr></table></figure>

<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><code>public ArrayList(int initialCapacity)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建容量大小为initialCapacity的ArrayList，如果initialCapacity小于0，则抛出IllegalArgumentException异常；如果initialCapacity为0，则elementData为EMPTY_ELEMENTDATA。</p>
<p><code>public ArrayList()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空参构造函数，elementData为DEFAULTCAPACITY_EMPTY_ELEMENTDATA。</p>
<p><code>public ArrayList(Collection&lt;? extends E&gt; c)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个包含指定集合c数据的ArrayList。上面为什么要多此一举使用<code>Arrays.copyOf(elementData, size, Object[].class)</code>复制一遍数组呢？这是因为在某些情况下调用集合的toArray()方法返回的类型并不是Object[].class，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Long[] array1 = &#123;<span class="number">1L</span>, <span class="number">2L</span>&#125;;</span><br><span class="line">List&lt;Long&gt; list1 = Arrays.asList(array1);</span><br><span class="line">Object[] array2 = list1.toArray();</span><br><span class="line">System.out.println(array2.getClass() == Object[].class); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">List&lt;Long&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">System.out.println(list2.toArray().getClass() == Object[].class); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h4><p><code>add(E e)</code>用于尾部添加元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于确定数组容量</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如现在我们通过如下代码创建了一个ArrayList实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>内部过程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于确定数组容量，e=hello，size=0</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 末尾添加元素，然后size递增1</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123; <span class="comment">// minCapacity=1,elementData=&#123;&#125;</span></span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">// DEFAULT_CAPACITY=10，minCapacity=1，故返回10</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123; <span class="comment">// minCapacity=10</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// minCapacity=10，elementData.length=0，所以调用grow方法扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123; <span class="comment">//minCapacity=10</span></span><br><span class="line">    <span class="comment">// oldCapacity=0</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// newCapacity为oldCapacity的1.5倍，这里为0</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// newCapacity=0，minCapacity=10，所以该条件成立</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// newCapacity=10</span></span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 复制到新数组，数组容量为10</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">// MAX_ARRAY_SIZE常量值为Integer.MAX_VALUE - 8，通过</span></span><br><span class="line">    <span class="comment">// 这段逻辑我们可以知道，ArrayList最大容量为Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面源码分析我们可以知道：</p>
<ol>
<li>任何一个空的ArrayList在添加第一个元素时，内部数组容量将被扩容为10；</li>
<li>扩容时，newCapacity为oldCapacity的1.5倍；</li>
<li>数组容量最大为Integer.MAX_VALUE；</li>
<li>尾部添加元素不用移动任何元素，所以速度快。</li>
</ol>
<h4 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h4><p><code>add(int index, E element)</code>用于在指定位置添加元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下标检查</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 确定数组容量，和上面add(E e)方法介绍的一致</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将原来index后面的所有元素往后面移动一个位置</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    <span class="comment">// index处放入新元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// size递增</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下标比size大或者下标小于0，都会抛出下标越界异常</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及到元素移动，所以速度较慢。</p>
<h4 id="get-int-index"><a href="#get-int-index" class="headerlink" title="get(int index)"></a>get(int index)</h4><p><code>get(int index)</code>获取指定位置元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下标合法性检查</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 直接返回数组指定位置元素</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>get</code>方法直接返回数组指定下标元素，速度非常快。</p>
<h4 id="set-int-index-E-element"><a href="#set-int-index-E-element" class="headerlink" title="set(int index, E element)"></a>set(int index, E element)</h4><p><code>set(int index, E element)</code>设置指定位置元素为指定值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下标合法性检查</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 根据下标获取旧值</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">// 设置新值</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 返回旧值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>set</code>方法不涉及元素移动和遍历，所以速度快。</p>
<h4 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h4><p><code>remove(int index)</code>删除指定位置元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 获取指定位置元素（需要被删除的元素）</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 直接将index后面的元素往前移动一位，覆盖index处的元素</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="comment">// 返回被删除的元</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法涉及到元素移动，所以效率也不高。</p>
<h4 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h4><p><code>remove(Object o)</code>删除指定元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历数组，找到第一个目标元素，然后删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 逻辑和remove一致，都是将index后面的元素往前移动一位，覆盖index处的元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法涉及到数组遍历和元素移动，效率也不高。</p>
<h4 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize()"></a>trimToSize()</h4><p><code>trimToSize()</code>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">          ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法用于将数组容量调整为实际元素个数大小，当一个ArrayList元素个数不会发生改变时，可以调用该方法减少内存占用。</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="类结构-1"><a href="#类结构-1" class="headerlink" title="类结构"></a>类结构</h3><p>LinkedList底层采用双向链表结构存储数据，允许重复数据和null值，长度没有限制：</p>
<p><img src="/images/LinkedList%E7%B1%BB%E7%BB%93%E6%9E%84.png"></p>
<p>每个节点用内部类Node表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Node节点包含item（存储数据），next（后继节点）和prev（前继节点）。数组内存地址必须连续，而链表就没有这个限制了，Node可以分布于各个内存地址，它们之间的关系通过prev和next维护。</p>
<h3 id="LinkedList类关系图："><a href="#LinkedList类关系图：" class="headerlink" title="LinkedList类关系图："></a>LinkedList类关系图：</h3><p><img src="/images/LinkedList%E7%B1%BB%E5%85%B3%E7%B3%BB.png"></p>
<p>可以看到LinkedList类并没有实现RandomAccess接口，额外实现了Deque接口，所以包含一些队列方法。</p>
<p>LinkedList包含如下成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素个数，默认为0</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示第一个节点，第一个节点必须满足(first == null &amp;&amp; last == null) || (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示最后一个节点，最后一个节点必须满足(first == null &amp;&amp; last == null) || (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>

<h3 id="方法解析-1"><a href="#方法解析-1" class="headerlink" title="方法解析"></a>方法解析</h3><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><p><code>LinkedList()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空参构造函数，默认size为0，每次添加新元素都要创建Node节点。</p>
<p><code>LinkedList(Collection&lt;? extends E&gt; c)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环创建节点，设置prev，next指向</span></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该构造函数用于创建LinkedList，并往里添加指定集合元素。</p>
<h4 id="add-int-index-E-element-1"><a href="#add-int-index-E-element-1" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h4><p><code>add(int index, E element)</code>指定下标插入元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下标合法性检查</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        <span class="comment">// 如果插入下标等于size，说明是在尾部插入，执行尾部插入操作</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果不是尾插入，则在指定下标节点前插入</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取最后一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 创建一个新节点，prev为原链表最后一个节点，next为null</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 更新last为新节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果原链表最后一个节点为null，说明原链表没有节点，将新节点赋给first</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则更新原链表最后一个节点的next为新节点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">// size递增</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 模数递增，用于快速失败</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// succ为原链表指定index位置的节点，获取其prev节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">// 创建新节点，prev为原链表指定index位置的节点的prev节点，next为原链表指定index位置的节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">// 将原链表指定index位置的节点的prev更新为新节点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果链表指定index位置的节点的prev为null，说明原链表没有节点，将新节点赋给first</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则更新原链表指定index位置的节点的prev的next节点为新节点</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    <span class="comment">// size递增</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 模数递增，用于快速失败</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用二分法遍历每个Node节点，直到找到index位置的节点</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码较为简单，无非就是设置节点的prev和next关系。可以看到，除了头插和尾插外，在链表别的位置插入新节点，涉及到节点遍历操作，所以我们常说的链表插入速度快，指的是插入节点改变前后节点的引用过程很快。</p>
<h4 id="get-int-index-1"><a href="#get-int-index-1" class="headerlink" title="get(int index)"></a>get(int index)</h4><p><code>get(int index)</code>获取指定下标元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用二分法遍历每个Node节点，直到找到index位置的节点</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码较为简单，就是通过node函数查找指定index下标Node，然后获取其item属性值，节点查找需要遍历。</p>
<h4 id="set-int-index-E-element-1"><a href="#set-int-index-E-element-1" class="headerlink" title="set(int index, E element)"></a>set(int index, E element)</h4><p><code>set(int index, E element)</code>设置指定下标节点的item为指定值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下标合法性检查</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 获取index下标节点</span></span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    <span class="comment">// 获取旧值</span></span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    <span class="comment">// 设置新值</span></span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="comment">// 返回旧值</span></span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用二分法遍历每个Node节点，直到找到index位置的节点</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，set方法也需要通过遍历查找目标节点。</p>
<h4 id="remove-int-index-1"><a href="#remove-int-index-1" class="headerlink" title="remove(int index)"></a>remove(int index)</h4><p><code>remove(int index)</code>删除指定下标节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>remove(int index)</code>通过node方法找到需要删除的节点，然后调用unlink方法改变删除节点的prev和next节点的前继和后继节点。</p>
<h2 id="RandomAccess接口"><a href="#RandomAccess接口" class="headerlink" title="RandomAccess接口"></a>RandomAccess接口</h2><p>RandomAccess接口是一个空接口，不包含任何方法，只是作为一个标识：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现该接口的类说明其支持快速随机访问，比如ArrayList实现了该接口，说明ArrayList支持快速随机访问。所谓快速随机访问指的是通过元素的下标即可快速获取元素对象，无需遍历，而LinkedList则没有这个特性，元素获取必须遍历链表。</p>
<p>在Collections类的<code>binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)</code>方法中，可以看到RandomAccess的应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当list实现了RandomAccess接口时，调用indexedBinarySearch方法，否则调用iteratorBinarySearch。所以当我们遍历集合时，如果集合实现了RandomAccess接口，优先选择普通for循环，其次foreach；遍历未实现RandomAccess的接口，优先选择iterator遍历。</p>
]]></content>
      <tags>
        <tag>ArrayList, LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Concurrency Lock</title>
    <url>/2020/08/24/Java-Concurrency-Lock/</url>
    <content><![CDATA[<p>Lock锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。</p>
<span id="more"></span>

<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock字面上意思就是可重入锁（又称为递归锁），表示该锁能够支持一个线程对资源的重复加锁。定义一个ReentrantLock：</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock()<span class="comment">;</span></span><br></pre></td></tr></table></figure>



<p>默认无参构造函数创建的是非公平锁，构造函数重载方法<code>ReentrantLock(boolean fair)</code>支持传入<code>true</code>创建公平锁。公平锁的意思是多线程在获取锁的时候是公平的，也就是等待时间最长的线程最优先获取锁，类似FIFO。</p>
<p>使用ReentrantLock可以实现和synchronized一样的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">2</span>).forEach(i -&gt; <span class="keyword">new</span> Thread(ReentrantLockTest::needLock).start());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">needLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始工作&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：确保在finally里释放锁，否则容易造成死锁</strong></p>
<p>上面例子同一时刻只能有一个线程可以获得锁<code>lock</code>，别的线程必须等待锁被释放（<code>unlock</code>）才能开始竞争获取锁。程序运行结果如下所示：</p>
<p><img src="/images/lock%E9%94%81.gif"></p>
<p><code>needLock</code>方法和下面通过synchronized关键字实现锁方法效果是一样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">needLockBySync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (ReentrantLockTest.class) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始工作&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么<code>ReentrantLock</code>又称为递归锁呢？这是因为：一个线程如果获取了某个方法的锁，这个方法内部即使调用了别的需要获取锁的方法，那么这个线程不需要再次等待获取锁，可以直接进去。说着可能有点抽象，下面举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream.rangeClosed(<span class="number">0</span>,<span class="number">1</span>).forEach(i-&gt; <span class="keyword">new</span> Thread(Test::method1, String.valueOf(i)).start());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; invoked method1&quot;</span>);</span><br><span class="line">            method2();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; invoked method2&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span>invoked method1</span><br><span class="line"><span class="symbol">0 </span>invoked method2</span><br><span class="line"><span class="symbol">1 </span>invoked method1</span><br><span class="line"><span class="symbol">1 </span>invoked method2</span><br></pre></td></tr></table></figure>

<p>上面例子中，method1和method2都加了锁，线程0获取到了method1的锁后，内部可以直接调用method2，无需重新获取锁对象。<code>synchronized</code>也具有相同的特性。</p>
<p><code>ReentrantLock</code>可以对一个方法不限次的重复加锁，但解锁次数必须和加锁次数一致，否则锁永远不会被释放，别的线程将无法获取该方法的锁，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream.rangeClosed(<span class="number">0</span>,<span class="number">1</span>).forEach(i-&gt; <span class="keyword">new</span> Thread(Test::method1, String.valueOf(i)).start());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加锁4次</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        lock.lock();</span><br><span class="line">        lock.lock();</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; invoked method1&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 解锁3次</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">            lock.unlock();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85.png"></p>
<p>线程1一直处于WAITING状态，因为线程0加锁了4次，但只释放了3次锁，所以线程1一直无法获取到锁。</p>
<p><code>lock</code>方法是不可被打断的，即调用线程的<code>interrupt</code>方法不起作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(ReentrantLockTest::testLockUnInterruptibly);</span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(ReentrantLockTest::testLockUnInterruptibly);</span><br><span class="line">        thread2.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testLockUnInterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 不可以被打断</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始工作&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p><img src="/images/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%8F%AF%E8%A2%AB%E6%89%93%E6%96%AD.png"></p>
<p>thread2(Thread-1)依旧在继续等待获取锁，没有被打断。</p>
<p>ReentrantLock提供了可打断获取锁的方法<code>lockInterruptibly</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(ReentrantLockTest::testLockInterruptibly);</span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(ReentrantLockTest::testLockInterruptibly);</span><br><span class="line">        thread2.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testLockInterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lockInterruptibly(); <span class="comment">// 可以被打断</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始工作&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%A2%AB%E6%89%93%E6%96%AD.png"></p>
<p>thread2在等待获取锁时被打断，抛出<code>InterruptedException</code>异常。</p>
<p>ReentrantLock的<code>tryLock</code>方法用于尝试获取锁，返回boolean类型，表示获取锁成功与否：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(ReentrantLockTest::testTryLock, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(ReentrantLockTest::testTryLock, <span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始工作&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;没有获取到锁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">thread1开始工作</span><br><span class="line">thread2没有获取到锁</span><br></pre></td></tr></table></figure>

<p>thread1抢到锁后进入死循环，一直不释放锁。thread2尝试获取锁失败后直接放弃。</p>
<p><code>tryLock</code>的重载方法<code>tryLock(long timeout, TimeUnit unit)</code>可以设置尝试获取锁的时间范围，超过这个时间没有获取到锁则返回false。</p>
<p>ReentrantLock一些别的方法：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>getQueueLength()</code></td>
<td align="left">等待获取锁线程数量</td>
</tr>
<tr>
<td align="left"><code>hasQueuedThreads()</code></td>
<td align="left">是否有在等待获取锁的线程</td>
</tr>
<tr>
<td align="left"><code>hasQueuedThread(Thread thread)</code></td>
<td align="left">等待获取锁的线程队列里是包含指定的线程</td>
</tr>
<tr>
<td align="left"><code>isLocked</code></td>
<td align="left">当前锁是否被任意一个线程获取到了</td>
</tr>
</tbody></table>
<h2 id="Spin-Lock"><a href="#Spin-Lock" class="headerlink" title="Spin Lock"></a>Spin Lock</h2><p>JUC中并没有自旋锁对应的类，而所谓的自旋锁就是：尝试获取锁的线程不会马上阻塞，而是采用循环的方式去尝试获取锁。这种方式的好处是可以减少线程上下文切换的消耗，缺点是循环会消耗CPU资源。</p>
<p>我们可以利用CAS实现一个自旋锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AtomicReference&lt;Thread&gt; reference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot;尝试获取锁&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!reference.compareAndSet(<span class="keyword">null</span>, thread)) &#123;</span><br><span class="line">            <span class="comment">// 自旋锁就是利用CAS思想制造循环，block住代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot;获取到了锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        reference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpinLock lock = <span class="keyword">new</span> SpinLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;做某事...&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;做某事...&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出结果：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">线程<span class="number">1</span>尝试获取锁</span><br><span class="line">线程<span class="number">1</span>获取到了锁</span><br><span class="line">线程<span class="number">1</span>做某事...</span><br><span class="line">线程<span class="number">2</span>尝试获取锁</span><br><span class="line">线程<span class="number">1</span>释放锁</span><br><span class="line">线程<span class="number">2</span>获取到了锁</span><br><span class="line">线程<span class="number">2</span>做某事...</span><br><span class="line">线程<span class="number">2</span>释放锁</span><br></pre></td></tr></table></figure>

<h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p>ReadWriteLock为读写锁。ReentrantLock为排他锁，同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p>
<p>简而言之，ReadWriteLock包含读写锁，遵循以下规则：</p>
<ul>
<li>写的时候不能读</li>
<li>写的时候不能写</li>
<li>读的时候不能写</li>
<li>读的时候可以读</li>
</ul>
<p>ReadWriteLock为接口，我们使用它的实现类ReentrantReadWriteLock创建读写锁实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock(<span class="keyword">true</span>);</span><br><span class="line">ReentrantReadWriteLock.ReadLock readLock = lock.readLock();</span><br><span class="line">ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();</span><br></pre></td></tr></table></figure>

<p>使用读写锁创建一个读写的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 读锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.ReadLock readLock = lock.readLock();</span><br><span class="line">    <span class="comment">// 写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();</span><br><span class="line">    <span class="comment">// 存放数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Long&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;writer&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;reader&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeLock.lock(); <span class="comment">// 写锁</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">long</span> value = System.currentTimeMillis();</span><br><span class="line">            data.add(value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入value: &quot;</span> + value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            readLock.lock(); <span class="comment">// 获取读锁</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            String value = data.stream().map(String::valueOf).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读取data: &quot;</span> + value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<p><img src="/images/%E8%AF%BB%E5%86%99%E9%94%81%E6%B5%8B%E8%AF%95.gif"></p>
<p>ReentrantReadWriteLock还包含了一些别的实用方法：</p>
<p><img src="/images/ReentrantReadWriteLock%E5%88%AB%E7%9A%84%E6%96%B9%E6%B3%95.png"></p>
<h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p>JDK8 新增了一个锁StampedLock，它是对ReadWriteLock的改进。</p>
<p>使用ReadWriteLock的时候，当读线程数量远大于写线程数量的时候就会出现“写饥饿”现象。因为锁大概率都被读线程抢走了，写线程很难抢到锁，这将使得读写效率非常低下。</p>
<p>JDK8的StampedLock就是为了解决这个问题而设计的，StampedLock包含<strong>乐观锁</strong>和<strong>悲观锁</strong>：</p>
<ul>
<li>乐观锁：每次去拿数据的时候，并不获取锁对象，而是判断标记位（stamp）是否有被修改，如果有修改就再去读一次。</li>
<li>悲观锁：每次拿数据的时候都去获取锁。</li>
</ul>
<p>通过乐观锁，当写线程没有写数据的时候，标志位stamp并没有改变，所以即使有再多的读线程在读取数据，它们都可以直接去读数据，而无需获取锁，这就不会使得写线程抢不到锁了。</p>
<p>简而言之，stamp类似一个时间戳的作用，每次写的时候对其+1来改变被操作对象的stamp值。</p>
<p>下面通过一个例子来模拟写饥饿的情况：创建20个线程，其中19个线程用于读数据，1个线程用于写数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StampedLock lock = <span class="keyword">new</span> StampedLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Long&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Runnable read = StampedLockTest::read;</span><br><span class="line">        Runnable write = StampedLockTest::write;</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">19</span>).forEach(i -&gt; executorService.submit(read));</span><br><span class="line">        executorService.submit(write);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped = lock.readLock(); <span class="comment">// 获取悲观锁，阻塞写线程</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            String collect = data.stream().map(String::valueOf).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; read value: &quot;</span> + collect);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockRead(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped = lock.writeLock();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">long</span> value = System.currentTimeMillis();</span><br><span class="line">            data.add(value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; write value: &quot;</span> + value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockWrite(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子通过StampedLock调用<code>writeLock</code>、<code>unlockWrite</code>、<code>readLock</code>和<code>unlockRead</code>的时候都会导致StampedLock的stamp值的变化，即每次+1，直到加到最大值，然后从0重新开始。</p>
<p>上面程序运行结果如下：</p>
<p><img src="/images/StampLock%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>
<p>可以看到写线程最后才抢到锁并写入数据。</p>
<p>我们通过乐观锁来改善这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StampedLock lock = <span class="keyword">new</span> StampedLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Long&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Runnable read = StampedLockTest2::read;</span><br><span class="line">        Runnable write = StampedLockTest2::write;</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">19</span>).forEach(i -&gt; executorService.submit(read));</span><br><span class="line">        executorService.submit(write);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped = lock.tryOptimisticRead(); <span class="comment">// 获取乐观锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接读取值</span></span><br><span class="line">        String collect = data.stream().map(String::valueOf).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果戳被改变，方法返回false，说明stamped被修改过了（被write方法修改过了，有新的数据写入），</span></span><br><span class="line">        <span class="comment">// 那么重新获取锁并去读取值，否则直接使用上面读取的值。</span></span><br><span class="line">        <span class="keyword">if</span> (!lock.validate(stamped)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stamped = lock.readLock();</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                collect = data.stream().map(String::valueOf).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlockRead(stamped);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; read value: &quot;</span> + collect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped = lock.writeLock();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">long</span> value = System.currentTimeMillis();</span><br><span class="line">            data.add(value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; write value: &quot;</span> + value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockWrite(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们重点关注<code>read</code>方法。<code>read</code>方法一开始通过调用StampedLock的<code>tryOptimisticRead</code>方法来获取标志位stamp，获取乐观锁并不会真正的去获取锁（所以不会阻塞写操作），然后直接去读数据。接着通过StampedLock的<code>validate</code>方法判断标志位stamp是否被修改了（<code>write</code>方法里会修改标志位的值），如果方法返回true，则说明数据没有被修改过，直接使用前面读取的数据即可；否则需要去获取锁重新去读数据，阻止写操作。</p>
<p>上面例子运行结果如下：</p>
<p><img src="/images/StampLock%E4%B9%90%E8%A7%82%E9%94%81.png"></p>
<p>可以看到，写操作一开始就抢到了锁，并写入了数据。</p>
<p><strong>简而言之，StampedLock解决了在没有新数据写入时，由于过多读操作抢夺锁而使得写操作一直获取不到锁无法写入新数据的问题。</strong></p>
<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>Condition接口提供了类似Object的<code>wait</code>、<code>notify</code>和<code>notifyAll</code>方法，与Lock配合可以实现生产/消费模式，但是这两者在使用方式以及功能特性上还是有差别的。</p>
<p>使用Codition实现一个生产消费的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="comment">// 初始数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 是否被消费</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> consumed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                produceData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;producer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                consumeData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;consumer&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">produceData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">            <span class="keyword">while</span> (!consumed) &#123; <span class="comment">// 判断数据是否被消费</span></span><br><span class="line">                condition.await(); <span class="comment">// 如果没有被消费则进入等待</span></span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            data++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; produce data = &quot;</span> + data);</span><br><span class="line">            consumed = <span class="keyword">false</span>; <span class="comment">// 生产完数据将消费标识置为false</span></span><br><span class="line">            condition.signal(); <span class="comment">// 解除await，用于通知消费者可以开始消费了</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumeData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">            <span class="keyword">while</span> (consumed) &#123; <span class="comment">// 判断数据是否被消费</span></span><br><span class="line">                condition.await(); <span class="comment">// 如果被消费了则进入等待</span></span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.MICROSECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; consume data = &quot;</span> + data);</span><br><span class="line">            consumed = <span class="keyword">true</span>; <span class="comment">// 消费完将消费标识置为true</span></span><br><span class="line">            condition.signal(); <span class="comment">// 解除await，用于通知生产者可以开始生产了</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中，通过<code>consumed</code>判断数据是否被消费。<code>produceData</code>方法在获取锁后，判断数据是否被消费，如果没有被消费，则调用Condition的<code>await</code>方法进入等待，直到Condition对象的<code>signal</code>方法被调用；<code>consumeData</code>方法逻辑和<code>produceData</code>一致。</p>
<p>Condition核心用法就是通过<code>await</code>方法让线程进入阻塞等待状态，通过<code>signal</code>解除阻塞状态。上面的例子运行效果如下所示：</p>
<p><img src="/images/Condition%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.gif"></p>
<p>对应上面的例子可以思考下面三个问题：</p>
<ol>
<li>是否可以只使用Lock而不使用Condition？</li>
<li>生产者抢到了锁进入await，并没有释放锁，为什么消费者可以获得锁？</li>
<li>是否可以只使用Condition不使用Lock？</li>
</ol>
<p>对于第一个问题：<strong>是否可以只使用Lock而不使用Condition？</strong></p>
<p>虽然可以定义公平的ReentrantLock，但是实际上并不能确保100%公平，只是尽可能的公平。生产消费模型必须为生产者生成完了数据通知消费者消费，消费者消费完了通知生产者生产，这是环环相扣的，不允许出现别的情况。</p>
<p>对于第二个问题：<strong>生产者抢到了锁进入await，并没有释放锁，为什么消费者可以获得锁？</strong></p>
<p>假如一开始<code>produceData</code>方法先通过<code>lock.lock()</code>获取到了锁，consumed初始值为false，所以接着方法会调用<code>condition.await()</code>进入阻塞等待。<code>await</code>方法会使得当前线程<strong>释放锁对象</strong>，然后进入休眠状态，直到发生下面三种情况之一才会被解除休眠：</p>
<ol>
<li>Condition的<code>signal</code>方法被调用；</li>
<li>Condition的<code>signalAll</code>方法被调用；</li>
<li>其他线程调用了当前线程的<code>interrupt</code>方法</li>
</ol>
<p>对于第三个问题：<strong>是否可以只使用Condition不使用Lock？</strong></p>
<p>既然<code>await</code>会使得线程进入阻塞等待状态，那么是否可以直接使用<code>await</code>，而不使用Lock呢？改造上面的例子，去掉获取和释放锁的相关代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 公平锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="comment">// 初始数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 是否被消费</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> consumed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                produceData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                consumeData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">produceData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!consumed) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            data++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; produce data = &quot;</span> + data);</span><br><span class="line">            consumed = <span class="keyword">false</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumeData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (consumed) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.MICROSECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; consume data = &quot;</span> + data);</span><br><span class="line">            consumed = <span class="keyword">true</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E4%B8%8D%E4%BD%BF%E7%94%A8Lock%E7%9A%84Condition.png"></p>
<p>可以看到，程序抛出<code>IllegalMonitorStateException</code>异常，所以Condition必须配合Lock使用。</p>
<p>正如前面说的，Condition的功能类似于Object对象的<code>wait</code>和<code>notify</code>方法，下面我们使用Object对象的<code>wait</code>和<code>notify</code>方法实现一个类似上面生产消费的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> used = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Object MONITOR = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                produceData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                consumeData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">produceData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (MONITOR) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!used) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    MONITOR.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            data++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 生产data = &quot;</span> + data);</span><br><span class="line">            used = <span class="keyword">false</span>;</span><br><span class="line">            MONITOR.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumeData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (MONITOR) &#123;</span><br><span class="line">            <span class="keyword">while</span> (used) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    MONITOR.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 消费data = &quot;</span> + data);</span><br><span class="line">            used = <span class="keyword">true</span>;</span><br><span class="line">            MONITOR.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下所示：</p>
<p><img src="/images/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85.gif"></p>
<p><code>Condition</code>还可以绑定多个条件，并唤醒指定的线程，举个三个线程循环干活的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Loop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String value = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 条件1</span></span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="comment">// 条件2</span></span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="comment">// 条件3</span></span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (!value.equals(<span class="string">&quot;a&quot;</span>)) &#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; print a&quot;</span>);</span><br><span class="line">            value = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (!value.equals(<span class="string">&quot;b&quot;</span>)) &#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; print b&quot;</span>);</span><br><span class="line">            value = <span class="string">&quot;c&quot;</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (!value.equals(<span class="string">&quot;c&quot;</span>)) &#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; print c&quot;</span>);</span><br><span class="line">            value = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Loop loop = <span class="keyword">new</span> Loop();</span><br><span class="line">        IntStream.rangeClosed(<span class="number">0</span>, <span class="number">2</span>).forEach(i -&gt; <span class="keyword">new</span> Thread(loop::printA, <span class="string">&quot;线程A&quot;</span>).start());</span><br><span class="line">        IntStream.rangeClosed(<span class="number">0</span>, <span class="number">2</span>).forEach(i -&gt; <span class="keyword">new</span> Thread(loop::printB, <span class="string">&quot;线程B&quot;</span>).start());</span><br><span class="line">        IntStream.rangeClosed(<span class="number">0</span>, <span class="number">2</span>).forEach(i -&gt; <span class="keyword">new</span> Thread(loop::printC, <span class="string">&quot;线程C&quot;</span>).start());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">线程A <span class="builtin-name">print</span> a</span><br><span class="line">线程B <span class="builtin-name">print</span> b</span><br><span class="line">线程C <span class="builtin-name">print</span> c</span><br><span class="line">线程A <span class="builtin-name">print</span> a</span><br><span class="line">线程B <span class="builtin-name">print</span> b</span><br><span class="line">线程C <span class="builtin-name">print</span> c</span><br><span class="line">线程A <span class="builtin-name">print</span> a</span><br><span class="line">线程B <span class="builtin-name">print</span> b</span><br><span class="line">线程C <span class="builtin-name">print</span> c</span><br></pre></td></tr></table></figure>

<h2 id="synchronized和Lock区别"><a href="#synchronized和Lock区别" class="headerlink" title="synchronized和Lock区别"></a>synchronized和Lock区别</h2><p><strong>1. 构成不一样</strong></p>
<p><code>synchronized</code>是Java关键字，属于JVM层面，底层是由monitorenter和monitorexit指令完成（查看字节码证实）：</p>
<p><img src="/images/synchronized%E5%BA%95%E5%B1%82.png"></p>
<p><strong>2.使用方式不同</strong></p>
<p><code>synchronized</code>不需要我们手动释放锁，当<code>synchronized</code>代码执行完后，当前线程会自动释放锁；</p>
<p><code>ReentrantLock</code>需要手动释放锁，不然会造成死锁。</p>
<p><strong>3.可中断性</strong></p>
<p><code>synchronized</code>是不可中断的，除非同步方法内抛出异常或者程序正常运行完成； <code>ReentrantLock</code>是可以中断的，比如<code>lockInterruptibly()</code>方法。</p>
<p><strong>4.公平否</strong></p>
<p><code>synchronized</code>是非公平锁；</p>
<p><code>ReentrantLock</code>可以通过构造方法<code>ReentrantLock(boolean fair)</code>设置公平与否。</p>
<p><strong>5.灵活性</strong></p>
<p><code>synchronized</code>不可以设置条件；</p>
<p><code>ReentrantLock</code>可以通过condition绑定多条件，精确唤醒指定线程。</p>
]]></content>
      <tags>
        <tag>concurrency, lock</tag>
      </tags>
  </entry>
  <entry>
    <title>Java HashMap底层实现原理</title>
    <url>/2020/09/04/Java-HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>Java HashMap底层数据结构、方法实现原理等，基于JDK 1.8</p>
<span id="more"></span>

<h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><p>Java HashMap底层采用哈希表结构（数组+链表、JDK1.8后为数组+链表或红黑树）实现，结合了数组和链表的优点：</p>
<ol>
<li>数组优点：通过数组下标可以快速实现对数组元素的访问，效率极高；</li>
<li>链表优点：插入或删除数据不需要移动元素，只需修改节点引用，效率极高。</li>
</ol>
<p>HashMap图示如下所示：</p>
<p><img src="/images/HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p>
<p>HashMap内部使用数组存储数据，数组中的每个元素类型为<code>Node&lt;K,V&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Node包含了四个字段：hash、key、value、next，其中next表示链表的下一个节点。</p>
<p>HashMap通过<code>hash</code>方法计算key的哈希码，然后通过<code>(n-1)&amp;hash</code>公式（n为数组长度）得到key在数组中存放的下标。当两个key在数组中存放的下标一致时，数据将以链表的方式存储（哈希冲突，哈希碰撞）。我们知道，在链表中查找数据必须从第一个元素开始一层一层往下找，直到找到为止，时间复杂度为O(N)，所以当链表长度越来越长时，HashMap的效率越来越低。</p>
<p>为了解决这个问题，JDK1.8开始采用数组+链表+红黑树的结构来实现HashMap。当链表中的元素超过8个（<strong>TREEIFY_THRESHOLD</strong>）并且数组长度大于64（<strong>MIN_TREEIFY_CAPACITY</strong>）时，会将链表转换为红黑树，转换后数据查询时间复杂度为O(logN)。</p>
<p>红黑树的节点使用TreeNode表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap包含几个重要的变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组默认的初始化长度16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组最大容量，2的30次幂，即1073741824</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认加载因子值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表转换为红黑树的长度阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树转换为链表的长度阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表转换为红黑树时，数组容量必须大于等于64</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap里键值对个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容阈值，计算方法为 数组容量*加载因子</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap使用数组存放数据，数组元素类型为Node&lt;K,V&gt;</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），直接抛出ConcurrentModificationException异常</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>

<p>上面这些字段在下面源码解析的时候尤为重要，其中需要着重讨论的是加载因子是什么，为什么默认值为0.75f。</p>
<p>加载因子也叫扩容因子，用于决定HashMap数组何时进行扩容。比如数组容量为16，加载因子为0.75，那么扩容阈值为<code>16*0.75=12</code>，即HashMap数据量大于等于12时，数组就会进行扩容。我们都知道，数组容量的大小在创建的时候就确定了，所谓的扩容指的是重新创建一个指定容量的数组，然后将旧值复制到新的数组里。扩容这个过程非常耗时，会影响程序性能。所以加载因子是基于容量和性能之间平衡的结果：</p>
<ul>
<li>当加载因子过大时，扩容阈值也变大，也就是说扩容的门槛提高了，这样容量的占用就会降低。但这时哈希碰撞的几率就会增加，效率下降；</li>
<li>当加载因子过小时，扩容阈值变小，扩容门槛降低，容量占用变大。这时候哈希碰撞的几率下降，效率提高。</li>
</ul>
<p>可以看到容量占用和性能是此消彼长的关系，它们的平衡点由加载因子决定，0.75是一个即兼顾容量又兼顾性能的经验值。</p>
<p>此外用于存储数据的table字段使用transient修饰，通过transient修饰的字段在序列化的时候将被排除在外，那么HashMap在序列化后进行反序列化时，是如何恢复数据的呢？HashMap通过自定义的readObject/writeObject方法自定义序列化和反序列化操作。这样做主要是出于以下两点考虑：</p>
<ol>
<li>table一般不会存满，即容量大于实际键值对个数，序列化table未使用的部分不仅浪费时间也浪费空间；</li>
<li>key对应的类型如果没有重写hashCode方法，那么它将调用Object的hashCode方法，该方法为native方法，在不同JVM下实现可能不同；换句话说，同一个键值对在不同的JVM环境下，在table中存储的位置可能不同，那么在反序列化table操作时可能会出错。</li>
</ol>
<h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><p>put方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put方法通过hash函数计算key对应的哈希值，hash函数源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果key为null，返回0，不为null，则通过<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>公式计算得到哈希值。该公式通过hashCode的高16位异或低16位得到哈希值，主要从性能、哈希碰撞角度考虑，减少系统开销，不会造成因为高位没有参与下标计算从而引起的碰撞。</p>
<p>得到key对应的哈希值后，再调用<code>putVal(hash(key), key, value, false, true)</code>方法插入元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果数组(哈希表)为null或者长度为0，则进行数组初始化操作</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 根据key的哈希值计算出数据插入数组的下标位置，公式为(n-1)&amp;hash</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果该下标位置还没有元素，则直接创建Node对象，并插入</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果目标位置key已经存在，则直接覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果目标位置key不存在，并且节点为红黑树，则插入红黑树中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则为链表结构，遍历链表，尾部插入</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果链表长度大于等于TREEIFY_THRESHOLD，则考虑转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash); <span class="comment">// 转换为红黑树操作，内部还会判断数组长度是否小于MIN_TREEIFY_CAPACITY，如果是的话不转换</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果链表中已经存在该key的话，直接覆盖替换</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">// 返回被替换的值</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模数递增</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 当键值对个数大于等于扩容阈值的时候，进行扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put操作过程总结：</p>
<ol>
<li><p>判断HashMap数组是否为空，是的话初始化数组（由此可见，在创建HashMap对象的时候并不会直接初始化数组）；</p>
</li>
<li><p>通过<code>(n-1) &amp; hash</code>计算key在数组中的存放索引；</p>
</li>
<li><p>目标索引位置为空的话，直接创建Node存储；</p>
</li>
<li><p>目标索引位置不为空的话，分下面三种情况：</p>
<p>4.1. key相同，覆盖旧值；</p>
<p>4.2. 该节点类型是红黑树的话，执行红黑树插入操作；</p>
<p>4.3. 该节点类型是链表的话，遍历到最后一个元素尾插入，如果期间有遇到key相同的，则直接覆盖。如果链表长度大于等于TREEIFY_THRESHOLD，并且数组容量大于等于MIN_TREEIFY_CAPACITY，则将链表转换为红黑树结构；</p>
</li>
<li><p>判断HashMap元素个数是否大于等于threshold，是的话，进行扩容操作。</p>
</li>
</ol>
<h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><p>get和put相比，就简单多了，下面是get操作源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 判断数组是否为空，数组长度是否大于0，目标索引位置下元素是否为空，是的话直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果目标索引位置元素就是要找的元素，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 如果目标索引位置元素的下一个节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果类型是红黑树，则从红黑树中查找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 否则就是链表，遍历链表查找目标元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h2><p>由前面的put源码分析知道，数组的初始化和扩容都是通过调用resize方法完成的，所以现在来关注下resize方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 扩容前的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 扩容前的数组的大小和阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 预定义新数组的大小和阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩容了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩大容量为当前容量的两倍，但不能超过 MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前数组没有数据，使用初始化的值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 如果初始化的值为 0，则使用默认的初始化容量，默认值为16</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新的容量等于 0</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; </span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">// 开始扩容，将新的容量赋值给 table</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 原数据不为空，将原数据复制到新 table 中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据容量循环数组，复制非空元素到新 table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果链表只有一个，则进行直接赋值</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 红黑树相关的操作</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 链表复制，JDK 1.8 扩容优化部分</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引 + oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 将原索引放到哈希桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将原索引 + oldCap 放到哈希桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.8在扩容时通过高位运算<code>e.hash &amp; oldCap</code>结果是否为0来确定元素是否需要移动，主要有如下两种情况：</p>
<p>情况一：</p>
<p>扩容前oldCap=16，hash=5，<code>(n-1)&amp;hash=15&amp;5=5</code>，<code>hash&amp;oldCap=5&amp;16=0</code>；</p>
<p>扩容后newCap=32，hash=5，<code>(n-1)&amp;hash=31&amp;5=5</code>，<code>hash&amp;oldCap=5&amp;16=0</code>。</p>
<p>这种情况下，扩容后元素索引位置不变，并且hash&amp;oldCap==0。</p>
<p>情况二：</p>
<p>扩容前oldCap=16，hash=18，<code>(n-1)&amp;hash=15&amp;18=2</code>，<code>hash&amp;oldCap=18&amp;16=16</code>；</p>
<p>扩容后newCap=32，hash=18，<code>(n-1)&amp;hash=31&amp;18=18</code>，<code>hash&amp;oldCap=18&amp;16=16</code>。</p>
<p>这种情况下，扩容后元素索引位置为18，即旧索引2加16(oldCap)，并且hash&amp;oldCap!=0。</p>
<h2 id="遍历原理"><a href="#遍历原理" class="headerlink" title="遍历原理"></a>遍历原理</h2><p>通常使用下面两种方式遍历HashMap：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;9&quot;</span>, <span class="string">&quot;i&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;Map.Entry&lt;String, Object&gt;&gt; entries = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : entries) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-------&quot;</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line"><span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">    System.out.println(key + <span class="string">&quot;: &quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight ldif"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>: a</span><br><span class="line"><span class="attribute">2</span>: b</span><br><span class="line"><span class="attribute">3</span>: c</span><br><span class="line"><span class="attribute">4</span>: d</span><br><span class="line"><span class="attribute">9</span>: i</span><br><span class="line"><span class="literal">-------</span></span><br><span class="line"><span class="attribute">1</span>: a</span><br><span class="line"><span class="attribute">2</span>: b</span><br><span class="line"><span class="attribute">3</span>: c</span><br><span class="line"><span class="attribute">4</span>: d</span><br><span class="line"><span class="attribute">9</span>: i</span><br></pre></td></tr></table></figure>

<p>通过前面对put源码的分析，可知HashMap是无序的，输出元素顺序和插入元素顺序一般都不一样。但是多次运行上面的程序你会发现，每次遍历的顺序都是一样的。那么遍历的原理是什么，内部是如何操作的？</p>
<p>通过entrySet或者keySet遍历，它们的内部原理是一样的，这里以entrySet为例。</p>
<p>通过查看代码对应的class文件，会发现下面这段代码实际会被转换为iterator遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String, Object&gt;&gt; entries = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : entries) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增强for循环会被编译为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Entry&lt;String, Object&gt;&gt; entries = map.entrySet();</span><br><span class="line">Iterator var3 = entries.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">    Entry&lt;String, Object&gt; entry = (Entry)var3.next();</span><br><span class="line">    System.out.println((String)entry.getKey() + <span class="string">&quot;: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看entrySet，iterator，hasNext，next方法的源码就可以清楚的了解到HashMap遍历原理:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="comment">// entrySet一开始为null，通过new EntrySet()创建</span></span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="comment">// EntrySet内部包含迭代器方法，方法内部通过new EntryIterator()创建Entry迭代器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    ...... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EntryIterator继承自HashIterator，调用EntryIterator的hasNext方法实际调用的是</span></span><br><span class="line"><span class="comment">// 父类HashIterator的hashNext方法，调用EntryIterator的next方法，方法内部调用的是父类HashIterator</span></span><br><span class="line"><span class="comment">// 的nextNode方法，所以我们主要关注HashIterator的源码</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// 下一个节点</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// 当前节点</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;  <span class="comment">// 期待的模数值，用于快速失败</span></span><br><span class="line">    <span class="keyword">int</span> index;             <span class="comment">// 当前遍历的table index</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        <span class="comment">// 将当前模数值赋值给期待的模数值，所以在遍历的时候，别的线程调用了当前hashMap实例的</span></span><br><span class="line">        <span class="comment">// 增删改方法，模数值会改变，那么expectedModCount和modCount就不相等了，遍历操作直接</span></span><br><span class="line">        <span class="comment">// 抛出ConcurrentModificationException</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从hashMap数组头部开始遍历</span></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="comment">// 从数组头部开始找，index递增，当index位置的节点不为空时，将其赋值给next</span></span><br><span class="line">            <span class="comment">// 也就是说，在创建hashMap迭代器的时候，内部就已经找到了hashMap数组中第一个非空节点了</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 逻辑很简单，就是判断next是否为空</span></span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="comment">// 模数判断</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 如果next为空了，还调用nextNode方法的话，将抛出NoSuchElementException异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="comment">// 这段逻辑也很简单，主要包含如下两种情况：</span></span><br><span class="line">        <span class="comment">// 1. 如果当前节点的next节点为空的话，说明该节点无需进行链表遍历了（就一个节点或者已经到了链表的末尾），那么进行do while循环，直到找到hashMap数组中下一个不为空的节点</span></span><br><span class="line">        <span class="comment">// 2. 如果当前节点的next节点不为空的话，说明该位置存在链表，那么外界在循环调用iterator的next方法时，实际就是不断调用nextNode方法遍历链表操作</span></span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，遍历HashMap的过程就是从头查找HashMap数组中的不为空的结点，如果该结点下存在链表，则遍历该链表，遍历完链表后再找HashMap数组中下一个不为空的结点，以此进行下去直到遍历结束。</p>
<p>那么，如果某个结点下是红黑树结构的话，怎么遍历？其实当链表转换为红黑树时，链表节点里包含的next字段信息是保留的，所以依旧可以通过红黑树节点中的next字段找到下一个节点。</p>
<h2 id="和JDK1-7的区别"><a href="#和JDK1-7的区别" class="headerlink" title="和JDK1.7的区别"></a>和JDK1.7的区别</h2><h3 id="hash计算规则不同"><a href="#hash计算规则不同" class="headerlink" title="hash计算规则不同"></a>hash计算规则不同</h3><p>JDK1.7 hash计算规则为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于JDK1.8的hash方法，JDK1.7的hash方法的性能会稍差一点</p>
<h3 id="put操作不同"><a href="#put操作不同" class="headerlink" title="put操作不同"></a>put操作不同</h3><p>JDK1.7并没有使用红黑树，如果哈希冲突后，都用链表解决。区别于JDK1.8的尾部插入，JDK1.7采用头部插入的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;   </span><br><span class="line">    <span class="comment">// 键为null，将元素放置到table数组的0下标处</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value); </span><br><span class="line">    <span class="comment">// 计算hash和数组下标索引位置</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());  </span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);  </span><br><span class="line">    <span class="comment">// 遍历链表，当key一致时，说明该key已经存在，使用新值替换旧值并返回</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;  </span><br><span class="line">        Object k;  </span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </span><br><span class="line">            V oldValue = e.value;  </span><br><span class="line">            e.value = value;  </span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);  </span><br><span class="line">            <span class="keyword">return</span> oldValue;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 插入链表</span></span><br><span class="line">    addEntry(hash, key, value, i);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 一样的，新旧值替换</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            V oldValue = e.value;  </span><br><span class="line">            e.value = value;  </span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);  </span><br><span class="line">            <span class="keyword">return</span> oldValue;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    modCount++;  </span><br><span class="line">    <span class="comment">// 插入到数组下标为0位置</span></span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新值头部插入，原先头部变成新的头部元素的next</span></span><br><span class="line">    Entry&lt;K, V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K, V&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">// 计数，扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容操作不同"><a href="#扩容操作不同" class="headerlink" title="扩容操作不同"></a>扩容操作不同</h3><p>JDK1.8在扩容时通过高位运算<code>e.hash &amp; oldCap</code>结果是否为0来确定元素是否需要移动，JDK1.7重新计算了每个元素的哈希值，按旧链表的正序遍历链表、在新链表的头部依次插入，即在转移数据、扩容后，容易出现链表逆序的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时若多线程并发执行resize操作，容易出现环形链表，从而在获取数据、遍历链表时造成死循环</p>
]]></content>
      <tags>
        <tag>HashMap, 原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对称加密算法</title>
    <url>/2020/08/04/Java%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>对称加密算法加密和解密使用的是同一份秘钥，解密是加密的逆运算。对称加密算法加密速度快，密文可逆，一旦秘钥文件泄露，就会导致原始数据暴露。对称加密的结果一般使用Base64算法编码，便于阅读和传输。JDK8支持的对称加密算法主要有DES、DESede、AES、Blowfish，以及RC2和RC4等。不同的算法秘钥长度不同，秘钥长度越长，加密安全性越高。</p>
<span id="more"></span>

<h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><p>DES（Data Encryption Standard，数据加密标准）算法是对称加密算法领域中的典型算法，DES算法秘钥较短，以现在计算机的计算能力，DES算法加密的数据在24小时内可能被破解。所以DES算法已经被淘汰，建议使用AES算法，不过这里还是简单了解下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String value = <span class="string">&quot;Doug Wilson&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;待加密值：&quot;</span> + value);</span><br><span class="line">        <span class="comment">// 加密算法</span></span><br><span class="line">        String algorithm = <span class="string">&quot;DES&quot;</span>;</span><br><span class="line">        <span class="comment">// 转换模式</span></span><br><span class="line">        String transformation = <span class="string">&quot;DES&quot;</span>;</span><br><span class="line">        <span class="comment">// --- 生成秘钥 ---</span></span><br><span class="line">        <span class="comment">// 实例化秘钥生成器</span></span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化秘钥长度</span></span><br><span class="line">        keyGenerator.init(<span class="number">56</span>);</span><br><span class="line">        <span class="comment">// 生成秘钥</span></span><br><span class="line">        SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">        <span class="comment">// 实例化DES秘钥材料</span></span><br><span class="line">        DESKeySpec desKeySpec = <span class="keyword">new</span> DESKeySpec(secretKey.getEncoded());</span><br><span class="line">        <span class="comment">// 实例化秘钥工厂</span></span><br><span class="line">        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 生成DES秘钥</span></span><br><span class="line">        SecretKey desSecretKey = secretKeyFactory.generateSecret(desKeySpec);</span><br><span class="line">        System.out.println(<span class="string">&quot;DES秘钥：&quot;</span> + Base64.getEncoder().encodeToString(desSecretKey.getEncoded()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化密码对象</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(transformation);</span><br><span class="line">        <span class="comment">// 设置模式（ENCRYPT_MODE：加密模式；DECRYPT_MODE：解密模式）和指定秘钥</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, desSecretKey);</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] encrypt = cipher.doFinal(value.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;DES加密结果：&quot;</span> + Base64.getEncoder().encodeToString(encrypt));</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        <span class="comment">// 设置为解密模式</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, desSecretKey);</span><br><span class="line">        <span class="keyword">byte</span>[] decrypt = cipher.doFinal(encrypt);</span><br><span class="line">        System.out.println(<span class="string">&quot;DES解密结果：&quot;</span> + <span class="keyword">new</span> String(decrypt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面步骤看着挺多，其实可以总结为如下几步：</p>
<ol>
<li><p>生成加密秘钥；</p>
<p>1.1. 通过KeyGenerator生成一个指定位数的秘钥；</p>
<p>1.2. 通过上面生成的秘钥实例化算法对应的秘钥材料KeySpec；</p>
<p>1.3. 使用秘钥材料通过秘钥工厂SecretKeyFactory生成算法秘钥SecretKey。</p>
</li>
<li><p>通过转换模式实例化Cipher；</p>
</li>
<li><p>指定Cipher模式和秘钥，进行加解密操作。</p>
</li>
</ol>
<p>运行结果如下：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">待加密值：Doug Wilson</span><br><span class="line"><span class="keyword">DES</span>秘钥：LO/CCEC8y8E=</span><br><span class="line"><span class="keyword">DES</span>加密结果：hRZdN6f+6yj/lhPWUPsayA==</span><br><span class="line"><span class="keyword">DES</span>解密结果：Doug Wilson</span><br></pre></td></tr></table></figure>

<p>特别注意：<strong>如果在生成秘钥的时候，不指定为56位，则会抛出java.security.InvalidParameterException: Wrong keysize: must be equal to 56异常</strong></p>
<h2 id="DESede"><a href="#DESede" class="headerlink" title="DESede"></a>DESede</h2><p>作为DES算法的一种改良，DESede算法（也称为3DES，三重DES）针对其秘钥长度偏短和迭代次数偏少等问题做了相应改进，提高了安全强度，但同时也造成处理速度较慢、秘钥计算时间加长、加密效率不高的问题。所以这里还是简单了解下，实际还是推荐用AES。</p>
<p>JDK8支持112位或168位长度的DESede秘钥：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String value = <span class="string">&quot;Doug Wilson&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;待加密值：&quot;</span> + value);</span><br><span class="line">        <span class="comment">// 加密算法</span></span><br><span class="line">        String algorithm = <span class="string">&quot;DESede&quot;</span>;</span><br><span class="line">        <span class="comment">// 转换模式</span></span><br><span class="line">        String transformation = <span class="string">&quot;DESede&quot;</span>;</span><br><span class="line">        <span class="comment">// --- 生成秘钥 ---</span></span><br><span class="line">        <span class="comment">// 实例化秘钥生成器</span></span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化秘钥长度</span></span><br><span class="line">        keyGenerator.init(<span class="number">112</span>);</span><br><span class="line">        <span class="comment">// 生成秘钥</span></span><br><span class="line">        SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">        <span class="comment">// 实例化DESede秘钥材料</span></span><br><span class="line">        DESedeKeySpec desKeySpec = <span class="keyword">new</span> DESedeKeySpec(secretKey.getEncoded());</span><br><span class="line">        <span class="comment">// 实例化秘钥工厂</span></span><br><span class="line">        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 生成DES秘钥</span></span><br><span class="line">        SecretKey desSecretKey = secretKeyFactory.generateSecret(desKeySpec);</span><br><span class="line">        System.out.println(<span class="string">&quot;DESede秘钥：&quot;</span> + Base64.getEncoder().encodeToString(desSecretKey.getEncoded()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化密码对象</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(transformation);</span><br><span class="line">        <span class="comment">// 设置模式（ENCRYPT_MODE：加密模式；DECRYPT_MODE：解密模式）和指定秘钥</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, desSecretKey);</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] encrypt = cipher.doFinal(value.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;DESede加密结果：&quot;</span> + Base64.getEncoder().encodeToString(encrypt));</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        <span class="comment">// 设置为解密模式</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, desSecretKey);</span><br><span class="line">        <span class="keyword">byte</span>[] decrypt = cipher.doFinal(encrypt);</span><br><span class="line">        System.out.println(<span class="string">&quot;DESede解密结果：&quot;</span> + <span class="keyword">new</span> String(decrypt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过程和DES一致，区别仅在于使用的加密算法为DESede，秘钥长度指定为112，秘钥材料对象为DESedeKeySpec类。</p>
<p>上面程序输出如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">待加密值：Doug Wilson</span><br><span class="line">DESede秘钥：1fFb+F1wboVGGTSPNIBJ+9XxW/hdcG6F</span><br><span class="line">DESede加密结果：WVg9w6exyRREqY1vNyRI+<span class="attribute">Q</span>==</span><br><span class="line">DESede解密结果：Doug Wilson</span><br></pre></td></tr></table></figure>

<p>特别注意：<strong>如果指定不合法的秘钥长度，程序将抛出java.security.InvalidParameterException: Wrong keysize: must be equal to 112 or 168异常</strong></p>
<h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><p>AES（AdvancedEncryption Standard，高级数据加密标准）算法支持128位、192位和256位的秘钥长度，加密速度比DES和DESede都快，至今还没有被破解的报道。经过验证，目前采用的AES算法能够有效抵御已知的针对DES算法的所有攻击方法，如部分差分攻击、相关秘钥攻击等。AES算法因秘钥建立时间短、灵敏性好、内存需求低等优点，在各个领域得到广泛的研究与应用。</p>
<p>JDK8支持128位、192位和256位长度的AES秘钥：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String value = <span class="string">&quot;Doug Wilson&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;待加密值：&quot;</span> + value);</span><br><span class="line">        <span class="comment">// 加密算法</span></span><br><span class="line">        String algorithm = <span class="string">&quot;AES&quot;</span>;</span><br><span class="line">        <span class="comment">// 转换模式</span></span><br><span class="line">        String transformation = <span class="string">&quot;AES&quot;</span>;</span><br><span class="line">        <span class="comment">// --- 生成秘钥 ---</span></span><br><span class="line">        <span class="comment">// 实例化秘钥生成器</span></span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化秘钥长度</span></span><br><span class="line">        keyGenerator.init(<span class="number">256</span>);</span><br><span class="line">        <span class="comment">// 生成秘钥</span></span><br><span class="line">        SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">        <span class="comment">// 生成秘钥材料</span></span><br><span class="line">        SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), algorithm);</span><br><span class="line">        System.out.println(<span class="string">&quot;AES秘钥：&quot;</span> + Base64.getEncoder().encodeToString(secretKey.getEncoded()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化密码对象</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(transformation);</span><br><span class="line">        <span class="comment">// 设置模式（ENCRYPT_MODE：加密模式；DECRYPT_MODE：解密模式）和指定秘钥</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] encrypt = cipher.doFinal(value.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;AES加密结果：&quot;</span> + Base64.getEncoder().encodeToString(encrypt));</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        <span class="comment">// 设置为解密模式</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);</span><br><span class="line">        <span class="keyword">byte</span>[] decrypt = cipher.doFinal(encrypt);</span><br><span class="line">        System.out.println(<span class="string">&quot;AES解密结果：&quot;</span> + <span class="keyword">new</span> String(decrypt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过程和上面例子大体一致，唯一区别是使用AES算法无需指定特定类型的秘钥材料，直接用SecretKeySpec对象即可。</p>
<p>程序输出如下：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">待加密值：Doug Wilson</span><br><span class="line">AES秘钥：vMj1fnhYdIGpTfxpEeKaynG879ARZ5r2AcfBpf+<span class="attr">yoRs=</span></span><br><span class="line">AES加密结果：GCmIlqEJIBlBRw/<span class="number">474</span><span class="attr">OanQ==</span></span><br><span class="line">AES解密结果：Doug Wilson</span><br></pre></td></tr></table></figure>

<p>特别注意：<strong>如果指定不合法的秘钥长度，程序将抛出java.security.InvalidParameterException: Wrong keysize: must be equal to 128, 192 or 256异常</strong></p>
<h2 id="RC2、RC4"><a href="#RC2、RC4" class="headerlink" title="RC2、RC4"></a>RC2、RC4</h2><p>RC2和RC4算法也可以用于替换DES算法，特点是秘钥长度较为灵活，RC2和RC4的秘钥长度范围为40到1024位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String value = <span class="string">&quot;Doug Wilson&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;待加密值：&quot;</span> + value);</span><br><span class="line">        <span class="comment">// 加密算法</span></span><br><span class="line">        String algorithm = <span class="string">&quot;RC2&quot;</span>;</span><br><span class="line">        <span class="comment">// 转换模式</span></span><br><span class="line">        String transformation = <span class="string">&quot;RC2&quot;</span>;</span><br><span class="line">        <span class="comment">// --- 生成秘钥 ---</span></span><br><span class="line">        <span class="comment">// 实例化秘钥生成器</span></span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化秘钥长度</span></span><br><span class="line">        keyGenerator.init(<span class="number">666</span>);</span><br><span class="line">        <span class="comment">// 生成秘钥</span></span><br><span class="line">        SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">        <span class="comment">// 生成秘钥材料</span></span><br><span class="line">        SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), algorithm);</span><br><span class="line">        System.out.println(<span class="string">&quot;RC2秘钥：&quot;</span> + Base64.getEncoder().encodeToString(secretKey.getEncoded()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化密码对象</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(transformation);</span><br><span class="line">        <span class="comment">// 设置模式（ENCRYPT_MODE：加密模式；DECRYPT_MODE：解密模式）和指定秘钥</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] encrypt = cipher.doFinal(value.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;RC2加密结果：&quot;</span> + Base64.getEncoder().encodeToString(encrypt));</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        <span class="comment">// 设置为解密模式</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);</span><br><span class="line">        <span class="keyword">byte</span>[] decrypt = cipher.doFinal(encrypt);</span><br><span class="line">        System.out.println(<span class="string">&quot;RC2解密结果：&quot;</span> + <span class="keyword">new</span> String(decrypt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">待加密值：Doug Wilson</span><br><span class="line">RC2秘钥：<span class="regexp">//</span>wHmkfa<span class="regexp">/TpQqeard5RD8h6Gdd1YJQZbFT4pUsssRfitpz1YkhJfCN/</span>J<span class="regexp">/hjR0Q1HmVReJaSPCNDqP+GUBlvnWi7zsoKW35O6R5W/</span>R0Bgnjh/qVsu</span><br><span class="line">RC2加密结果：+XL70sqXz/myi1JRiLVbCw==</span><br><span class="line">RC2解密结果：Doug Wilson</span><br></pre></td></tr></table></figure>

<p><strong>如果指定不合法的秘钥长度，程序将抛出java.security.InvalidParameterException: Key length for RC2 must be between 40 and 1024 bits异常</strong></p>
<h2 id="Blowfish"><a href="#Blowfish" class="headerlink" title="Blowfish"></a>Blowfish</h2><p>Blowfish算法也可以用于替换DES，Blowfish算法的秘钥长度范围为32到448位，并且必须为8的倍数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String value = <span class="string">&quot;Doug Wilson&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;待加密值：&quot;</span> + value);</span><br><span class="line">        <span class="comment">// 加密算法</span></span><br><span class="line">        String algorithm = <span class="string">&quot;Blowfish&quot;</span>;</span><br><span class="line">        <span class="comment">// 转换模式</span></span><br><span class="line">        String transformation = <span class="string">&quot;Blowfish&quot;</span>;</span><br><span class="line">        <span class="comment">// --- 生成秘钥 ---</span></span><br><span class="line">        <span class="comment">// 实例化秘钥生成器</span></span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化秘钥长度</span></span><br><span class="line">        keyGenerator.init(<span class="number">128</span>);</span><br><span class="line">        <span class="comment">// 生成秘钥</span></span><br><span class="line">        SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">        <span class="comment">// 生成秘钥材料</span></span><br><span class="line">        SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), algorithm);</span><br><span class="line">        System.out.println(<span class="string">&quot;Blowfish秘钥：&quot;</span> + Base64.getEncoder().encodeToString(secretKey.getEncoded()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化密码对象</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(transformation);</span><br><span class="line">        <span class="comment">// 设置模式（ENCRYPT_MODE：加密模式；DECRYPT_MODE：解密模式）和指定秘钥</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] encrypt = cipher.doFinal(value.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;Blowfish加密结果：&quot;</span> + Base64.getEncoder().encodeToString(encrypt));</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        <span class="comment">// 设置为解密模式</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);</span><br><span class="line">        <span class="keyword">byte</span>[] decrypt = cipher.doFinal(encrypt);</span><br><span class="line">        System.out.println(<span class="string">&quot;Blowfish解密结果：&quot;</span> + <span class="keyword">new</span> String(decrypt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">待加密值：Doug Wilson</span><br><span class="line">Blowfish秘钥：<span class="attribute">d3ReFylxI2OI7n3qgPFViQ</span>==</span><br><span class="line">Blowfish加密结果：<span class="attribute">nnH2mqVZhhhegBwAuqecLw</span>==</span><br><span class="line">Blowfish解密结果：Doug Wilson</span><br></pre></td></tr></table></figure>

<p><strong>如果指定不合法的秘钥长度，程序将抛出java.security.InvalidParameterException: Keysize must be multiple of 8, and can only range from 32 to 448 (inclusive)异常</strong></p>
<h2 id="加密模式"><a href="#加密模式" class="headerlink" title="加密模式"></a>加密模式</h2><p>对称加密算法分为：序列密码(流密码)加密，分组密码(块密码)加密两种。流密码是对信息流中的每一个元素（一个字母或一个比特）作为基本的处理单元进行加密，块密码是先对信息流分块，再对每一块分别加密。</p>
<p>上面介绍的这些都属于块密码加密。不同的算法侧重点不同，有的强调效率，有的强调安全，有的强调容错性。根据数据加密时每个加密区块间的关联方式来区分，可以分为4种加密模式：电子密码本模式（Electronic Code Book，ECB）、密文链接模式（Cipher Book Chaining，CBC）、密文反馈模式（Cipher Feed Back，CFB）、输出反馈模式（Output Feed Back，OFB）。AES标准除了推荐上述4种工作模式外，还推荐了一种新的工作模式—计数器模式（Counter，CTR）。这些工作模式可适用于各种分组密码算法。</p>
<h3 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h3><p>ECB模式加解密过程如下图所示：</p>
<p><img src="/images/ECB%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86.png"></p>
<p>明文分为若干块，每次加密均产生独立的密文分组，每组的加密结果不会对其他分组产生影响，相同的明文加密后对应产生相同的密文。</p>
<ul>
<li><strong>优点</strong>：可并行操作，没有误差传递（因为每个密文都是独立加密来的）；</li>
<li><strong>缺点</strong>：如果明文重复，则对应的密文也会重复，对明文进行主动攻击的可能性较高；</li>
<li><strong>用途</strong>：适合加密秘钥、随机数等短数据。例如，安全地传递DES秘钥，ECB是最合适的模式。</li>
</ul>
<h3 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h3><p>CBC模式加解密过程如下图所示：</p>
<p><img src="/images/CBC%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86.png"></p>
<p>明文分为若干块，每次加密前，明文块都和前一个明文块加密后的内容进行异或处理，然后再用秘钥加密。因为第一个明文块没有可以用来异或处理的密文块，所以我们需要提供一个初始化向量来替代。</p>
<ul>
<li><strong>优点</strong>：密文链接模式加密后的密文上下文关联，对明文的主动攻击的可能性较低；</li>
<li><strong>缺点</strong>：不能并行加密，如果在加密过程中发生错误，则错误将被无限放大，导致加密失败。并且需要提供初始化向量；</li>
<li><strong>用途</strong>：可加密任意长度的数据；适用于计算产生检测数据完整性的消息认证码Mac。</li>
</ul>
<h3 id="CFB"><a href="#CFB" class="headerlink" title="CFB"></a>CFB</h3><p>CFB模式加解密过程如下图所示：</p>
<p><img src="/images/CFB%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86.png"></p>
<p>明文分为若干块，每次加密前，先将前一个密文块使用秘钥加密，加密结果和当前明文块异或处理得到密文块。同样的，需要为第一个明文块加密提供初始化向量。</p>
<ul>
<li><strong>优点</strong>：和CBC类似；</li>
<li><strong>缺点</strong>：和CBC类似；</li>
<li><strong>用途</strong>：因错误传播无界，可用于检查发现明文密文的篡改。</li>
</ul>
<h3 id="OFB"><a href="#OFB" class="headerlink" title="OFB"></a>OFB</h3><p>OFB模式加解密过程如下图所示：</p>
<p><img src="/images/OFB%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86.png"></p>
<p>过程和CFB类似，区别在于OFB第一次使用秘钥对初始化向量进行加密（结果为A），加密结果和明文块异或处理得到密文块，下一次操作时候，不是使用秘钥加密前一个密文块，而是使用秘钥加密A的结果再和明文块异或处理，得到当前密文块。</p>
<ul>
<li><strong>优点</strong>：和CFB类似；</li>
<li><strong>缺点</strong>：不利于并行计算；对明文的主动攻击是可能的，安全性较CFB差；</li>
<li><strong>用途</strong>：适用于加密冗余性较大的数据，比如语音和图像数据。</li>
</ul>
<h3 id="CTR"><a href="#CTR" class="headerlink" title="CTR"></a>CTR</h3><p>CTR模式加解密过程如下图所示：</p>
<p><img src="/images/CTR%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86.png"></p>
<p>CTR含义是计数器模式，所以它维护了一个递增的计数器。秘钥加密计数器，结果和明文块异或得到密文块，依次类推。</p>
<ul>
<li><strong>优点</strong>：可以并行操作，安全性和CBC一样好；</li>
<li><strong>缺点</strong>：没有错误传播，因此不易确保数据完整性；</li>
<li><strong>用途</strong>：适用于各种加密应用。</li>
</ul>
<h2 id="填充模式"><a href="#填充模式" class="headerlink" title="填充模式"></a>填充模式</h2><p>当需要按块处理的数据, 数据长度不符合块处理需求时, 按照一定的方法填充满块长的规则。如果不填充，待加密的数据块长度不符合要求时程序会抛出异常。</p>
<p>JDK8中主要支持NoPadding和PKCS5Padding填充模式。</p>
<ol>
<li>NoPadding：不填充；</li>
<li>PKCS5Padding：数据块的大小为8位, 不够就补足。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th align="left">算法</th>
<th align="left">秘钥长度（位）</th>
<th align="left">工作模式</th>
<th align="left">填充模式</th>
<th align="left">初始化向量秘钥长度（字节）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DES</td>
<td align="left">56</td>
<td align="left">ECB、CBC、CFB、OFB、CTR等</td>
<td align="left">NoPadding、 PKCS5Padding、 ISO10126Padding</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">DESede</td>
<td align="left">112、168</td>
<td align="left">ECB、CBC、CFB、OFB、CTR等</td>
<td align="left">NoPadding、 PKCS5Padding、 ISO10126Padding</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">AES</td>
<td align="left">128、192、256</td>
<td align="left">ECB、CBC、CFB、OFB、CTR等</td>
<td align="left">NoPadding、 PKCS5Padding、 ISO10126Padding</td>
<td align="left">16</td>
</tr>
<tr>
<td align="left">RC2</td>
<td align="left">40~1024</td>
<td align="left">ECB、CBC、CFB、OFB、CTR等</td>
<td align="left">NoPadding、 PKCS5Padding、 ISO10126Padding</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">RC4</td>
<td align="left">40~1024</td>
<td align="left">ECB</td>
<td align="left">NoPadding</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">Blowfish</td>
<td align="left">32~448，8的倍数</td>
<td align="left">ECB、CBC、CFB、OFB、CTR等</td>
<td align="left">NoPadding、 PKCS5Padding、 ISO10126Padding</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">PBE</td>
<td align="left">无</td>
<td align="left">CBC</td>
<td align="left">PKCS5Padding</td>
<td align="left">16（带Hmac）</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>对称加密算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java非对称加密算法</title>
    <url>/2020/08/03/Java%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>非对称加密和对称加密算法相比，多了一把秘钥，为双秘钥模式，一个公开称为公钥，一个保密称为私钥。遵循公钥加密私钥解密，或者私钥加密公钥解密。非对称加密算法源于DH算法，后又有基于椭圆曲线加密算法的密钥交换算法ECDH，不过目前最为流行的非对称加密算法是RSA，本文简单记录下RSA的使用。</p>
<span id="more"></span>

<h2 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h2><p>RSA算法是最为典型的非对称加密算法，该算法由美国麻省理工学院（MIT）的Ron Rivest、Adi Shamir和Leonard Adleman三位学者提出，并以这三位学者的姓氏开头字母命名，称为RSA算法。</p>
<p>RSA算法的数据交换过程分为如下几步：</p>
<ol>
<li>A构建RSA秘钥对；</li>
<li>A向B发布公钥；</li>
<li>A用私钥加密数据发给B；</li>
<li>B用公钥解密数据；</li>
<li>B用公钥加密数据发给A；</li>
<li>A用私钥解密数据。</li>
</ol>
<p>JDK8支持RSA算法：</p>
<table>
<thead>
<tr>
<th align="left">算法</th>
<th align="left">秘钥长度</th>
<th align="left">加密模式</th>
<th align="left">填充模式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">RSA</td>
<td align="left">512~16384位，64倍数</td>
<td align="left">ECB</td>
<td align="left">NoPadding   PKCS1Padding OAEPWithMD5AndMGF1Padding OAEPWithSHA1AndMGF1Padding    OAEPWithSHA-1AndMGF1Padding OAEPWithSHA-224AndMGF1Padding      OAEPWithSHA-256AndMGF1Padding     OAEPWithSHA-384AndMGF1Padding OAEPWithSHA-512AndMGF1Padding   OAEPWithSHA-512/224AndMGF1Padding    OAEPWithSHA-512/2256ndMGF1Padding</td>
</tr>
</tbody></table>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String value = <span class="string">&quot;Doug Wilson&quot;</span>;</span><br><span class="line">        <span class="comment">// 加密算法</span></span><br><span class="line">        String algorithm = <span class="string">&quot;RSA&quot;</span>;</span><br><span class="line">        <span class="comment">// 转换模式</span></span><br><span class="line">        String transform = <span class="string">&quot;RSA/ECB/PKCS1Padding&quot;</span>;</span><br><span class="line">        <span class="comment">// 实例化秘钥对生成器</span></span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化，秘钥长度512~16384位，64倍数</span></span><br><span class="line">        keyPairGenerator.initialize(<span class="number">512</span>);</span><br><span class="line">        <span class="comment">// 生成秘钥对</span></span><br><span class="line">        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        <span class="comment">// 公钥</span></span><br><span class="line">        PublicKey publicKey = keyPair.getPublic();</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA公钥: &quot;</span> + Base64.getEncoder().encodeToString(publicKey.getEncoded()));</span><br><span class="line">        <span class="comment">// 私钥</span></span><br><span class="line">        PrivateKey privateKey = keyPair.getPrivate();</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA私钥: &quot;</span> + Base64.getEncoder().encodeToString(privateKey.getEncoded()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------ 测试公钥加密，私钥解密 ------</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(transform);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">byte</span>[] pubEncryptBytes = cipher.doFinal(value.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA公钥加密后数据: &quot;</span> + Base64.getEncoder().encodeToString(pubEncryptBytes));</span><br><span class="line"></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">byte</span>[] priDecryptBytes = cipher.doFinal(pubEncryptBytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA私钥解密后数据: &quot;</span> + <span class="keyword">new</span> String(priDecryptBytes));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------ 测试私钥加密，公钥解密 ------</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">byte</span>[] priEncryptBytes = cipher.doFinal(value.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA私钥加密后数据: &quot;</span> + Base64.getEncoder().encodeToString(priEncryptBytes));</span><br><span class="line"></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">byte</span>[] pubDecryptBytes = cipher.doFinal(priEncryptBytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA公钥解密后数据: &quot;</span> + <span class="keyword">new</span> String(pubDecryptBytes));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">RSA</span>公钥: MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAL<span class="number">2</span>Zq<span class="number">7</span>TVzBpN<span class="number">4</span>LBegajgh<span class="number">6</span>cOp<span class="number">6</span>mU<span class="number">1</span>FeNBu<span class="number">6</span>pePDaAOaxW<span class="number">13</span>JsoR<span class="number">3</span>+<span class="number">6</span>gPFg<span class="number">8</span>OIEpnOjl<span class="number">3</span>AvM<span class="number">6</span>DZbs+<span class="number">3</span>ec<span class="number">3</span>Gb<span class="number">5</span>cWUCAwEAAQ==</span><br><span class="line"><span class="attribute">RSA</span>私钥: MIIBVgIBADANBgkqhkiG<span class="number">9</span>w<span class="number">0</span>BAQEFAASCAUAwggE<span class="number">8</span>AgEAAkEAvZmrtNXMGk<span class="number">3</span>gsF<span class="number">6</span>BqOCHpw<span class="number">6</span>nqZTUV<span class="number">40</span>G<span class="number">7</span>ql<span class="number">48</span>NoA<span class="number">5</span>rFbXcmyhHf<span class="number">7</span>qA<span class="number">8</span>WDw<span class="number">4</span>gSmc<span class="number">6</span>OXcC<span class="number">8</span>zoNluz<span class="number">7</span>d<span class="number">5</span>zcZvlxZQIDAQABAkEAqOdQBs<span class="number">37</span>gGdmRdg<span class="number">7</span>K<span class="number">8</span>WyMwmkJTdXnxMcXNqOygl<span class="number">7</span>igZmK<span class="number">3</span>VQENAasGVaxAzs+<span class="number">5</span>kBGn<span class="number">0</span>q<span class="number">5</span>xRiu<span class="number">4</span>zPokUn/Ej<span class="number">3</span>wQIhAOzsuGEV<span class="number">2</span>mf<span class="number">2</span>JbT<span class="number">8</span>Q<span class="number">0</span>lrsZ<span class="number">7</span>DdI<span class="number">8</span>hDGS<span class="number">6</span>/vLXQ<span class="number">2</span>aPKtLRAiEAzN<span class="number">2</span>Kwz<span class="number">1</span>xdphRMISwms<span class="number">3</span>c<span class="number">586</span>/ratJuBDlcodTe<span class="number">5</span>Ay<span class="number">0</span>lUCIQCE<span class="number">4</span>Zvj<span class="number">79</span>LIXjj<span class="number">10</span>kqW<span class="number">4</span>k<span class="number">0</span>Dw<span class="number">5</span>IbOKjv<span class="number">0</span>iVt<span class="number">5</span>CgMXJ<span class="number">3</span>jEQIgSMNDHtc<span class="number">67</span>oFpDM+EHmeR<span class="number">129</span>yWw+kblDp/cSc<span class="number">3</span>R<span class="number">05</span>P<span class="number">8</span>UCIQCbzKKLVj<span class="number">7</span>wXIyOcLQTsDrz<span class="number">6</span>n<span class="number">6</span>Hbpy<span class="number">9</span>BqTznO<span class="number">272</span>PPrEA==</span><br><span class="line"><span class="attribute">RSA</span>公钥加密后数据: CgQ<span class="number">9</span>rkRvb<span class="number">5</span>vzG<span class="number">6</span>R/vMnhWPfQLWlo<span class="number">2</span>igEr<span class="number">3</span>GRx<span class="number">4</span>zOf+oSh<span class="number">9</span>MdlfD<span class="number">6</span>n<span class="number">0</span>PRV<span class="number">5</span>jQFdtMbpQ<span class="number">3</span>qjDqqnD<span class="number">48</span>/<span class="number">3</span>VwskCrw==</span><br><span class="line"><span class="attribute">RSA</span>私钥解密后数据: Doug Wilson</span><br><span class="line"><span class="attribute">RSA</span>私钥加密后数据: grY<span class="number">7</span>iL<span class="number">5</span>tP<span class="number">7316</span>hC+OUbBa<span class="number">15</span>p<span class="number">7</span>sMfBXQ<span class="number">9</span>dRjdjtJIUHgPKL+VWwIlIZ<span class="number">64</span>VzMAFVaOIsZKsrg<span class="number">6</span>L<span class="number">0</span>lS<span class="number">7</span>Lk<span class="number">4</span>O<span class="number">4</span>ORKw==</span><br><span class="line"><span class="attribute">RSA</span>公钥解密后数据: Doug Wilson</span><br></pre></td></tr></table></figure>

<p>可以看到，公钥加密私钥解密和私钥加密公钥解密的模式都可行</p>
<h2 id="公钥获取"><a href="#公钥获取" class="headerlink" title="公钥获取"></a>公钥获取</h2><p>假如现在有RSA公钥：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAL2Zq7TVzBpN4LBegajgh6cOp6mU1FeNBu6pePDaAOaxW13JsoR3</span>+<span class="number">6</span>gPFg<span class="number">8</span>OIEpnOjl<span class="number">3</span>AvM<span class="number">6</span>DZbs+<span class="number">3</span>ec<span class="number">3</span>Gb<span class="number">5</span>cWUCAwEAAQ==</span><br></pre></td></tr></table></figure>

<p>RSA私钥：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">MIIBVgIBADANBgkqhkiG9w0BAQEFAASCAUAwggE8AgEAAkEAvZmrtNXMGk3gsF6BqOCHpw6nqZTUV40G7ql48NoA5rFbXcmyhHf7qA8WDw4gSmc6OXcC8zoNluz7d5zcZvlxZQIDAQABAkEAqOdQBs37gGdmRdg7K8WyMwmkJTdXnxMcXNqOygl7igZmK3VQENAasGVaxAzs</span>+<span class="number">5</span>kBGn<span class="number">0</span>q<span class="number">5</span>xRiu<span class="number">4</span>zPokUn/Ej<span class="number">3</span>wQIhAOzsuGEV<span class="number">2</span>mf<span class="number">2</span>JbT<span class="number">8</span>Q<span class="number">0</span>lrsZ<span class="number">7</span>DdI<span class="number">8</span>hDGS<span class="number">6</span>/vLXQ<span class="number">2</span>aPKtLRAiEAzN<span class="number">2</span>Kwz<span class="number">1</span>xdphRMISwms<span class="number">3</span>c<span class="number">586</span>/ratJuBDlcodTe<span class="number">5</span>Ay<span class="number">0</span>lUCIQCE<span class="number">4</span>Zvj<span class="number">79</span>LIXjj<span class="number">10</span>kqW<span class="number">4</span>k<span class="number">0</span>Dw<span class="number">5</span>IbOKjv<span class="number">0</span>iVt<span class="number">5</span>CgMXJ<span class="number">3</span>jEQIgSMNDHtc<span class="number">67</span>oFpDM+EHmeR<span class="number">129</span>yWw+kblDp/cSc<span class="number">3</span>R<span class="number">05</span>P<span class="number">8</span>UCIQCbzKKLVj<span class="number">7</span>wXIyOcLQTsDrz<span class="number">6</span>n<span class="number">6</span>Hbpy<span class="number">9</span>BqTznO<span class="number">272</span>PPrEA==</span><br></pre></td></tr></table></figure>

<p>将它们还原为PublicKey和PrivateKey对象，可以参考如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String value = <span class="string">&quot;Doug Wilson&quot;</span>;</span><br><span class="line">        <span class="comment">// 加密算法</span></span><br><span class="line">        String algorithm = <span class="string">&quot;RSA&quot;</span>;</span><br><span class="line">        <span class="comment">// 转换模式</span></span><br><span class="line">        String transform = <span class="string">&quot;RSA/ECB/PKCS1Padding&quot;</span>;</span><br><span class="line">        <span class="comment">// RSA公钥BASE64字符串</span></span><br><span class="line">        String rsaPublicKey = <span class="string">&quot;MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAKBvz9cma+hXNiv2yXg6e1PyZhHVZm3bJXDvTJP2LyXo4vs9grH36Q9kNgr6quHtuU6fEoUxUu2zbEB8dkEWB9UCAwEAAQ==&quot;</span>;</span><br><span class="line">        <span class="comment">// RSA私钥BASE64字符串</span></span><br><span class="line">        String rsaPrivateKey = <span class="string">&quot;MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEAoG/P1yZr6Fc2K/bJeDp7U/JmEdVmbdslcO9Mk/YvJeji+z2CsffpD2Q2Cvqq4e25Tp8ShTFS7bNsQHx2QRYH1QIDAQABAkEAjemZXORdesz52/WVzEVepai6ZHfw/Kdl/PmPMSoIFmz7mk55rprl2Akn2V0odSiHSnMWvDmOUIAvHaHF4Re4wQIhAN5GxVeF7ndyoWasxqIOVb6baNkUrapBM0nacPS4WA8JAiEAuMcvNM2Z1rW74JagoGlSIfRkNUqa+3LTCN/fK7VR2W0CICs/+gYduVjkpSMlW0ENKQH9m1kh/Oiz5xbnujLj676BAiBVGif7wdXgtcLaJYXFW7ygNtcQVFQdCz13EOTQVKpl4QIgY2YyH3vUYI2J68qCGtYjj5iNHUEwwze+Za1R7y0V43k=&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------- 还原公钥 --------</span></span><br><span class="line">        <span class="keyword">byte</span>[] publicKeyBytes = Base64.getDecoder().decode(rsaPublicKey);</span><br><span class="line">        X509EncodedKeySpec x509EncodedKeySpec = <span class="keyword">new</span> X509EncodedKeySpec(publicKeyBytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);</span><br><span class="line">        PublicKey publicKey = keyFactory.generatePublic(x509EncodedKeySpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------- 还原私钥 --------</span></span><br><span class="line">        <span class="keyword">byte</span>[] privateKeyBytes = Base64.getDecoder().decode(rsaPrivateKey);</span><br><span class="line">        PKCS8EncodedKeySpec pkcs8EncodedKeySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(privateKeyBytes);</span><br><span class="line">        PrivateKey privateKey = keyFactory.generatePrivate(pkcs8EncodedKeySpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------- 测试加解密 --------</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(transform);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">byte</span>[] pubEncryptBytes = cipher.doFinal(value.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA公钥加密数据: &quot;</span> + Base64.getEncoder().encodeToString(pubEncryptBytes));</span><br><span class="line"></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">byte</span>[] priDecryptBytes = cipher.doFinal(pubEncryptBytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA私钥解密数据: &quot;</span> + <span class="keyword">new</span> String(priDecryptBytes));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">RSA</span>公钥加密数据: clQ<span class="number">6</span>HuRVCWHm<span class="number">3</span>pCJ<span class="number">6</span>yTbj/mW<span class="number">7</span>clTwe/ZE<span class="number">7</span>IfMah<span class="number">3</span>aPzdHJMle<span class="number">6</span>AqD<span class="number">4</span>sPLkLwskn+<span class="number">4</span>nZ<span class="number">1</span>gYlvkoqceJiFm+IkIg==</span><br><span class="line"><span class="attribute">RSA</span>私钥解密数据: Doug Wilson</span><br></pre></td></tr></table></figure>

<h2 id="分段加解密"><a href="#分段加解密" class="headerlink" title="分段加解密"></a>分段加解密</h2><p>RSA加解密中必须考虑到的密钥长度、明文长度和密文长度问题。明文长度需要小于密钥长度，而密文长度则等于密钥长度。因此当加密内容长度大于密钥长度时，有效的RSA加解密就需要对内容进行分段。</p>
<p>这是因为，RSA算法本身要求加密内容也就是明文长度m必须满足<code>0&lt;m&lt;密钥长度n</code>。如果小于这个长度就需要进行padding，因为如果没有padding，就无法确定解密后内容的真实长度，字符串之类的内容问题还不大，以0作为结束符，但对二进制数据就很难，因为不确定后面的0是内容还是内容结束符。而只要用到padding，那么就要占用实际的明文长度，于是实际明文长度需要减去padding字节长度。我们一般使用的padding标准有NoPPadding、OAEPPadding、PKCS1Padding等，其中PKCS#1建议的padding就占用了11个字节。</p>
<p>以秘钥长度为1024bits为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       StringBuilder value = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">29</span>; i++) &#123;</span><br><span class="line">           value.append(<span class="string">&quot;18cm&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;待加密内容长度: &quot;</span> + value.toString().length());</span><br><span class="line">       <span class="comment">// 加密算法</span></span><br><span class="line">       String algorithm = <span class="string">&quot;RSA&quot;</span>;</span><br><span class="line">       <span class="comment">// 转换模式</span></span><br><span class="line">       String transform = <span class="string">&quot;RSA/ECB/PKCS1Padding&quot;</span>;</span><br><span class="line">       <span class="comment">// 实例化秘钥对生成器</span></span><br><span class="line">       KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm);</span><br><span class="line">       <span class="comment">// 初始化，秘钥长度512~16384位，64倍数</span></span><br><span class="line">       keyPairGenerator.initialize(<span class="number">1024</span>);</span><br><span class="line">       <span class="comment">// 生成秘钥对</span></span><br><span class="line">       KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">       <span class="comment">// 公钥</span></span><br><span class="line">       PublicKey publicKey = keyPair.getPublic();</span><br><span class="line">       System.out.println(<span class="string">&quot;RSA公钥: &quot;</span> + Base64.getEncoder().encodeToString(publicKey.getEncoded()));</span><br><span class="line">       <span class="comment">// 私钥</span></span><br><span class="line">       PrivateKey privateKey = keyPair.getPrivate();</span><br><span class="line">       System.out.println(<span class="string">&quot;RSA私钥: &quot;</span> + Base64.getEncoder().encodeToString(privateKey.getEncoded()));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// ------ 测试公钥加密，私钥解密 ------</span></span><br><span class="line">       Cipher cipher = Cipher.getInstance(transform);</span><br><span class="line">       cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">       <span class="keyword">byte</span>[] pubEncryptBytes = cipher.doFinal(value.toString().getBytes());</span><br><span class="line">       System.out.println(<span class="string">&quot;RSA公钥加密后数据: &quot;</span> + Base64.getEncoder().encodeToString(pubEncryptBytes));</span><br><span class="line"></span><br><span class="line">       cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">       <span class="keyword">byte</span>[] priDecryptBytes = cipher.doFinal(pubEncryptBytes);</span><br><span class="line">       System.out.println(<span class="string">&quot;RSA私钥解密后数据: &quot;</span> + <span class="keyword">new</span> String(priDecryptBytes));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// ------ 测试私钥加密，公钥解密 ------</span></span><br><span class="line">       cipher.init(Cipher.ENCRYPT_MODE, privateKey);</span><br><span class="line">       <span class="keyword">byte</span>[] priEncryptBytes = cipher.doFinal(value.toString().getBytes());</span><br><span class="line">       System.out.println(<span class="string">&quot;RSA私钥加密后数据: &quot;</span> + Base64.getEncoder().encodeToString(priEncryptBytes));</span><br><span class="line"></span><br><span class="line">       cipher.init(Cipher.DECRYPT_MODE, publicKey);</span><br><span class="line">       <span class="keyword">byte</span>[] pubDecryptBytes = cipher.doFinal(priEncryptBytes);</span><br><span class="line">       System.out.println(<span class="string">&quot;RSA公钥解密后数据: &quot;</span> + <span class="keyword">new</span> String(pubDecryptBytes));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">待加密内容长度: <span class="number">120</span></span><br><span class="line">RSA公钥: MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrYRsr7qLnZSv2SmDOjddnAc2K0SYVY4lg3o/l85mFCFEivkse0aKVBQ068E7P2HlHhBvDP97hlGUt8z4pH7XZqRBVsBPT+HlYJTXsYB2FZC+Vdm+bSq75JxHyVI0ov1jLUImFV6j/Des7KC/<span class="number">68</span>TZ4qmIMbwwlt8vAuTmy8MD3KQIDAQAB</span><br><span class="line">RSA私钥: MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAKthGyvuoudlK/ZKYM6N12cBzYrRJhVjiWDej+XzmYUIUSK+Sx7RopUFDTrwTs/YeUeEG8M/<span class="number">3</span>uGUZS3zPikftdmpEFWwE9P4eVglNexgHYVkL5V2b5tKrvknEfJUjSi/WMtQiYVXqP8N6zsoL/rxNniqYgxvDCW3y8C5ObLwwPcpAgMBAAECgYBE+dNezjAgo7aa7Pqjh7EfUzlv2pfSWfpr04flDDNIuL03F5HSeJtQEPVvOFLwEndVklU+M1G4RuqmINVu5cVhhrURkNNKvFC0LhjeEABXqdhiGmmIpPJ1SGq0bVcjtHXjP1Ee2R+JKmtbh6CYuBeKn5QTX2VQi+uyXJrAJnUndQJBAPy1JiPFCbZXPQ890zzxXtV9ymrCieudLrQNHHATwoiMhTUO3XbfhdEtwbEKcdxrgBV2duIg8NOSWnVUT/g/Y+<span class="number">8</span>CQQCtnLRUOzB6zIc8PLbIrNaNwygabA90aSWpft0EDNf5qGBW0ISgJ6R8Le6Fz29uzGaGC3UP1B4yq7oFJj2aUl5nAkBKdGDZVxtmcsuVqwSKxx7GzfoOfGTAW55ABEDlsJy3OJeiq0+Kz46Qs+eGbupfI/kn2bBrLYNnAo7OVNn+<span class="number">7</span>UZXAkAsrIY6poBzGO4zsevW96K+F9nZ8rSHYAcw9lQpFqT8uTcRH9cA3zKUQb1+<span class="number">8</span>UHbYP2AwLH+wLaEk2vqp0xyyX9BAkEAimpo/rQ+<span class="number">14</span>ydBHJK5gWrEstp7lIyyrF9GWLGcH7unGXIzezxCuoZZkoY2uO9c8RZ8jYlk6anYgrFCdugBXCnDg==</span><br><span class="line"></span><br><span class="line">javax<span class="selector-class">.crypto</span><span class="selector-class">.IllegalBlockSizeException</span>: Data must not be longer than <span class="number">117</span> bytes</span><br><span class="line"></span><br><span class="line">	at java.base/com<span class="selector-class">.sun</span><span class="selector-class">.crypto</span><span class="selector-class">.provider</span><span class="selector-class">.RSACipher</span><span class="selector-class">.doFinal</span>(RSACipher<span class="selector-class">.java</span>:<span class="number">347</span>)</span><br><span class="line">	at java.base/com<span class="selector-class">.sun</span><span class="selector-class">.crypto</span><span class="selector-class">.provider</span><span class="selector-class">.RSACipher</span><span class="selector-class">.engineDoFinal</span>(RSACipher<span class="selector-class">.java</span>:<span class="number">392</span>)</span><br><span class="line">	at java.base/javax<span class="selector-class">.crypto</span><span class="selector-class">.Cipher</span><span class="selector-class">.doFinal</span>(Cipher<span class="selector-class">.java</span>:<span class="number">2208</span>)</span><br><span class="line">	at com<span class="selector-class">.doug</span><span class="selector-class">.wilson</span><span class="selector-class">.rsa</span><span class="selector-class">.Demo</span><span class="selector-class">.test</span>(Demo<span class="selector-class">.java</span>:<span class="number">40</span>)</span><br><span class="line">	at java.base/jdk<span class="selector-class">.internal</span><span class="selector-class">.reflect</span><span class="selector-class">.NativeMethodAccessorImpl</span><span class="selector-class">.invoke0</span>(Native Method)</span><br><span class="line">	at java.base/jdk<span class="selector-class">.internal</span><span class="selector-class">.reflect</span><span class="selector-class">.NativeMethodAccessorImpl</span><span class="selector-class">.invoke</span>(NativeMethodAccessorImpl<span class="selector-class">.java</span>:<span class="number">62</span>)</span><br><span class="line">	at java.base/jdk<span class="selector-class">.internal</span><span class="selector-class">.reflect</span><span class="selector-class">.DelegatingMethodAccessorImpl</span><span class="selector-class">.invoke</span>(DelegatingMethodAccessorImpl<span class="selector-class">.java</span>:<span class="number">43</span>)</span><br><span class="line">	at java.base/java<span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.Method</span><span class="selector-class">.invoke</span>(Method<span class="selector-class">.java</span>:<span class="number">567</span>)</span><br><span class="line">	at org<span class="selector-class">.junit</span><span class="selector-class">.runners</span><span class="selector-class">.model</span>.FrameworkMethod$<span class="number">1</span><span class="selector-class">.runReflectiveCall</span>(FrameworkMethod<span class="selector-class">.java</span>:<span class="number">50</span>)</span><br><span class="line">	at </span><br><span class="line">	......</span><br></pre></td></tr></table></figure>

<p>对于1024长度的密钥。128字节（1024bits/8）减去PKCS#1建议的padding就占用了11个字节正好是117字节。所以加密的明文长度120字节大于117字节，程序抛出了异常。</p>
<p>要解决这个问题，可以采用分段加密的手段。编写一个分段加解密的工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RSA分段加解密</span></span><br><span class="line"><span class="comment"> * 针对秘钥长度为1024bits</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RsaUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大加密块长度 1024/8 - 11</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENCRYPT_BLOCK = <span class="number">117</span>;</span><br><span class="line">    <span class="comment">// 最大解密块长度 1024/8</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_DECRYPT_BLOCK = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRANSFORM = <span class="string">&quot;RSA/ECB/PKCS1Padding&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value     待加密值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(PublicKey publicKey, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">            Cipher cipher = Cipher.getInstance(TRANSFORM);</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = value.getBytes();</span><br><span class="line">            <span class="keyword">int</span> length = bytes.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> offSet = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] cache;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 对数据分段加密</span></span><br><span class="line">            <span class="keyword">while</span> (length - offSet &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (length - offSet &gt; MAX_ENCRYPT_BLOCK) &#123;</span><br><span class="line">                    cache = cipher.doFinal(bytes, offSet, MAX_ENCRYPT_BLOCK);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cache = cipher.doFinal(bytes, offSet, length - offSet);</span><br><span class="line">                &#125;</span><br><span class="line">                out.write(cache, <span class="number">0</span>, cache.length);</span><br><span class="line">                i++;</span><br><span class="line">                offSet = i * MAX_ENCRYPT_BLOCK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] encryptedData = out.toByteArray();</span><br><span class="line">            <span class="keyword">return</span> Base64.getEncoder().encodeToString(encryptedData);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encrypt    带解密值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解密值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(PrivateKey privateKey, String encrypt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">            Cipher cipher = Cipher.getInstance(TRANSFORM);</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = Base64.getDecoder().decode(encrypt);</span><br><span class="line">            <span class="keyword">int</span> length = bytes.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> offSet = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] cache;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 对数据分段解密</span></span><br><span class="line">            <span class="keyword">while</span> (length - offSet &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (length - offSet &gt; MAX_DECRYPT_BLOCK) &#123;</span><br><span class="line">                    cache = cipher.doFinal(bytes, offSet, MAX_DECRYPT_BLOCK);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cache = cipher.doFinal(bytes, offSet, length - offSet);</span><br><span class="line">                &#125;</span><br><span class="line">                out.write(cache, <span class="number">0</span>, cache.length);</span><br><span class="line">                i++;</span><br><span class="line">                offSet = i * MAX_DECRYPT_BLOCK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] decryptedData = out.toByteArray();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(decryptedData);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       StringBuilder value = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">29</span>; i++) &#123;</span><br><span class="line">           value.append(<span class="string">&quot;18cm&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;待加密内容长度: &quot;</span> + value.toString().length());</span><br><span class="line">       <span class="comment">// 加密算法</span></span><br><span class="line">       String algorithm = <span class="string">&quot;RSA&quot;</span>;</span><br><span class="line">       <span class="comment">// 实例化秘钥对生成器</span></span><br><span class="line">       KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm);</span><br><span class="line">       <span class="comment">// 初始化，秘钥长度512~16384位，64倍数</span></span><br><span class="line">       keyPairGenerator.initialize(<span class="number">1024</span>);</span><br><span class="line">       <span class="comment">// 生成秘钥对</span></span><br><span class="line">       KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">       <span class="comment">// 公钥</span></span><br><span class="line">       PublicKey publicKey = keyPair.getPublic();</span><br><span class="line">       System.out.println(<span class="string">&quot;RSA公钥: &quot;</span> + Base64.getEncoder().encodeToString(publicKey.getEncoded()));</span><br><span class="line">       <span class="comment">// 私钥</span></span><br><span class="line">       PrivateKey privateKey = keyPair.getPrivate();</span><br><span class="line">       System.out.println(<span class="string">&quot;RSA私钥: &quot;</span> + Base64.getEncoder().encodeToString(privateKey.getEncoded()));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// ------ 测试公钥加密，私钥解密 ------</span></span><br><span class="line">       String pubEncrypt= RsaUtil.encrypt(publicKey, value.toString());</span><br><span class="line">       System.out.println(<span class="string">&quot;RSA公钥加密后数据: &quot;</span> + pubEncrypt);</span><br><span class="line"></span><br><span class="line">       String priDecrypt = RsaUtil.decrypt(privateKey, pubEncrypt);</span><br><span class="line">       System.out.println(<span class="string">&quot;RSA私钥解密后数据: &quot;</span> + priDecrypt);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">待加密内容长度: <span class="number">120</span></span><br><span class="line">RSA公钥: MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDFO9e1imMmI73<span class="regexp">/nss+4Qy272mvePgKo6l5wKj8X2kYXc7LriJ3U4l9Rlggh+h59PhycbxSzeAPiJRLDuIHbh9XO1ETtMh3LkaqWlUHYqfUkwGBk6TnYDn7fF+nRuMrj0WkKo5cCKL9+Pqc/y</span>GCQxUo5TEALNNcqZh+VRrQc7vEiwIDAQAB</span><br><span class="line">RSA私钥: MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAMU717WKYyYjvf+eyz7hDLbvaa94+AqjqXnAqPxfaRhdzsuuIndTiX1GWCCH6Hn0+HJxvFLN4A+IlEsO4gduH1c7URO0yHcuRqpaVQdip9STAYGTpOdgOft8X6dG4yuPRaQqjlwIov34+pz<span class="regexp">/IYJDFSjlMQAs01ypmH5VGtBzu8SLAgMBAAECgYEAw4ASy/</span>bVWpu5HCSJb9VhZf8f8fflXZ5mQbHvjuD<span class="regexp">/6lApyAjeTws10EAm4G/</span><span class="number">2</span>xtREZCRKuIUrIBqQa2ngL98<span class="regexp">/HdlfsMpKsOFwoWYOTdbrg7v7GlfzoPIy4XnciIrtwCg24MFiHT2lY685aBcwRITFQtxqReZT3kWIH3yQAglc/</span>xkCQQDqzr57v0grxiCKYzHLW4Jggiq7wIv0I1b+pOt4DPqhThQuzcNBXuJoT1pXOPhk7w6K<span class="regexp">/Kd77yPkuyg5hC14TtF1AkEA1wjzbGMKqr3o0ab3iVGRU8xMYFPU6CBqxVeSrf8iz0meUbDAkN9N0e7B8jgW1r6xc+n1SwisCmARulCoM8d9/</span>wJADIaK0r8ZcnxXMAqqlVaEVfGbpfhXfuaDtYHGrdjDZedsXDLNv6b4HOhewVhgp8G43OEtbgcLux<span class="regexp">/gvXC3nDtYIQJAROP1OJAyZqkY4bHgM/</span>oR2QrmnSW+W++mxTpdH6lReZ9YPUunJcKkp9EaCYO2rW3CZCRcFYHdvCUzCMG2YYBT+QJBAIRGQhiWGwrI8dSqfx+Ays5qKc1zPfAF35O6OB3rE52CPx87hLTnkBxCh3PWaR62rrwwaNPsTHxiG3Isa6dj8QI=</span><br><span class="line">RSA公钥加密后数据: Bc8n04ImBwKbf+mTHBA92qrEK4OH+lzS1LDRm8rTSPn0snTfofM1iXMRiOxdaVIr1dDi0SLQHNCBMoSHJUJIXSg8JG1qrkMG684NimqdMVbSTuQZMowMpEHjdCrYfNScmJ2nKidHiW5En7Iz7uNDG20DCtGwBu49snPPj8vtgPoR1XY5fzIpS1QMNEjtwYcbriuF2D5iRUQM3x1klvHMFeIgNBXVFSHYeYt4SjmzHDaXp8hmGO7HhAaiUJhX1iNRkMO21JipBKQBDwG/D8yysdDYxS4ijeCLYgF8bhM2NC7kXCXA0rN2yINWy0PTCUnz7KlWBXaK3lZW0IrzI5WynQ==</span><br><span class="line">RSA私钥解密后数据: <span class="number">18</span>cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm</span><br></pre></td></tr></table></figure>

<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ol>
<li>公钥是通过A发送给B的，其在传递过程中很有可能被截获，也就是说窃听者很有可能获得公钥。如果窃听者获得了公钥，向A发送数据，A是无法辨别消息的真伪的。因此，虽然可以使用公钥对数据加密，但这种方式还是会有存在一定的安全隐患。如果要建立更安全的加密消息传递模型，就需要AB双方构建两套非对称加密算法密钥，仅遵循“私钥加密，公钥解密”的方式进行加密消息传递；</li>
<li>RSA不适合加密过长的数据，虽然可以通过分段加密手段解决，但过长的数据加解密耗时较长，在响应速度要求较高的情况下慎用。一般推荐使用非对称加密算法传输对称加密秘钥，双方数据加密用对称加密算法加解密。</li>
</ol>
]]></content>
      <tags>
        <tag>非对称加密</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis级联</title>
    <url>/2020/12/19/MyBatis%E7%BA%A7%E8%81%94/</url>
    <content><![CDATA[<p>MyBatis中的级联分为3种：association，collection和discriminator：</p>
<ol>
<li><p><code>association</code>：代表一对一关系，比如学生和学生证是一对一关系。</p>
</li>
<li><p><code>collection</code>：代表一对多关系，比如学生和课程是一对多关系，一个学生可以有多个课程。</p>
</li>
<li><p><code>discriminator</code>：鉴别器，它可以根据实际选择采用哪个类作为实例，允许你根据特定的条件去关联不同的结果集。</p>
</li>
</ol>
<span id="more"></span>

<p>设计一个模型关系：</p>
<p><img src="/images/%E5%AD%A6%E7%94%9F%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B.png"></p>
<p>根据模型新建库表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_lecture(</span><br><span class="line">    id <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">    lecture_name <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;课程名称&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">table</span> t_student(</span><br><span class="line">    id <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">    cnname <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;学生姓名&#x27;</span>,</span><br><span class="line">    sex TINYINT(<span class="number">4</span>) <span class="keyword">not</span> <span class="keyword">null</span> COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">    selfcard_no <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学生证号&#x27;</span>,</span><br><span class="line">    note <span class="type">VARCHAR</span>(<span class="number">1024</span>) COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">table</span> t_student_health_female(</span><br><span class="line">    id <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">    student_id <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;学生编号&#x27;</span>,</span><br><span class="line">    check_date <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;检查日期&#x27;</span>,</span><br><span class="line">    heart <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;心&#x27;</span>,</span><br><span class="line">    liver <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;肝&#x27;</span>,</span><br><span class="line">    spleen <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;脾&#x27;</span>,</span><br><span class="line">    lung <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;肺&#x27;</span>,</span><br><span class="line">    kidney <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;肾&#x27;</span>,</span><br><span class="line">    uterus <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;子宫&#x27;</span>,</span><br><span class="line">    note <span class="type">VARCHAR</span>(<span class="number">1024</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> comment <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">table</span> t_student_health_male(</span><br><span class="line">    id <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">    student_id <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;学生编号&#x27;</span>,</span><br><span class="line">    check_date <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;检查日期&#x27;</span>,</span><br><span class="line">    heart <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;心&#x27;</span>,</span><br><span class="line">    liver <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;肝&#x27;</span>,</span><br><span class="line">    spleen <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;脾&#x27;</span>,</span><br><span class="line">    lung <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;肺&#x27;</span>,</span><br><span class="line">    kidney <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;肾&#x27;</span>,</span><br><span class="line">    prostate <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;前列腺&#x27;</span>,</span><br><span class="line">    note <span class="type">VARCHAR</span>(<span class="number">1024</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> comment <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_student_lecture(</span><br><span class="line">    id <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">    student_id <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;学生编号&#x27;</span>,</span><br><span class="line">    lecture_id <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;课程编号&#x27;</span>,</span><br><span class="line">    grade <span class="type">DECIMAL</span>(<span class="number">16</span>,<span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;评分&#x27;</span>,</span><br><span class="line">    note <span class="type">VARCHAR</span>(<span class="number">1024</span>) comment <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_student_selfcard(</span><br><span class="line">    id <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">    student_id <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;学生编号&#x27;</span>,</span><br><span class="line">    native <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;籍贯&#x27;</span>,</span><br><span class="line">    issue_date <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> comment <span class="string">&#x27;发证日期&#x27;</span>,</span><br><span class="line">    end_date <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;结束日期&#x27;</span>,</span><br><span class="line">    note <span class="type">VARCHAR</span>(<span class="number">1024</span>) comment <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="association"><a href="#association" class="headerlink" title="association"></a>association</h2><p>用t_student和t_student_selfcard演示一对一级联。</p>
<p>新增Student POJO：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String cnName;</span><br><span class="line">    <span class="keyword">private</span> Sex sex;</span><br><span class="line">    <span class="keyword">private</span> Long selfCardNo;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    <span class="comment">//一对一关系</span></span><br><span class="line">    <span class="keyword">private</span> StudentSelfcard selfCard;</span><br><span class="line">    <span class="comment">// getter，setter略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StudentSelfcard POJO：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentSelfcard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Long studentId;</span><br><span class="line">    <span class="keyword">private</span> String natives;</span><br><span class="line">    <span class="keyword">private</span> Date issueDate;</span><br><span class="line">    <span class="keyword">private</span> Date endDate;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    <span class="comment">// getter，setter略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义接口StudentSelfcardMapper：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentSelfcardMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentSelfcard <span class="title">findStudentSelfcardByStudentId</span><span class="params">(Long id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertStudentSelfcard</span><span class="params">(StudentSelfcard selfCard)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建对应的映射文件StudentSelfcardMapper.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>    </span><br><span class="line">    <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>   </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentSelfcardMapper&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;studentSelfcard_column&quot;</span>&gt;</span></span><br><span class="line">        id,student_id as studentId,native as natives,issue_date as issueDate,</span><br><span class="line">        end_date as endDate,note</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findStudentSelfcardByStudentId&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">resultType</span>=<span class="string">&quot;studentSelfcard&quot;</span>&gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;studentSelfcard_column&quot;</span>/&gt;</span> </span><br><span class="line">        from t_student_selfcard where student_id = #&#123;studentId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertStudentSelfcard&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;studentSelfcard&quot;</span>&gt;</span></span><br><span class="line">        insert into t_student_selfcard (student_id,native,issue_date,end_date,</span><br><span class="line">        note) values (#&#123;studentId&#125;,#&#123;natives&#125;,#&#123;issueDate&#125;,#&#123;endDate&#125;,#&#123;note&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着定义接口StudentMapper：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">public interface StudentMapper &#123;</span><br><span class="line">    public Student findStudentById(Long id);</span><br><span class="line">    public int createStudent(Student s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其相对于的映射文件StudentMapper.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>    </span><br><span class="line">    <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>   </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentMapper&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;student&quot;</span> <span class="attr">id</span>=<span class="string">&quot;studentList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;cnname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;cnName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">typeHandler</span>=<span class="string">&quot;org.apache.ibatis.type.EnumTypeHandler&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;selfcard_no&quot;</span> <span class="attr">property</span>=<span class="string">&quot;selfCardNo&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;note&quot;</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 一对一关联，column指定用哪列的值作为select查询的条件，如果有多个值用</span></span><br><span class="line"><span class="comment">            逗号隔开，select指定查询方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;selfCard&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">select</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentSelfcardMapper.findStudentSelfcardByStudentId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;student_column&quot;</span>&gt;</span></span><br><span class="line">        id,cnname as cnName,sex,selfcard_no as selfCardNo,note </span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findStudentById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentList&quot;</span>&gt;</span></span><br><span class="line">        select </span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;student_column&quot;</span>/&gt;</span> </span><br><span class="line">        from t_student where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置主键回填，供t_student_selfcard的student_id字段使用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;createStudent&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;student&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        insert into t_student(cnname,sex,selfcard_no,note) values (#&#123;cnName&#125;,</span><br><span class="line">        #&#123;sex,typeHandler=org.apache.ibatis.type.EnumTypeHandler&#125;,</span><br><span class="line">        #&#123;selfCardNo&#125;,#&#123;note&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>设置别名，指定mapper略。</p>
<p>先往库表插入值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = SqlSessionFactoryUtil.openSqlSession();</span><br><span class="line">StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">StudentSelfcardMapper selfcardMapper = sqlSession.getMapper(StudentSelfcardMapper.class);</span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.setCnName(<span class="string">&quot;辛久奈&quot;</span>);</span><br><span class="line">student.setNote(<span class="string">&quot;旋涡辛久奈&quot;</span>);</span><br><span class="line">student.setSelfCardNo(<span class="number">10000L</span>);</span><br><span class="line">student.setSex(Sex.FEMALE);</span><br><span class="line"><span class="keyword">int</span> n = studentMapper.createStudent(student);</span><br><span class="line"><span class="keyword">if</span>( n == <span class="number">1</span>)&#123;</span><br><span class="line">    StudentSelfcard selfCard = <span class="keyword">new</span> StudentSelfcard();</span><br><span class="line">    selfCard.setStudentId(student.getId());</span><br><span class="line">    selfCard.setNatives(<span class="string">&quot;福州&quot;</span>);</span><br><span class="line">    selfCard.setIssueDate(<span class="keyword">new</span> Date());</span><br><span class="line">    selfCard.setEndDate(<span class="keyword">new</span> Date());</span><br><span class="line">    selfCard.setNote(<span class="string">&quot;旋涡辛久奈的学生证&quot;</span>);</span><br><span class="line">    selfcardMapper.insertStudentSelfcard(selfCard);</span><br><span class="line">&#125;</span><br><span class="line">sqlSession.commit();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>查询库表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_student;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+-------------+------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> cnname <span class="operator">|</span> sex    <span class="operator">|</span> selfcard_no <span class="operator">|</span> note       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+-------------+------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span> 辛久奈  <span class="operator">|</span> FEMALE <span class="operator">|</span>   <span class="number">10000</span>    <span class="operator">|</span> 旋涡辛久奈  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+-------------+------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_student_selfcard;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+--------+------------+------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> student_id <span class="operator">|</span> native <span class="operator">|</span> issue_date <span class="operator">|</span> end_date   <span class="operator">|</span> note               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+--------+------------+------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span>         <span class="number">10</span> <span class="operator">|</span> 福州   <span class="operator">|</span> <span class="number">2017</span><span class="number">-01</span><span class="number">-06</span> <span class="operator">|</span> <span class="number">2017</span><span class="number">-01</span><span class="number">-06</span> <span class="operator">|</span> 旋涡辛久奈的学生证   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+--------+------------+------------+--------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>插入成功，现测试级联获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = SqlSessionFactoryUtil.openSqlSession();</span><br><span class="line">StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">Student student = studentMapper.findStudentById(<span class="number">10L</span>);</span><br><span class="line">System.out.println(student.getSelfCard().getNote());</span><br><span class="line">sqlSession.commit();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">旋涡辛久奈的学生证</span><br></pre></td></tr></table></figure>

<p>success.</p>
<h2 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h2><p>学生和学生成绩是一对多的关系，所以用t_student和t_student_lecture表练习一对多级联。</p>
<p>修改Student POJO：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String cnName;</span><br><span class="line">    <span class="keyword">private</span> Sex sex;</span><br><span class="line">    <span class="keyword">private</span> Long selfCardNo;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    <span class="comment">//一对多关联</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;StudentLecture&gt; lectures;</span><br><span class="line">    <span class="comment">// getter，setter略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增StudentLecture POJO：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentLecture</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Long studentId;</span><br><span class="line">    <span class="keyword">private</span> Long lectureId;</span><br><span class="line">    <span class="keyword">private</span> Double grade;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    <span class="comment">// getter，setter略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建StudentLectureMapper接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentLectureMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;StudentLecture&gt; <span class="title">getLecturesByStudentId</span><span class="params">(Long studentId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertStudentLecture</span><span class="params">(StudentLecture lecture)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其对应的映射文件StudentLectureMapper.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>    </span><br><span class="line">    <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>   </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentLectureMapper&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;studentLecture&quot;</span> <span class="attr">id</span>=<span class="string">&quot;lectures&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;student_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;studentId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;lecture_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lectureId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;grade&quot;</span> <span class="attr">property</span>=<span class="string">&quot;grade&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;note&quot;</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;student_lecture_column&quot;</span>&gt;</span></span><br><span class="line">        id,student_id as studentId,lecture_id as lectureId,grade,note </span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getLecturesByStudentId&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">resultMap</span>=<span class="string">&quot;lectures&quot;</span>&gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;student_lecture_column&quot;</span>/&gt;</span> </span><br><span class="line">        from t_student_lecture where student_id = #&#123;studentId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertStudentLecture&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        &lt;![CDATA[</span><br><span class="line">            insert into t_student_lecture(student_id,lecture_id,grade,note) </span><br><span class="line">            values (#&#123;studentId&#125;,#&#123;lectureId&#125;,#&#123;grade&#125;,#&#123;note&#125;)</span><br><span class="line">        ]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改StudentMapper.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>    </span><br><span class="line">    <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>   </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentMapper&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;student&quot;</span> <span class="attr">id</span>=<span class="string">&quot;studentList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;cnname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;cnName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">typeHandler</span>=<span class="string">&quot;org.apache.ibatis.type.EnumTypeHandler&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;selfcard_no&quot;</span> <span class="attr">property</span>=<span class="string">&quot;selfCardNo&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;note&quot;</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 一对多关联，column指定用哪列的值作为select查询的条件，如果由多个值用</span></span><br><span class="line"><span class="comment">            逗号隔开，select指定查询方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;lectures&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">select</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentLectureMapper.getLecturesByStudentId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;student_column&quot;</span>&gt;</span></span><br><span class="line">        id,cnname as cnName,sex,selfcard_no as selfCardNo,note </span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findStudentById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentList&quot;</span>&gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;student_column&quot;</span>/&gt;</span> </span><br><span class="line">        from t_student where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置主键回填，供t_student_selfcard的student_id字段使用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;createStudent&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;student&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        insert into t_student(cnname,sex,selfcard_no,note) values (#&#123;cnName&#125;,</span><br><span class="line">        #&#123;sex,typeHandler=org.apache.ibatis.type.EnumTypeHandler&#125;,</span><br><span class="line">        #&#123;selfCardNo&#125;,#&#123;note&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>先插入一些测试数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = SqlSessionFactoryUtil.openSqlSession();</span><br><span class="line">StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">StudentLectureMapper lectureMapper = sqlSession.getMapper(StudentLectureMapper.class);</span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.setCnName(<span class="string">&quot;水门&quot;</span>);</span><br><span class="line">student.setSelfCardNo(<span class="number">11111L</span>);</span><br><span class="line">student.setNote(<span class="string">&quot;波风水门&quot;</span>);</span><br><span class="line">student.setSex(Sex.MALE);</span><br><span class="line"><span class="keyword">int</span> n = studentMapper.createStudent(student);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">    Long studentId = student.getId();</span><br><span class="line">    String[] noteArr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;语文成绩&quot;</span>,<span class="string">&quot;数学成绩&quot;</span>,<span class="string">&quot;英语成绩&quot;</span>&#125;;</span><br><span class="line">    Double[] gradeArr = <span class="keyword">new</span> Double[]&#123;<span class="number">99.0</span>,<span class="number">100.0</span>,<span class="number">98.0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;noteArr.length;i++)&#123;</span><br><span class="line">        StudentLecture lecture = <span class="keyword">new</span> StudentLecture();</span><br><span class="line">        lecture.setStudentId(studentId);</span><br><span class="line">        lecture.setLectureId(Long.valueOf(i));</span><br><span class="line">        lecture.setGrade(gradeArr[i]);</span><br><span class="line">        lecture.setNote(noteArr[i]);</span><br><span class="line">        lectureMapper.insertStudentLecture(lecture);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sqlSession.commit();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>查询数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_student;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+-------------+------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> cnname <span class="operator">|</span> sex    <span class="operator">|</span> selfcard_no <span class="operator">|</span> note       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+-------------+------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span> 辛久奈 <span class="operator">|</span> FEMALE <span class="operator">|</span>       <span class="number">10000</span> <span class="operator">|</span> 旋涡辛久奈  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12</span> <span class="operator">|</span> 水门   <span class="operator">|</span> MALE   <span class="operator">|</span>       <span class="number">11111</span> <span class="operator">|</span> 波风水门    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+-------------+------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_student_lecture;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+------------+--------+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> student_id <span class="operator">|</span> lecture_id <span class="operator">|</span> grade  <span class="operator">|</span> note     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+------------+--------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span>         <span class="number">12</span> <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span>  <span class="number">99.00</span> <span class="operator">|</span> 语文成绩  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span>         <span class="number">12</span> <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> <span class="number">100.00</span> <span class="operator">|</span> 数学成绩  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span>         <span class="number">12</span> <span class="operator">|</span>          <span class="number">2</span> <span class="operator">|</span>  <span class="number">98.00</span> <span class="operator">|</span> 英语成绩  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+------------+--------+----------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>插入成功，现测试级联获取lectures：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = SqlSessionFactoryUtil.openSqlSession();</span><br><span class="line">StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">Student student = studentMapper.findStudentById(<span class="number">12L</span>);</span><br><span class="line">List&lt;StudentLecture&gt; lectures = student.getLectures();</span><br><span class="line"><span class="keyword">for</span>(StudentLecture l : lectures)&#123;</span><br><span class="line">    System.out.println(l.getNote()+<span class="string">&quot;：&quot;</span>+l.getGrade());</span><br><span class="line">&#125; </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">语文成绩：99.0</span><br><span class="line">数学成绩：100.0</span><br><span class="line">英语成绩：98.0</span><br></pre></td></tr></table></figure>

<p>success.</p>
<h2 id="discriminator"><a href="#discriminator" class="headerlink" title="discriminator"></a>discriminator</h2><p>鉴别器其实同其他级联一样，只不过是多了个鉴别的过程罢了。</p>
<p>为了学习鉴别器，我们向t_student_health_female和t_student_health_male中插入一组数据：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">INSERT INTO `t_student_health_female`</span><br><span class="line">VALUES(</span><br><span class="line">    1,</span><br><span class="line">    &#x27;10&#x27;,</span><br><span class="line">    &#x27;2017-1-6&#x27;,</span><br><span class="line">    &#x27;心正常&#x27;,</span><br><span class="line">    &#x27;肝正常&#x27;,</span><br><span class="line">    &#x27;脾正常&#x27;,</span><br><span class="line">    &#x27;肺正常&#x27;,</span><br><span class="line">    &#x27;肾正常&#x27;,</span><br><span class="line">    &#x27;子宫正常&#x27;,</span><br><span class="line">    &#x27;健康&#x27;);</span><br><span class="line"> </span><br><span class="line">INSERT INTO `t_student_health_male`</span><br><span class="line">VALUES(</span><br><span class="line">    1,</span><br><span class="line">    &#x27;12&#x27;,</span><br><span class="line">    &#x27;2017-1-6&#x27;,</span><br><span class="line">    &#x27;心脏良好&#x27;,</span><br><span class="line">    &#x27;肝良好&#x27;,</span><br><span class="line">    &#x27;脾良好&#x27;,</span><br><span class="line">    &#x27;肺良好&#x27;,</span><br><span class="line">    &#x27;肾良好&#x27;,</span><br><span class="line">    &#x27;前列腺良好&#x27;,</span><br><span class="line">    &#x27;健康&#x27;);</span><br></pre></td></tr></table></figure>

<p>其对应的实体类StudentHealthFemale和StudentHealthMale略。</p>
<p>新增两个POJO：MaleStudent和FemaleStudent均继承自Student：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaleStudent</span> <span class="keyword">extends</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;StudentHealthMale&gt; studentHealthMaleList;</span><br><span class="line">   <span class="comment">// getter，setter略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FemaleStudent</span> <span class="keyword">extends</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;StudentHealthFemale&gt; studentHealthFemaleList;</span><br><span class="line">    <span class="comment">// getter，setter略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着编写两个接口StudentHealthMaleMapper和StudentHealthFemaleMapper，包含一个根据studentId获取health的抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mrbird.leanote.pojo.StudentHealthMale;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentHealthMaleMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentHealthMale <span class="title">findStudentHealthMaleByStudentId</span><span class="params">(Long studentId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mrbird.leanote.pojo.StudentHealthFemale;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentHealthFemaleMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentHealthFemale <span class="title">findStudentHealthFemaleByStudentId</span><span class="params">(Long studentId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>各自对应的映射器：</p>
<p>StudentHealthMaleMapper.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>    </span><br><span class="line">    <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>   </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentHealthMaleMapper&quot;</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findStudentHealthMaleByStudentId&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">resultType</span>=<span class="string">&quot;studentHealthMale&quot;</span>&gt;</span></span><br><span class="line">        select * from t_student_health_male where student_id = #&#123;studentId&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为在MyBatis配置文件中配置了<code>&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</code>，并且数据库命名规范，所以这里可以用select * from…</p>
<p>studentHealthFemaleMapper.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>   </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentHealthFemaleMapper&quot;</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findStudentHealthFemaleByStudentId&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">resultType</span>=<span class="string">&quot;studentHealthFemale&quot;</span>&gt;</span></span><br><span class="line">        select * from t_student_health_female where student_id = #&#123;studentId&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接下来就是重点了，我们修改StudentMapper.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>    </span><br><span class="line">    <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>   </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentMapper&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 定义maleStudentList，类型为“maleStudent”。这是一个一对多关联，一个学生可以体检多次。</span></span><br><span class="line"><span class="comment">        调用的方法为findStudentHealthMaleByStudentId。</span></span><br><span class="line"><span class="comment">        正如其POJO继承Student那样，resultMap也同样继承自studentList--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;maleStudent&quot;</span> <span class="attr">id</span>=<span class="string">&quot;maleStudentList&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;studentList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;studentHealthMaleList&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">select</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentHealthMaleMapper</span></span></span><br><span class="line"><span class="string"><span class="tag">                .findStudentHealthMaleByStudentId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;femaleStudent&quot;</span> <span class="attr">id</span>=<span class="string">&quot;femaleStudentList&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;studentList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;studentHealthFemaleList&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">select</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentHealthFemaleMapper</span></span></span><br><span class="line"><span class="string"><span class="tag">                .findStudentHealthFemaleByStudentId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;student&quot;</span> <span class="attr">id</span>=<span class="string">&quot;studentList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;cnname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;cnName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;selfcard_no&quot;</span> <span class="attr">property</span>=<span class="string">&quot;selfCardNo&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;note&quot;</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置鉴别器，类似于switch，用于鉴别的列为“sex”，</span></span><br><span class="line"><span class="comment">            值为MALE时结果集为maleStudentList</span></span><br><span class="line"><span class="comment">            值为FEMALE时结果集为femaleStudentList --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;MALE&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;maleStudentList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;FEMALE&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;femaleStudentList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;student_column&quot;</span>&gt;</span></span><br><span class="line">        id,cnname as cnName,sex,selfcard_no as selfCardNo,note </span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findStudentById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentList&quot;</span>&gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;student_column&quot;</span>/&gt;</span> </span><br><span class="line">        from t_student where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = SqlSessionFactoryUtil.openSqlSession();</span><br><span class="line">StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">MaleStudent student = (MaleStudent) studentMapper.findStudentById(<span class="number">12L</span>);</span><br><span class="line">System.out.println(student.getCnName()+<span class="string">&quot;的&quot;</span>+</span><br><span class="line">    student.getStudentHealthMaleList().get(<span class="number">0</span>).getProstate());</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>页面输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">水门的前例腺良好</span><br></pre></td></tr></table></figure>

<h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><p>假如一次性将所有与Student有关的信息都加载出来，这必定会造成性能的问题，如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>    </span><br><span class="line">    <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>   </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentMapper&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;student&quot;</span> <span class="attr">id</span>=<span class="string">&quot;studentList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;cnname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;cnName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;selfcard_no&quot;</span> <span class="attr">property</span>=<span class="string">&quot;selfCardNo&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;note&quot;</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;selfCard&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">select</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentSelfcardMapper</span></span></span><br><span class="line"><span class="string"><span class="tag">                .findStudentSelfcardByStudentId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;lectures&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">select</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentLectureMapper</span></span></span><br><span class="line"><span class="string"><span class="tag">                .getLecturesByStudentId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;MALE&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;maleStudentList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;FEMALE&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;femaleStudentList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  ...  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>MyBatis的延迟加载策略可以很好的应对这种情况。只需在mybatis-config.xml中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">&lt;!-- 开启延迟加载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 关闭按层级加载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在级联标签上可以自由的配置fetchType=”lazy”或者fetchType=”eager”来改变加载策略。</p>
<h2 id="另外一种级联"><a href="#另外一种级联" class="headerlink" title="另外一种级联"></a>另外一种级联</h2><p>所谓的另外一种级联就是用一条sql查出所有学生的信息，没有性能问题。</p>
<p>在StudentMapper中定义一个查找所有学生信息的抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">finAllStudentMsg</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>其映射文件如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>    </span><br><span class="line">    <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>   </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mrbird.leanote.mapper.StudentMapper&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;finAllStudentMsg&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;allStudentList&quot;</span>&gt;</span></span><br><span class="line">        select s.id,s.cnname,s.sex,s.selfcard_no,s.note as snote,</span><br><span class="line">        IF (s.sex = &#x27;MALE&#x27;,shm.id,shf.id) as hid,</span><br><span class="line">        IF (s.sex = &#x27;MALE&#x27;,shm.check_date,shf.check_date) as checkDate,</span><br><span class="line">        IF (s.sex = &#x27;MALE&#x27;,shm.heart,shf.heart) as heart,</span><br><span class="line">        IF (s.sex = &#x27;MALE&#x27;,shm.liver,shf.liver) as liver,</span><br><span class="line">        IF (s.sex = &#x27;MALE&#x27;,shm.spleen,shf.spleen) as spleen,</span><br><span class="line">        IF (s.sex = &#x27;MALE&#x27;,shm.lung,shf.lung) as lung,</span><br><span class="line">        IF (s.sex = &#x27;MALE&#x27;,shm.kidney,shf.kidney) as kidney,</span><br><span class="line">        IF (s.sex = &#x27;MALE&#x27;,shm.note,shf.note) as hnote,</span><br><span class="line">        shm.prostate,shf.uterus,</span><br><span class="line">        ss.id as ssid,ss.native as natives,</span><br><span class="line">        ss.issue_date as issueDate,ss.end_date as endDate,</span><br><span class="line">        ss.note as ssNote,</span><br><span class="line">        sl.id as slid,sl.lecture_id as lectureId,sl.grade,</span><br><span class="line">        sl.note as slNote </span><br><span class="line">        FROM t_student s </span><br><span class="line">        LEFT JOIN t_student_health_male shm on s.id = shm.student_id </span><br><span class="line">        LEFT JOIN t_student_health_female shf on s.id = shf.student_id </span><br><span class="line">        LEFT JOIN t_student_selfcard ss on s.id = ss.student_id </span><br><span class="line">        LEFT JOIN t_student_lecture sl on s.id = sl.student_id </span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;student&quot;</span> <span class="attr">id</span>=<span class="string">&quot;allStudentList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;cnname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;cnName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;selfcard_no&quot;</span> <span class="attr">property</span>=<span class="string">&quot;selfCardNo&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;snote&quot;</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- javaType属性告诉MyBtis用哪个类去映射这些字段 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;selfCard&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;studentSelfcard&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ssid&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;studentId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;natives&quot;</span> <span class="attr">column</span>=<span class="string">&quot;natives&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;issueDate&quot;</span> <span class="attr">column</span>=<span class="string">&quot;issueDate&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;endDate&quot;</span> <span class="attr">column</span>=<span class="string">&quot;endDate&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ssNote&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;lectures&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;studentLecture&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;slid&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;studentId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;lectureId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;lectureId&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;grade&quot;</span> <span class="attr">column</span>=<span class="string">&quot;grade&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span> <span class="attr">column</span>=<span class="string">&quot;slNote&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;MALE&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;maleStudentList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;FEMALE&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;femaleStudentList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;maleStudent&quot;</span> <span class="attr">id</span>=<span class="string">&quot;maleStudentList&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;allStudentList&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ofType属性指定了其泛型 --&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;studentHealthMaleList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;studentHealthMale&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;hid&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;studentId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;checkDate&quot;</span> <span class="attr">column</span>=<span class="string">&quot;checkDate&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;heart&quot;</span> <span class="attr">column</span>=<span class="string">&quot;heart&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;liver&quot;</span> <span class="attr">column</span>=<span class="string">&quot;liver&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;spleen&quot;</span> <span class="attr">column</span>=<span class="string">&quot;spleen&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;lung&quot;</span> <span class="attr">column</span>=<span class="string">&quot;lung&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;kidney&quot;</span> <span class="attr">column</span>=<span class="string">&quot;kidney&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;prostate&quot;</span> <span class="attr">column</span>=<span class="string">&quot;prostate&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span> <span class="attr">column</span>=<span class="string">&quot;hnote&quot;</span>/&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;femaleStudent&quot;</span> <span class="attr">id</span>=<span class="string">&quot;femaleStudentList&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;allStudentList&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;studentHealthFemaleList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;studentHealthFemale&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;hid&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;studentId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;checkDate&quot;</span> <span class="attr">column</span>=<span class="string">&quot;checkDate&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;heart&quot;</span> <span class="attr">column</span>=<span class="string">&quot;heart&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;liver&quot;</span> <span class="attr">column</span>=<span class="string">&quot;liver&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;spleen&quot;</span> <span class="attr">column</span>=<span class="string">&quot;spleen&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;lung&quot;</span> <span class="attr">column</span>=<span class="string">&quot;lung&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;kidney&quot;</span> <span class="attr">column</span>=<span class="string">&quot;kidney&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;uterus&quot;</span> <span class="attr">column</span>=<span class="string">&quot;uterus&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;note&quot;</span> <span class="attr">column</span>=<span class="string">&quot;hnote&quot;</span>/&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试finAllStudentMsg方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sqlSession = SqlSessionFactoryUtil.openSqlSession();</span><br><span class="line">StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">List&lt;Student&gt; students = studentMapper.finAllStudentMsg();</span><br><span class="line"><span class="keyword">for</span>(Student student : students)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;MALE&quot;</span>.equalsIgnoreCase(student.getSex().toString()))&#123;</span><br><span class="line">        MaleStudent male = (MaleStudent) student;</span><br><span class="line">        System.out.println(male.getCnName()+<span class="string">&quot;的卡号：&quot;</span>+male.getSelfCardNo());</span><br><span class="line">        StudentSelfcard selfcard = male.getSelfCard();</span><br><span class="line">        System.out.println(<span class="string">&quot;来自：&quot;</span>+selfcard.getNatives()+<span class="string">&quot;,&quot;</span>+selfcard.getNote());</span><br><span class="line">        List&lt;StudentLecture&gt; lectures = male.getLectures();</span><br><span class="line">        <span class="keyword">for</span>(StudentLecture le : lectures)&#123;</span><br><span class="line">            System.out.println(le.getNote()+<span class="string">&quot;：&quot;</span>+le.getGrade());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;StudentHealthMale&gt; healthMales = male.getStudentHealthMaleList();</span><br><span class="line">        <span class="keyword">for</span>(StudentHealthMale healthMale : healthMales)&#123;</span><br><span class="line">            System.out.println(healthMale.getCheckDate()+<span class="string">&quot;，&quot;</span>+healthMale.getProstate());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	FemaleStudent female = (FemaleStudent) student;</span><br><span class="line">    	System.out.println(female.getCnName()+<span class="string">&quot;的卡号：&quot;</span>+female.getSelfCardNo());</span><br><span class="line">    	StudentSelfcard selfcard = female.getSelfCard();</span><br><span class="line">    	System.out.println(<span class="string">&quot;来自：&quot;</span>+selfcard.getNatives()+<span class="string">&quot;,&quot;</span>+selfcard.getNote());</span><br><span class="line">    	List&lt;StudentLecture&gt; lectures = female.getLectures();</span><br><span class="line">    	<span class="keyword">for</span>(StudentLecture le : lectures)&#123;</span><br><span class="line">            System.out.println(le.getNote()+<span class="string">&quot;：&quot;</span>+le.getGrade());</span><br><span class="line">    	&#125;</span><br><span class="line">    	List&lt;StudentHealthFemale&gt; healthFemales = female.getStudentHealthFemaleList();</span><br><span class="line">    	<span class="keyword">for</span>(StudentHealthFemale healthfemale : healthFemales)&#123;</span><br><span class="line">            System.out.println(healthfemale.getCheckDate()+<span class="string">&quot;，&quot;</span>+healthfemale.getUterus());</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">辛久奈的卡号：10000</span><br><span class="line">来自：福州,旋涡辛久奈的学生证</span><br><span class="line">语文成绩：99.0</span><br><span class="line">数学成绩：99.0</span><br><span class="line">英语成绩：99.0</span><br><span class="line">2017<span class="string">-1</span><span class="string">-6</span>，子宫正常</span><br><span class="line">水门的卡号：11111</span><br><span class="line">来自：厦门,波风水门的学生证</span><br><span class="line">语文成绩：99.0</span><br><span class="line">数学成绩：100.0</span><br><span class="line">英语成绩：98.0</span><br><span class="line">2017<span class="string">-1</span><span class="string">-6</span>，前例腺良好</span><br></pre></td></tr></table></figure>

<p>这种方式比较直观明了，但是SQL编写起来较为繁琐。</p>
]]></content>
      <tags>
        <tag>MyBatis, 级联</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring框架</title>
    <url>/2020/02/23/Spring%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>Spring作为现在最优秀的框架之一，被广泛地使用并且其地位越来越重要。”Spring全家桶”这个词也逐渐流行于程序员间。但无论Spring家族如何变化，其最核心的永远是Spring中的骨架——Spring Bean/Spring Core/Spring Context，这三个jar包是所有Spring工具的使用基础，也是整个Spring框架的基础结构。</p>
<span id="more"></span>

<h2 id="Spring基础架构"><a href="#Spring基础架构" class="headerlink" title="Spring基础架构"></a>Spring基础架构</h2><blockquote>
<p>Spring框架的总体架构图：</p>
<p><img src="/images/Spring%E6%A1%86%E6%9E%B6.png"></p>
<p>Spring的核心组件只有3个：Core/Context/Bean，它们构建起了整个Spring的骨架。其中Bean更是核心中的核心。</p>
<p>其实Spring就是面向Bean的编程(Bean Oriented Programming BOP)，Bean在Spring中的作用就像Object对OOP面向对象编程的意义一样，没有Bean对象就没有Spring存在的意义。而Spring之所以这么流行，就在于Spring解决了一个关键的问题：<strong>将对象间的依赖关系转为配置文件进行管理(依赖注入机制)。Spring将根据配置信息创建对象并将对象包装成Bean对象，然后又提供一个IOC容器，对容器中的Bean对象进行管理，并管理Bean对象间的依赖注入关系。</strong></p>
<p>这个IOC容器就是由Context来提供。Context要发现每个Bean之间的关系，并为Bean建立和维护好这种关系。所以，从另一个角度来说，Context也是一个Bean关系的集合，只不过我们将这种集合称为容器，更具体地说是叫IOC容器。一旦建立好这个容器，Spring就可以开始工作。</p>
<p>Core，其实更应该称为Util。它提供了发现Bean，建立Bean，维护每个Bean间关系所需要的一系列工具，是一个工具组件。</p>
</blockquote>
<h3 id="核心组件Bean"><a href="#核心组件Bean" class="headerlink" title="核心组件Bean"></a>核心组件Bean</h3><p>Bean组件：<code>org.springframework.beans</code></p>
<p>这个包下的类主要解决3件事情：Bean的定义、Bean的创建、Bean的解析</p>
<p>对于开发者来说，只需要了解Bean的创建，而Bean的定义，Bean的解析由Spring在内部完成，对开发者是透明的。也正因如此，使用Spring十分简单，就像面对对象编程中创建对象一样，你只需要知道如何创建(new)，创建过程对你来说是透明的。</p>
<blockquote>
<p><img src="/images/Bean%E5%B7%A5%E5%8E%82%E7%9A%84%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<p>Spring Bean是典型的工厂模式，顶级接口为BeanFactory。</p>
<p>BeanFactory有3个子类：ListableBeanFactory/HierarchicalBeanFactory/AutowireCapableBeanFactory(这从图中可以看出，hierarchical含义为体系的，等级的)，最终的默认实现类为DefaultListableBeanFactory，实现了所有接口。</p>
<p>为什么要定义这么多接口层次？其实每个接口都有它的使用场景，并对对象的数据访问做限制。比如ListableBeanFactory接口表示Bean是可列表的；HierarchicalBeanFactory接口表示Bean是有继承关系的(Bean有父Bean)；AutowireCapableBeanFactory接口定义Bean的自动装配规则。这可以从代码得到一窥：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String var1, Class&lt;T&gt; var2)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String var1, Object... var2)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; var1, Object... var2)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(Class&lt;T&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(ResolvableType var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String var1)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String var1)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String var1, ResolvableType var2)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String var1, Class&lt;?&gt; var2)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getType(String var1) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getType(String var1, <span class="keyword">boolean</span> var2) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    String[] getAliases(String var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略一些方法</span></span><br><span class="line">    String[] getBeanDefinitionNames();</span><br><span class="line">    </span><br><span class="line">    String[] getBeanNamesForType(ResolvableType var1);</span><br><span class="line">    </span><br><span class="line">    String[] getBeanNamesForType(ResolvableType var1, <span class="keyword">boolean</span> var2, <span class="keyword">boolean</span> var3);</span><br><span class="line">    </span><br><span class="line">    String[] getBeanNamesForType(<span class="meta">@Nullable</span> Class&lt;?&gt; var1);</span><br><span class="line">    </span><br><span class="line">    String[] getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt; var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HierarchicalBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">BeanFactory <span class="title">getParentBeanFactory</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsLocalBean</span><span class="params">(String var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> AUTOWIRE_NO = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> AUTOWIRE_BY_NAME = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> AUTOWIRE_BY_TYPE = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> AUTOWIRE_CONSTRUCTOR = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//省略一些方法</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">createBean</span><span class="params">(Class&lt;T&gt; var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">autowireBean</span><span class="params">(Object var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Object <span class="title">configureBean</span><span class="params">(Object var1, String var2)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Object <span class="title">createBean</span><span class="params">(Class&lt;?&gt; var1, <span class="keyword">int</span> var2, <span class="keyword">boolean</span> var3)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Object <span class="title">autowire</span><span class="params">(Class&lt;?&gt; var1, <span class="keyword">int</span> var2, <span class="keyword">boolean</span> var3)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当Spring成功解析定义的一个&lt;bean/&gt;节点(@Component,@Bean)后，在Spring内部它就被转化成BeanDefinition对象，之后所有的操作都是对这个对象进行。</strong></p>
<p>Bean的解析过程比较复杂，主要就是对Spring配置文件的解析，之后再进行学习了解。</p>
</blockquote>
<h3 id="核心组件Context"><a href="#核心组件Context" class="headerlink" title="核心组件Context"></a>核心组件Context</h3><blockquote>
<p>Context组件类结构图：</p>
<p><img src="/images/Context%E7%BB%84%E4%BB%B6%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<p>从图中我们可知，ApplicationContext是Context的顶级父类，有两个子类：ConfigurableApplicationContext和WebApplicationContext。ApplicationContext继承了BeanFactory，说明Spring容器的主体是Bean对象。此外，ApplicationContext还继承了多个接口，这主要是用于扩展ApplicationContext的功能。比如ApplicationContext继承的ResourceLoader接口，可以使ApplicationContext访问到任何外部资源。</p>
<p>主要对ApplicationContext的子类做个简要说明：</p>
<ul>
<li>ConfigurableApplicationContext表示该Context是可修改的，也就是说在构建Context时，用户可以动态地添加或修改已有的配置信息。ConfigurableApplicationContext有多个子类，使用较多的是AbstractRefreshableApplicationContext类，为可更新Context。</li>
<li>WebApplicationContext顾名思义就是为Web准备的Context，可以直接访问ServletContext。这个接口用的比较少。</li>
</ul>
<p>总的来说，ApplicationContext必须要完成以下几件事：</p>
<ol>
<li>标识一个应用环境</li>
<li>利用BeanFactory创建Bean对象</li>
<li>保存对象间的关系表</li>
<li>捕获各种事件</li>
</ol>
</blockquote>
<h3 id="核心组件Core"><a href="#核心组件Core" class="headerlink" title="核心组件Core"></a>核心组件Core</h3><blockquote>
<p>Core组件包含了许多关键类，一个比较重要的部分就是定义了资源的访问方式。</p>
</blockquote>
<h3 id="IOC容器如何工作"><a href="#IOC容器如何工作" class="headerlink" title="IOC容器如何工作"></a>IOC容器如何工作</h3><blockquote>
<p>IOC容器实际上是Context组件和其他两个组件beans和core共同构建的一个Bean关系网。Bean关系网具体构建过程，在context包的AbstractApplicationContext类的refresh方法中。就其源码和注释，开始分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">			<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">            <span class="comment">// 准备用于刷新的context</span></span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 告诉子类刷新内部的BeanFactory并获取用于在context中创建Bean对象的BeanFactory，</span></span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 配置BeanFactory所需要的contex特征(环境)</span></span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">                <span class="comment">// 允许context的子类对BeanFactory进行后处理</span></span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">                <span class="comment">// 激活BeanFactory的PostProcessor并将其注册为context的bean对象，用于拦截bean</span></span><br><span class="line">                <span class="comment">//对象的创建</span></span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">				<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">                <span class="comment">// 初始化context的MessageSource</span></span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">                <span class="comment">// 初始化context的EventMulticaster</span></span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">                <span class="comment">// 初始化特定的context子类中的特定Bean对象</span></span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">                <span class="comment">// 检查并注册Listener监听器的Bean对象</span></span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">                <span class="comment">// 实例化所有non-lazy-init的单例Bean</span></span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">                <span class="comment">// 发布相应的事件</span></span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">					logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">							<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">				<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">				resetCommonCaches();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>refresh方法就是构建整个IOC容器过程的完整代码，要知道如何构建IOC容器的，就需要对上面的代码进行研究。大体步骤如下：</p>
<ol>
<li>构建BeanFactory，以便生产Bean对象</li>
<li>注册相关事件</li>
<li>创建Bean实例对象</li>
<li>触发被监听的事件</li>
</ol>
<h4 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh()"></a>prepareRefresh()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prepare this context for refreshing, setting its startup date and</span></span><br><span class="line"><span class="comment"> * active flag as well as performing any initialization of property sources.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 准备用于刷新的context，设定开始日期，活动标识，初始化属性源</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Switch to active.</span></span><br><span class="line">	<span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">	<span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Refreshing &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Refreshing &quot;</span> + getDisplayName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line">       <span class="comment">//由具体子类实现，父类中该方法默认为空方法</span></span><br><span class="line">	initPropertySources();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Validate that all properties marked as required are resolvable:</span></span><br><span class="line">	<span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">	getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">		<span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">		<span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">	<span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">	<span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory()"></a>obtainFreshBeanFactory()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the fresh BeanFactory instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	refreshBeanFactory();  <span class="comment">//父类方法没有实现，只有在子类 AbstractRefreshableApplicationContext中才有实现</span></span><br><span class="line">	<span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// refreshBeanFactory()方法实现</span></span><br><span class="line">	<span class="comment">// 刷新context用于生产Bean对象的BeanFactory，如果它已经存在则将其关闭，不存在则创建一个新的BeanFactory用于context生命周期的下一个阶段</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * This implementation performs an actual refresh of this context&#x27;s underlying</span></span><br><span class="line"><span class="comment">	 * bean factory, shutting down the previous bean factory (if any) and</span></span><br><span class="line"><span class="comment">	 * initializing a fresh bean factory for the next phase of the context&#x27;s lifecycle.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">//BeanFactory存在则关闭</span></span><br><span class="line">		<span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">			destroyBeans();</span><br><span class="line">			closeBeanFactory();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//不存在则创建</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里采用BeanFactory的默认子类DefaultListableBeanFactory作为context的BeanFactory</span></span><br><span class="line">			DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">			beanFactory.setSerializationId(getId());</span><br><span class="line">			customizeBeanFactory(beanFactory);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//这行代码最为关键，解析Bean的定义，将其加载到BeanFactory中。换句话说就是加载解析Bean的定义，将用户自定义的数据结构转化为IOC容器中的数据结构，这样一来，才能被BeanFactory构建成一个Bean对象</span></span><br><span class="line">			loadBeanDefinitions(beanFactory); </span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">				<span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="prepareBeanFactory-ConfigurableListableBeanFactory"><a href="#prepareBeanFactory-ConfigurableListableBeanFactory" class="headerlink" title="prepareBeanFactory(ConfigurableListableBeanFactory)"></a>prepareBeanFactory(ConfigurableListableBeanFactory)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置BeanFactory所需要的contex特征(环境)</span></span><br><span class="line"><span class="comment">// 如context的类加载器和后处理器</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configure the factory&#x27;s standard context characteristics,</span></span><br><span class="line"><span class="comment"> * such as the context&#x27;s ClassLoader and post-processors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the BeanFactory to configure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Tell the internal bean factory to use the context&#x27;s class loader etc.</span></span><br><span class="line">	beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">	beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">	beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">	beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">	beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">	<span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">	beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">	beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">	beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">	beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">		<span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">		beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register default environment beans.</span></span><br><span class="line">	<span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="postProcessBeanFactory、invokeBeanFactoryPostProcessors、registerBeanPostProcessors"><a href="#postProcessBeanFactory、invokeBeanFactoryPostProcessors、registerBeanPostProcessors" class="headerlink" title="postProcessBeanFactory、invokeBeanFactoryPostProcessors、registerBeanPostProcessors"></a>postProcessBeanFactory、invokeBeanFactoryPostProcessors、registerBeanPostProcessors</h4><p>三个方法主要用于Spring的功能扩展。postProcessBeanFactory用于对已经构建的BeanFactory的配置做修改，invokeBeanFactoryPostProcessors和registerBeanPostProcessors则是可以对创建的Bean对象添加一些自定义的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于在BeanFactory初始化后修改ApplicationContext内部BeanFactory。此时所有的Bean的定义</span></span><br><span class="line"><span class="comment">// 已经被加载，但是还未被实例化。因此，可以允许在特定的ApplicationContext中注册特殊的</span></span><br><span class="line"><span class="comment">// BeanPostProcessors等，扩展Spring功能。</span></span><br><span class="line"><span class="comment">// 在具体子类中实现，父类提供空方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Modify the application context&#x27;s internal bean factory after its standard</span></span><br><span class="line"><span class="comment"> * initialization. All bean definitions will have been loaded, but no beans</span></span><br><span class="line"><span class="comment"> * will have been instantiated yet. This allows for registering special</span></span><br><span class="line"><span class="comment"> * BeanPostProcessors etc in certain ApplicationContext implementations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当有明确的指令时，实例化和激活所有已注册的BeanFactoryPostProcessor的Bean对象</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and invoke all registered BeanFactoryPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before singleton instantiation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">	<span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">		beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Instantiate and register all BeanPostProcessor beans,</span></span><br><span class="line"><span class="comment">	 * respecting explicit order if given.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Must be called before any instantiation of application beans.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="initMessageSource-、initApplicationEventMulticaster-、onRefresh-、registerListeners"><a href="#initMessageSource-、initApplicationEventMulticaster-、onRefresh-、registerListeners" class="headerlink" title="initMessageSource()、initApplicationEventMulticaster()、onRefresh()、registerListeners()"></a>initMessageSource()、initApplicationEventMulticaster()、onRefresh()、registerListeners()</h4><p>这几个方法主要是初始化操作，以及初始化监听事件、对系统其他监听者的注册。</p>
<h4 id="finishBeanFactoryInitialization-beanFactory"><a href="#finishBeanFactoryInitialization-beanFactory" class="headerlink" title="finishBeanFactoryInitialization(beanFactory)"></a>finishBeanFactoryInitialization(beanFactory)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结束context的BeanFactory的初始化过程</span></span><br><span class="line"><span class="comment">// 并初始化non-lazy单例Bean对象</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the initialization of this context&#x27;s bean factory,</span></span><br><span class="line"><span class="comment"> * initializing all remaining singleton beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">			beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">		beanFactory.setConversionService(</span><br><span class="line">				beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">	<span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">	<span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">	<span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">		beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">	String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">		getBean(weaverAwareName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Bean的实例化代码，由3个方法完成</span></span><br><span class="line">       <span class="comment">// 不使用TempClassLoader类加载器</span></span><br><span class="line">	<span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">	beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 禁止修改当前Bean的配置信息</span></span><br><span class="line">	<span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">	beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 实例化non-lazy-init类型的单例Bean</span></span><br><span class="line">	<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">	beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Bean的实例化代码，我们也可看出，Bean的实例化都在BeanFactory完成。比较重要的方法就是preInstantiateSingletons方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.trace(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">        Iterator var2 = beanNames.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            String beanName;</span><br><span class="line">            Object bean;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    RootBeanDefinition bd;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="keyword">do</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (!var2.hasNext()) &#123;</span><br><span class="line">                                    var2 = beanNames.iterator();</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">                                        <span class="comment">//核心实现部分</span></span><br><span class="line">                                        beanName = (String)var2.next();</span><br><span class="line">                                        Object singletonInstance = <span class="keyword">this</span>.getSingleton(beanName);</span><br><span class="line">                                        <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">                                            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton)singletonInstance;</span><br><span class="line">                                            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                                AccessController.doPrivileged(() -&gt; &#123;</span><br><span class="line">                                                    smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                                                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                                                &#125;, <span class="keyword">this</span>.getAccessControlContext());</span><br><span class="line">                                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">return</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                beanName = (String)var2.next();</span><br><span class="line">                                bd = <span class="keyword">this</span>.getMergedLocalBeanDefinition(beanName);</span><br><span class="line">                            &#125; <span class="keyword">while</span>(bd.isAbstract());</span><br><span class="line">                        &#125; <span class="keyword">while</span>(!bd.isSingleton());</span><br><span class="line">                    &#125; <span class="keyword">while</span>(bd.isLazyInit());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.isFactoryBean(beanName)) &#123;</span><br><span class="line">                        bean = <span class="keyword">this</span>.getBean(<span class="string">&quot;&amp;&quot;</span> + beanName);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">this</span>.getBean(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span>(!(bean <span class="keyword">instanceof</span> FactoryBean));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//FactoryBean，一个重要的Bean对象，大部分扩展功能都与之相关</span></span><br><span class="line">            FactoryBean&lt;?&gt; factory = (FactoryBean)bean;</span><br><span class="line">            <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                SmartFactoryBean var10000 = (SmartFactoryBean)factory;</span><br><span class="line">                ((SmartFactoryBean)factory).getClass();</span><br><span class="line">                isEagerInit = (Boolean)AccessController.doPrivileged(var10000::isEagerInit, <span class="keyword">this</span>.getAccessControlContext());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isEagerInit = factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp; ((SmartFactoryBean)factory).isEagerInit();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在preInstantiateSingletons方法中出现了一个比较重要的Bean——FactoryBean。Spring多数的扩展功能都和该Bean有关。FactoryBean是一个工厂的Bean(将工厂包装成Bean对象)，是用于生产Bean实例对象的Bean。如果一个类继承FactoryBean，就可以自己定义生产Bean实例对象的方法，只需要继承它的getObject方法即可，然后在Spring内部，继承FactoryBean的类就会被实例化成FactoryBean的实例对象，再通过调用其getObject方法就能获取用户自定义的对象，从而为Spring提供良好的扩展性。</p>
<p>该方法的主要创建流程如下：</p>
<p><img src="/images/bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
</blockquote>
<h3 id="IOC容器的扩展"><a href="#IOC容器的扩展" class="headerlink" title="IOC容器的扩展"></a>IOC容器的扩展</h3><blockquote>
<p>Bean对象需要有一定的扩展性，前面也稍微提了一些用于扩展Bean对象功能的接口，主要有：BeanFactoryProcessor和BeanPostProcessor，它们分别在构建BeanFactory和构建Bean对象时调用。还有就是InitializingBean和DisposableBean，分别在Bean实例创建和销毁时被调用。可以实现这些接口中的方法，Spring在需要的时候会调用它们。另外一个比较重要的扩展就是FactoryBean，虽然它也是个Bean对象，但是是特殊的Bean对象，可以被用户更多地控制。</p>
<p>自己目前的水平，看这些东西是迷迷糊糊的，看部分内容可以看得懂，但是想要去学习更多，就显得吃力，困难。而Spring要掌握好内在机理，就看有没有掌握好Spring的扩展点，如何使用这些扩展点。很明显，写这篇博客的自己还没有达到这个水平。但我会加油，以后，希望自己能回来重新搞懂。</p>
</blockquote>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Linux命令第二版</title>
    <url>/2020/03/25/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4%E7%AC%AC%E4%BA%8C%E7%89%88/</url>
    <content><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><blockquote>
<h4 id="set和printenv"><a href="#set和printenv" class="headerlink" title="set和printenv"></a>set和printenv</h4><p>shell在环境中存储了两种变量，shell变量（bash存放的少量数据），环境变量（除shell变量外的其他所有变量）。此外，shell还存储了别名和shell函数。</p>
<p>set命令会同时显示shell变量和环境变量，printenv只会显示环境变量，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set | less   重定向到less便于查看</span><br><span class="line">printenv | less</span><br><span class="line">查看某个特定的变量：</span><br><span class="line">printenv USER</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>常用变量：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SHELL</td>
<td>本机shell名称</td>
</tr>
<tr>
<td>HOME</td>
<td>本机主目录的路径</td>
</tr>
<tr>
<td>LANG</td>
<td>本机语言的字符集和排序规则</td>
</tr>
<tr>
<td>PATH</td>
<td>以冒号分割的一个目录列表</td>
</tr>
<tr>
<td>PWD</td>
<td>当前工作目录</td>
</tr>
<tr>
<td>USER</td>
<td>用户名</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ printenv SHELL</span><br><span class="line">/bin/bash</span><br><span class="line">dougwilson@doug:~$ printenv HOME</span><br><span class="line">/home/dougwilson</span><br><span class="line">dougwilson@doug:~$ printenv LANG</span><br><span class="line">en_US.UTF-8</span><br><span class="line">dougwilson@doug:~$ printenv PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">dougwilson@doug:~$ printenv PWD</span><br><span class="line">/home/dougwilson</span><br><span class="line">dougwilson@doug:~$ printenv USER</span><br><span class="line">dougwilson</span><br></pre></td></tr></table></figure>

<p>也可以通过 echo $变量名 获取变量对应的值</p>
</blockquote>
<h3 id="VI行编辑器"><a href="#VI行编辑器" class="headerlink" title="VI行编辑器"></a>VI行编辑器</h3><blockquote>
<h4 id="基本命令-vi-q-q-w"><a href="#基本命令-vi-q-q-w" class="headerlink" title="基本命令 vi :q :q!  :w"></a>基本命令 vi :q :q!  :w</h4><ul>
<li>vi 启动vi行编辑器</li>
<li>vi filename.txt 启动行编辑器编辑filename.txt内容</li>
<li>:q 退出</li>
<li>:q! 强制退出</li>
<li>:w 保存编辑内容</li>
</ul>
<p>启动后，vi行编辑器是命令模式。在命令模式中，<strong>键盘上的每一个键都代表一条命令</strong>。如果要进行文本编辑，需要切换到插入模式。如何切换？按下<kbd>I</kbd>键即可切换到插入模式。</p>
<p>进入插入模式后，可编辑文本内容。当编辑完成，需要切换回命令模式。如何切换？按下<kbd>Esc</kbd>键即可切换回命令模式。</p>
<p>切换回命令模式后，有两个选择。一个是放弃编辑的内容，则可以在命令模式中通过命令 :q! 强制退出。另一个选择就是通过命令 :w 保存编辑内容，然后才退出。</p>
<h4 id="取消命令u-命令模式下有效"><a href="#取消命令u-命令模式下有效" class="headerlink" title="取消命令u(命令模式下有效)"></a>取消命令u(命令模式下有效)</h4><p>取消上一个命令执行的结果，回退到之前的状态</p>
<h4 id="常用光标移动命令-命令模式下有效"><a href="#常用光标移动命令-命令模式下有效" class="headerlink" title="常用光标移动命令(命令模式下有效)"></a>常用光标移动命令(命令模式下有效)</h4><table>
<thead>
<tr>
<th>光标移动效果</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>上下左右</td>
<td>方向键上下左右</td>
</tr>
<tr>
<td>移至本行开头</td>
<td>数字0</td>
</tr>
<tr>
<td>移至本行末尾</td>
<td><kbd>Shift</kbd>+<kbd>$</kbd></td>
</tr>
<tr>
<td>移至上一单词开头</td>
<td>W</td>
</tr>
<tr>
<td>移至下一单词开头</td>
<td>B</td>
</tr>
<tr>
<td>移到文件最后一行</td>
<td><kbd>Shift</kbd>+<kbd>G</kbd></td>
</tr>
<tr>
<td>移到文件第n行</td>
<td>输入数字再<kbd>Shift</kbd>+<kbd>G</kbd></td>
</tr>
</tbody></table>
<h4 id="插入模式——插入文本"><a href="#插入模式——插入文本" class="headerlink" title="插入模式——插入文本"></a>插入模式——插入文本</h4><p>以下操作均在命令模式中操作，在插入模式中编辑：</p>
<ul>
<li><kbd>I</kbd> 从光标开始处编辑，并进入插入模式</li>
<li><kbd>a</kbd> 从光标开始的下一个字符开始编辑，并进入插入模式</li>
<li><kbd>A</kbd> 光标自动移动到行末，可以在行末进行编辑，并进入插入模式</li>
<li><kbd>o</kbd> 在当前行的下方创建一个新行，光标移动到新行开头，并进入插入模式</li>
<li><kbd>O</kbd> 在当前行的上方创建一个新行，光标移动到新行开头，并进入插入模式</li>
</ul>
<h4 id="插入模式——删除文本"><a href="#插入模式——删除文本" class="headerlink" title="插入模式——删除文本"></a>插入模式——删除文本</h4><p>以下命令均在命令模式中操作：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>删除内容</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>光标所在字符</td>
</tr>
<tr>
<td>3x</td>
<td>光标所在字符和之后2个字符</td>
</tr>
<tr>
<td>dd</td>
<td>当前行</td>
</tr>
<tr>
<td>5dd</td>
<td>当前行和之后4行</td>
</tr>
<tr>
<td>dW</td>
<td>光标所在字符到下一个单词开头之前</td>
</tr>
<tr>
<td>d$</td>
<td>光标所在字符到当前行末尾</td>
</tr>
<tr>
<td>d0</td>
<td>光标所在字符到当前行开头</td>
</tr>
<tr>
<td>d^</td>
<td>光标所在字符到当前行下一个非空字符</td>
</tr>
<tr>
<td>dG</td>
<td>当前行到文件末尾</td>
</tr>
<tr>
<td>d20G</td>
<td>当前行到文件第20行</td>
</tr>
</tbody></table>
<h4 id="插入模式——剪切、复制、粘贴"><a href="#插入模式——剪切、复制、粘贴" class="headerlink" title="插入模式——剪切、复制、粘贴"></a>插入模式——剪切、复制、粘贴</h4><p>和命令d相关的操作都是剪切文本。在每次使用d命令之后，都会复制删除的内容进缓存，然后可以使用<kbd>p</kbd>命令将缓存中的内容粘贴到光标之后，或使用<kbd>P</kbd>命令将内容粘贴到光标之前。</p>
<p>下面是关于复制的命令，和剪切命令d很相似:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>复制内容</th>
</tr>
</thead>
<tbody><tr>
<td>yy</td>
<td>当前行</td>
</tr>
<tr>
<td>5yy</td>
<td>当前行和之后4行</td>
</tr>
<tr>
<td>yW</td>
<td>光标所在字符到下一个单词起始字符之前</td>
</tr>
<tr>
<td>y$</td>
<td>光标所在字符到当前行的末尾</td>
</tr>
<tr>
<td>y0</td>
<td>光标所在字符到当前行的起始</td>
</tr>
<tr>
<td>y^</td>
<td>光标所在字符到当前行下一个非空字符</td>
</tr>
<tr>
<td>yG</td>
<td>当前行到文件末尾</td>
</tr>
<tr>
<td>y20G</td>
<td>当前行到文件第20行</td>
</tr>
</tbody></table>
<h4 id="插入模式——搜索整个文件"><a href="#插入模式——搜索整个文件" class="headerlink" title="插入模式——搜索整个文件"></a>插入模式——搜索整个文件</h4><p>按下<kbd>/</kbd>键，输入要搜索的单词或短语，按下Enter结束。光标会移动到被搜索字符串的地方。按下n键，光标可以移动到下一个匹配的字符串，直到文件末尾。</p>
</blockquote>
<h3 id="挂载和卸载设备"><a href="#挂载和卸载设备" class="headerlink" title="挂载和卸载设备"></a>挂载和卸载设备</h3><blockquote>
<p>/etc/fstab文件内容列出了系统启动时挂载的设备（通常是硬盘分区）。部分文件内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LABEL=/12      /        ext3    defaults    1    1</span><br><span class="line">LABEL=/home    /home    ext3    defaults    1    2</span><br><span class="line">LABEL=/boot    /boot    ext3    defaults    1    2</span><br></pre></td></tr></table></figure>

<p>文件中6个字段（列）的含义：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>内容</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>设备</td>
<td>由于热拔插设备的存在（如USB驱动器），所以许多Linux发行版采用文本标签来关联设备。当设备与系统连接后，该标签就会被操作系统识别。</td>
</tr>
<tr>
<td>2</td>
<td>挂载节点</td>
<td>设备挂载到文件系统上目录的目录名称</td>
</tr>
<tr>
<td>3</td>
<td>文件系统类型</td>
<td>Linux能挂载许多文件类型，常见的有ext3，FAT32，NTFS，iso</td>
</tr>
<tr>
<td>4</td>
<td>选项</td>
<td>文件系统挂载时的选项参数</td>
</tr>
<tr>
<td>5</td>
<td>频率</td>
<td>该数值被dump命令用来决定是否对该文件系统进行备份以及多久备份一次</td>
</tr>
<tr>
<td>6</td>
<td>优先级</td>
<td>此数值被fsck命令决定在启动时需要被扫描的文件系统的顺序</td>
</tr>
</tbody></table>
<h4 id="mount-unmount"><a href="#mount-unmount" class="headerlink" title="mount/unmount"></a>mount/unmount</h4><p>mount命令可用于查看已经挂载的文件系统列表，或者用于挂载文件系统。</p>
<p>unmount命令可用于卸载设备。</p>
<p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount | less   查看已经挂载的文件系统列表，通常重定向到less查看</span><br><span class="line">显示的列表格式为：</span><br><span class="line">设备 on 挂载节点 type 文件系统类型 (选项参数)  </span><br><span class="line">如：</span><br><span class="line">sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">/dev/sr0 on /media/dougwilson/Ubuntu 20.10 amd64 type iso9660 (ro,nosuid,nodev,relatime,nojoliet,check=s,map=n,blocksize=2048,uid=1000,gid=1000,dmode=500,fmode=400,uhelper=udisks2)</span><br><span class="line"></span><br><span class="line">挂载设备格式：</span><br><span class="line">mount [设备名称] [设备挂载的文件系统的目录的目录名称]</span><br><span class="line">卸载设备格式：</span><br><span class="line">unmount [设备名称]</span><br><span class="line">如：</span><br><span class="line">mount -t iso9660 /dev/hdc /mnt/cdrom  /dev/hdc是设备名称，/mnt/cdrom是挂载文件系统，该操作含义为挂载光盘设备/deb/hdc到新的节点cdrom目录，并使用-t指定了文件系统的类型</span><br><span class="line">unmount /dev/hdc  卸载光盘设备</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><blockquote>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>find命令通过给定一个或若干个目录名作为其搜索范围。如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find ~ | less  列出当前系统主目录下的文件列表</span><br><span class="line">统计系统主目录下文件个数：</span><br><span class="line">dougwilson@doug:~$ find ~ | wc -l</span><br><span class="line">518</span><br></pre></td></tr></table></figure>

<p>find命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find 查找目录 [test选项] [action选项] [option选项]</span><br></pre></td></tr></table></figure>

<h5 id="test选项"><a href="#test选项" class="headerlink" title="test选项"></a>test选项</h5><p>常用test选项参数：</p>
<table>
<thead>
<tr>
<th>test参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-perm mode</td>
<td>寻找访问权限与既定模式匹配的文件或目录。既定模式可以以八进制或符号的形式表示</td>
</tr>
<tr>
<td>-size n</td>
<td>匹配n大小的文件</td>
</tr>
<tr>
<td>-type c</td>
<td>匹配c类型的文件</td>
</tr>
<tr>
<td>-empty</td>
<td>匹配空文件和空目录</td>
</tr>
<tr>
<td>-name pattern</td>
<td>匹配特定通配符模式的文件或目录</td>
</tr>
</tbody></table>
<p>-type支持搜索的文件类型：</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-type b</td>
<td>块设备文件</td>
</tr>
<tr>
<td>-type c</td>
<td>字符设备文件</td>
</tr>
<tr>
<td>-type d</td>
<td>目录</td>
</tr>
<tr>
<td>-type f</td>
<td>普通文件</td>
</tr>
<tr>
<td>-type l</td>
<td>符号链接</td>
</tr>
</tbody></table>
<p>-size支持的计量单位：</p>
<table>
<thead>
<tr>
<th>字母</th>
<th>单位</th>
</tr>
</thead>
<tbody><tr>
<td>-size b</td>
<td>512字节的块</td>
</tr>
<tr>
<td>-size c</td>
<td>字节</td>
</tr>
<tr>
<td>-size w</td>
<td>两个字节的字</td>
</tr>
<tr>
<td>-size k</td>
<td>KB</td>
</tr>
<tr>
<td>-size M</td>
<td>MB</td>
</tr>
<tr>
<td>-size G</td>
<td>GB</td>
</tr>
</tbody></table>
<p><strong>test选项操作符</strong></p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>-and</td>
<td>与</td>
</tr>
<tr>
<td>-or</td>
<td>或</td>
</tr>
<tr>
<td>-not</td>
<td>非</td>
</tr>
<tr>
<td>()</td>
<td>括号操作。注意在命令行中使用需要进行转义，它是特殊字符。</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find ~ -type d | wc -l    统计主目录下目录数量</span><br><span class="line">find ~ -type f | wc -l    统计主目录下普通文件数量</span><br><span class="line">find ~ -type f -name &quot;*.JPG&quot; -size +1M | wc -l  统计大于1M的JPG文件</span><br><span class="line">find ~ -type f -name &quot;*.JPG&quot; -size -1M | wc -l  统计小于1M的JPG文件</span><br><span class="line">find ~ -type f -name &quot;*.JPG&quot; -size 1M | wc -l   统计等于1M的JPG文件</span><br><span class="line">find ~ \(-type f -not -perm 0600\) -or \(-type f -not -perm 0700\) 确定主目录下是否所有文件和子目录都有安全的访问权限</span><br></pre></td></tr></table></figure>

<h5 id="action选项"><a href="#action选项" class="headerlink" title="action选项"></a>action选项</h5><p>常用选项参数：</p>
<table>
<thead>
<tr>
<th>动作</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>-delete</td>
<td>删除匹配文件</td>
</tr>
<tr>
<td>-ls</td>
<td>对匹配文件执行ls操作，输出文件信息</td>
</tr>
<tr>
<td>-print</td>
<td>将匹配的文件的全路径以标准形式输出。该操作是默认操作</td>
</tr>
<tr>
<td>-quit</td>
<td>一旦匹配便成功退出</td>
</tr>
</tbody></table>
<p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find ~ -print</span><br><span class="line">find ~ -type f -name &quot;*.BAK&quot; -delete</span><br></pre></td></tr></table></figure>

<h5 id="option选项"><a href="#option选项" class="headerlink" title="option选项"></a>option选项</h5><p>option选项用于控制find命令的搜索范围。暂且搁置。</p>
</blockquote>
<h3 id="打包压缩命令"><a href="#打包压缩命令" class="headerlink" title="打包压缩命令"></a>打包压缩命令</h3><blockquote>
<h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>tar命令用于对文件进行打包压缩或解压，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar [选项] [文件]</span><br></pre></td></tr></table></figure>

<p>常用选项：</p>
<table>
<thead>
<tr>
<th>选项参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>创建压缩文件</td>
</tr>
<tr>
<td>-C</td>
<td>解压到指定目录</td>
</tr>
<tr>
<td>-f</td>
<td>目标文件名</td>
</tr>
<tr>
<td>-p</td>
<td>保留原始权限与属性</td>
</tr>
<tr>
<td>-P</td>
<td>使用绝对路径进行压缩</td>
</tr>
<tr>
<td>-v</td>
<td>显示解压过程</td>
</tr>
<tr>
<td>-x</td>
<td>解压</td>
</tr>
<tr>
<td>-z</td>
<td>用Gzip压缩或解压</td>
</tr>
<tr>
<td>-j</td>
<td>用Bzip2压缩或解压</td>
</tr>
<tr>
<td>-t</td>
<td>查看压缩包内容</td>
</tr>
</tbody></table>
<p>常用选项组合：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">压缩文件：</span><br><span class="line">tar -czvf 压缩包名称 打包目录</span><br><span class="line">解压文件：</span><br><span class="line">tar -xzvf 压缩包名称 -C 解压文件存放的目录</span><br></pre></td></tr></table></figure>

<h4 id="gzip-gunzip文件压缩与解压"><a href="#gzip-gunzip文件压缩与解压" class="headerlink" title="gzip/gunzip文件压缩与解压"></a>gzip/gunzip文件压缩与解压</h4><p>gzip命令用于压缩一个或多个文件，执行后，原文件会被其压缩文件取代。</p>
<p>gunzip命令则将压缩文件还原为原文件。格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gzip filename...</span><br><span class="line">gunzip filename...</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ ls -l ls-output.txt</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 81043  5月 19 15:07 ls-output.txt</span><br><span class="line">dougwilson@doug:~$ ls -l ls-error.txt</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 56  5月 19 14:32 ls-error.txt</span><br><span class="line"></span><br><span class="line">dougwilson@doug:~$ gzip ls-output.txt ls-error.txt</span><br><span class="line"></span><br><span class="line">dougwilson@doug:~$ ls -l ls-error.txt.gz</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 89  5月 19 14:32 ls-error.txt.gz</span><br><span class="line">dougwilson@doug:~$ ls -l ls-output.txt.gz</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 14652  5月 19 15:07 ls-output.txt.gz</span><br><span class="line"></span><br><span class="line">dougwilson@doug:~$ gunzip ls-error.txt.gz ls-output.txt.gz</span><br><span class="line"></span><br><span class="line">dougwilson@doug:~$ ls -l ls-error.txt</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 56  5月 19 14:32 ls-error.txt</span><br><span class="line">dougwilson@doug:~$ ls -l ls-output.txt</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 81043  5月 19 15:07 ls-output.txt</span><br></pre></td></tr></table></figure>

<h4 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h4><p>bzip2与gzip命令功能相似，但使用不同的压缩算法。该算法具有高质量的数据压缩能力，但牺牲了压缩速度。</p>
</blockquote>
<h3 id="文本搜索"><a href="#文本搜索" class="headerlink" title="文本搜索"></a>文本搜索</h3><blockquote>
<h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>grep命令用于在文本中执行关键词搜索，并显示匹配结果。格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep [options] regex [file...]</span><br></pre></td></tr></table></figure>

<p>regex是正则表达式，这里就不进行扩展，之前学过一些。</p>
<p>grep命令常用选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>-i</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>-v</td>
<td>正常情况下，grep命令会输出匹配行，而该选项可使grep输出不包含匹配项所有行</td>
</tr>
<tr>
<td>-c</td>
<td>输出匹配项数目</td>
</tr>
<tr>
<td>-l</td>
<td>输出匹配项文件名而不是直接输出匹配行自身</td>
</tr>
<tr>
<td>-n</td>
<td>在每个匹配行前加上该行在文件内的行号</td>
</tr>
<tr>
<td>-h</td>
<td>进行多文件搜索时，抑制文件名输出</td>
</tr>
<tr>
<td>-L</td>
<td>和-l选项类似，但输出的是不包含匹配项的文件名</td>
</tr>
</tbody></table>
<p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ ls /bin &gt; dirlist-bin.txt</span><br><span class="line">dougwilson@doug:~$ ls /usr/bin &gt; dirlist-usr-bin.txt</span><br><span class="line">dougwilson@doug:~$ ls /sbin &gt; dirlist-sbin.txt</span><br><span class="line">dougwilson@doug:~$ ls /usr/sbin &gt; dirlist-usr-sbin.txt</span><br><span class="line">dougwilson@doug:~$ ls dirlist*.txt</span><br><span class="line">dirlist-bin.txt  dirlist-sbin.txt  dirlist-usr-bin.txt  dirlist-usr-sbin.txt</span><br><span class="line">dougwilson@doug:~$ grep bzip dirlist*.txt</span><br><span class="line">dirlist-bin.txt:bzip2</span><br><span class="line">dirlist-bin.txt:bzip2recover</span><br><span class="line">dirlist-usr-bin.txt:bzip2</span><br><span class="line">dirlist-usr-bin.txt:bzip2recover</span><br><span class="line">dougwilson@doug:~$ grep -l bzip dirlist*.txt</span><br><span class="line">dirlist-bin.txt</span><br><span class="line">dirlist-usr-bin.txt</span><br><span class="line">dougwilson@doug:~$ grep -L bzip dirlist*.txt</span><br><span class="line">dirlist-sbin.txt</span><br><span class="line">dirlist-usr-sbin.txt</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><blockquote>
<p>文本处理常用命令：</p>
<ul>
<li>cat：连接多个文件并复制到标准输出</li>
<li>sort：对文本进行排序</li>
<li>uniq：省略重复行</li>
<li>cut：从每一行中移除文本区域</li>
<li>paste：合并文件文本行</li>
<li>join：基于某个共享字段来联合两个文件的文本行</li>
<li>common：逐行比较两个已经排序好的文件</li>
<li>diff：逐行比较文件</li>
<li>patch：对原文件打补丁</li>
<li>tr：转换或删除字符</li>
<li>sed：用于过滤和转换文本的流编辑器</li>
<li>aspel：交互式拼写检查器</li>
</ul>
<p>这里先列出命令，用到时再查。</p>
<h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat [options] [filename...]</span><br></pre></td></tr></table></figure>

<p>cat命令用于将多个文件的文本内容复制到标准输出中进行显示。当然，也可以重定向到文件中。</p>
<p>当没有文件参数时，默认为键盘输入。如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ cat &gt; foo.txt</span><br><span class="line">I never give up because I have faith.</span><br><span class="line">dougwilson@doug:~$ cat -A foo.txt</span><br><span class="line">I never give up because I have faith.$</span><br></pre></td></tr></table></figure>

<p>cat也有很多参数选项，比较常用的有两个：-n 对文本行进行编号 以及 -s 禁止输出多个空白行 。如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ cat &gt; foo.txt</span><br><span class="line">The first line</span><br><span class="line"></span><br><span class="line">The second line</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">blank two line. The third line</span><br><span class="line">dougwilson@doug:~$ cat -n foo.txt</span><br><span class="line">     1	The first line</span><br><span class="line">     2	</span><br><span class="line">     3	The second line</span><br><span class="line">     4	</span><br><span class="line">     5	</span><br><span class="line">     6	blank two line. The third line</span><br><span class="line">dougwilson@doug:~$ cat -s foo.txt</span><br><span class="line">The first line</span><br><span class="line"></span><br><span class="line">The second line</span><br><span class="line"></span><br><span class="line">blank two line. The third line</span><br><span class="line">dougwilson@doug:~$ cat -ns foo.txt</span><br><span class="line">     1	The first line</span><br><span class="line">     2	</span><br><span class="line">     3	The second line</span><br><span class="line">     4	</span><br><span class="line">     5	blank two line. The third line</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><blockquote>
<h4 id="Shell脚本格式"><a href="#Shell脚本格式" class="headerlink" title="Shell脚本格式"></a>Shell脚本格式</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is our first script</span></span><br><span class="line">echo &#x27;Hello World!&#x27;</span><br></pre></td></tr></table></figure>

<p>第一行 <strong>#!</strong> 字符是一种特殊的结构，称之为shebang。shebang用来告知操作系统，执行后的脚本应该使用的解释器名字。每个shell脚本都务必将其作为第一行</p>
<p>第二行 <strong>#</strong> 是注释行，虽然它不会被编译，但是对开发人员起到一个解释说明的作用，也是十分重要的</p>
<p>第三行 脚本行，用于执行脚本的代码</p>
<h4 id="设置脚本可执行权限"><a href="#设置脚本可执行权限" class="headerlink" title="设置脚本可执行权限"></a>设置脚本可执行权限</h4><p>对于脚本，有两种常见的权限设置：权限为755的脚本，每个人都可以执行；权限为700的脚本，只有脚本所有人才能执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 755 脚本名称</span><br><span class="line">chmod 700 脚本名称</span><br></pre></td></tr></table></figure>

<h4 id="脚本文件的位置"><a href="#脚本文件的位置" class="headerlink" title="脚本文件的位置"></a>脚本文件的位置</h4><p>为了使脚本能够运行，必须显示指定脚本文件的路径，如果不这么做，脚本可能无法被执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ ./hello_world</span><br><span class="line">Hello World</span><br><span class="line">dougwilson@doug:~$ hello_world</span><br><span class="line">hello_word: command not found</span><br></pre></td></tr></table></figure>

<p>这和一个环境变量PATH有关。如果没有显式指定路径，则系统查找一个可执行程序时，需要搜索一系列路径下的目录，这些目录就保存在环境变量PATH中。这也是为什么我们输入命令ls时，就能执行/bin/ls的原因。</p>
<p>所以，如果你想创建一个自己的脚本目录，并且不想显式地指定路径，那么你就应该将目录存入PATH环境变量中。这之前，先了解PATH变量是如何存储目录的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br></pre></td></tr></table></figure>

<p>发现，目录间是以冒号 <strong>:</strong> 作为区分的，而且最后一个目录后面没有带冒号。所以，设置自己的脚本目录时，应该以冒号开头，否则是设置失败的。比如你在家目录下创建了一个bin目录作为脚本文件目录，那么你可以在 <strong>.bashrc</strong> 文件中增加下面的行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=~/bin:&quot;$PATH&quot;</span><br></pre></td></tr></table></figure>

<p>修改完毕后，它会在每个新的终端会话中生效。</p>
<p>一个更加推荐的方法是，在PATH环境变量中的目录列表中的目录存储脚本，比如在/usr/local/bin中存放你的脚本</p>
<h4 id="脚本的变量与常量"><a href="#脚本的变量与常量" class="headerlink" title="脚本的变量与常量"></a>脚本的变量与常量</h4><p>需要注意的点：</p>
<ol>
<li>变量或常量名一定不能拼写错误。因为你拼写错误，并不会提示错误，反而会得到一个空值。</li>
<li>格式为：<strong>variable=value</strong></li>
<li>赋值时变量名、等号、值之间不能有空格</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is a simple page</span></span><br><span class="line"></span><br><span class="line">title=&quot;This is a variable&quot;</span><br><span class="line">TITLE=&quot;This is a constant variable&quot;</span><br><span class="line">echo &quot;&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;title&gt;$title&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;h1&gt;$TITLE&lt;/h1&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;	</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<h4 id="here文档"><a href="#here文档" class="headerlink" title="here文档"></a>here文档</h4><p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command &lt;&lt; token</span><br><span class="line">text body</span><br><span class="line">token</span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># Program to output a system information page</span></span><br><span class="line"></span><br><span class="line">TITLE=<span class="string">&quot;System information report for <span class="variable">$HOSTNAME</span>&quot;</span></span><br><span class="line">CURRENT_TIME=$(date + <span class="string">&quot;%x %r %z&quot;</span>)</span><br><span class="line">TIME_STAMP=<span class="string">&quot;Generated <span class="variable">$CURRENT_TIME</span>, by <span class="variable">$USER</span>&quot;</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt; <span class="string">_EOF_</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">	&lt;head&gt;</span></span><br><span class="line"><span class="string">		&lt;title&gt;$TITLE&lt;/title&gt;</span></span><br><span class="line"><span class="string">	&lt;/head&gt;</span></span><br><span class="line"><span class="string">	&lt;body&gt;</span></span><br><span class="line"><span class="string">		&lt;h1&gt;$TITLE&lt;/h1&gt;</span></span><br><span class="line"><span class="string">		&lt;p&gt;$TIME_STAMP&lt;/p&gt;</span></span><br><span class="line"><span class="string">	&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">_EOF_</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~/bin$ foo=&quot;some text&quot;</span><br><span class="line">dougwilson@doug:~/bin$ cat &lt;&lt; _EOF_</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="variable">$foo</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> \<span class="variable">$foo</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="string">&quot;<span class="variable">$foo</span>&quot;</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="string">&#x27;$foo&#x27;</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> _EOF_</span></span><br><span class="line">some text</span><br><span class="line"><span class="meta">$</span><span class="bash">foo</span></span><br><span class="line">&quot;some text&quot;</span><br><span class="line">&#x27;some text&#x27;</span><br></pre></td></tr></table></figure>

<p>here文档和echo命令很相似，但是在默认情况下，here文档内的单引号和双引号将失去它们在shell中的特殊含义，被当作普通字符。这意味着我们可以在here文档中随意嵌入引号。此外，here文档和echo文档没有什么特别的区别。</p>
<h4 id="shell脚本函数"><a href="#shell脚本函数" class="headerlink" title="shell脚本函数"></a>shell脚本函数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># function demo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一种格式</span></span><br><span class="line">funtion fun &#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;first function type&quot;</span></span><br><span class="line">	<span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种格式</span></span><br><span class="line"><span class="function"><span class="title">funTwo</span></span>() &#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;second function type&quot;</span></span><br><span class="line">	<span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;step1&quot;</span></span><br><span class="line">fun</span><br><span class="line">funTwo</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;step4&quot;</span></span><br></pre></td></tr></table></figure>

<p>return 是可以返回值的，比如下面的代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test_file() &#123;</span><br><span class="line">	FILE=~/.bash</span><br><span class="line">	if [ -e &quot;FILE&quot; ]; then</span><br><span class="line">		echo &quot;$FILE is exist&quot;</span><br><span class="line">		return 0</span><br><span class="line">	else </span><br><span class="line">		echo &quot;$FILE is not exist&quot;</span><br><span class="line">		return 1</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="if分支语句"><a href="#if分支语句" class="headerlink" title="if分支语句"></a>if分支语句</h4><p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if commands; then</span><br><span class="line">	commands</span><br><span class="line">elif commands; then</span><br><span class="line">	commands</span><br><span class="line">else </span><br><span class="line">	commands</span><br><span class="line">fi</span><br><span class="line">如：</span><br><span class="line">if true; then</span><br><span class="line">	echo &quot;It&#x27;s true&quot;</span><br><span class="line">else </span><br><span class="line">	echo &quot;It&#x27;s false&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p><strong>退出状态</strong></p>
<p>不同于高级语言编程会返回true或者false。在命令执行完毕后，会向操作系统发送一个值，称为退出状态。退出状态的值为0~255的整数，当退出状态的值为0时，表示命令执行成功。当退出状态的值不为0时，表示命令执行失败。shell提供了一个用于检测退出状态的参数**$?**</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ ls -d /usr/bin</span><br><span class="line">/usr/bin</span><br><span class="line">dougwilson@doug:~$ echo $?</span><br><span class="line">0</span><br><span class="line">dougwilson@doug:~$ ls -d /bin/ussr</span><br><span class="line">ls: cannot access &#x27;/bin/ussr&#x27;: No such file or directory</span><br><span class="line">dougwilson@doug:~$ echo $?</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h4 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h4><p>经常和if一起使用的命令是test，test命令有两种等价形式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test expression</span><br><span class="line">[ expression ]  常用形式</span><br></pre></td></tr></table></figure>

<p>这里的expression是一个表达式，其结果为true或者false。当表达式结果为true时，test命令返回一个为0的退出状态；当表达式结果为false时，test命令返回一个为1的退出状态</p>
<h5 id="test命令的文件表达式"><a href="#test命令的文件表达式" class="headerlink" title="test命令的文件表达式"></a>test命令的文件表达式</h5><p>常用文件表达式格式：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>达成true的条件</th>
</tr>
</thead>
<tbody><tr>
<td>file1 -ef file2</td>
<td>两个文件通过硬链接指向同一个文件</td>
</tr>
<tr>
<td>file1 -nt file2</td>
<td>文件1比文件2新</td>
</tr>
<tr>
<td>file1 -ot file2</td>
<td>文件1比文件2旧</td>
</tr>
<tr>
<td>-d file</td>
<td>文件存在并且是一个目录</td>
</tr>
<tr>
<td>-e file</td>
<td>文件存在</td>
</tr>
<tr>
<td>-f file</td>
<td>文件存在并且是一个普通文件</td>
</tr>
<tr>
<td>-L file</td>
<td>文件是一个符号链接</td>
</tr>
<tr>
<td>-r file</td>
<td>文件存在并且可读</td>
</tr>
<tr>
<td>-s file</td>
<td>文件存在并且其长度大于0</td>
</tr>
<tr>
<td>-w file</td>
<td>文件存在并且可写</td>
</tr>
<tr>
<td>-x file</td>
<td>文件存在并且可执行</td>
</tr>
</tbody></table>
<p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">FILE=~/.bashrc</span><br><span class="line"></span><br><span class="line">if [ -e &quot;$FILE&quot; ]; then</span><br><span class="line">	if [ -f &quot;$FILE&quot; ]; then</span><br><span class="line">		echo &quot;$FILE is a regular file.&quot;</span><br><span class="line">	fi</span><br><span class="line">	if [ -d &quot;$FILE&quot; ]; then</span><br><span class="line">		echo &quot;$FILE is a directory.&quot;</span><br><span class="line">	fi</span><br><span class="line">else </span><br><span class="line">	echo &quot;$FILE does not exists&quot;</span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h5 id="test命令的字符串表达式"><a href="#test命令的字符串表达式" class="headerlink" title="test命令的字符串表达式"></a>test命令的字符串表达式</h5><p>常用字符串表达式：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>达成true的条件</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>string不为空</td>
</tr>
<tr>
<td>-n string</td>
<td>string长度大于0</td>
</tr>
<tr>
<td>-z string</td>
<td>string长度等于0</td>
</tr>
<tr>
<td>string1=string2 或 string1==string2</td>
<td>string1和string2相等</td>
</tr>
<tr>
<td>string1!=string2</td>
<td>string1和string2不相等</td>
</tr>
<tr>
<td>string1&gt;string2</td>
<td>排序时，string1排在string2之后</td>
</tr>
<tr>
<td>string1&lt;string2</td>
<td>排序时，string1排在string2之前</td>
</tr>
</tbody></table>
<p>注意，使用test命令时，”&lt;”和”&gt;“运算符必须进行转义，或者用引号括起来。如果不这么做，则会被shell解释为重定向符。</p>
<p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">ANSWER=maybe</span><br><span class="line">if [ -z &quot;$ANSWER&quot; ]; then</span><br><span class="line">	echo &quot;There is no answer.&quot; &gt;&amp;2</span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$ANSWER&quot;=&quot;yes&quot;]; then</span><br><span class="line">	echo &quot;The answer is yes&quot;</span><br><span class="line">elif [ &quot;$ANSWER&quot;=&quot;no&quot; ]; then</span><br><span class="line">	echo &quot;The answer is no&quot;</span><br><span class="line">else </span><br><span class="line">	echo &quot;The answer is unknown&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h5 id="test命令的整数表达式"><a href="#test命令的整数表达式" class="headerlink" title="test命令的整数表达式"></a>test命令的整数表达式</h5><p>常用整数表达式为：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>达成true的条件</th>
</tr>
</thead>
<tbody><tr>
<td>integer1 -eq integer2</td>
<td>integer1和integer2相等</td>
</tr>
<tr>
<td>integer1 -ne integer2</td>
<td>integer1和integer2不相等</td>
</tr>
<tr>
<td>integer1 -le integer2</td>
<td>integer1 小于等于 integer2</td>
</tr>
<tr>
<td>integer1 -lt integer2</td>
<td>integer1 小于 integer2</td>
</tr>
<tr>
<td>integer1 -ge integer2</td>
<td>integer1 大于等于 integer2</td>
</tr>
<tr>
<td>integer1 -gt integer2</td>
<td>integer1 大于 integer2</td>
</tr>
</tbody></table>
<p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">INT=-5</span><br><span class="line">if [ -z &quot;$INT&quot; ]; then</span><br><span class="line">	echo &quot;INT is empty.&quot; &gt;&amp;2</span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br><span class="line">if [ $INT -eq 0 ]; then</span><br><span class="line">	echo &quot;INT is zero.&quot;</span><br><span class="line">else </span><br><span class="line">	if [ $INT -lt 0 ]; then</span><br><span class="line">		echo &quot;INT is negative.&quot;</span><br><span class="line">	else </span><br><span class="line">		echo &quot;INT is positive.&quot;</span><br><span class="line">	fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h4 id="增强test命令"><a href="#增强test命令" class="headerlink" title="增强test命令"></a>增强test命令</h4><p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ [ expression ] ]</span><br></pre></td></tr></table></figure>

<p>看起来多了一个方括号，但是不用担心，用法是一样的，只不过是增加了一个很重要的字符串表达式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ [ string1=~regex ] ]</span><br></pre></td></tr></table></figure>

<p>regex是一个正则表达式。如果string1和扩展的正则表达式regex相匹配，那么就会返回true。下面给一个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">INT=-5</span><br><span class="line">if [[ &quot;$INT&quot;=~^-?[0-9]+$ ]]; then</span><br><span class="line">	echo &quot;INT is an integer&quot;</span><br><span class="line">else </span><br><span class="line">	echo &quot;INT is not an integer.&quot; &gt;&amp;2</span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h4 id="增强整数设计"><a href="#增强整数设计" class="headerlink" title="增强整数设计"></a>增强整数设计</h4><p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(( expression ))</span><br></pre></td></tr></table></figure>

<p>当算术计算结果为非0值时，结果为true；算术结果为0值时，结果为false</p>
<p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">INT=-5</span><br><span class="line">if [[ &quot;$INT&quot;=~^-?[0-9]+$ ]]; then</span><br><span class="line">	if (( INT == 0 )); then</span><br><span class="line">		echo &quot;INT is zero.&quot;</span><br><span class="line">	else </span><br><span class="line">		if (( INT &lt; 0 )); then</span><br><span class="line">			echo &quot;INT is negative.&quot;</span><br><span class="line">		else</span><br><span class="line">			echo &quot;INT is positive.&quot;</span><br><span class="line">	fi</span><br><span class="line">else</span><br><span class="line">	echo &quot;INT is not an integer&quot; &gt;&amp;2 </span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h4 id="组合表达式"><a href="#组合表达式" class="headerlink" title="组合表达式"></a>组合表达式</h4><table>
<thead>
<tr>
<th>Operation</th>
<th>test</th>
<th>[[]]and(())</th>
</tr>
</thead>
<tbody><tr>
<td>AND</td>
<td>-a</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>OR</td>
<td>-o</td>
<td>||</td>
</tr>
<tr>
<td>NOT</td>
<td>!</td>
<td>!</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="从键盘读取输入"><a href="#从键盘读取输入" class="headerlink" title="从键盘读取输入"></a>从键盘读取输入</h3><blockquote>
<h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">echo -n &quot;please enter an integer -&gt; &quot;</span><br><span class="line">read inputNum</span><br><span class="line"></span><br><span class="line">if [[ &quot;$inputNum&quot;=~^?[0-9]+$ ]]; then</span><br><span class="line">	if [ $inputNum -eq 0 ]; then</span><br><span class="line">		echo &quot;$inputNum is zero.&quot;</span><br><span class="line">	else</span><br><span class="line">		if [ $inputNum -lt 0 ]; then</span><br><span class="line">			echo &quot;$inputNum is negative.&quot;</span><br><span class="line">		else</span><br><span class="line">			echo &quot;$inputNum is positive.&quot;</span><br><span class="line">		fi</span><br><span class="line">	fi</span><br><span class="line">else</span><br><span class="line">	echo &quot;Input value is not an integer.&quot;&gt;&amp;2</span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>在上述代码中，inputNum为键盘输入的赋值变量。如果read命令后面没有赋值变量，那么会将键盘的输入赋值给默认shell变量 <strong>REPLY</strong> 比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;Enter values &gt; &quot; </span><br><span class="line">read</span><br><span class="line"></span><br><span class="line">echo &quot;REPLY=&#x27;$REPLY&#x27;&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><blockquote>
<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while commands; do commands; done</span><br></pre></td></tr></table></figure>

<p>如同if命令一样，while会判断指令的退出状态。只要退出状态为0，它旧执行循环内的指令，直到退出状态不为0，退出循环。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">count = 1</span><br><span class="line">while [ $count -le 5 ]; do</span><br><span class="line">	echo $count</span><br><span class="line">	count=$(( count+1 ))</span><br><span class="line">done</span><br><span class="line">echo &quot;Finished.&quot;</span><br></pre></td></tr></table></figure>

<h4 id="continue-break"><a href="#continue-break" class="headerlink" title="continue/break"></a>continue/break</h4><p>和其他高级语言一样，shell中也有continue命令和break命令，用于执行下一个循环和跳出循环。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">DELAY=3</span><br><span class="line">while true; do</span><br><span class="line">	clear</span><br><span class="line">	cat &lt;&lt;-_EOF_</span><br><span class="line">		please Select:</span><br><span class="line">		1. Display System Information</span><br><span class="line">		2. Display Disk Space</span><br><span class="line">		3. Display Home Space Utilization</span><br><span class="line">		0. Quit</span><br><span class="line">	_EOF_</span><br><span class="line">	read -p &quot;Enter selection[0-3] &gt; &quot;</span><br><span class="line">	if [[ $REPLY=~^[0-3]$ ]]; then</span><br><span class="line">		if [[ $REPLY==1 ]]; then</span><br><span class="line">			echo &quot;Hostname: $HOSTNAME&quot;</span><br><span class="line">			uptime</span><br><span class="line">			sleep $DELAY</span><br><span class="line">			continue</span><br><span class="line">		fi</span><br><span class="line">		if [[ $REPLY==2 ]]; then</span><br><span class="line">			df -h</span><br><span class="line">			sleep $DELAY</span><br><span class="line">			continue</span><br><span class="line">		fi</span><br><span class="line">		if [[ $REPLY==3 ]]; then</span><br><span class="line">			if [[ $(id -u) -eq 0 ]]; then</span><br><span class="line">				echo &quot;Home Space Utilization (All Users)&quot;</span><br><span class="line">				du -sh /home/*</span><br><span class="line">			else </span><br><span class="line">				echo &quot;Home Space Utilization ($USER)&quot;</span><br><span class="line">				du -sh $HOME</span><br><span class="line">			fi</span><br><span class="line">			sleep $DELAY</span><br><span class="line">			continue</span><br><span class="line">		fi</span><br><span class="line">		if [[ $REPLY==0 ]]; then</span><br><span class="line">			break</span><br><span class="line">		fi</span><br><span class="line">	else </span><br><span class="line">		echo &quot;Invalid entry.&quot;</span><br><span class="line">		sleep $DELAY</span><br><span class="line">	fi</span><br><span class="line">done</span><br><span class="line">echo &quot;Program terminated&quot;</span><br></pre></td></tr></table></figure>

<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for variable [in words]; do</span><br><span class="line">	commands</span><br><span class="line">done</span><br><span class="line">variable是循环执行时会增值的变量名，words是一列按顺序赋值给variable的可选项，for循环的强大之处就在于可选项的多变性</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~/bin$ for num in A B C D; do echo $num; done</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">D</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">for num in A B C D; do</span><br><span class="line">	echo $num</span><br><span class="line">done</span><br><span class="line">或</span><br><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">for num in &#123;A..D&#125;; do</span><br><span class="line">	echo $num</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="c语言形式for循环"><a href="#c语言形式for循环" class="headerlink" title="c语言形式for循环"></a>c语言形式for循环</h4><p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for((expression1;expression2;expression3)); do</span><br><span class="line">	commands</span><br><span class="line">done</span><br><span class="line">如：</span><br><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">for((i=0;i&lt;5;i=i+1)); do</span><br><span class="line">	echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

</blockquote>
]]></content>
      <tags>
        <tag>linux, 命令</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习Spring Boot中的SpringApplication</title>
    <url>/2020/09/25/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Spring-Boot%E4%B8%AD%E7%9A%84SpringApplication/</url>
    <content><![CDATA[<p>在Spring Boot的入口类中，通常是通过调用<code>SpringApplication</code>的run方法来启动Spring Boot项目，本文来深入学习下SpringApplication的一些细节。</p>
<span id="more"></span>

<h2 id="自定义SpringApplication"><a href="#自定义SpringApplication" class="headerlink" title="自定义SpringApplication"></a>自定义SpringApplication</h2><p>默认情况下都是直接通过<code>SpringApplication</code>的run方法来直接启动Spring Boot，其实可以通过API来调整某些行为。</p>
<h3 id="通过SpringApplication-API调整"><a href="#通过SpringApplication-API调整" class="headerlink" title="通过SpringApplication API调整"></a>通过SpringApplication API调整</h3><p>我们新建一个SpringBoot项目，Spring Boot版本为2.1.0.RELEASE，<code>artifactId</code>为SpringApplication，并引入<code>spring-boot-starter-web</code>依赖。项目结构如下所示：</p>
<p>![](/images/Spring Boot项目结构.png)</p>
<p>我们将入口类的代码改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringApplication application = <span class="keyword">new</span> SpringApplication(DemoApplication.class);</span><br><span class="line">application.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">application.setWebApplicationType(WebApplicationType.NONE);</span><br><span class="line">application.setAdditionalProfiles(<span class="string">&quot;dev&quot;</span>);</span><br><span class="line">application.run(args);</span><br></pre></td></tr></table></figure>

<p>通过调用<code>SpringApplication</code>的方法，我们关闭了Banner的打印，设置应用环境为非WEB应用，profiles指定为dev。除此之外，<code>SpringApplication</code>还包含了许多别的方法，具体可以查看源码或者官方文档：</p>
<p><img src="/images/SpringApplication%E6%96%B9%E6%B3%95.png"></p>
<h3 id="通过SpringApplicationBuilder-API调整"><a href="#通过SpringApplicationBuilder-API调整" class="headerlink" title="通过SpringApplicationBuilder API调整"></a>通过SpringApplicationBuilder API调整</h3><p><code>SpringApplicationBuilder</code>提供了Fluent API，可以实现链式调用，下面的代码和上面的效果一致，但在编写上较为方便：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(DemoApplication.class)</span><br><span class="line">        .bannerMode(Banner.Mode.OFF)</span><br><span class="line">        .web(WebApplicationType.NONE)</span><br><span class="line">        .profiles(<span class="string">&quot;dev&quot;</span>)</span><br><span class="line">        .run(args);</span><br></pre></td></tr></table></figure>

<h2 id="SpringApplication准备阶段"><a href="#SpringApplication准备阶段" class="headerlink" title="SpringApplication准备阶段"></a>SpringApplication准备阶段</h2><p><code>SpringApplication</code>的生命周期阶段大致可以分为准备阶段和运行阶段。</p>
<p>我们通过源码来查看<code>SpringApplication</code>的有参构造器：</p>
<p><img src="/images/SpringApplication%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%99%A8.png"></p>
<p>通过有参构造器里的代码我们可以将<code>SpringApplication</code>的准备阶段分为以下几个步骤：</p>
<h3 id="配置源"><a href="#配置源" class="headerlink" title="配置源"></a>配置源</h3><p>构造器中<code>this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</code>这行代码用于加载我们配置的Spring Boot Bean源。通常我们使用<code>SpringApplication</code>或者<code>SpringApplicationBuilder</code>的构造器来直接指定源。</p>
<p>所谓的Spring Boot Bean源指的是某个被<code>@SpringBootApplication</code>注解标注的类，比如入口类：</p>
<p><img src="/images/%E5%85%A5%E5%8F%A3%E7%B1%BB.png"></p>
<p>我们也可以将上面的代码改为下面这种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication application = <span class="keyword">new</span> SpringApplication(ApplicationResource.class);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SpringBootApplication</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationResource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样也是可行的。查看<code>SpringApplication</code>的单个参数构造器：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="title">SpringApplication</span>(<span class="params">Class&lt;?&gt;... primarySources</span>)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(<span class="literal">null</span>, primarySources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明我们除了配置单个源外，还可以配置多个源</p>
<h3 id="推断应用类型"><a href="#推断应用类型" class="headerlink" title="推断应用类型"></a>推断应用类型</h3><p>构造器中这行<code>this.webApplicationType = WebApplicationType.deduceFromClasspath();</code>代码用于推断当前Spring Boot应用类型。</p>
<p>Spring Boot 2.0后，应用可以分为下面三种类型：</p>
<ol>
<li><code>WebApplicationType.NONE</code>：非WEB类型；</li>
<li><code>WebApplicationType.REACTIVE</code>：Web Reactive类型；</li>
<li><code>WebApplicationType.SERVLET</code>：Web Servlet类型。</li>
</ol>
<p><code>WebApplicationType.deduceFromClasspath()</code>方法根据当前应用ClassPath中是否存在相关的实现类来判断应用类型到底是哪个，<code>deduceFromClasspath</code>方法的源码如下所示:</p>
<p><img src="/images/deduceFromClasspath%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png"></p>
<p>我们也可以直接通过<code>SpringApplication</code>的<code>setWebApplicationType</code>方法或者<code>SpringApplicationBuilder</code>的<code>web</code>方法来指定当前应用的类型。</p>
<h3 id="加载应用上下文初始器"><a href="#加载应用上下文初始器" class="headerlink" title="加载应用上下文初始器"></a>加载应用上下文初始器</h3><p>接着下一行代码<code>setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</code>用于加载应用上下文初始器<code>ApplicationContextInitializer</code>。</p>
<p><code>getSpringFactoriesInstances</code>方法的源码如下所示：</p>
<p><img src="/images/getSpringFactoriesInstances%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png"></p>
<p>上面代码利用Spring工厂加载机制，实例化<code>ApplicationContextInitializer</code>实现类，并进行排序。</p>
<p>所以我们可以通过实现<code>ApplicationContextInitializer</code>接口用于在Spring Boot应用初始化之前执行一些自定义操作。</p>
<p>举个例子，在<code>com.example.demo</code>下新建<code>initializer</code>包，然后创建一个<code>HelloApplicationContextInitializer</code>类，实现<code>ApplicationContextInitializer</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationContextInitializer</span> <span class="keyword">implements</span> <span class="title">ApplicationContextInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConfigurableApplicationContext.id - &quot;</span> + applicationContext.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中实现了initialize方法，并且使用<code>@Order</code>注解指定优先级。其中<code>Ordered.HIGHEST_PRECEDENCE</code>等于<code>Integer.MIN_VALUE</code>，<code>Ordered.LOWEST_PRECEDENCE</code>等于<code>Integer.MAX_VALUE</code>。所以数值越小，优先级越高。</p>
<p>除了使用<code>@Order</code>注解来指定优先级外，我们也可以通过实现<code>org.springframework.core.Ordered</code>接口的<code>getOrder</code>方法来指定优先级。</p>
<p>接着我们来创建一个优先级比<code>HelloApplicationContextInitializer</code>低的Initializer —— <code>AfterHelloApplicationContextInitializer</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterHelloApplicationContextInitializer</span> <span class="keyword">implements</span> <span class="title">ApplicationContextInitializer</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AfterHelloApplicationContextInitializer: &quot;</span> + applicationContext.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面通过<code>getOrder</code>方法来指定了优先级为最低优先级。</p>
<p>创建好后，我们还需在工厂配置文件里配置这两个实现类。在resources目录下新建META-INF目录，并创建spring.factories文件：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.<span class="built_in">context</span>.ApplicationContextInitializer=\</span><br><span class="line">com.<span class="built_in">example</span>.<span class="built_in">demo</span>.initializer.HelloApplicationContextInitializer,\</span><br><span class="line">com.<span class="built_in">example</span>.<span class="built_in">demo</span>.initializer.AfterHelloApplicationContextInitializer</span><br></pre></td></tr></table></figure>

<p>这时候，启动Spring Boot项目，会发现控制台在打印Banner后就执行了这两个初始化器，并且<code>HelloApplicationContextInitializer</code>的<code>initialize</code>方法执行时机先于<code>AfterHelloApplicationContextInitializer</code>的<code>initialize</code>方法：</p>
<p><img src="/images/initialize%E6%96%B9%E6%B3%95.png"></p>
<h3 id="加载应用事件监听器"><a href="#加载应用事件监听器" class="headerlink" title="加载应用事件监听器"></a>加载应用事件监听器</h3><p>在加载完应用上下文初始器后，下一行的<code>setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</code>代码加载了应用事件监听器。与加载事件上下文初始器类似，Spring Boot也是通过Spring的工厂方法来实例化<code>ApplicationListener</code>的实现类，并进行排序。</p>
<p>既然是事件监听，那么其可以监听什么事件呢？其监听的是<code>ApplicationEvent</code>接口的实现类，我们查看一下都有哪些事件实现了这个接口：</p>
<p>![](/images/Spring Boot监听事件.png)</p>
<p>这里我们以<code>ContextClosedEvent</code>为例子来编写自定义的应用事件监听器，监听Spring上下文关闭事件。</p>
<p>在<code>com.example.demo</code>下新建<code>listener</code>包，然后创建一个<code>ContextClosedEventListener</code>类，实现<code>ApplicationListener</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextClosedEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextClosedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ContextClosedEvent: &quot;</span> + event.getApplicationContext().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码实现了对<code>ContextClosedEvent</code>事件的监听，并且分配了最高优先级。</p>
<p>接着创建一个优先级比<code>ContextClosedEventListener</code>低的监听器<code>AfterContextClosedEventListener</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterContextClosedEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextClosedEvent</span>&gt;, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AfterContextClosedEventr: &quot;</span> + event.getApplicationContext().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Ordered.HIGHEST_PRECEDENCE + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在Spring工厂配置文件里进行配置：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"># Application Listeners</span><br><span class="line">org.springframework.<span class="built_in">context</span>.ApplicationListener=\</span><br><span class="line">com.<span class="built_in">example</span>.<span class="built_in">demo</span>.listener.ContextClosedEventListener,\</span><br><span class="line">com.<span class="built_in">example</span>.<span class="built_in">demo</span>.listener.AfterContextClosedEventListener</span><br></pre></td></tr></table></figure>

<p>在Spring Boot入口类中将环境指定为非WEB环境（这样在启动后应用会马上关闭）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(DemoApplication.class)</span><br><span class="line">                .web(WebApplicationType.NONE)</span><br><span class="line">                .run(args);</span><br></pre></td></tr></table></figure>

<p>运行Spring Boot入口类，控制台输出如下：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">ContextClosedEvent：<span class="built_in">application</span></span><br><span class="line">AfterContextCloseEvent: <span class="built_in">application</span></span><br></pre></td></tr></table></figure>

<h3 id="推断入口类"><a href="#推断入口类" class="headerlink" title="推断入口类"></a>推断入口类</h3><p>接着构造器里的代码下一行<code>this.mainApplicationClass = deduceMainApplicationClass();</code>用于推断运行Spring Boot应用的入口类。查看<code>deduceMainApplicationClass</code>方法源码：</p>
<p><img src="/images/deduceMainApplicationClass%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png"></p>
<p>代码主要逻辑是根据Main线程执行堆栈判断实际的入口类。</p>
<p>准备阶段介绍完毕后，接下来开始介绍运行阶段。</p>
<h2 id="SpringApplication运行阶段"><a href="#SpringApplication运行阶段" class="headerlink" title="SpringApplication运行阶段"></a>SpringApplication运行阶段</h2><p>SpringApplication的运行阶段对应<code>SpringApplication</code>的<code>run</code>方法，我们查看其源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">    listeners.starting();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">                args);</span><br><span class="line">        ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">                applicationArguments);</span><br><span class="line">        configureIgnoreBeanInfo(environment);</span><br><span class="line">        Banner printedBanner = printBanner(environment);</span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">                SpringBootExceptionReporter.class,</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;ConfigurableApplicationContext.class&#125;, context);</span><br><span class="line">        prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">                printedBanner);</span><br><span class="line">        refreshContext(context);</span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">                    .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        listeners.started(context);</span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        listeners.running(context);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行阶段大致可以分为下面这几个过程：</p>
<h3 id="开启时间监听"><a href="#开启时间监听" class="headerlink" title="开启时间监听"></a>开启时间监听</h3><p><code>run</code>方法开头的这两行代码用于开启时间监听：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br></pre></td></tr></table></figure>

<p>上面代码用于开启Spring Boot应用启动时间监听，配合下面的<code>stopWatch.stop();</code>便可以计算出完整的启动时间。</p>
<h3 id="开启运行监听器"><a href="#开启运行监听器" class="headerlink" title="开启运行监听器"></a>开启运行监听器</h3><p><code>run</code>方法的这几行代码用于加载Spring应用运行监听器（SpringApplicationRunListener）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">listeners.started();</span><br></pre></td></tr></table></figure>

<p><code>getRunListeners</code>方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SpringApplicationRunListeners <span class="title">getRunListeners</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SpringApplicationRunListeners(logger, getSpringFactoriesInstances(</span><br><span class="line">        SpringApplicationRunListener.class, types, <span class="keyword">this</span>, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码通过<code>SpringFactoriesLoader</code>检索META-INF/spring.factories找到声明的所有<code>SpringApplicationRunListener</code>的实现类并将其实例化，然后装配到<code>List&lt;SpringApplicationRunListener&gt;</code>运行监听器集合中。</p>
<p><code>listeners.started();</code>用于遍历运行监听器集合中的所有<code>SpringApplicationRunListener</code>的实现类，并逐一调用它们的<code>starting</code>方法，广播Spring Boot应用要开始启动了。</p>
<p>在Spring Boot中<code>SpringApplicationRunListener</code>接口用于监听整个Spring Boot应用生命周期，其代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpringApplicationRunListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">started</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">running</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些方法对应着Spring Boot应用生命周期的各个阶段：</p>
<table>
<thead>
<tr>
<th align="left">方法名称</th>
<th align="left">对应生命周期</th>
<th align="left">Spring Boot起始版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left">starting()</td>
<td align="left">Spring 应用刚启动</td>
<td align="left">1.0</td>
</tr>
<tr>
<td align="left">environmentPrepared(ConfigurableEnvironment)</td>
<td align="left">ConfigurableEnvironment 准备完毕，允许将其调整</td>
<td align="left">1.0</td>
</tr>
<tr>
<td align="left">contextPrepared(ConfigurableApplicationContext)</td>
<td align="left">ConfigurableApplicationContext 准备完毕，允许将其调整</td>
<td align="left">1.0</td>
</tr>
<tr>
<td align="left">contextLoaded(ConfigurableApplicationContext)</td>
<td align="left">ConfigurableApplicationContext 已装载，但仍未启动</td>
<td align="left">1.0</td>
</tr>
<tr>
<td align="left">started(ConfigurableApplicationContext)</td>
<td align="left">ConfigurableApplicationContext 已启动，此时 Spring Bean 已初始化完成</td>
<td align="left">2.0</td>
</tr>
<tr>
<td align="left">running(ConfigurableApplicationContext)</td>
<td align="left">Spring 应用正在运行</td>
<td align="left">2.0</td>
</tr>
<tr>
<td align="left">failed(ConfigurableApplicationContext,Throwable)</td>
<td align="left">Spring 应用运行失败</td>
<td align="left">2.0</td>
</tr>
</tbody></table>
<p>在<code>com.example.demo.linstener</code>下自定义一个<code>SpringApplicationRunListener</code>接口实现类<code>HelloSpringApplicationRunListener</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationRunListener</span> <span class="keyword">implements</span> <span class="title">SpringApplicationRunListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloApplicationRunListener</span><span class="params">(SpringApplication application, String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloApplicationRunListener starting......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">started</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">running</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个实现类，我们可以在Spring Boot应用刚启动的时候在控制台输出<code>HelloApplicationRunListener starting......</code>。</p>
<p>因为其基于Spring的工厂方法来实现，所以我们需要在spring.factories文件里配置这个实现类:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Run Listeners</span></span><br><span class="line">org.springframework.boot.<span class="attribute">SpringApplicationRunListener</span>=\</span><br><span class="line">com.example.demo.run.HelloApplicationRunListener</span><br></pre></td></tr></table></figure>

<p>启动Spring Boot便可以在控制台看到如下输出了：</p>
<p>![](/images/Spring Boot输出显示.png)</p>
<h3 id="创建-Environment"><a href="#创建-Environment" class="headerlink" title="创建 Environment"></a>创建 Environment</h3><p><code>run</code>方法中的这行代码用于创建并配置当前SpringBoot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ConfigurableEnvironment environment = prepare<span class="constructor">Environment(<span class="params">listeners</span>, <span class="params">applicationArguments</span>)</span>;</span><br></pre></td></tr></table></figure>



<p>我们已经在准备阶段里推断出了应用类型，这里只要根据相应的应用类型来创建相应的应用环境即可，类型和环境对应关系如下：</p>
<ul>
<li>Web Reactive： StandardReactiveWebEnvironment</li>
<li>Web Servlet： StandardServletEnvironment</li>
<li>非 Web： StandardEnvironment</li>
</ul>
<p>在<code>prepareEnvironment</code>方法中会执行<code>listeners.environmentPrepared(environment);</code>，用于遍历调用所有<code>SpringApplicationRunListener</code>实现类的<code>environmentPrepared()</code>方法，广播Environment准备完毕。</p>
<h3 id="是否打印Banner"><a href="#是否打印Banner" class="headerlink" title="是否打印Banner"></a>是否打印Banner</h3><p><code>run</code>方法中的这行代码会根据我们的配置来决定是否打印Banner：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Banner printedBanner = printBanner(environment);</span><br></pre></td></tr></table></figure>

<h3 id="创建Context"><a href="#创建Context" class="headerlink" title="创建Context"></a>创建Context</h3><p><code>run</code>方法中的这行代码用于创建<code>ApplicationContext</code>：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">context</span> = createApplicationContext()<span class="comment">;</span></span><br></pre></td></tr></table></figure>



<p>不同的环境对应不同的<code>ApplicationContext</code>：</p>
<ul>
<li>Web Reactive： AnnotationConfigReactiveWebServerApplicationContext</li>
<li>Web Servlet： AnnotationConfigServletWebServerApplicationContext</li>
<li>非 Web： AnnotationConfigApplicationContext</li>
</ul>
<h3 id="装配Context"><a href="#装配Context" class="headerlink" title="装配Context"></a>装配Context</h3><p><code>run</code>方法中的这行代码用于装配Context：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">prepare<span class="constructor">Context(<span class="params">context</span>, <span class="params">environment</span>, <span class="params">listeners</span>, <span class="params">applicationArguments</span>, <span class="params">printedBanner</span>)</span>;</span><br></pre></td></tr></table></figure>



<p>方法<code>prepareContext</code>的源码如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="params"><span class="function">                            ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="params"><span class="function">                            ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">    context.setEnvironment(environment);</span><br><span class="line">    postProcessApplicationContext(context);</span><br><span class="line">    applyInitializers(context);</span><br><span class="line">    listeners.contextPrepared(context);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">        logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">        logStartupProfileInfo(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add boot specific singleton beans</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">    beanFactory.registerSingleton(<span class="string">&quot;springApplicationArguments&quot;</span>, applicationArguments);</span><br><span class="line">    <span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">&quot;springBootBanner&quot;</span>, printedBanner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">        ((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">                .setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Load the sources</span></span><br><span class="line">    Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">    Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line">    load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">    listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>prepareContext</code>方法开头为<code>ApplicationContext</code>加载了environment，之后通过<code>applyInitializers</code>方法逐个执行<code>ApplicationContextInitializer</code>的<code>initialize</code>方法来进一步封装<code>ApplicationContext</code>，并调用所有的<code>SpringApplicationRunListener</code>实现类的<code>contextPrepared</code>方法，广播ApplicationContext已经准备完毕了。</p>
<p>之后初始化IOC容器，并调用<code>SpringApplicationRunListener</code>实现类的<code>contextLoaded</code>方法，广播<code>ApplicationContext</code>加载完成，这里就包括通过<code>@EnableAutoConfiguration</code>导入的各种自动配置类。</p>
<h3 id="Refresh-Context"><a href="#Refresh-Context" class="headerlink" title="Refresh Context"></a>Refresh Context</h3><p><code>run</code>方法中的这行代码用于初始化所有自动配置类，并调用<code>ApplicationContext</code>的<code>refresh</code>方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">refresh<span class="constructor">Context(<span class="params">context</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="广播应用已启动"><a href="#广播应用已启动" class="headerlink" title="广播应用已启动"></a>广播应用已启动</h3><p><code>run</code>方法中的这行代码用于广播Spring Boot应用已启动：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">listeners.started(context)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p><code>started</code>方法会调用所有的<code>SpringApplicationRunListener</code>的<code>finished</code>方法，广播SpringBoot应用已经成功启动。</p>
<h3 id="执行Runner"><a href="#执行Runner" class="headerlink" title="执行Runner"></a>执行Runner</h3><p><code>run</code>方法中的这行代码<code>callRunners(context, applicationArguments);</code>遍历所有<code>ApplicationRunner</code>和<code>CommandLineRunner</code>的实现类，并执行其<code>run</code>方法。我们可以实现自己的<code>ApplicationRunner</code>或者<code>CommandLineRunner</code>，来对Spring Boot的启动过程进行扩展。</p>
<p>我们在<code>com.example.demo</code>下新建<code>runner</code>包，然后创建一个<code>ApplicationRunner</code>的实现类<code>HelloApplicationRunner</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloApplicationRunner: hello spring boot&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们需要将<code>HelloApplicationRunner</code>使用<code>@Component</code>注解标注，让其注册到IOC容器中。</p>
<p>然后再创建一个<code>CommandLineRunner</code>的实现类<code>HelloCommandLineRunner</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloCommandLineRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloCommandLineRunner: hello spring boot&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动Spring Boot应用，便可以在应用刚启动好后看到如下输出：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">HelloApplicationRunner:</span> hello spring boot</span><br><span class="line"><span class="symbol">HelloCommandLineRunner:</span> hello spring boot</span><br></pre></td></tr></table></figure>

<h3 id="广播应用运行中"><a href="#广播应用运行中" class="headerlink" title="广播应用运行中"></a>广播应用运行中</h3><p><code>run</code>方法中的这行代码<code>listeners.running(context);</code>用于调用<code>SpringApplicationRunListener</code>的<code>running</code>方法，广播Spring Boot应用正在运行中。</p>
<p>当<code>run</code>方法运行出现异常时，便会调用<code>handleRunFailure</code>方法来处理异常，该方法里会通过<code>listeners.failed(context, exception);</code>来调用<code>SpringApplicationRunListener</code>的<code>failed</code>方法，广播应用启动失败，并将异常扩散出去。</p>
]]></content>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Spring AOP原理</title>
    <url>/2020/05/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring-AOP%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>AOP底层为动态代理，AOP指的是：在程序运行期间动态地将某段代码切入到指定方法指定位置进行运行的编程方式，相关设计模式为代理模式。</p>
<span id="more"></span>

<h2 id="AOP的使用"><a href="#AOP的使用" class="headerlink" title="AOP的使用"></a>AOP的使用</h2><p>创建一个目标类TatgetClass，包含需要被AOP代理增强的方法test：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;目标方法test被执行&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasLength(value)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;value不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写切面类MyAspect：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * cc.mrbird..*.TargetClass.test(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;onBefore：&quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot;方法开始执行，参数：&quot;</span></span><br><span class="line">                + Arrays.asList(joinPoint.getArgs()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAfter</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;onAfter：&quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot;方法执行结束，参数：&quot;</span></span><br><span class="line">                + Arrays.asList(joinPoint.getArgs()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;pointcut()&quot;, returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(JoinPoint joinPoint, Object result)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning：&quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot;方法执行结束返回，参数：&quot;</span></span><br><span class="line">                + Arrays.asList(joinPoint.getArgs()) + <span class="string">&quot;，返回值：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;pointcut()&quot;, throwing = &quot;exception&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(JoinPoint joinPoint, Exception exception)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing：&quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot;方法执行出错，参数：&quot;</span></span><br><span class="line">                + Arrays.asList(joinPoint.getArgs()) + <span class="string">&quot;，异常：&quot;</span> + exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该切面包含了4个通知方法：</p>
<ul>
<li>前置通知（@Before）：在目标方法被调用之前调用通知功能；</li>
<li>后置通知（@After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li>
<li>返回通知（@AfterReturning）：在目标方法成功执行之后调用通知；</li>
<li>异常通知（@AfterThrowing）：在目标方法抛出异常后调用通知。</li>
</ul>
<p>测试AOP结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(AopApplication.class, args);</span><br><span class="line">        TargetClass targetClass = context.getBean(TargetClass.class);</span><br><span class="line">        targetClass.test(<span class="string">&quot;aop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序测试结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">onBefore：<span class="built_in">test</span>方法开始执行，参数：[aop]</span><br><span class="line">目标方法<span class="built_in">test</span>被执行</span><br><span class="line">afterReturning：<span class="built_in">test</span>方法执行结束返回，参数：[aop]，返回值：aop</span><br><span class="line">onAfter：<span class="built_in">test</span>方法执行结束，参数：[aop]</span><br></pre></td></tr></table></figure>

<p><code>test</code>方法参数为空时，程序运行结果如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">onBefore：test方法开始执行，参数：<span class="selector-attr">[]</span></span><br><span class="line">目标方法test被执行</span><br><span class="line">afterThrowing：test方法执行出错，参数：<span class="selector-attr">[]</span>，异常：java<span class="selector-class">.lang</span><span class="selector-class">.RuntimeException</span>: value不能为空</span><br><span class="line">onAfter：test方法执行结束，参数：<span class="selector-attr">[]</span></span><br></pre></td></tr></table></figure>

<p>回顾了AOP使用后，下面就深入探究Spring AOP的实现原理</p>
<h3 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h3><p>@EnableAspectJAutoProxy用于开启AspectJ自动代理，源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123;AspectJAutoProxyRegistrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该注解类上通过@Import导入了<code>AspectJAutoProxyRegistrar</code>AspectJ自动代理注册器，查看<code>AspectJAutoProxyRegistrar</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span></span><br><span class="line"><span class="comment">	 * of the @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">			AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">		AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line">				AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">		<span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>)) &#123;</span><br><span class="line">				AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;exposeProxy&quot;</span>)) &#123;</span><br><span class="line">				AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过注释我们大体可以知道，该注册器的作用是往IOC容器里注册了一个类型为<code>AnnotationAwareAspectJAutoProxyCreator</code>（注解驱动的AspectJ自动代理创建器）的Bean。该类的<code>registerBeanDefinitions</code>方法主要关注：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br></pre></td></tr></table></figure>

<p>查看其源码：</p>
<p><img src="/images/AopConfigUtils%E6%BA%90%E7%A0%81.png"></p>
<p>可以看到，核心逻辑为通过<code>RootBeanDefinition</code>往IOC注册了名称为<code>AUTO_PROXY_CREATOR_BEAN_NAME</code>（常量，值为org.springframework.aop.config.internalAutoProxyCreator），类型为AnnotationAwareAspectJAutoProxyCreator的Bean</p>
<p>综上，可以知道：<code>@EnableAspectJAutoProxy</code>模块驱动注解往IOC容器中注册了类型为AnnotationAwareAspectJAutoProxyCreator的Bean，Bean名称为org.springframework.aop.config.internalAutoProxyCreator。</p>
<h3 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h3><p>通过前面的分析，主要目标就是<code>AnnotationAwareAspectJAutoProxyCreator</code>类，为了搞清楚这个类的作用，先捋清类的层级关系：</p>
<p><img src="/images/AnnotationAwareAspectJAutoProxyCreator%E7%B1%BB%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.png"></p>
<p>可以看到AnnotationAwareAspectJAutoProxyCreator的父类AbstractAutoProxyCreator实现了SmartInstantiationAwareBeanPostProcessor和BeanFactoryAware接口。实现BeanFactoryAware用于在Bean初始化时注入BeanFactory，而SmartInstantiationAwareBeanPostProcessor接口的父类为InstantiationAwareBeanPostProcessor接口，该接口继承自BeanPostProcessor接口。</p>
<p>通过查看AnnotationAwareAspectJAutoProxyCreator及其各个层级父类源码可以发现，AbstractAutoProxyCreator类实现了InstantiationAwareBeanPostProcessor接口的postProcessBeforeInstantiation方法（自定义Bean实例化前操作逻辑），实现了BeanPostProcessor的postProcessAfterInitialization方法（自定义Bean初始化后操作逻辑）。所以后续就是分析这两个方法：</p>
<p><img src="/images/postProcessBeforeInstantiation%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95.png"></p>
<h3 id="AOP代理创建过程"><a href="#AOP代理创建过程" class="headerlink" title="AOP代理创建过程"></a>AOP代理创建过程</h3><p>以debug的方式启动前面的AOP例子，因为后置处理器对所有Bean都生效，所以每个Bean创建时都会进入我们刚刚打断点的那两个方法中。但我们只关心Spring AOP是怎样增强我们定义的目标类TargetClass的，所以如果Bean类型不是TargetClass，我们都直接点击Resume Program按钮跳过，直到Bean类型是TargetClass：</p>
<p>postProcessBeforeInstantiation方法主要包含以下几个核心步骤：</p>
<p><img src="/images/postProcessBeforeInstantiation%E6%96%B9%E6%B3%95%E6%A0%B8%E5%BF%83%E6%AD%A5%E9%AA%A4.png"></p>
<p><strong>分析上面的步骤</strong></p>
<ol>
<li><p>通过Bean名称和Bean类型获取该Bean的唯一缓存键名，getCacheKey方法源码如下所示：</p>
<p><img src="/images/getCacheKey%E6%96%B9%E6%B3%95.png"></p>
</li>
<li><p>判断当前Bean（TargetClass）是否包含在advisedBeans集合中（AbstractAutoProxyCreator的成员变量<code>private final Map&lt;Object, Boolean&gt; advisedBeans = new ConcurrentHashMap&lt;&gt;(256)</code>，用于存放所有Bean是否需要增强标识，键为每个Bean的cacheKey，值为布尔类型，true表示需要增强，false表示不需要增强），此时TargetClass还未实例化，所以不在该集合中。</p>
</li>
<li><p>判断当前Bean（TargetClass）是否是基础类，查看isInfrastructureClass方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isInfrastructureClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.isInfrastructureClass(beanClass) || (<span class="keyword">this</span>.aspectJAdvisorFactory != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.aspectJAdvisorFactory.isAspect(beanClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了父类的 <code>isInfrastructureClass</code> 方法 以及 this.aspectJAdvisorFactory.isAspect方法</p>
<p>两个方法源码如下所示：</p>
<p><img src="/images/isInfrastructureClass%E6%BA%90%E7%A0%81.png"></p>
<p><img src="/images/isAspect%E6%BA%90%E7%A0%81.png"></p>
<p>所以这一步逻辑为：判断当前Bean（TargetClass）是否是Advice，Pointcut，Advisor，AopInfrastructureBean的子类或者是否为切面类（@Aspect注解标注）</p>
</li>
<li><p>判断是否需要跳过。通过Bean名称判断是否以AutowireCapableBeanFactory.ORIGINAL_INSTANCE_SUFFIX（.ORIGINAL）结尾，是的话返回true表示跳过代理。</p>
</li>
<li><p>如果自定义了TargetSource，则在此处创建Bean代理，以取代目标Bean的后续默认实例化方式。但是代码中并没有自定义TargetSource，所以直接跳过。</p>
</li>
</ol>
<p>经过以上这些步骤，就TargetClass这个Bean而言，postProcessBeforeInstantiation方法最终返回null。Bean实例化前置处理到此完毕，点击Resume Program，继续Bean的后续生命周期处理逻辑，程序跳转到Bean初始化后置处理方法postProcessAfterInitialization：</p>
<p><img src="/images/postProcessAfterInitialization%E5%BC%80%E5%A7%8B%E8%B0%83%E8%AF%95.png"></p>
<p>该方法重点关注wrapIfNecessary方法，查看wrapIfNecessary方法源码：</p>
<p><img src="/images/wrapIfNecessary%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png"></p>
<ol>
<li><p>getAdvicesAndAdvisorsForBean方法内部主要包含以下这些逻辑：</p>
<ul>
<li>获取所有的通知方法（切面里定义的各个方法）；</li>
<li>通过切点表达式判断这些通知方法是否可为当前Bean所用；</li>
<li>如果有符合的通知方法，则对它们进行排序（排序规则不同版本Spring有所不同，上面已经提及过）。</li>
</ul>
<p>在前面的AOP例子中，切面MyAspect里的通知方法就是为了增强TargetClass所设的（根据切点表达式），所以getAdvicesAndAdvisorsForBean方法返回值如下所示：</p>
<p><img src="/images/getAdvicesAndAdvisorsForBean%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC.png"></p>
<p>这些通知方法就是我们在MyAspect切面里定义的通知方法：</p>
<p><img src="/images/aop%E9%80%9A%E7%9F%A5%E6%96%B9%E6%B3%95.png"></p>
</li>
<li><p>如果该Bean的通知方法集合不为空的话，则创建该Bean的代理对象，具体查看createProxy方法源码：</p>
<p><img src="/images/createProxy%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png"></p>
<p>继续跟踪proxyFactory.getProxy(getProxyClassLoader())源码：</p>
<p><img src="/images/getProxy%E6%BA%90%E7%A0%811.png"></p>
<p><img src="/images/getProxy%E6%BA%90%E7%A0%812.png"></p>
<p>Spring会判断当前使用哪种代理对象（一般来说当Bean有实现接口时，使用JDK动态代理，当Bean没有实现接口时，使用cglib代理，在Boot中，我们可以通过<code>spring.aop.proxy-target-class=true</code>配置来强制使用cglib代理）。</p>
</li>
</ol>
<p>通过Bean初始化后置代理方法postProcessBeforeInstantiation处理后，TargetClass被包装为了cglib代理的增强Bean，注册到IOC容器中：</p>
<p><img src="/images/TargetClass%E8%A2%AB%E5%8C%85%E8%A3%85.png"></p>
<p>后续从IOC容器中获得的TargetClass就是被代理后的对象，执行代理对象的目标方法的时候，代理对象会执行相应的通知方法链。</p>
<h3 id="生成拦截器链MethodInterceptor"><a href="#生成拦截器链MethodInterceptor" class="headerlink" title="生成拦截器链MethodInterceptor"></a>生成拦截器链MethodInterceptor</h3><p>AOP代理对象生成后，需要关注代理对象的目标方法执行时，通知方法是怎么被执行的。</p>
<p>先将前面打的断点都去掉，然后在SpringBoot的入口类AopApplication的如下位置打个断点：</p>
<p><img src="/images/AopApplication%E6%89%93%E6%96%AD%E7%82%B9.png"></p>
<p>以debug方式启动程序，可以看到获取到的TargetClass Bean就是前面cglib代理后的Bean（TargetClass$$EnhanceBySpringCGLIB）</p>
<p><img src="/images/TargetClass%E7%9A%84Bean%E5%AF%B9%E8%B1%A1.png"></p>
<p>点击Step Into进入test方法内部调用逻辑，会发现程序跳转到了CglibAopProxy的intercept方法中，也就是说我们的目标对象的目标方法被CglibAopProxy的intercept方法拦截了，该拦截方法主要逻辑如下：</p>
<p><img src="/images/CglibAopProxy%E6%8B%A6%E6%88%AA%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.png"></p>
<p>getInterceptorsAndDynamicInterceptionAdvice方法，其源码如下所示:</p>
<p><img src="/images/getInterceptorsAndDynamicInterceptionAdvice%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png"></p>
<p>继续查看this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice源码：</p>
<p><img src="/images/this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice%E6%BA%90%E7%A0%81.png"></p>
<p>通过debug我们可以看到，当前代理对象的test方法的拦截器链不为空，并且元素个数为5：</p>
<p><img src="/images/%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE%E4%B8%AA%E6%95%B0.png"></p>
<p>拦截器链5个元素：拦截器链第一个元素类型为ExposeInvocationInterceptor，是默认的拦截器，后面会介绍到它的作用。剩下四个依次为：MethodBeforeAdviceInterceptor、AspectJAfterAdvice、AfterReturningAdviceInterceptor和AspectJAfterThrowingAdvice，它们都是MethodInterceptor的实现类：</p>
<p><img src="/images/%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE%E7%B1%BB%E7%BB%93%E6%9E%84.png"></p>
<h3 id="链式调用通知方法"><a href="#链式调用通知方法" class="headerlink" title="链式调用通知方法"></a>链式调用通知方法</h3><p>获取到了代理对象目标方法的拦截器链后，当获取拦截器链并且拦截器链不为空时，CglibAopProxy的intercept方法创建CglibMethodInvocation对象，并调用它的proceed方法：</p>
<p><img src="/images/proceed%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%9C.png"></p>
<p>查看CglibMethodInvocation源码：</p>
<p><img src="/images/CglibMethodInvocation%E6%BA%90%E7%A0%81.png"></p>
<p>查看CglibMethodInvocation父类ReflectiveMethodInvocation proceed方法源码：</p>
<p><img src="/images/ReflectiveMethodInvocation%E7%9A%84proceed%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.png"></p>
<p>清除掉之前打的断点，在该方法上第一行打个端点，重新以debug方式启动Boot应用：</p>
<p><img src="/images/%E9%87%8D%E5%90%AFBoot%E5%BA%94%E7%94%A8.png"></p>
<p>程序第一次进该方法时currentInterceptorIndex值为-1，this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex)取出拦截器链第一个拦截器ExposeInvocationInterceptor，方法最后调用该拦截器的invoke方法，Step Into进入该方法：</p>
<p>![](/images/Step Into进入该方法.png)</p>
<p>mi就是我们传入的ReflectiveMethodInvocation对象，程序执行到mi.proceed方法时，Step Into进入该方法：</p>
<p><img src="/images/mi.proceed%E6%96%B9%E6%B3%95.png"></p>
<p>可以看到，此时程序第二次执行ReflectiveMethodInvocation的poceed方法，currentInterceptorIndex值为0，this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex)取出拦截器链第二个拦截器MethodBeforeAdviceInterceptor，方法最后调用该拦截器的invoke方法，Step Into进入该方法：</p>
<p><img src="/images/%E8%B0%83%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84invoke%E6%96%B9%E6%B3%95.png"></p>
<p>可以看到MethodBeforeAdviceInterceptor的invoke方法第一行调用了通知方法before，此时控制台打印内容为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">onBefore：<span class="built_in">test</span>方法开始执行，参数：[hello]</span><br></pre></td></tr></table></figure>

<p>接着又通过mi.proceed再次调用ReflectiveMethodInvocation的poceed方法。就这样，随着invokeJoinpoint()方法执行结束返回出栈，程序回到AspectJAfterThrowingAdvice的invoke方法：</p>
<p><img src="/images/AspectJAfterThrowingAdvice%E7%9A%84invoke%E6%96%B9%E6%B3%95.png"></p>
<p>就这个例子来说，目标方法test并没有抛出异常，所以AspectJAfterThrowingAdvice的invoke方法执行结束出栈，程序回到AfterReturningAdviceInteceptor的invoke方法：</p>
<p><img src="/images/AfterReturningAdviceInteceptor%E7%9A%84invoke%E6%96%B9%E6%B3%95.png"></p>
<p>this.advice.afterReturning执行afterReturning通知方法，控制台打印内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">onBefore：<span class="built_in">test</span>方法开始执行，参数：[hello]</span><br><span class="line">目标方法<span class="built_in">test</span>被执行</span><br><span class="line">afterReturning：<span class="built_in">test</span>方法执行结束返回，参数：[hello]，返回值：hello</span><br></pre></td></tr></table></figure>

<p>AfterReturningAdviceInteceptor的invoke方法执行结束出栈，程序回到AspectJAfterAdvice的invoke方法：</p>
<p><img src="/images/AspectJAfterAdvice%E7%9A%84invoke%E6%96%B9%E6%B3%95.png"></p>
<p>AspectJAfterAdvice的invoke方法最终执行finally after逻辑，控制台打印内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">onBefore：<span class="built_in">test</span>方法开始执行，参数：[hello]</span><br><span class="line">目标方法<span class="built_in">test</span>被执行</span><br><span class="line">afterReturning：<span class="built_in">test</span>方法执行结束返回，参数：[hello]，返回值：hello</span><br><span class="line">onAfter：<span class="built_in">test</span>方法执行结束，参数：[hello]</span><br></pre></td></tr></table></figure>

<p>AspectJAfterAdvice的invoke方法执行结束出栈，程序回到MethodBeforeAdviceInterceptor的invoke方法：</p>
<p><img src="/images/MethodBeforeAdviceInterceptor%E7%9A%84invoke%E6%96%B9%E6%B3%95.png"></p>
<p>MethodBeforeAdviceInterceptor的invoke方法正常执行结束，出栈，程序回到ExposeInvocationInterceptor的invoke方法：</p>
<p><img src="/images/ExposeInvocationInterceptor%E7%9A%84invoke%E6%96%B9%E6%B3%95.png"></p>
<p>ExposeInvocationInterceptor的invoke方法执行结束出栈，程序回到CglibAopProxy的intercept方法。当CglibAopProxy的intercept方法执行结束出栈后，整个AOP的拦截器链调用也随之结束了：</p>
<p><img src="/images/CglibAopProxy%E7%9A%84intercept%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9D%9F.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/aop%E6%80%BB%E7%BB%93.png"></p>
]]></content>
      <tags>
        <tag>spring, aop</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2020/04/07/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>前段时间考试周，没有很多时间看书。这两天比较闲，不如把背包问题好好解决一番，供以后复习。</p>
<p>之前讨论过动态规划的问题，动态规划最终的结果是通过解决小问题来解决大问题。同样的道理，解决背包问题也是如此，先解决小背包问题，再解决大背包问题。</p>
<p>下面由浅入深，条件由简单到复杂地讨论背包问题的动态规划解决方案。</p>
<p>还是老办法，参照4个步骤：</p>
<ol>
<li>描述最优解的结构</li>
<li>递归定义最优解的值</li>
<li>按自底向上的方式计算最优解的值(非递归，通常为循环)</li>
<li>由计算出的结果构造一个最优解</li>
</ol>
<p>Tip:</p>
<ol>
<li>每种动态规划解决方案都涉及网格(数组)</li>
<li>单元格(数组项)中的值通常为要优化的值</li>
<li>每个单元格都是一个子问题最优解，因此，应该考虑如何将问题分成子问题，这有助于找出网格的坐标轴(行和列号对应含义)</li>
</ol>
<span id="more"></span>

<h2 id="背包问题1——基本背包"><a href="#背包问题1——基本背包" class="headerlink" title="背包问题1——基本背包"></a>背包问题1——基本背包</h2><blockquote>
<p>问题描述：</p>
<p>有N种物品和一个容量为V的背包，每种物品仅有1件，放入第i件物品耗费的空间为Ci，得到的价值为Vi。问，如何组合才能使背包里物品的价值最大。</p>
<p><strong>实际问题描述：</strong></p>
<p><em>假设你是一个小偷，背着一个可装4kg东西的背包，可盗窃的商品如下：</em></p>
<table>
<thead>
<tr>
<th>商品</th>
<th>价值（美元）</th>
<th>重量（kg）</th>
</tr>
</thead>
<tbody><tr>
<td>音响</td>
<td>3000</td>
<td>4</td>
</tr>
<tr>
<td>笔记本电脑</td>
<td>2000</td>
<td>3</td>
</tr>
<tr>
<td>吉他</td>
<td>1500</td>
<td>1</td>
</tr>
<tr>
<td>iphone</td>
<td>2000</td>
<td>1</td>
</tr>
<tr>
<td>项链</td>
<td>1000</td>
<td>0.5</td>
</tr>
<tr>
<td>戒指</td>
<td>1500</td>
<td>0.5</td>
</tr>
</tbody></table>
<p><em>每样商品数量只有一个，你该如何窃取，窃取财务的价值才能最大？</em></p>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li> 描述最优解结构</li>
</ol>
<p>   <img src="/images/%E5%B0%8F%E5%81%B7%E8%83%8C%E5%8C%85%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0.png"></p>
<ol start="2">
<li><p>递归定义最优解值</p>
<p>假设当前商品属于最大价值的商品的一部分，那么当前子背包容量扣去当前商品重量后的剩余重量所产生的商品价值应该为最大，否则假设不成立。</p>
<p>$$<br>为了方便讨论，定义如下变量： \<br>假设当前放入物品的索引为i，当前背包容量的索引为j。那么对应物品重量则为W_{i}，\ 对应的物品价值则为V_{i}，对应的背包容量为C_{j}，扣去当前物理重量，剩余背包容量对应的索引为k。\<br>再定义一个变量F_{i,j}表示放入一个容量为C_{j}的背包，可以获得的最大价值。那么会有如下方程：<br>$$</p>
<p>$$<br>F_{i,j}=\left{\begin{matrix}<br>V_{i} \quad\quad  i=0&amp;&amp;W_{i}&lt;=C_{j} \<br>0 \quad\quad i=0&amp;&amp;W_{i}&gt;C_{j} \<br>F_{i-1,j} \quad\quad i&gt;=1&amp;&amp;W_{i}&gt;C_{j} \<br>max{ F_{i-1,j}\quad , F_{i-1,k}+V_{i} } \quad\quad i&gt;=1&amp;&amp;W_{i}&lt;=C_{j} \</p>
<p>\end{matrix}\right.  \<br>$$</p>
</li>
</ol>
<ol start="3">
<li><p>按自底向上方式求解最优值</p>
<p>根据描述，需要定义一个双层循环，外层循环控制行——物品项。内层循环控制列——背包重量。</p>
<p>通过求解子背包的最大价值，进而求得当前背包的最大价值。伪代码描述如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外层循环，索引为i，最大值为物品数量-<span class="number">1</span></span><br><span class="line">	内层循环，索引为j，最大值为定义的子背包数量-<span class="number">1</span></span><br><span class="line">		获取当前物品的重量Wi，当前物品的价值Vi，当前背包容量Cj</span><br><span class="line">		判断Wi和Cj大小，Wi&gt;Cj，如果i!=<span class="number">0</span>，则Fij=Fi-1j，如果i=<span class="number">0</span>，则Fij=<span class="number">0</span></span><br><span class="line">    	Wi&lt;=Cj，如果i=<span class="number">0</span>，则Fij=Vi，如果i!=<span class="number">0</span>，则需要找出剩余背包容量最大价值Fi-1k</span><br><span class="line">    	找到后进行Fi-1k+Vi和Fi-1j的比较，较大的为当前项Fij的值</span><br></pre></td></tr></table></figure></li>
<li><p>用代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Goods</span>&gt; </span>&#123;</span><br><span class="line">   </span><br><span class="line"> <span class="keyword">private</span> String name;  <span class="comment">// 商品名称</span></span><br><span class="line"> <span class="keyword">private</span> Integer value;  <span class="comment">// 商品价值</span></span><br><span class="line"> <span class="keyword">private</span> Double weight;  <span class="comment">// 商品重量</span></span><br><span class="line">   </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String name, Integer value, Double weight)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.name = name;</span><br><span class="line">     <span class="keyword">this</span>.value = value;</span><br><span class="line">     <span class="keyword">this</span>.weight = weight;</span><br><span class="line"> &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Goods goods)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 按照商品重量进行比较</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.weight &lt; goods.weight) &#123;</span><br><span class="line">         <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.weight &gt; goods.weight) &#123;</span><br><span class="line">         <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//省略getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThiefWithGoodsProblem</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> bagCapacity;  <span class="comment">// 背包容量</span></span><br><span class="line"> <span class="keyword">private</span> Goods[] goodsList;  <span class="comment">// 商品列表</span></span><br><span class="line"> <span class="keyword">private</span> Double[] weightList; <span class="comment">//重量列表</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span>[][] valueCalculate;  <span class="comment">//偷走商品价值计算</span></span><br><span class="line"> <span class="keyword">private</span> ArrayList&lt;Goods&gt;[][] valueRecord;  <span class="comment">//偷走商品记录</span></span><br><span class="line">   </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThiefWithGoodsProblem</span><span class="params">(Goods[] goodsList, <span class="keyword">int</span> bagCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.bagCapacity = bagCapacity;</span><br><span class="line">     <span class="keyword">this</span>.goodsList = goodsList;</span><br><span class="line">     <span class="comment">// 根据重量从小到大排序</span></span><br><span class="line">     Arrays.sort(goodsList);</span><br><span class="line">     TreeSet&lt;Double&gt; weightTempList = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span> (Goods g : goodsList) &#123;</span><br><span class="line">         weightTempList.add(g.getWeight());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">this</span>.weightList = weightTempList.toArray(<span class="keyword">new</span> Double[<span class="number">0</span>]);</span><br><span class="line">   </span><br><span class="line">     <span class="comment">//初始化</span></span><br><span class="line">     valueCalculate = <span class="keyword">new</span> <span class="keyword">int</span>[goodsList.length][weightList.length];</span><br><span class="line">     valueRecord = <span class="keyword">new</span> ArrayList[goodsList.length][weightList.length];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueRecord.length; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; valueRecord[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">             valueRecord[i][j] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">     <span class="comment">//开始计算并记录小偷能偷走的最大价值商品</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueRecord.length; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; valueRecord[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">             <span class="comment">// 获取当前商品</span></span><br><span class="line">             Goods currentGoods = goodsList[i];</span><br><span class="line">             <span class="comment">// 获取当前子背包重量</span></span><br><span class="line">             <span class="keyword">double</span> currentBagCapacity = weightList[j];</span><br><span class="line">             <span class="keyword">if</span> (currentGoods.getWeight() &gt; currentBagCapacity) &#123;</span><br><span class="line">                 <span class="comment">// 如果当前商品重量大于子背包重量，则将valueCalculate[i-1][j]的值作为</span></span><br><span class="line">                 <span class="comment">// 当前项的最大值</span></span><br><span class="line">                 <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                     valueCalculate[i][j] = valueCalculate[i - <span class="number">1</span>][j];</span><br><span class="line">                     valueRecord[i][j] = valueRecord[i - <span class="number">1</span>][j];</span><br><span class="line">                     <span class="keyword">continue</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 如果当前商品重量小于等于子背包重量，则需要比较valueCalculate[i][j]</span></span><br><span class="line">             <span class="comment">// 和valueCalculate[i][j - 1]的大小</span></span><br><span class="line">             <span class="keyword">int</span> maxGoodsValue = currentGoods.getValue();</span><br><span class="line">             currentBagCapacity = currentBagCapacity - currentGoods.getWeight();</span><br><span class="line">             <span class="comment">// 计算子背包剩余容量价值</span></span><br><span class="line">             <span class="keyword">if</span> (currentBagCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> w = weightList.length - <span class="number">1</span>; w &gt;= <span class="number">0</span>; w--) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (weightList[w] &lt;= currentBagCapacity) &#123;</span><br><span class="line">                         <span class="comment">// 找到背包剩余容量最大价值</span></span><br><span class="line">                         <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                             maxGoodsValue += valueCalculate[i - <span class="number">1</span>][w];</span><br><span class="line">                             <span class="comment">// 这里千万不要写成valueRecord[i][j] = valueRecord[i - 1][w]，被坑了一天</span></span><br><span class="line">                             <span class="comment">// 如果你这样做的话，它们是指向同一个列表，修改的时候是同时修改</span></span><br><span class="line">                             <span class="keyword">for</span> (Goods g : valueRecord[i - <span class="number">1</span>][w]) &#123;</span><br><span class="line">                                 valueRecord[i][j].add(g);</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                 valueCalculate[i][j] = maxGoodsValue;</span><br><span class="line">                 valueRecord[i][j].add(currentGoods);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (maxGoodsValue &gt; valueCalculate[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                     valueCalculate[i][j] = maxGoodsValue;</span><br><span class="line">                     valueRecord[i][j].add(currentGoods);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     valueCalculate[i][j] = valueCalculate[i - <span class="number">1</span>][j];</span><br><span class="line">                     <span class="comment">// 需要先清空残留记录</span></span><br><span class="line">                     valueRecord[i][j].clear();</span><br><span class="line">                     <span class="keyword">for</span> (Goods g : valueRecord[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                         valueRecord[i][j].add(g);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<blockquote>
<h4 id="对上述问题进行优化："><a href="#对上述问题进行优化：" class="headerlink" title="对上述问题进行优化："></a>对上述问题进行优化：</h4><p>$$<br>为了方便讨论，定义如下变量： \假设当前放入物品的索引为i，当前背包容量的索引为j。那么对应物品重量则为W_{i}，\ 对应的物品价值则为V_{i}，对应的背包容量为C_{j}，扣去当前物理重量，剩余背包容量对应的索引为k。\再定义一个变量F_{i,j}表示放入一个容量为C_{j}的背包，可以获得的最大价值。那么会有如下方程：<br>$$</p>
</blockquote>
<blockquote>
<p>$$<br>F_{i,j}=\left{\begin{matrix}V_{i} \quad\quad  i=0&amp;&amp;W_{i}&lt;=C_{j} \ 0 \quad\quad i=0&amp;&amp;W_{i}&gt;C_{j} \F_{i-1,j} \quad\quad i&gt;=1&amp;&amp;W_{i}&gt;C_{j} \max{ F_{i-1,j}\quad , F_{i-1,k}+V_{i} } \quad\quad i&gt;=1&amp;&amp;W_{i}&lt;=C_{j} \\end{matrix}\right.  \<br>$$</p>
<p>这4个式子，可以优化成剩下两个。需要增加一项：i=0时，表示没有物品放入背包。那么F0j就可以都表示为0。上述方程就可以优化成：<br>$$<br>F_{i,j}=\left{\begin{matrix}F_{i-1,j} \quad\quad W_{i}&gt;C_{j} \max{ F_{i-1,j}\quad , F_{i-1,k}+V_{i} } \quad\quad W_{i}&lt;=C_{j} \\end{matrix}\right.  \<br>$$</p>
</blockquote>
<blockquote>
<h4 id="关于背包初始化的问题"><a href="#关于背包初始化的问题" class="headerlink" title="关于背包初始化的问题"></a>关于背包初始化的问题</h4><p>上面的背包问题要求我们将背包内物品的价值最大化，并没有要求我们将背包装满。而背包初始化问题可以分成两类：一类就是背包内物品价值最大化，但不要求背包装满；另一类就是要求背包恰好装满时的最优解。</p>
<p>如果是第一类背包初始化问题，没有要求背包装满，只是希望价格尽可能大，那么初始化时应该将F0,j全部设为0。如果是第二类背包初始化问题，要求背包恰好装满的最优解，那么在初始化的时候除了F0,0=0，其他的Fi,j均应设为-∞，这样就可以保证最终得到的Fi,j为恰好装满背包的最优解。</p>
<p>这样做的原因就是，初始化的F数组实际上就是没有在装入任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可以在什么也不装且价值为0的情况下被恰好装满，其他容量的背包均处于未定义的状态，或者说还没有合法的解，应该被赋值为-∞。如果背包并非必须被装满，那么任何容量的背包都有一个合法解——什么都不装，这个解的价值为0，索引初始时状态的值也就全部为0。</p>
</blockquote>
<h2 id="背包问题2——完全背包"><a href="#背包问题2——完全背包" class="headerlink" title="背包问题2——完全背包"></a>背包问题2——完全背包</h2><blockquote>
<p>问题描述：</p>
<p>有N件物品和一个容量为V的背包，每种物品都有无限件可用，放入第i件的物品耗费的空间为Ci，得到的价值为Wi。如何组合，才能使背包里物品的价值最大？</p>
<ol>
<li>描述最优解结构。</li>
</ol>
<p>  <img src="/images/%E5%B0%8F%E5%81%B7%E8%83%8C%E5%8C%85%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0.png"></p>
<ol start="2">
<li>递归定义最优解的值<br>$$<br>定义如下变量：\<br>假设当前放入的物品索引为i，当前背包容量索引为j，放入物品数量为k。那么放入的物品重量则为W_{i}*k，\对应的物品价值为V_{i}<em>k,对应的背包容量为C_{j}，剩余背包容量对应的索引为C_{j}-k</em>W_{i}。\最后定义一个变量F_{i,j}表示容量为C_{j}的背包在当前物品情况下可以获取的最大价值。那么方程如下：<br>$$</li>
</ol>
<p>$$<br>  F_{i,j}=\left{\begin{matrix}F_{i-1,j} \quad\quad W_{i}&gt;C_{j} \max{ F_{i-1,C_{j}-k*W_{i}}+V_{i}<em>k \quad 0&lt;=k</em>W_{i}&lt;=C_{j} \quad k \in[0,1,2,3…] } \quad\quad W_{i}&lt;=C_{j} \\end{matrix}\right.  \<br>$$</p>
<ol start="3">
<li><p>按自底向上的方式求解最优解</p>
</li>
<li><p>用代码实现</p>
</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThiefWithMultipleGoodsProblem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bagCapacity;  <span class="comment">// 背包容量</span></span><br><span class="line">    <span class="keyword">private</span> Goods[] goodsList;  <span class="comment">// 商品列表</span></span><br><span class="line">    <span class="keyword">private</span> Double[] weightList; <span class="comment">//重量列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] valueCalculate;  <span class="comment">//偷走商品价值计算</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Goods&gt;[][] valueRecord;  <span class="comment">//偷走商品记录</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThiefWithMultipleGoodsProblem</span><span class="params">(Goods[] goodsList, <span class="keyword">int</span> bagCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bagCapacity = bagCapacity;</span><br><span class="line">        <span class="keyword">this</span>.goodsList = <span class="keyword">new</span> Goods[goodsList.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">this</span>.goodsList[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0.0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.goodsList.length; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.goodsList[i] = goodsList[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据重量从小到大排序</span></span><br><span class="line">        Arrays.sort(<span class="keyword">this</span>.goodsList);</span><br><span class="line">        TreeSet&lt;Double&gt; weightTempList = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Goods g : <span class="keyword">this</span>.goodsList) &#123;</span><br><span class="line">            weightTempList.add(g.getWeight());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.weightList = weightTempList.toArray(<span class="keyword">new</span> Double[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        valueCalculate = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.goodsList.length][weightList.length];</span><br><span class="line">        valueRecord = <span class="keyword">new</span> ArrayList[<span class="keyword">this</span>.goodsList.length][weightList.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueRecord.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; valueRecord[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                valueRecord[i][j] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; valueCalculate[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            valueCalculate[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; valueCalculate.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; valueCalculate[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                Goods currentGoods = <span class="keyword">this</span>.goodsList[i];</span><br><span class="line">                <span class="keyword">double</span> currentCapacity = <span class="keyword">this</span>.weightList[j];</span><br><span class="line">                valueCalculate[i][j] = valueCalculate[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">for</span> (Goods g : valueRecord[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                    valueRecord[i][j].add(g);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (currentGoods.getWeight() &gt; currentCapacity) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k * currentGoods.getWeight() &lt;= currentCapacity; k++) &#123;</span><br><span class="line">                    <span class="comment">// k = 0 的情况就是用[i-1][j]的值和记录进行替代</span></span><br><span class="line">                    <span class="keyword">int</span> maxValue = valueCalculate[i][j];</span><br><span class="line">                    <span class="keyword">double</span> remainCapacity = currentCapacity - k * currentGoods.getWeight();</span><br><span class="line">                    <span class="keyword">int</span> valueCalculateTemp = <span class="number">0</span>;  <span class="comment">//暂时记录计算值</span></span><br><span class="line">                    ArrayList&lt;Goods&gt; valueRecordTemp = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 暂时记录计算商品</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (remainCapacity != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> w = valueCalculate[<span class="number">0</span>].length - <span class="number">1</span>; w &gt;= <span class="number">0</span>; w--) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (valueCalculate[i - <span class="number">1</span>][w] &lt;= remainCapacity) &#123;</span><br><span class="line">                                valueCalculateTemp = valueCalculate[i - <span class="number">1</span>][w];</span><br><span class="line">                                <span class="keyword">for</span> (Goods g : valueRecord[i - <span class="number">1</span>][w]) &#123;</span><br><span class="line">                                    valueRecordTemp.add(g);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (maxValue &lt; k * currentGoods.getValue() + valueCalculateTemp) &#123;</span><br><span class="line">                        valueCalculate[i][j] = k * currentGoods.getValue() + valueCalculateTemp;</span><br><span class="line">                        valueRecord[i][j] = valueRecordTemp;  <span class="comment">// 清理原有记录并更改引用</span></span><br><span class="line">                        <span class="keyword">if</span> (k != <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;= k; m++) &#123;</span><br><span class="line">                                valueRecord[i][j].add(currentGoods);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">// max &gt;= k * currentGoods.getValue() + valueCalculateTemp 则不用进行替换</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="背包问题3——多重背包"><a href="#背包问题3——多重背包" class="headerlink" title="背包问题3——多重背包"></a>背包问题3——多重背包</h2><blockquote>
<p>问题描述：</p>
<p>有N件物品和一个容量为V的背包，每种物品只有Ni件物品可用(Ni&gt;=1)，放入第i件的物品耗费的空间为Ci，得到的价值为Wi。如何组合，才能使背包里物品的价值最大？</p>
<p>这和完全背包的问题几乎一致，只需进行细节部分的处理：对物品取走个数的限制，而不是偷到背包满。因此，只需要对内层循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k * currentGoods.getWeight() &lt;= currentCapacity; k++) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做修改，改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= limitNumber &amp;&amp; k * currentGoods.getWeight() &lt;= currentCapacity; k++) </span><br></pre></td></tr></table></figure>

<p>即可</p>
</blockquote>
]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树(BST)</title>
    <url>/2020/09/11/%E4%BA%8C%E5%8F%89%E6%A0%91(BST)/</url>
    <content><![CDATA[<p>树（Tree）是一种很有趣的数据结构，它既能像链表那样快速的插入和删除，又能像有序数组那样快速查找。树的种类很多，本节将记录一种特殊的树————二叉树（Binary Tree）。二叉树的每个节点最多只能有两个子节点，通常称为左子节点和右子节点。如果一个二叉树的每个节点的左子节点的关键字值小于该节点，右子节点的关键字值大于等于该节点，那么这种二叉树也称为二叉搜索树（Binary Search Tree,<strong>BST</strong>）</p>
<span id="more"></span>

<h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><p><img src="/images/BST%E4%BE%8B%E5%AD%90.png"></p>
<ul>
<li>路径：从一个节点走到另一个节点，经过的节点顺序就称为路径；</li>
<li>根：树的顶端节点称为根，一个数只能有一个根节点，并且从根节点到任意子节点只能有一条路径；</li>
<li>父节点：每个节点（除了根）都有一条边向上连接到另一个节点，这个节点就是下面节点的父节点；</li>
<li>子节点：每个节点（除了叶子节点）都有一条或两条边向下连接其他节点，下面这些节点就是当前节点的子节点。子节点分为左子节点和右子节点；</li>
<li>叶节点：没有子节点的节点称为叶子节点，或叶节点；</li>
<li>关键字：节点中的数据，比如上图中的数值。</li>
</ul>
<h2 id="操作BST"><a href="#操作BST" class="headerlink" title="操作BST"></a>操作BST</h2><p>在操作BST前，我们先用代码定义一个BST的骨架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的这些操作都以这个BST为例：</p>
<p><img src="/images/BST%E5%AE%9E%E4%BE%8B.png"></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>假如我们需要插入一个key为88的节点，需要经过如下步骤：</p>
<ol>
<li>从根节点出发，88比72大，所以走右子节点82路径；</li>
<li>88比82大，所以走右子节点90路径；</li>
<li>88比90小，所以走左子节点87路径；</li>
<li>88比87大，并且87的右子节点为空，所以我们最终把88作为87的右子节点插入树中。</li>
</ol>
<p>当key重复时，可以选择覆盖或者忽略，这由业务决定。</p>
<p>上述过程动态图如下所示：</p>
<p><img src="/images/BST%E6%8F%92%E5%85%A5%E5%8A%A8%E5%9B%BE.gif"></p>
<p>Java代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 插入 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个新节点</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果根为null，则这个新节点就是根</span></span><br><span class="line">            root = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果跟不为null，则从根开始搜索插入位置</span></span><br><span class="line">            Node currentNode = root;</span><br><span class="line">            <span class="comment">// 用于暂存父节点</span></span><br><span class="line">            Node parentNode;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 父节点设置为当前节点</span></span><br><span class="line">                parentNode = currentNode;</span><br><span class="line">                <span class="keyword">if</span> (key &lt; currentNode.key) &#123;</span><br><span class="line">                    currentNode = currentNode.leftChild;</span><br><span class="line">                    <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果key小于当前节点key，并且当前节点的左子节点为空，则将新节点</span></span><br><span class="line">                        <span class="comment">// 设置为当前节点（父节点暂存对象）的左子节点，退出循环</span></span><br><span class="line">                        parentNode.leftChild = newNode;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; currentNode.key) &#123;</span><br><span class="line">                    currentNode = currentNode.rightChild;</span><br><span class="line">                    <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果key大于当前节点key，并且当前节点的右子节点为空，则将新节点</span></span><br><span class="line">                        <span class="comment">// 设置为当前节点（父节点暂存对象）的又子节点，退出循环</span></span><br><span class="line">                        parentNode.rightChild = newNode;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果key等于当前节点key，则将value覆盖当前节点value</span></span><br><span class="line">                    currentNode.value = newNode.value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearchTree bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">        Arrays.asList(<span class="number">72</span>, <span class="number">57</span>, <span class="number">82</span>, <span class="number">30</span>, <span class="number">63</span>, <span class="number">79</span>, <span class="number">90</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">62</span>, <span class="number">67</span>, <span class="number">80</span>, <span class="number">87</span>, <span class="number">48</span>).forEach(key -&gt; &#123;</span><br><span class="line">            String value = <span class="string">&quot;我是key为&quot;</span> + key + <span class="string">&quot;的value&quot;</span>;</span><br><span class="line">            bst.insert(key, value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%8F%92%E5%85%A5%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>假如我们需要查找key为67的节点，需要经过如下步骤：</p>
<ol>
<li>从根节点出发，67比72小，所以走左子节点57路径；</li>
<li>67比57大，所以走右子节点63路径；</li>
<li>67比63大，所以走右子节点67路径；</li>
<li>67等于67，找到目标节点，退出；</li>
<li>如果搜索直到叶子节点都没找到，则返回空。</li>
</ol>
<p>上述过程动态图如下所示：</p>
<p><img src="/images/BST%E6%9F%A5%E6%89%BE%E5%8A%A8%E5%9B%BE.gif"></p>
<p>Java代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 查找 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从根节点开始查找</span></span><br><span class="line">        Node currentNode = root;</span><br><span class="line">        <span class="comment">// 当前节点的key不等于被查找的key时</span></span><br><span class="line">        <span class="keyword">while</span> (currentNode.key != key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; currentNode.key) &#123;</span><br><span class="line">                <span class="comment">// 如果key值小于当前节点key，则查找左子节点</span></span><br><span class="line">                currentNode = currentNode.leftChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果key值大于等于当前节点key，则查找右子节点</span></span><br><span class="line">                currentNode = currentNode.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前节点为null，说明查到叶子节点了，仍没查到目标key，则直接返回null</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回当前节点（退出while循环要么key相等，要么没找到，结果为null）</span></span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearchTree bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">        Arrays.asList(<span class="number">72</span>, <span class="number">57</span>, <span class="number">82</span>, <span class="number">30</span>, <span class="number">63</span>, <span class="number">79</span>, <span class="number">90</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">62</span>, <span class="number">67</span>, <span class="number">80</span>, <span class="number">87</span>, <span class="number">48</span>).forEach(key -&gt; &#123;</span><br><span class="line">            String value = <span class="string">&quot;我是key为&quot;</span> + key + <span class="string">&quot;的value&quot;</span>;</span><br><span class="line">            bst.insert(key, value);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(bst.find(<span class="number">87</span>).value);</span><br><span class="line">        bst.insert(<span class="number">87</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        System.out.println(bst.find(<span class="number">87</span>).value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">我是<span class="built_in">key</span>为<span class="number">87</span>的value</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h3 id="最大最小值"><a href="#最大最小值" class="headerlink" title="最大最小值"></a>最大最小值</h3><p>在BST里查找最大值和最小值是非常容易的一件事，根据BST特性，小的值都分布在左节点，大的值都分布在右节点，所以<strong>最小值查找方法为：从根节点出发，一直往下查找左子节点，当该节点不再有左子节点时，该节点就是最小节点；最大值查找方法为：从根节点出发，一直往下查找右子节点，当该节点不再有右子节点时，该节点就是最大节点</strong>。</p>
<p>查找最小值图示：</p>
<p><img src="/images/BST%E6%9F%A5%E6%89%BE%E6%9C%80%E5%B0%8F%E5%80%BC.gif"></p>
<p>查找最大值图示：</p>
<p><img src="/images/BST%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC.gif"></p>
<p>Java代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最小值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node currentNode = root;</span><br><span class="line">        <span class="keyword">while</span> (currentNode.leftChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentNode = currentNode.leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node currentNode = root;</span><br><span class="line">        <span class="keyword">while</span> (currentNode.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentNode = currentNode.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearchTree bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">        Arrays.asList(<span class="number">72</span>, <span class="number">57</span>, <span class="number">82</span>, <span class="number">30</span>, <span class="number">63</span>, <span class="number">79</span>, <span class="number">90</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">62</span>, <span class="number">67</span>, <span class="number">80</span>, <span class="number">87</span>, <span class="number">48</span>).forEach(key -&gt; &#123;</span><br><span class="line">            String value = <span class="string">&quot;我是key为&quot;</span> + key + <span class="string">&quot;的value&quot;</span>;</span><br><span class="line">            bst.insert(key, value);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(bst.min().value);</span><br><span class="line">        System.out.println(bst.max().value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下所示：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">我是<span class="built_in">key</span>为<span class="number">27</span>的value</span><br><span class="line">我是<span class="built_in">key</span>为<span class="number">90</span>的value</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除是BST操作里最复杂的一个，因为需要考虑的因素比较多：</p>
<ol>
<li>被删除的节点是叶子节点；</li>
<li>被删除的节点只有一个子节点；</li>
<li>被删除的节点有两个子节点。</li>
</ol>
<p>下面我们逐个分析：</p>
<h4 id="被删除的节点是叶子节点"><a href="#被删除的节点是叶子节点" class="headerlink" title="被删除的节点是叶子节点"></a>被删除的节点是叶子节点</h4><p>这种情况最为简单，删除节点前需要先找到该节点，过程和上面的查找类似。找到需要删除的节点后，如果是叶子节点，则将该节点的父节点引用置为null，被删除的节点没了引用，后续由GC自动回收。</p>
<p>假如我们需要删除key为48的节点，需要经过如下步骤：</p>
<ol>
<li>从根节点出发，48比72小，所以走左子节点57路径；</li>
<li>48比57小，所以走左子节点30路径；</li>
<li>48比30大，所以走右子节点40路径；</li>
<li>48比40大，所以走右子节点48路径；</li>
<li>48等于48，所以当前节点就是需要被删除节点；</li>
<li>48没有子节点，为叶子节点，所以直接将40的右子节点引用设置为null即可。</li>
</ol>
<p>该过程如下图所示：</p>
<p><img src="/images/BST%E5%88%A0%E9%99%A4%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9.gif"></p>
<p>Java代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 删除 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* --------- 查找需要被删除的节点以及它的父节点 ------- */</span></span><br><span class="line">        <span class="comment">// 从根节点开始查找</span></span><br><span class="line">        Node deleteNode = root;</span><br><span class="line">        <span class="comment">// 暂存需要被删除节点的父节点</span></span><br><span class="line">        Node parentNode = root;</span><br><span class="line">        <span class="comment">// 标识被删除的节点时父节点的左子节点还是右子节点</span></span><br><span class="line">        <span class="keyword">boolean</span> isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 下面这个过程和查找一致，只不过加了isLeftChild标识</span></span><br><span class="line">        <span class="keyword">while</span> (deleteNode.key != key) &#123;</span><br><span class="line">            parentNode = deleteNode;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; deleteNode.key) &#123;</span><br><span class="line">                isLeftChild = <span class="keyword">true</span>;</span><br><span class="line">                deleteNode = deleteNode.leftChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">                deleteNode = deleteNode.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果目标key对应的节点为空，则不需要删除，直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (deleteNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* --------- 情况1：被删除的节点是叶子节点 ------- */</span></span><br><span class="line">        <span class="keyword">if</span> (deleteNode.leftChild == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; deleteNode.rightChild == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deleteNode == root) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的节点为root，则直接将root节点设置为null</span></span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的左子节点，则将父节点的左子节点关联置为null</span></span><br><span class="line">                parentNode.leftChild = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的右子节点，则将父节点的右子节点关联置为null</span></span><br><span class="line">                parentNode.rightChild = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearchTree bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">        Arrays.asList(<span class="number">72</span>, <span class="number">57</span>, <span class="number">82</span>, <span class="number">30</span>, <span class="number">63</span>, <span class="number">79</span>, <span class="number">90</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">62</span>, <span class="number">67</span>, <span class="number">80</span>, <span class="number">87</span>, <span class="number">48</span>).forEach(key -&gt; &#123;</span><br><span class="line">            String value = <span class="string">&quot;我是key为&quot;</span> + key + <span class="string">&quot;的value&quot;</span>;</span><br><span class="line">            bst.insert(key, value);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(bst.delete(<span class="number">49</span>));</span><br><span class="line">        System.out.println(bst.delete(<span class="number">48</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>可以看到40的右子节点已经被删除</p>
<h4 id="被删除的节点只有一个子节点"><a href="#被删除的节点只有一个子节点" class="headerlink" title="被删除的节点只有一个子节点"></a>被删除的节点只有一个子节点</h4><p>这种情况也比较简单，只需要将被删除节点的子节点和其父节点建立连接关系即可。</p>
<p>假如我们需要删除key为79的节点，需要经过如下步骤：</p>
<ol>
<li>从根节点出发，79比72大，所以走右子节点82路径；</li>
<li>79比82小，所以走左子节点79路径；</li>
<li>79等于79，所以当前节点就是需要被删除节点；</li>
<li>79只有一个右子节点，因为79是82的左子节点，所以直接将80设置为82的左子节点即可。</li>
</ol>
<p>该过程如下图所示：</p>
<p><img src="/images/BST%E8%A2%AB%E5%88%A0%E8%8A%82%E7%82%B9%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9.gif"></p>
<p>Java代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* --------- 查找需要被删除的节点以及它的父节点 ------- */</span></span><br><span class="line">        <span class="comment">// 从根节点开始查找</span></span><br><span class="line">        Node deleteNode = root;</span><br><span class="line">        <span class="comment">// 暂存需要被删除节点的父节点</span></span><br><span class="line">        Node parentNode = root;</span><br><span class="line">        <span class="comment">// 标识被删除的节点时父节点的左子节点还是右子节点</span></span><br><span class="line">        <span class="keyword">boolean</span> isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 下面这个过程和查找一致，只不过加了isLeftChild标识</span></span><br><span class="line">        <span class="keyword">while</span> (deleteNode.key != key) &#123;</span><br><span class="line">            parentNode = deleteNode;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; deleteNode.key) &#123;</span><br><span class="line">                isLeftChild = <span class="keyword">true</span>;</span><br><span class="line">                deleteNode = deleteNode.leftChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">                deleteNode = deleteNode.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果目标key对应的节点为空，则不需要删除，直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (deleteNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* --------- 情况1：被删除的节点是叶子节点 ------- */</span></span><br><span class="line">        <span class="keyword">if</span> (deleteNode.leftChild == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; deleteNode.rightChild == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deleteNode == root) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的节点为root，则直接将root节点设置为null</span></span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的左子节点，则将父节点的左子节点关联置为null</span></span><br><span class="line">                parentNode.leftChild = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的右子节点，则将父节点的右子节点关联置为null</span></span><br><span class="line">                parentNode.rightChild = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deleteNode.leftChild != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; deleteNode.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* --------- 情况3：被删除的节点有两个子节点 ------- */</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* --------- 情况2：被删除的节点只有一个子节点 ------- */</span></span><br><span class="line">            <span class="comment">// 获取被删除节点的唯一子节点</span></span><br><span class="line">            Node deleteNodeChild = deleteNode.leftChild == <span class="keyword">null</span> ?</span><br><span class="line">                    deleteNode.rightChild : deleteNode.leftChild;</span><br><span class="line">            <span class="keyword">if</span> (deleteNode == root) &#123;</span><br><span class="line">                <span class="comment">// 如果被删除节点就是root，那么将其唯一子节点设置为root</span></span><br><span class="line">                root = deleteNodeChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的左子节点，则将父节点的左子节点关联置为被删除节点的唯一子节点</span></span><br><span class="line">                parentNode.leftChild = deleteNodeChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的右子节点，则将父节点的右子节点关联置为被删除节点的唯一子节点</span></span><br><span class="line">                parentNode.rightChild = deleteNodeChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearchTree bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">        Arrays.asList(<span class="number">72</span>, <span class="number">57</span>, <span class="number">82</span>, <span class="number">30</span>, <span class="number">63</span>, <span class="number">79</span>, <span class="number">90</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">62</span>, <span class="number">67</span>, <span class="number">80</span>, <span class="number">87</span>, <span class="number">48</span>).forEach(key -&gt; &#123;</span><br><span class="line">            String value = <span class="string">&quot;我是key为&quot;</span> + key + <span class="string">&quot;的value&quot;</span>;</span><br><span class="line">            bst.insert(key, value);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(bst.delete(<span class="number">79</span>));</span><br><span class="line">        System.out.println(bst.find(<span class="number">82</span>).leftChild.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line">我是<span class="built_in">key</span>为<span class="number">80</span>的value</span><br></pre></td></tr></table></figure>

<h4 id="被删除的节点有两个子节点"><a href="#被删除的节点有两个子节点" class="headerlink" title="被删除的节点有两个子节点"></a>被删除的节点有两个子节点</h4><p>这种情况比较复杂，删除的节点不能用删除节点的某个子节点来代替。比如现在需要删除上述BST的57节点，假如用57节点的右子节点63代替该节点，那么63的左子节点既不能是62，也不能是57的左子节点30。</p>
<p>这种情况下需要找到被删除节点的中序后继节点（successor）来代替它。所谓的中序后继节点就是：<strong>整个树中关键字值比被删除节点大，并且比被删除节点右子节点小的那部分节点中的关键字值最小的节点</strong>。</p>
<p>根据中序后继节点的定义来看，要找到它也很简单：</p>
<ol>
<li>从被删除节点的右子节点出发，一直往下找左子节点，当该节点不再有左子节点时，该节点就是中序后继节点；</li>
<li>如果被删除节点的右子节点没有左子节点，那么它就是要找的中序后继节点。</li>
</ol>
<p>举个例子，比如现在需要删除上述BST的57节点，那么它的中序后继节点为62；假如要删除的节点为63，那么它的中序后继为67：</p>
<ol>
<li><p>当删除的节点为57时，过程如下所示：</p>
<p><img src="/images/BST%E8%A2%AB%E5%88%A0%E9%99%A4%E7%9A%84%E8%8A%82%E7%82%B9%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9.gif"></p>
</li>
<li><p>当删除的节点为63时，过程如下所示：</p>
<p><img src="/images/BST%E8%A2%AB%E5%88%A0%E9%99%A4%E7%9A%84%E8%8A%82%E7%82%B9%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B91.gif"></p>
</li>
</ol>
<p>编写查找中序后继节点的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找中序后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getSuccessor</span><span class="params">(Node deleteNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暂存中序后继节点的父节点</span></span><br><span class="line">        Node successorParent = deleteNode;</span><br><span class="line">        <span class="comment">// 暂存中序后继节点</span></span><br><span class="line">        Node successor = deleteNode;</span><br><span class="line">        <span class="comment">// 先从删除节点的右子节点开始查找</span></span><br><span class="line">        Node currentNode = deleteNode.rightChild;</span><br><span class="line">        <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            successorParent = successor;</span><br><span class="line">            successor = currentNode;</span><br><span class="line">            <span class="comment">// 一直往下查找当前节点的左子节点，直到为空</span></span><br><span class="line">            currentNode = currentNode.leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如上面文章所说，中序后继节点和删除节点有两种可能性，</span></span><br><span class="line">        <span class="comment">// 当中序后继节点不是删除节点的右子节点时，需要做如下额外操作</span></span><br><span class="line">        <span class="keyword">if</span> (successor != deleteNode.rightChild) &#123;</span><br><span class="line">            <span class="comment">// 如果中序后继节点的右子节点不为空的话，将其和中序后继节点父节点的左子节点挂钩</span></span><br><span class="line">            <span class="keyword">if</span> (successor.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">                successorParent.leftChild = successor.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 中序后继节点的右子节点和删除节点的右子节点挂钩</span></span><br><span class="line">            successor.rightChild = deleteNode.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中序后继节点的左子节点和删除节点的左子节点挂钩</span></span><br><span class="line">        successor.leftChild = deleteNode.leftChild;</span><br><span class="line">        <span class="comment">// 剩下的删除节点的父节点和中序后继节点的连接关系在删除方法里处理，</span></span><br><span class="line">        <span class="comment">// 因为这个方法内无法获取删除节点的父节点对象</span></span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成删除方法的最后一个部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* --------- 查找需要被删除的节点已经它的父节点 ------- */</span></span><br><span class="line">        <span class="comment">// 从根节点开始查找</span></span><br><span class="line">        Node deleteNode = root;</span><br><span class="line">        <span class="comment">// 暂存需要被删除节点的父节点</span></span><br><span class="line">        Node parentNode = root;</span><br><span class="line">        <span class="comment">// 标识被删除的节点时父节点的左子节点还是右子节点</span></span><br><span class="line">        <span class="keyword">boolean</span> isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 下面这个过程和查找一致，只不过加了isLeftChild标识</span></span><br><span class="line">        <span class="keyword">while</span> (deleteNode.key != key) &#123;</span><br><span class="line">            parentNode = deleteNode;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; deleteNode.key) &#123;</span><br><span class="line">                isLeftChild = <span class="keyword">true</span>;</span><br><span class="line">                deleteNode = deleteNode.leftChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">                deleteNode = deleteNode.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果目标key对应的节点为空，则不需要删除，直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (deleteNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* --------- 情况1：被删除的节点是叶子节点 ------- */</span></span><br><span class="line">        <span class="keyword">if</span> (deleteNode.leftChild == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; deleteNode.rightChild == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deleteNode == root) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的节点为root，则直接将root节点设置为null</span></span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的左子节点，则将父节点的左子节点关联置为null</span></span><br><span class="line">                parentNode.leftChild = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的右子节点，则将父节点的右子节点关联置为null</span></span><br><span class="line">                parentNode.rightChild = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deleteNode.leftChild != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; deleteNode.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* --------- 情况3：被删除的节点有两个子节点 ------- */</span></span><br><span class="line">            <span class="comment">// 获取删除节点的中序后继节点</span></span><br><span class="line">            Node successor = getSuccessor(deleteNode);</span><br><span class="line">            <span class="comment">// 如果伤处节点就是根节点的话，中序后继节点直接成为新的根</span></span><br><span class="line">            <span class="keyword">if</span> (deleteNode == root) &#123;</span><br><span class="line">                root = successor;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">                <span class="comment">// 如果删除节点是父节点的左子节点，则将父节点的左子节点和中序后继节点挂钩</span></span><br><span class="line">                parentNode.leftChild = successor;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果删除节点是父节点的右子节点，则将父节点的右子节点和中序后继节点挂钩</span></span><br><span class="line">                parentNode.rightChild = successor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* --------- 情况2：被删除的节点只有一个子节点 ------- */</span></span><br><span class="line">            <span class="comment">// 获取被删除节点的唯一子节点</span></span><br><span class="line">            Node deleteNodeChild = deleteNode.leftChild == <span class="keyword">null</span> ?</span><br><span class="line">                    deleteNode.rightChild : deleteNode.leftChild;</span><br><span class="line">            <span class="keyword">if</span> (deleteNode == root) &#123;</span><br><span class="line">                <span class="comment">// 如果被删除节点就是root，那么将其唯一子节点设置为root</span></span><br><span class="line">                root = deleteNodeChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的左子节点，则将父节点的左子节点关联置为被删除节点的唯一子节点</span></span><br><span class="line">                parentNode.leftChild = deleteNodeChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的右子节点，则将父节点的右子节点关联置为被删除节点的唯一子节点</span></span><br><span class="line">                parentNode.rightChild = deleteNodeChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序测试一下：</p>
<p>当删除的节点为57时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearchTree bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">        Arrays.asList(<span class="number">72</span>, <span class="number">57</span>, <span class="number">82</span>, <span class="number">30</span>, <span class="number">63</span>, <span class="number">79</span>, <span class="number">90</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">62</span>, <span class="number">67</span>, <span class="number">80</span>, <span class="number">87</span>, <span class="number">48</span>).forEach(key -&gt; &#123;</span><br><span class="line">            String value = <span class="string">&quot;我是key为&quot;</span> + key + <span class="string">&quot;的value&quot;</span>;</span><br><span class="line">            bst.insert(key, value);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除57节点: &quot;</span> + bst.delete(<span class="number">57</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;72节点的左子节点为: &quot;</span> + bst.find(<span class="number">72</span>).leftChild.key);</span><br><span class="line">        BinarySearchTree.Node node62 = bst.find(<span class="number">62</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;62节点的左子节点为: &quot;</span> + node62.leftChild.key);</span><br><span class="line">        System.out.println(<span class="string">&quot;62节点的右子节点为: &quot;</span> + node62.rightChild.key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">删除57节点: true</span></span><br><span class="line"><span class="section">72节点的左子节点为: 62</span></span><br><span class="line"><span class="section">62节点的左子节点为: 30</span></span><br><span class="line"><span class="section">62节点的右子节点为: 63</span></span><br></pre></td></tr></table></figure>

<p>当删除的节点为63时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearchTree bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">        Arrays.asList(<span class="number">72</span>, <span class="number">57</span>, <span class="number">82</span>, <span class="number">30</span>, <span class="number">63</span>, <span class="number">79</span>, <span class="number">90</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">62</span>, <span class="number">67</span>, <span class="number">80</span>, <span class="number">87</span>, <span class="number">48</span>).forEach(key -&gt; &#123;</span><br><span class="line">            String value = <span class="string">&quot;我是key为&quot;</span> + key + <span class="string">&quot;的value&quot;</span>;</span><br><span class="line">            bst.insert(key, value);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除63节点: &quot;</span> + bst.delete(<span class="number">63</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;57节点的右子节点为: &quot;</span> + bst.find(<span class="number">57</span>).rightChild.key);</span><br><span class="line">        BinarySearchTree.Node node67 = bst.find(<span class="number">67</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;67节点的左子节点为: &quot;</span> + node67.leftChild.key);</span><br><span class="line">        System.out.println(<span class="string">&quot;67节点的右子节点为: &quot;</span> + (node67.rightChild == <span class="keyword">null</span> ? <span class="keyword">null</span> : node67.rightChild.key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">删除63节点: true</span></span><br><span class="line"><span class="section">57节点的右子节点为: 67</span></span><br><span class="line"><span class="section">67节点的左子节点为: 62</span></span><br><span class="line"><span class="section">67节点的右子节点为: null</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>遍历树指的是以一种特定顺序访问树的每一个节点，这个顺序分为：中序、前序和后序。</p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>中序遍历的步骤为：</p>
<ol>
<li>递归遍历目标节点的左子节点；</li>
<li>访问目标节点本身；</li>
<li>递归遍历目标节点的右子节点。</li>
</ol>
<p>Java实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 遍历需要从根开始遍历，所以添加根的get方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 中序遍历 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node targetNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (targetNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的左子节点</span></span><br><span class="line">            inOrder(targetNode.leftChild);</span><br><span class="line">            <span class="comment">// 访问目标节点本身</span></span><br><span class="line">            System.out.print(targetNode.key + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的右子节点</span></span><br><span class="line">            inOrder(targetNode.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearchTree bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">        Arrays.asList(<span class="number">72</span>, <span class="number">57</span>, <span class="number">82</span>, <span class="number">30</span>, <span class="number">63</span>, <span class="number">79</span>, <span class="number">90</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">62</span>, <span class="number">67</span>, <span class="number">80</span>, <span class="number">87</span>, <span class="number">48</span>).forEach(key -&gt; &#123;</span><br><span class="line">            String value = <span class="string">&quot;我是key为&quot;</span> + key + <span class="string">&quot;的value&quot;</span>;</span><br><span class="line">            bst.insert(key, value);</span><br><span class="line">        &#125;);</span><br><span class="line">        bst.inOrder(bst.getRoot());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">27</span> <span class="number">30</span> <span class="number">40</span> <span class="number">48</span> <span class="number">57</span> <span class="number">62</span> <span class="number">63</span> <span class="number">67</span> <span class="number">72</span> <span class="number">79</span> <span class="number">80</span> <span class="number">82</span> <span class="number">87</span> <span class="number">90</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/BST%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.gif"></p>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>前序遍历的步骤为：</p>
<ol>
<li>访问目标节点本身；</li>
<li>递归遍历目标节点的左子节点；</li>
<li>递归遍历目标节点的右子节点。</li>
</ol>
<p>Java实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 遍历需要从根开始遍历，所以添加根的get方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 前序遍历 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node targetNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (targetNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 访问目标节点本身</span></span><br><span class="line">            System.out.print(targetNode.key + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的左子节点</span></span><br><span class="line">            preOrder(targetNode.leftChild);</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的右子节点</span></span><br><span class="line">            preOrder(targetNode.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearchTree bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">        Arrays.asList(<span class="number">72</span>, <span class="number">57</span>, <span class="number">82</span>, <span class="number">30</span>, <span class="number">63</span>, <span class="number">79</span>, <span class="number">90</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">62</span>, <span class="number">67</span>, <span class="number">80</span>, <span class="number">87</span>, <span class="number">48</span>).forEach(key -&gt; &#123;</span><br><span class="line">            String value = <span class="string">&quot;我是key为&quot;</span> + key + <span class="string">&quot;的value&quot;</span>;</span><br><span class="line">            bst.insert(key, value);</span><br><span class="line">        &#125;);</span><br><span class="line">        bst.preOrder(bst.getRoot());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">72</span> <span class="number">57</span> <span class="number">30</span> <span class="number">27</span> <span class="number">40</span> <span class="number">48</span> <span class="number">63</span> <span class="number">62</span> <span class="number">67</span> <span class="number">82</span> <span class="number">79</span> <span class="number">80</span> <span class="number">90</span> <span class="number">87</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/BST%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.gif"></p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>后序遍历的步骤为：</p>
<ol>
<li>递归遍历目标节点的左子节点；</li>
<li>递归遍历目标节点的右子节点；</li>
<li>访问目标节点本身。</li>
</ol>
<p>Java实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** BST */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 遍历需要从根开始遍历，所以添加根的get方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 节点 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 关键字 */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/** 额外携带的数据 */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/** 左子节点 */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/** 右子节点 */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 后续遍历 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node targetNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (targetNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的左子节点</span></span><br><span class="line">            postOrder(targetNode.leftChild);</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的右子节点</span></span><br><span class="line">            postOrder(targetNode.rightChild);</span><br><span class="line">            <span class="comment">// 访问目标节点本身</span></span><br><span class="line">            System.out.print(targetNode.key + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySearchTree bst = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">        Arrays.asList(<span class="number">72</span>, <span class="number">57</span>, <span class="number">82</span>, <span class="number">30</span>, <span class="number">63</span>, <span class="number">79</span>, <span class="number">90</span>, <span class="number">27</span>, <span class="number">40</span>, <span class="number">62</span>, <span class="number">67</span>, <span class="number">80</span>, <span class="number">87</span>, <span class="number">48</span>).forEach(key -&gt; &#123;</span><br><span class="line">            String value = <span class="string">&quot;我是key为&quot;</span> + key + <span class="string">&quot;的value&quot;</span>;</span><br><span class="line">            bst.insert(key, value);</span><br><span class="line">        &#125;);</span><br><span class="line">        bst.postOrder(bst.getRoot());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">27</span> <span class="number">48</span> <span class="number">40</span> <span class="number">30</span> <span class="number">62</span> <span class="number">67</span> <span class="number">63</span> <span class="number">57</span> <span class="number">80</span> <span class="number">79</span> <span class="number">87</span> <span class="number">90</span> <span class="number">82</span> <span class="number">72</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/BST%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.gif"></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BST</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历需要从根开始遍历，所以添加根的get方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个新节点</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果根为null，则这个新节点就是根</span></span><br><span class="line">            root = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果跟不为null，则从根开始搜索插入位置</span></span><br><span class="line">            Node currentNode = root;</span><br><span class="line">            <span class="comment">// 用于暂存父节点</span></span><br><span class="line">            Node parentNode;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 父节点设置为当前节点</span></span><br><span class="line">                parentNode = currentNode;</span><br><span class="line">                <span class="keyword">if</span> (key &lt; currentNode.key) &#123;</span><br><span class="line">                    currentNode = currentNode.leftChild;</span><br><span class="line">                    <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果key小于当前节点key，并且当前节点的左子节点为空，则将新节点</span></span><br><span class="line">                        <span class="comment">// 设置为当前节点（父节点暂存对象）的左子节点，退出循环</span></span><br><span class="line">                        parentNode.leftChild = newNode;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; currentNode.key) &#123;</span><br><span class="line">                    currentNode = currentNode.rightChild;</span><br><span class="line">                    <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果key大于当前节点key，并且当前节点的右子节点为空，则将新节点</span></span><br><span class="line">                        <span class="comment">// 设置为当前节点（父节点暂存对象）的又子节点，退出循环</span></span><br><span class="line">                        parentNode.rightChild = newNode;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果key等于当前节点key，则将value覆盖当前节点value</span></span><br><span class="line">                    currentNode.value = newNode.value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从根节点开始查找</span></span><br><span class="line">        Node currentNode = root;</span><br><span class="line">        <span class="comment">// 当前节点的key不等于被查找的key时</span></span><br><span class="line">        <span class="keyword">while</span> (currentNode.key != key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; currentNode.key) &#123;</span><br><span class="line">                <span class="comment">// 如果key值小于当前节点key，则查找左子节点</span></span><br><span class="line">                currentNode = currentNode.leftChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果key值大于等于当前节点key，则查找右子节点</span></span><br><span class="line">                currentNode = currentNode.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前节点为null，说明查到叶子节点了，仍没查到目标key，则直接返回null</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回当前节点（退出while循环要么key相等，要么没找到，结果为null）</span></span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最小值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node currentNode = root;</span><br><span class="line">        <span class="keyword">while</span> (currentNode.leftChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentNode = currentNode.leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node currentNode = root;</span><br><span class="line">        <span class="keyword">while</span> (currentNode.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentNode = currentNode.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* --------- 查找需要被删除的节点已经它的父节点 ------- */</span></span><br><span class="line">        <span class="comment">// 从根节点开始查找</span></span><br><span class="line">        Node deleteNode = root;</span><br><span class="line">        <span class="comment">// 暂存需要被删除节点的父节点</span></span><br><span class="line">        Node parentNode = root;</span><br><span class="line">        <span class="comment">// 标识被删除的节点时父节点的左子节点还是右子节点</span></span><br><span class="line">        <span class="keyword">boolean</span> isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 下面这个过程和查找一致，只不过加了isLeftChild标识</span></span><br><span class="line">        <span class="keyword">while</span> (deleteNode.key != key) &#123;</span><br><span class="line">            parentNode = deleteNode;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; deleteNode.key) &#123;</span><br><span class="line">                isLeftChild = <span class="keyword">true</span>;</span><br><span class="line">                deleteNode = deleteNode.leftChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">                deleteNode = deleteNode.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果目标key对应的节点为空，则不需要删除，直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (deleteNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* --------- 情况1：被删除的节点是叶子节点 ------- */</span></span><br><span class="line">        <span class="keyword">if</span> (deleteNode.leftChild == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; deleteNode.rightChild == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deleteNode == root) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的节点为root，则直接将root节点设置为null</span></span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的左子节点，则将父节点的左子节点关联置为null</span></span><br><span class="line">                parentNode.leftChild = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的右子节点，则将父节点的右子节点关联置为null</span></span><br><span class="line">                parentNode.rightChild = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deleteNode.leftChild != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; deleteNode.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* --------- 情况3：被删除的节点有两个子节点 ------- */</span></span><br><span class="line">            <span class="comment">// 获取删除节点的中序后继节点</span></span><br><span class="line">            Node successor = getSuccessor(deleteNode);</span><br><span class="line">            <span class="comment">// 如果伤处节点就是根节点的话，中序后继节点直接成为新的根</span></span><br><span class="line">            <span class="keyword">if</span> (deleteNode == root) &#123;</span><br><span class="line">                root = successor;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">                <span class="comment">// 如果删除节点是父节点的左子节点，则将父节点的左子节点和中序后继节点挂钩</span></span><br><span class="line">                parentNode.leftChild = successor;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果删除节点是父节点的右子节点，则将父节点的右子节点和中序后继节点挂钩</span></span><br><span class="line">                parentNode.rightChild = successor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* --------- 情况2：被删除的节点只有一个子节点 ------- */</span></span><br><span class="line">            <span class="comment">// 获取被删除节点的唯一子节点</span></span><br><span class="line">            Node deleteNodeChild = deleteNode.leftChild == <span class="keyword">null</span> ?</span><br><span class="line">                    deleteNode.rightChild : deleteNode.leftChild;</span><br><span class="line">            <span class="keyword">if</span> (deleteNode == root) &#123;</span><br><span class="line">                <span class="comment">// 如果被删除节点就是root，那么将其唯一子节点设置为root</span></span><br><span class="line">                root = deleteNodeChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的左子节点，则将父节点的左子节点关联置为被删除节点的唯一子节点</span></span><br><span class="line">                parentNode.leftChild = deleteNodeChild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果要删除的叶子节点为父节点的右子节点，则将父节点的右子节点关联置为被删除节点的唯一子节点</span></span><br><span class="line">                parentNode.rightChild = deleteNodeChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 中序遍历 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node targetNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (targetNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的左子节点</span></span><br><span class="line">            inOrder(targetNode.leftChild);</span><br><span class="line">            <span class="comment">// 访问目标节点本身</span></span><br><span class="line">            System.out.print(targetNode.key + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的右子节点</span></span><br><span class="line">            inOrder(targetNode.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 前序遍历 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node targetNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (targetNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 访问目标节点本身</span></span><br><span class="line">            System.out.print(targetNode.key + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的左子节点</span></span><br><span class="line">            preOrder(targetNode.leftChild);</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的右子节点</span></span><br><span class="line">            preOrder(targetNode.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 后续遍历 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node targetNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (targetNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的左子节点</span></span><br><span class="line">            postOrder(targetNode.leftChild);</span><br><span class="line">            <span class="comment">// 递归遍历目标节点的右子节点</span></span><br><span class="line">            postOrder(targetNode.rightChild);</span><br><span class="line">            <span class="comment">// 访问目标节点本身</span></span><br><span class="line">            System.out.print(targetNode.key + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找中序后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getSuccessor</span><span class="params">(Node deleteNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暂存中序后继节点的父节点</span></span><br><span class="line">        Node successorParent = deleteNode;</span><br><span class="line">        <span class="comment">// 暂存中序后继节点</span></span><br><span class="line">        Node successor = deleteNode;</span><br><span class="line">        <span class="comment">// 先从删除节点的右子节点开始查找</span></span><br><span class="line">        Node currentNode = deleteNode.rightChild;</span><br><span class="line">        <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            successorParent = successor;</span><br><span class="line">            successor = currentNode;</span><br><span class="line">            <span class="comment">// 一直往下查找当前节点的左子节点，直到为空</span></span><br><span class="line">            currentNode = currentNode.leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如上面文章所说，中序后继节点和删除节点有两种可能性，</span></span><br><span class="line">        <span class="comment">// 当中序后继节点不是删除节点的右子节点时，需要做如下额外操作</span></span><br><span class="line">        <span class="keyword">if</span> (successor != deleteNode.rightChild) &#123;</span><br><span class="line">            <span class="comment">// 如果中序后继节点的右子节点不为空的话，将其和中序后继节点父节点的左子节点挂钩</span></span><br><span class="line">            <span class="keyword">if</span> (successor.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">                successorParent.leftChild = successor.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 中序后继节点的右子节点和删除节点的右子节点挂钩</span></span><br><span class="line">            successor.rightChild = deleteNode.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中序后继节点的左子节点和删除节点的左子节点挂钩</span></span><br><span class="line">        successor.leftChild = deleteNode.leftChild;</span><br><span class="line">        <span class="comment">// 剩下的删除节点的父节点和中序后继节点的连接关系在删除方法里处理，</span></span><br><span class="line">        <span class="comment">// 因为这个方法内无法获取删除节点的父节点对象</span></span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 关键字</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 额外携带的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String value;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 左子节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node leftChild;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 右子节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node rightChild;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BST效率"><a href="#BST效率" class="headerlink" title="BST效率"></a>BST效率</h3><p>节点的查找需要从根节点开始一层一层往下找，树节点数和层数的关系如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">节点数</th>
<th align="left">层数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">1023</td>
<td align="left">10</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">32767</td>
<td align="left">15</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">1048575</td>
<td align="left">20</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">33554432</td>
<td align="left">25</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">1073741824</td>
<td align="left">30</td>
</tr>
</tbody></table>
<p>假设节点数为N，层数为L，那么不难看出它们的关系为：N=2^(L-1)，所以L=log2(N+1)，大约为log2N，大O表示法为O(logN)</p>
<h3 id="BST缺陷"><a href="#BST缺陷" class="headerlink" title="BST缺陷"></a>BST缺陷</h3><p>虽然BST结合了数组和链表的优势，但它也不是完美的，当BST不平衡的时候，查找操作效率急剧下降。举个比较极端的例子：</p>
<p>假如插入的数据是升序数据：2，4，6，8，10，12…，这时候BST如下所示：</p>
<p><img src="/images/BST%E7%BC%BA%E9%99%B7.png"></p>
<p>这时候BST实际上就是一个链表结构了，搜索效率为O(N)。一个BST完全平衡和完全不平衡的情况比较少见，就概率来说，BST的搜索效率介于O(N)与O(logN)之间</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>为了解决非平衡树搜索效率下降的问题，人们又提出了红黑树的概念。在红黑树中，每个节点要么是红色的要么是黑色的，红黑树在插入和删除的过程中，需要遵循某些特定的规则，遵循这些规则可以确保数始终是趋于平衡的。</p>
<p>红黑树除了遵循基本的BST规则外，还需遵循以下4个规则：</p>
<ol>
<li>每一个节点不是红色就是黑色；</li>
<li>根节点一定是黑色的；</li>
<li>如果节点时红色的，那么它的子节点必须都是黑色的；</li>
<li>从根节点到叶子节点或空子节点的每条路径，必须包含相同数目的黑色节点。</li>
</ol>
<p>在数据插入和删除过程中，如果违背了上述4个规则，则树会执行以下操作进行修正，以重新满足上述4个规则：</p>
<ol>
<li>改变节点的颜色；</li>
<li>执行旋转操作。</li>
</ol>
]]></content>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Linux命令</title>
    <url>/2020/03/19/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>为了今后学习更复杂的知识，打算先分类地逐步掌握这些基础的Linux命令，命令内容分类：系统工作、系统状态、工作目录、文件、打包压缩、搜索等。</p>
<span id="more"></span>

<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">命令名称 [命令参数] [命令对象]</span><br></pre></td></tr></table></figure>

<p>命令参数的长格式和短格式(举例说明)：</p>
<ul>
<li>man –help</li>
<li>man -h</li>
</ul>
<p>命令参数的合并规则：</p>
<ul>
<li>长格式和长格式间不能合并</li>
<li>长格式和短格式间不能合并</li>
<li>短格式和短格式间可以合并，如 wget -r -p  可以合并成 wget -rp</li>
</ul>
</blockquote>
<h3 id="常用系统工作命令"><a href="#常用系统工作命令" class="headerlink" title="常用系统工作命令"></a>常用系统工作命令</h3><blockquote>
<h4 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h4><p>重启计算机</p>
<h4 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h4><p>关机</p>
<h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><p>echo命令用于在终端输出字符串或变量提取后的值，格式为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">echo</span> [字符串|$变量]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">echo</span> dougWilson</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span></span><br></pre></td></tr></table></figure>

<h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><p>date命令用于显示和设置系统的时间及日期，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">显示当前时间：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">date</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">按指定格式显示时间：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">date <span class="string">&quot;+%Y-%m-%d %H:%M:%S&quot;</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">设置系统当前时间：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">date -s <span class="string">&quot;20200518 8:30:00&quot;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="ping-traceroute-netstat"><a href="#ping-traceroute-netstat" class="headerlink" title="ping traceroute netstat"></a>ping traceroute netstat</h4><ul>
<li>ping 向网络主机发送特殊数据包</li>
<li>traceroute 跟踪网络数据包的传输路径</li>
<li>netstat 检查网络设置及相关统计数据</li>
</ul>
<p>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">ping url</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">traceroute url</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">netstat [参数]</span></span><br></pre></td></tr></table></figure>

<h4 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h4><p>wget命令用于在终端中下载网络文件，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">wget [参数] 下载地址</span></span><br></pre></td></tr></table></figure>

<p>参数：</p>
<table>
<thead>
<tr>
<th>-b</th>
<th>后台下载模式</th>
</tr>
</thead>
<tbody><tr>
<td>-p</td>
<td>下载页面所有资源</td>
</tr>
<tr>
<td>-P</td>
<td>下载到指定目录</td>
</tr>
<tr>
<td>-t</td>
<td>最大尝试次数</td>
</tr>
<tr>
<td>-c</td>
<td>断点续传</td>
</tr>
<tr>
<td>-r</td>
<td>递归下载</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">wget http://www.dougwilson.com/file/linux.pdf</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">wget -pr http://www.dougwilson.com</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="系统状态检测命令"><a href="#系统状态检测命令" class="headerlink" title="系统状态检测命令"></a>系统状态检测命令</h3><blockquote>
<h4 id="who"><a href="#who" class="headerlink" title="who"></a>who</h4><p>who命令用于查看当前登入主机的用户信息</p>
<h4 id="last"><a href="#last" class="headerlink" title="last"></a>last</h4><p>last命令用于查看所有系统的登录记录</p>
<h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><p>history命令用于显示历史执行过的命令，格式为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">history -c</span><br></pre></td></tr></table></figure>

<h4 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h4><p>ifconfig命令用于获取网卡配置与网络状态等信息，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig [网络设备] [参数]</span><br><span class="line">如：</span><br><span class="line">ifconfig 查看本机当前网卡配置与网络状态等信息</span><br><span class="line">		inet 192.168.125.129  netmask 255.255.255.0  broadcast 192.168.125.255</span><br><span class="line">        inet6 fe80::2726:fb6f:db31:6505  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:d1:76:ad  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 175  bytes 42815 (42.8 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 154  bytes 20761 (20.7 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">        device interrupt 19  base 0x2000  </span><br><span class="line">inet为IPV4的IP地址</span><br><span class="line">inet6为IPV6的IP地址</span><br><span class="line">ether为网卡硬件地址，即MAC地址</span><br></pre></td></tr></table></figure>

<h4 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h4><p>uname命令用于查看系统内核与系统版本信息，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname [-a]</span><br><span class="line">如：</span><br><span class="line">uname</span><br><span class="line">uname -a</span><br></pre></td></tr></table></figure>

<h4 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h4><p>uptime命令用于查看系统负载信息</p>
<h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>free命令用于显示当前系统中内存的使用量信息，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">free [-h]</span><br><span class="line">如：</span><br><span class="line">free</span><br><span class="line">free -h</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="工作目录切换命令"><a href="#工作目录切换命令" class="headerlink" title="工作目录切换命令"></a>工作目录切换命令</h3><blockquote>
<h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>pwd命令用于显示当前所处工作目录</p>
<h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p>cd命令用于切换工作路径，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd [目录名称]</span><br><span class="line">如：</span><br><span class="line">cd /etc  切换到etc目录</span><br><span class="line">cd -     返回上一次所处目录</span><br><span class="line">cd ~     返回到用户的家目录</span><br><span class="line">cd ..    返回到上级目录</span><br></pre></td></tr></table></figure>

<h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>ls命令用于显示目录中的文件信息，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls [选项] [文件]</span><br><span class="line">如：</span><br><span class="line">ls -a</span><br><span class="line">ls -l</span><br><span class="line">ls -al</span><br><span class="line">ls -a /usr</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<table>
<thead>
<tr>
<th>短格式</th>
<th>长格式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>–all</td>
<td>列出所有文件，包含隐藏文件</td>
</tr>
<tr>
<td>-d</td>
<td>–directory</td>
<td>与-l选项结合使用，用于查看目录的详细信息而不是目录中的内容</td>
</tr>
<tr>
<td>-F</td>
<td>–classify</td>
<td>在每个列出的名字后面加上类型指示符(比如，如果为目录名称，则会加上\)</td>
</tr>
<tr>
<td>-h</td>
<td>–human-readable</td>
<td>以可读的方式显示文件大小，而不是以字节的方式</td>
</tr>
<tr>
<td>-l</td>
<td></td>
<td>以长格式显示结果</td>
</tr>
<tr>
<td>-r</td>
<td>–reverse</td>
<td>以相反的顺序显示结果</td>
</tr>
<tr>
<td>-S</td>
<td></td>
<td>按文件大小对结果进行排序</td>
</tr>
<tr>
<td>-t</td>
<td></td>
<td>按修改时间排序</td>
</tr>
</tbody></table>
<h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><p>file命令可以帮助我们确定文件类型，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file filename</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ file Documents</span><br><span class="line">Documents: directory</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="文件目录管理命令"><a href="#文件目录管理命令" class="headerlink" title="文件目录管理命令"></a>文件目录管理命令</h3><blockquote>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>由于shell经常使用文件名，因此提供了一些特殊字符来快速指定一组文件名，这些符号称为通配符：</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>匹配项</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配任意多个字符(包括0个和1个)</td>
</tr>
<tr>
<td>？</td>
<td>匹配任一单个字符(不包括0个)</td>
</tr>
<tr>
<td>[characters]</td>
<td>匹配任意一个属于字符集中的字符</td>
</tr>
<tr>
<td>[!characters]</td>
<td>匹配任意一个不属于字符集中的字符</td>
</tr>
<tr>
<td>[[:class:]]</td>
<td>匹配任意一个属于指定<strong>字符类</strong>中的字符</td>
</tr>
</tbody></table>
<p>对于字符类，常用的如下：</p>
<table>
<thead>
<tr>
<th>字符类</th>
<th>匹配项</th>
</tr>
</thead>
<tbody><tr>
<td>[:alnum:]</td>
<td>匹配任意一个字母或数字</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>匹配任意一个字母</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>匹配任意一个数字</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>匹配任意一个小写字母</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>匹配任意一个大写字母</td>
</tr>
</tbody></table>
<p>常用匹配内容：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>匹配项</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>所有文件</td>
</tr>
<tr>
<td>g*</td>
<td>以g开头的任一文件</td>
</tr>
<tr>
<td>b*.txt</td>
<td>以b开头，并以.txt结尾的任一文件</td>
</tr>
<tr>
<td>Data???</td>
<td>以Data开头，后面跟3个字符的任一文件</td>
</tr>
<tr>
<td>[abc]*</td>
<td>以abc中任一一个字符开头的任一文件</td>
</tr>
<tr>
<td>BACKUP.[0-9][0-9]</td>
<td>以BACKUP.开头，后面紧跟2个数字的任一文件</td>
</tr>
<tr>
<td>[[:upper:]]*</td>
<td>以大写字母开头的任一文件</td>
</tr>
<tr>
<td>[![:digit:]]*</td>
<td>不以数字开头的任一文件</td>
</tr>
<tr>
<td>*[[:lower:]123]</td>
<td>以小写字母或数字123中任一一个结尾的任一文件</td>
</tr>
</tbody></table>
<h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>mkdir命令用于创建空文件目录，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">mkdir [选项] 目录名</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">mkdir doug   在当前目录下创建目录doug</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">mkdir -p a/b/c  在当前目录下创建递归目录</span></span><br></pre></td></tr></table></figure>

<h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>cp目录用于复制文件或目录，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">cp [选项] 源文件 目标文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">将单个文件或目录复制到另一个文件或目录中：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">cp item1 item2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">将多个文件或目录复制到另一个目录中：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">cp item... directory</span></span><br></pre></td></tr></table></figure>

<p>常用选项及示例：</p>
<table>
<thead>
<tr>
<th>短格式</th>
<th>长格式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>–archive</td>
<td>复制文件和目录及其属性，具有所有权限</td>
</tr>
<tr>
<td>-i</td>
<td>–interactive</td>
<td>覆盖一个文件前，提示用户进行确认。如果没有该选项，cp会默认覆盖文件</td>
</tr>
<tr>
<td>-r</td>
<td>–recursive</td>
<td>递归地复制目录及其内容，复制目录时需要该选项或-a选项</td>
</tr>
<tr>
<td>-u</td>
<td>–update</td>
<td>将一个文件从一个目录复制到另一个目录时，只会复制那些目标目录不存在的文件或是相应的更新文件</td>
</tr>
<tr>
<td>-v</td>
<td>–verbose</td>
<td>复制文件时，显示信息</td>
</tr>
</tbody></table>
<h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>mv命令用于剪切或重命名文件，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">mv [选项] 源文件 目标文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">将单个文件或目录剪切到另一个文件或目录中：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">mv item1 item2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">将多个文件或目录剪切到另一个目录中：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">cp item... directory</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">重命名</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">mv item1 item2</span></span><br></pre></td></tr></table></figure>

<p>mv用法和cp用法基本相似</p>
<h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>rm命令用于删除文件或目录，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">rm [选项] 文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">rm item</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">rm item1 item2 item3</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">rm -r directory 递归删除目录中的文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">rm -i item  删除文件或目录前进行询问</span></span><br></pre></td></tr></table></figure>

<p>注意，Linux系统并不包含还原删除操作的命令，一旦使用rm命令，就彻底删除了。</p>
<h4 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h4><p>ln命令用于创建硬链接和符号链接，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">ln file link 创建硬链接</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ln -s item link 创建符号链接</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ln /etc/passwd passwd-hard  在当前目录中创建一个硬链接指向/etc/passwd</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ln /etc/passwd dir1/passwd-hard  在dir1目录中创建一个硬链接指向/etc/passwd</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ln -s /etc/passwd passwd-hard  在当前目录中创建一个符号链接</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ln -s /etc/passwd dir1/passwd-hard  在dir1目录中创建一个符号链接</span></span><br></pre></td></tr></table></figure>

<p>这里解释一下硬链接和符号链接：</p>
<h5 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h5><p>硬链接是UNIX系统最初用来创建链接的方式。默认情况下，每个文件都有一个硬链接，该硬链接会给文件起名字。当为一个文件创建一个硬链接时，也为这个文件创建了一个额外的目录条目。总而言之，创建硬链接时，实际上是创建了文件的额外名称，这些名称都指向同一数据部分。（文件由两部分组成：包含文件内容的数据部分和包含文件名的名称部分。系统分配一系列盘块给索引节点，这些节点与文件名称部分建立关联，然后指向文件内容。而创建一个硬链接相当于创建索引节点，因此，创建硬链接实际上是创建文件的额外名称，其所在索引节点指向文件的数据部分。）</p>
<p>硬链接的局限性为：</p>
<ol>
<li>硬链接不能引用与该链接不在同一磁盘分区的文件</li>
<li>硬链接无法引用目录</li>
</ol>
<p>当文件的一个硬链接删除时，只是删除了这个链接，但是文件内容依然存在。除非文件所有的链接都被删除，则文件空间会被释放。</p>
<h5 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h5><p>符号链接克服了硬链接的局限性，通过创建一个特殊类型的文件，该文件包含指向文件或目录的文本指针，类似于windows的快捷方式。</p>
<p>当删除一个符号链接时，删除的只是符号链接没有删除文件。如果在符号链接删除前删除文件，那么这个符号链接依然存在，只不过不指向任何一个文件，此时的链接称为坏链接。</p>
<p>符号链接是一种特殊类型的文件，包含了指向目标文件或目录的文本指针。</p>
</blockquote>
<h3 id="文本文件编辑命令"><a href="#文本文件编辑命令" class="headerlink" title="文本文件编辑命令"></a>文本文件编辑命令</h3><blockquote>
<h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><p>less命令用于查看文本文件，如PDF，txt等。less为我们查看文件提供了方便。格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">less filename</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">less howTomcatWork.pdf</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">然后可以通过滚轮或page up/page down方向键进行阅读</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">Q键退出阅读</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">G键  大写G跳到文本末尾  小写g跳到文本开头</span></span><br></pre></td></tr></table></figure>

<h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h4><p>stat命令用于查看文件的具体存储信息和时间等信息，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">stat</span> filename</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">stat</span> howTomcatWork.pdf</span></span><br></pre></td></tr></table></figure>

<h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><p>wc命令用于统计指定文本的行数、字数、字节数，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">wc [参数] 文本</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">dougwilson@doug:~$ wc howTomcatWork.pdf</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">64090   342871 17676281 howTomcatWork.pdf</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="重定向命令"><a href="#重定向命令" class="headerlink" title="重定向命令"></a>重定向命令</h3><blockquote>
<p>重定向可以将命令行的输入，重定向为从文件获取内容。也可以将命令行的输出，重定向到文件中。甚至可以利用重定向将多个命令行关联起来，形成管道。</p>
<h5 id="标准输入、标准输出、标准错误"><a href="#标准输入、标准输出、标准错误" class="headerlink" title="标准输入、标准输出、标准错误"></a>标准输入、标准输出、标准错误</h5><p>输出通常为两种类型：一种为程序运行的结果，即该程序生成的数据。另一种为状态和错误信息，表示程序当前的运行情况。</p>
<p>与UNIX”一切都是文件”的思想一致，类似于 <code>ls</code> 的程序实际上会将它们的运行结果发送到一个称为标准输出（standard output，通常表示为 stdout）的特殊文件中，它们的状态信息则发送到另一个称为标准错误（standard error，通常表示为stderr）的文件中。默认情况下，标准输出和标准错误都将被链接到屏幕上，而不会被保存在磁盘文件中。</p>
<p>而标准输入则是许多程序从一个称为标准输入（standard input，表示为 stdin）的设备得到输入。默认情况下，标准输入连接到键盘。</p>
<h4 id="gt"><a href="#gt" class="headerlink" title="&gt;"></a>&gt;</h4><p>&gt;命令为标准输出重定向命令，用于将标准输出重定向到指定位置，格式为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">[<span class="built_in">command</span>] &gt; filename 将标准输出重定向到另外一个文件中，覆盖原来的内容</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">[<span class="built_in">command</span>] &gt;&gt; filename 将标准输出重定向到另外一个文件中，在原来的内容上进行内容的追加</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt; filename 删除一个文件的文件内容，或者创建一个新的空文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ls -l /usr/bin &gt; ls-output.txt  将ls命令的输出重定向到ls-output.txt文件中保存，而不是输出到屏幕上</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ls -l /usr/bin &gt;&gt; ls-output.txt 将ls命令输出追加到ls-output.txt文件中</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt; ls-output.txt 清空ls-output.txt文件内容</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如果我们尝试访问一个不存在的目录或文件，则会产生错误信息：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">dougwilson@doug:~$ ls -l /bin/usr &gt; ls-output.txt</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ls: cannot access <span class="string">&#x27;/bin/usr&#x27;</span>: No such file or directory</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">但这个错误信息并不会输出到ls-output.txt文件，而是显示到屏幕上。这就涉及到上面说的，输出有两个类型，标准输出，标准错误。当产生错误时，错误信息会输入到标准错误的文件中，而&gt;命令只会重定向标准输出文件，而标准错误的文件内容依然是重定向到屏幕进行输出。如何进行标准错误的重定向？</span></span><br></pre></td></tr></table></figure>

<h4 id="标准错误重定向"><a href="#标准错误重定向" class="headerlink" title="标准错误重定向"></a>标准错误重定向</h4><p>标准错误重定向并不能简单地用一个专用的重定向符号来实现，需要用到文件描述符。</p>
<p>一个程序可以将生成的输出内容发送到任意的文件流中，文件流的前3个对应标准输入文件，标准输出文件和标准错误文件，分别用文件描述符0，1，2描述。因此，标准错误等同于文件描述符2，所以可以用如下写法完成上面的标准错误的重定向：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">ls -l /bin/usr 2&gt; ls-error.txt</span></span><br></pre></td></tr></table></figure>

<h4 id="标准输出和标准错误重定向到同一个文件"><a href="#标准输出和标准错误重定向到同一个文件" class="headerlink" title="标准输出和标准错误重定向到同一个文件"></a>标准输出和标准错误重定向到同一个文件</h4><p>还是上面的例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1</span></span><br></pre></td></tr></table></figure>

<p>该操作执行了两个重定向操作。首先是将标准输出重定向到 <code>ls-output.txt</code> 文件中，然后使用标记符 <code>2&gt;&amp;1</code> 将标准错误重定向到标准输出中。</p>
<p>注意，标准错误的重定向在标准输出重定向之后，该顺序是不能颠倒的，必须严格遵守，否则将不起作用。比如，如果将上面的顺序改为 <code>ls -l /bin/usr 2&gt;&amp;1&gt; ls-output.txt</code> ，那么标准错误将会重定向到屏幕上。</p>
<h4 id="位桶-dev-null"><a href="#位桶-dev-null" class="headerlink" title="位桶/dev/null"></a>位桶/dev/null</h4><p>用于接受输入但是不对输入进行任何处理。</p>
<p>还是上面的例子，我们隐藏错误信息，不在屏幕显示，也不重定向到文件中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">ls -l /bin/usr 2&gt; /dev/null</span></span><br></pre></td></tr></table></figure>

<h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>cat命令用于读取一个或多个文件，并将它们复制到标准输出文件中，在屏幕上进行显示，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">cat [file...]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">cat ls-output.txt ls-error.txt</span></span><br></pre></td></tr></table></figure>

<p>cat命令也常用于重定向。因为cat命令可以接受多个文件作为输入参数，因此可以通过重定向将已经被拆分的多个部分合在一起还原成原来的文件。比如：movie.avi.000 movie.avi.001  ……  movie.avi.066</p>
<p>则可以使用cat命令将这些部分通过重定向拼接在一起还原文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">cat movie.avi.0* &gt; movie.avi</span></span><br></pre></td></tr></table></figure>

<p>如果cat命令缺少文件参数，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">cat</span></span><br></pre></td></tr></table></figure>

<p>那么它就和标准输入——键盘建立连接。可以在屏幕中输入字符，并以<kbd>ctrl</kbd>+<kbd>D</kbd>结束输入。如果要将标准输入重定向到文件中，也是可以：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">cat &gt; cat-input.txt</span></span><br></pre></td></tr></table></figure>

<h4 id="管道"><a href="#管道" class="headerlink" title="管道 |"></a>管道 |</h4><p>管道命令 | 可以将一个命令的标准输出传送到另一个命令的标准输入中，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">command1 | command2 | <span class="built_in">command</span>...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ls . /usr/<span class="built_in">local</span> | less</span></span><br></pre></td></tr></table></figure>

<h4 id="过滤器命令-sort-uniq-wc-grep-head-tail-tee"><a href="#过滤器命令-sort-uniq-wc-grep-head-tail-tee" class="headerlink" title="过滤器命令 sort uniq wc grep head tail tee"></a>过滤器命令 sort uniq wc grep head tail tee</h4><p>通常而言，我们会对改变数据的显示方式，比如排序，过滤重复行，等等。此时的管道就通常别称为过滤器，而使用的命令就称为过滤器命令。常用过滤器命令：</p>
<ul>
<li><strong>sort</strong> 对标准输入进行排序</li>
<li><strong>uniq</strong> 忽略或查看文件中的重复行</li>
<li><strong>wc</strong> 打印行数、字数、字节数</li>
<li><strong>grep</strong> 打印匹配行</li>
<li><strong>head/tail</strong> 打印文件的开头部分/结尾部分</li>
<li><strong>tee</strong> 从标准输入读取数据，并同时输出到标准输出或文件中</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">ls . /usr/<span class="built_in">local</span> | sort | less 将两个目录的文件名进行排序，从而产生一个排好序的列表</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ls . /usr/<span class="built_in">local</span> | sort | uniq | less 删除了列表的重复行，确保列表没有重复行</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ls . /usr/<span class="built_in">local</span> | sort | uniq -d | less 查看列表的重复行</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ls . /usr/<span class="built_in">local</span> | sort | uniq | wc 查看排好序列表的行数、子数、字节数</span></span><br></pre></td></tr></table></figure>

<p>grep是一个强大的命令，用于在文件中查找匹配文本，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">grep pattern [file...]   pattern的内容为正则表达式</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ls . /usr/<span class="built_in">local</span> | sort | uniq | grep zip  搜索文件名包含zip的所有文件</span></span><br></pre></td></tr></table></figure>

<p>head/tail用于在不需要输出所有内容时，只显示开头几行或结尾几行，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">head -n lines filename   显示filename的开头lines行</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">tail -n lines filename   显示filename的结尾lines行</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">head -n 10 ls-output.txt  显示ls-output.txt文件的开头10行</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">应用在管道中：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ls . /usr/<span class="built_in">local</span> | sort | uniq | tail -n 5</span></span><br></pre></td></tr></table></figure>

<p>tail中有一个选项 <code>-f</code> 可以用于实时查看文件，该选项在观察正在被写入的日志文件的进展状态很有用。使用该选项后，tail将持续监视文件，一旦添加新行，新行会立即显示在屏幕上，直到<kbd>Ctrl</kbd>+<kbd>C</kbd>按下后停止。格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">tail -f filename</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">比如经常用该命令查看messages文件：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">tail -f /var/<span class="built_in">log</span>/messages</span></span><br></pre></td></tr></table></figure>

<p>tee类似于“分流”的效果，用于将读取的标准输入复制到标准输出或若干个文件中去（即允许数据继续向下传递到管道中）。比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">ls /usr/bin | tee ls-tee.txt | grep zip</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">在grep过滤管道内容前，通过tee命令先将内容输出到ls-tee.txt文件中，然后才传递给grep命令进行过滤</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><blockquote>
<p>bash再执行命令前会对文本进行多重处理，使得文本在执行前被扩展成其他内容，这个结果产生的过程就被称为扩展。</p>
<h4 id="路径名扩展-通配符"><a href="#路径名扩展-通配符" class="headerlink" title="路径名扩展(通配符*)"></a>路径名扩展(通配符*)</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo *</span><br><span class="line">echo D*</span><br><span class="line">echo *s</span><br><span class="line">echo [[:upper:]]*</span><br><span class="line">echo /usr/*/share</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ *</span><br><span class="line">cat-input.txt: command not found</span><br><span class="line">dougwilson@doug:~$ echo *</span><br><span class="line">cat-input.txt Desktop Documents Downloads less LinuxProbe.pdf ls-error.txt ls-output.txt Music Pictures Public Templates Videos</span><br><span class="line">dougwilson@doug:~$ echo D*</span><br><span class="line">Desktop Documents Downloads</span><br><span class="line">dougwilson@doug:~$ echo *s</span><br><span class="line">Documents Downloads less Pictures Templates Videos</span><br><span class="line">dougwilson@doug:~$ echo /usr/*/share</span><br><span class="line">/usr/local/share</span><br><span class="line">dougwilson@doug:~$ echo [[:upper:]]*</span><br><span class="line">Desktop Documents Downloads LinuxProbe.pdf Music Pictures Public Templates Videos</span><br></pre></td></tr></table></figure>

<h4 id="波浪线扩展-波浪符"><a href="#波浪线扩展-波浪符" class="headerlink" title="波浪线扩展(波浪符~)"></a>波浪线扩展(波浪符~)</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo ~</span><br><span class="line">echo ~用户名</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ echo ~</span><br><span class="line">/home/dougwilson</span><br><span class="line">dougwilson@doug:~$ echo ~dougwilson</span><br><span class="line">/home/dougwilson</span><br></pre></td></tr></table></figure>

<h4 id="算术扩展-美元符"><a href="#算术扩展-美元符" class="headerlink" title="算术扩展(美元符$)"></a>算术扩展(美元符$)</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">格式为：  $((experssion))</span><br><span class="line">echo $((2+2))</span><br><span class="line">echo $((2*2))</span><br><span class="line">echo $((2%2))</span><br><span class="line">echo $(($((2*2))*2))</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ echo $((2+2))</span><br><span class="line">4</span><br><span class="line">dougwilson@doug:~$ echo $((2*2))</span><br><span class="line">4</span><br><span class="line">dougwilson@doug:~$ echo $((2%2))</span><br><span class="line">0</span><br><span class="line">dougwilson@doug:~$ echo $(($((2*2))*2))</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<h4 id="花括号扩展-花括号"><a href="#花括号扩展-花括号" class="headerlink" title="花括号扩展(花括号{})"></a>花括号扩展(花括号{})</h4><p>可以通过花括号的模式创建多种文本字符串，括号中的模式不能包含内嵌的空白：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo Front-&#123;A,B,C&#125;-Back</span><br><span class="line">echo Number_&#123;1..5&#125;   ..表示区间连续</span><br><span class="line">echo a&#123;A&#123;1,2&#125;,B&#123;3,4&#125;&#125;b</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ echo Front-&#123;A,B,C&#125;-Back</span><br><span class="line">Front-A-Back Front-B-Back Front-C-Back</span><br><span class="line">dougwilson@doug:~$ echo Number_&#123;1..5&#125;</span><br><span class="line">Number_1 Number_2 Number_3 Number_4 Number_5</span><br><span class="line">dougwilson@doug:~$ echo a&#123;A&#123;1,2&#125;,B&#123;3,4&#125;&#125;b</span><br><span class="line">aA1b aA2b aB3b aB4b</span><br></pre></td></tr></table></figure>

<p>花括号扩展经常用于创建一系列目录。比如存放日志的目录，你希望日志按照时间进行存储，那么就可以按如下方式创建一系列目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir logDir</span><br><span class="line">cd logDir</span><br><span class="line">mkdir &#123;2020..2021&#125;-0&#123;1..9&#125; &#123;2020..2021&#125;-&#123;10..12&#125;</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ mkdir logDir</span><br><span class="line">dougwilson@doug:~$ cd logDir</span><br><span class="line">dougwilson@doug:~/logDir$ mkdir &#123;2020..2021&#125;-0&#123;1..9&#125; &#123;2020..2021&#125;-&#123;10..12&#125;</span><br><span class="line">dougwilson@doug:~/logDir$ ls</span><br><span class="line">2020-01  2020-04  2020-07  2020-10  2021-01  2021-04  2021-07  2021-10</span><br><span class="line">2020-02  2020-05  2020-08  2020-11  2021-02  2021-05  2021-08  2021-11</span><br><span class="line">2020-03  2020-06  2020-09  2020-12  2021-03  2021-06  2021-09  2021-12</span><br></pre></td></tr></table></figure>

<h4 id="参数扩展-变量"><a href="#参数扩展-变量" class="headerlink" title="参数扩展(变量)"></a>参数扩展(变量)</h4><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">格式为：   <span class="variable">$变</span>量名</span><br><span class="line">echo <span class="variable">$USER</span></span><br><span class="line">echo <span class="variable">$SHELL</span></span><br><span class="line">printenv | less  查看可用变量名</span><br><span class="line">如：</span><br><span class="line">dougwilson<span class="variable">@doug</span><span class="symbol">:~/logDir</span><span class="variable">$ </span>echo <span class="variable">$USER</span></span><br><span class="line">dougwilson</span><br><span class="line">dougwilson<span class="variable">@doug</span><span class="symbol">:~/logDir</span><span class="variable">$ </span>echo <span class="variable">$SHELL</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h4><p>将一个命令的输出结果作为一个扩展模式使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">格式为：  $(command expression)</span><br><span class="line">echo $(ls)</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ ls</span><br><span class="line">cat-input.txt  Downloads       logDir         Music     Templates</span><br><span class="line">Desktop        less            ls-error.txt   Pictures  Videos</span><br><span class="line">Documents      LinuxProbe.pdf  ls-output.txt  Public</span><br><span class="line">dougwilson@doug:~$ echo $(ls)</span><br><span class="line">cat-input.txt Desktop Documents Downloads less LinuxProbe.pdf logDir ls-error.txt ls-output.txt Music Pictures Public Templates Videos</span><br></pre></td></tr></table></figure>

<h4 id="避免扩展-双引号和单引号"><a href="#避免扩展-双引号和单引号" class="headerlink" title="避免扩展(双引号和单引号)"></a>避免扩展(双引号和单引号)</h4><p>可以通过控制扩展(引用机制)来有选择性地避免不想要的扩展：</p>
<p>先来看一组内容，务必区分：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo The total is $100.00</span><br><span class="line">echo The total is $100</span><br><span class="line">echo The total is $price:100.00</span><br><span class="line">echo The total is $100price</span><br><span class="line">上面几个结果是完全不同的：</span><br><span class="line">dougwilson@doug:~$ echo The total is $100.00</span><br><span class="line">The total is 00.00</span><br><span class="line">dougwilson@doug:~$ echo The total is $100</span><br><span class="line">The total is 00</span><br><span class="line">dougwilson@doug:~$ echo The total is $price:100.00</span><br><span class="line">The total is :100.00</span><br><span class="line">dougwilson@doug:~$ echo The total is $100price</span><br><span class="line">The total is 00price</span><br><span class="line">dougwilson@doug:~$ echo The total is $p100rice</span><br><span class="line">The total is</span><br><span class="line">说明，当$后是一个数字时，则会寻找该数字对应的变量。当$后是一个字符时，则会将寻找$后字符串</span><br></pre></td></tr></table></figure>

<h4 id="双引号控制扩展"><a href="#双引号控制扩展" class="headerlink" title="双引号控制扩展"></a>双引号控制扩展</h4><p>双引号控制扩展，除了：</p>
<ul>
<li>美元符号 $</li>
<li>反斜杠  \</li>
<li>反引号  ‘</li>
</ul>
<p>之外，其他在双引号中的特殊字符都将失去其特殊意义。这意味着：单词扩展、路径名扩展、波浪线扩展、花括号扩展都将失效。</p>
<p>此外，双引号可用阻止单词分割，使得文件名可以包含空白符：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ <span class="keyword">ls</span> -<span class="keyword">l</span> <span class="keyword">two</span> words.txt</span><br><span class="line"><span class="keyword">ls</span>: cannot access &#x27;<span class="keyword">two</span>&#x27;: <span class="keyword">No</span> such <span class="keyword">file</span> or directory</span><br><span class="line"><span class="keyword">ls</span>: cannot access &#x27;words.txt&#x27;: <span class="keyword">No</span> such <span class="keyword">file</span> or directory</span><br><span class="line">dougwilson@doug:~$ <span class="keyword">ls</span> -<span class="keyword">l</span> <span class="string">&quot;two words.txt&quot;</span></span><br><span class="line"><span class="keyword">ls</span>: cannot access &#x27;<span class="keyword">two</span> words.txt&#x27;: <span class="keyword">No</span> such <span class="keyword">file</span> or directory</span><br></pre></td></tr></table></figure>

<p>默认清空下，单词分割会先查找是否存在空格、制表符以及换行符，然后把它们当作单词的界定符。这意味着，如果没有双引号包起来的空格、制表符和换行符，都不会被当作文本的一部分，而只是被当成分隔符。</p>
<p>但是如果加上双引号，单词分割功能将失效，嵌入的空格不再被当成界定符，而是被当作参数的一部分。</p>
<h4 id="单引号控制扩展"><a href="#单引号控制扩展" class="headerlink" title="单引号控制扩展"></a>单引号控制扩展</h4><p>单引号可以抑制所有的扩展。举例说明：不控制扩展，使用双引号控制扩展，使用单引号控制扩展的区别：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ echo text ~/*.txt &#123;a,b&#125; $(echo dougwilson) $((2+2)) $USER</span><br><span class="line">text /home/dougwilson/cat-input.txt /home/dougwilson/ls-error.txt /home/dougwilson/ls-output.txt a b dougwilson 4 dougwilson</span><br><span class="line">dougwilson@doug:~$ echo &quot;text ~/*.txt &#123;a,b&#125; $(echo dougwilson) $((2+2)) $USER&quot;</span><br><span class="line">text ~/*.txt &#123;a,b&#125; dougwilson 4 dougwilson</span><br><span class="line">dougwilson@doug:~$ echo &#x27;text ~/*.txt &#123;a,b&#125; $(echo dougwilson) $((2+2)) $USER&#x27;</span><br><span class="line">text ~/*.txt &#123;a,b&#125; $(echo dougwilson) $((2+2)) $USER</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><blockquote>
<p>UNIX操作系统是多用户系统，意味着同一时间内可以有多个用户使用同一台计算机。比如，如果计算机连接到一个网络或者互联网中，远程用户可以通过SSH登录并操作这台计算机。</p>
<p>这和早期的计算机发展有关。在个人计算机普遍之前，计算机普遍为体积大，价格昂贵的系统。比如，一个典型的校园计算机系统，是由一台在某建筑里面的超大型计算机和遍布校园的多台终端组成的，每台终端都连接到中央计算机上。为了包证多用户功能实际可用，系统就设计了一种方案保护当前用户不受其他用户操作的影响。</p>
<p>UNIX安全模型：</p>
<ul>
<li>一个用户可以拥有目录和文件，并对拥有的目录和文件的访问权限具有控制权</li>
<li>用户归属于群组（group），群组由一个用户和多个用户组成</li>
</ul>
<h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>id命令可以获得用户身份标识的相关信息，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ id</span><br><span class="line">uid=1000(dougwilson) gid=1000(dougwilson) groups=1000(dougwilson),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),121(lpadmin),132(lxd),133(sambashare)</span><br></pre></td></tr></table></figure>

<p>在创建用户的账号的时候，用户都会被分配一个用户ID——uid。同时，用户也会被分配一个组ID——gid。一个用户可以属于多个群组。这些信息保存在：</p>
<ul>
<li>用户账号  <code>/etc/passwd</code></li>
<li>用户密码  <code>/etc/shadow</code></li>
<li>用户的组   <code>/etc/group</code></li>
</ul>
<h4 id="文件的读取、写入、执行"><a href="#文件的读取、写入、执行" class="headerlink" title="文件的读取、写入、执行"></a>文件的读取、写入、执行</h4><p>首先查看文件的信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dougwilson@doug:~$ ls -l howTomcatWork.pdf</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 17676281  9月 22  2020 howTomcatWork.pdf</span><br></pre></td></tr></table></figure>

<p>前10个字符。按表示含义分成两组，第1个字符表示文件类型和剩余9个字符表示文件模式(文件所有者，文件所属群组，读取、写入、执行权限)。</p>
<p><strong>第一个字符——文件类型</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>文件类型</th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>普通文件</td>
</tr>
<tr>
<td>d</td>
<td>目录文件</td>
</tr>
<tr>
<td>l</td>
<td>符号链接。对于符号链接文件，剩下9个字符格式是固定的：rwxrwxrwx，它是个伪装属性值，符号链接指向的文件属性才是真正的文件属性</td>
</tr>
<tr>
<td>c</td>
<td>字符设备文件。表示以字节流形式处理数据的设备，如终端或调制解调器</td>
</tr>
<tr>
<td>b</td>
<td>块设备文件。表示以数据块方式处理数据的设备，如硬盘驱动或光盘驱动</td>
</tr>
</tbody></table>
<p><strong>剩下9个字符——文件模式</strong></p>
<p>3个字符一组，2、3、4字符表示文件所有者权限；5、6、7表示文件所有者所在组成员权限；8、9、10表示其他组成员权限</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>文件</th>
<th>目录</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>允许打开和读取文件</td>
<td>如果设置了执行权限，则允许列出目录下的内容</td>
</tr>
<tr>
<td>w</td>
<td>允许写入</td>
<td>该权限不允许重命名或删除文件</td>
</tr>
<tr>
<td>x</td>
<td>允许把文件当作程序一样执行</td>
<td>允许进入目录，如 cd directory</td>
</tr>
</tbody></table>
<p>常见文件属性设置：</p>
<table>
<thead>
<tr>
<th>文件属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-rwx——</td>
<td>普通文件，文件所有者具有读取、写入和执行权限。组成员和其他用户没有任何访问权限</td>
</tr>
<tr>
<td>-rw——-</td>
<td>普通文件，文件所有者具有读取和写入权限。组成员和其他用户没有任何访问权限</td>
</tr>
<tr>
<td>-rw-r–r–</td>
<td>普通文件，文件所有者具有读取和写入权限。文件对所有用户可读</td>
</tr>
<tr>
<td>-rwxr-xr-x</td>
<td>普通文件，文件所有者具有读取、写入和执行权限。所有用户对文件可读、可执行</td>
</tr>
<tr>
<td>-rw-rw—-</td>
<td>普通文件，文件所有者具有读取、写入权限。文件所有者组成员具有读取和写入权限</td>
</tr>
<tr>
<td>lrwxrwxrwx</td>
<td>符号链接。所有符号链接文件显示的都是伪权限属性，真正的权限属性由符号链接指向的实际文件决定</td>
</tr>
<tr>
<td>dwxrwx—-</td>
<td>目录文件。文件所有者和所有者所在的组成员可以进入该目录，并对目录下的文件进行创建，重命名，删除操作</td>
</tr>
<tr>
<td>drwxr-x—</td>
<td>目录文件。文件所有者可以进入该目录，并具有所有权限。文件所有者所在组成员可以进入目录，但是没有创建、重命名和删除操作权限</td>
</tr>
</tbody></table>
<h4 id="文件模式的修改chmod"><a href="#文件模式的修改chmod" class="headerlink" title="文件模式的修改chmod"></a>文件模式的修改chmod</h4><p>chmod可用于更改文件或目录的文件模式（权限），但只有文件所有者和超级用户才能进行修改。格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod pattern filename</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ ls -l howTomcatWork.pdf</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 17676281  9月 22  2020 howTomcatWork.pdf</span><br><span class="line">dougwilson@doug:~$ chmod 600 howTomcatWork.pdf</span><br><span class="line">dougwilson@doug:~$ ls -l howTomcatWork.pdf</span><br><span class="line">-rw------- 1 dougwilson dougwilson 17676281  9月 22  2020 howTomcatWork.pdf</span><br><span class="line">dougwilson@doug:~$ chmod 664 howTomcatWork.pdf</span><br><span class="line">dougwilson@doug:~$ ls -l howTomcatWork.pdf</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 17676281  9月 22  2020 howTomcatWork.pdf</span><br></pre></td></tr></table></figure>

<p><strong>八进制表示法</strong></p>
<p>使用3个二进制数和文件模式的结构一一对应</p>
<table>
<thead>
<tr>
<th>八进制</th>
<th>二进制</th>
<th>文件模式</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>000</td>
<td>—</td>
</tr>
<tr>
<td>1</td>
<td>001</td>
<td>–x</td>
</tr>
<tr>
<td>2</td>
<td>010</td>
<td>-w-</td>
</tr>
<tr>
<td>3</td>
<td>011</td>
<td>-wx</td>
</tr>
<tr>
<td>4</td>
<td>100</td>
<td>r–</td>
</tr>
<tr>
<td>5</td>
<td>101</td>
<td>r-x</td>
</tr>
<tr>
<td>6</td>
<td>110</td>
<td>rw-</td>
</tr>
<tr>
<td>7</td>
<td>111</td>
<td>rwx</td>
</tr>
</tbody></table>
<p><strong>符号表示法</strong></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u</td>
<td>user缩写，文件所有者</td>
</tr>
<tr>
<td>g</td>
<td>group缩写，文件所有者所在组</td>
</tr>
<tr>
<td>o</td>
<td>others缩写，其他所有用户</td>
</tr>
<tr>
<td>a</td>
<td>all缩写，ugo结合</td>
</tr>
<tr>
<td>+</td>
<td>添加某个权限</td>
</tr>
<tr>
<td>-</td>
<td>去掉某个权限</td>
</tr>
<tr>
<td>=</td>
<td>指定权限</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>读取权限</td>
</tr>
<tr>
<td>w</td>
<td>写入权限</td>
</tr>
<tr>
<td>x</td>
<td>执行权限</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod u+x howTomcatWork.pdf</span><br><span class="line">chmod u-x howTomcatWork.pdf</span><br><span class="line">chmod a+x howTomcatWork.pdf</span><br><span class="line">chmod u+x,go=rx howTomcatWork.pdf  指定多种权限时, 用逗号 , 分隔</span><br></pre></td></tr></table></figure>

<h4 id="设置默认权限umask"><a href="#设置默认权限umask" class="headerlink" title="设置默认权限umask"></a>设置默认权限umask</h4><p>默认权限的获得并没有想象的那么简单，通过8进制并不能直接设置。</p>
<p>Linux采用一种：<strong>原始文件模式+掩码</strong>   的方式设置文件的默认文件模式，即权限。</p>
<p>原始文件模式是不会变的，格式为：</p>
<table>
<thead>
<tr>
<th>原始文件模式</th>
<th>—</th>
<th>rw-</th>
<th>rw-</th>
<th>rw-</th>
</tr>
</thead>
</table>
<p>掩码，可以通过umask设置，得到不同的掩码值，进而改变文件的默认权限。权限对应二进制位为1时，表示删除该权限，为0时，不改变对应位置的权限。比如掩码为0022时：</p>
<table>
<thead>
<tr>
<th>原始文件模式</th>
<th>—</th>
<th>rw-</th>
<th>rw-</th>
<th>rw-</th>
</tr>
</thead>
<tbody><tr>
<td>掩码</td>
<td>000</td>
<td>000</td>
<td>010</td>
<td>010</td>
</tr>
<tr>
<td>结果</td>
<td>—</td>
<td>rw-</td>
<td>r–</td>
<td>r–</td>
</tr>
</tbody></table>
<p>因此，当掩码为0000时，掩码无效，原始文件模式为默认文件权限。当掩码为1111或0111时，文件不可访问，且为锁定状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">umask   查看掩码值</span><br><span class="line">umask 0022  设置掩码值</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ ls -l cat-input.txt</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 0  5月 20 08:59 cat-input.txt</span><br><span class="line">dougwilson@doug:~$ umask</span><br><span class="line">0002</span><br><span class="line">dougwilson@doug:~$ umask 0777</span><br><span class="line">dougwilson@doug:~$ rm cat-input.txt</span><br><span class="line">dougwilson@doug:~$ &gt; cat-input.txt</span><br><span class="line">dougwilson@doug:~$ ls -l cat-input.txt</span><br><span class="line">---------- 1 dougwilson dougwilson 0  5月 20 09:00 cat-input.txt</span><br><span class="line">dougwilson@doug:~$ umask 0002</span><br></pre></td></tr></table></figure>

<h4 id="更改身份-su-sudo"><a href="#更改身份-su-sudo" class="headerlink" title="更改身份 su sudo"></a>更改身份 su sudo</h4><h5 id="su"><a href="#su" class="headerlink" title="su"></a>su</h5><p>su命令以另一个用户的身份来启动shell，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su [-[l]] [user]</span><br><span class="line">如：</span><br><span class="line">su - dougwilson  指定用户</span><br><span class="line">su -l 没有指定用户，则默认为超级用户</span><br><span class="line">exit  退出当前用户环境，返回到之前的shell环境</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ ls -l howTomcatWork.pdf</span><br><span class="line">-rw-rw-r-- 1 dougwilson dougwilson 17676281  9月 22  2020 howTomcatWork.pdf</span><br><span class="line">dougwilson@doug:~$ su -l </span><br><span class="line">Password: </span><br><span class="line">root@doug:~# ls</span><br><span class="line">snap</span><br><span class="line">root@doug:~# exit</span><br><span class="line">logout</span><br><span class="line">dougwilson@doug:~$ </span><br></pre></td></tr></table></figure>

<p>如果包含”-l”选项，那么得到的shell会话界面是用于指定用户的登录shell界面，并且对应的用户运行环境将被加载，工作目录也会切换到指定用户的家目录。需要注意的是，”-l”可以缩写成”-“，且含义相同。</p>
<p>如果你想执行某一个命令，但是不希望切换用户，那么可以采用如下方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su -c &#x27;command&#x27;   必须要单引号</span><br><span class="line">如：</span><br><span class="line">dougwilson@doug:~$ su -c &#x27;ls -l /root/*&#x27;</span><br><span class="line">Password: </span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x 4 root root 4096  5月 17 10:46 snap-store</span><br></pre></td></tr></table></figure>

<p>这样，单个命令行就会被传递到一个新的shell环境下执行，然后将结果返回到当前shell环境</p>
<h5 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h5><p>sudo命令很类似于su命令，但它还具有一些重要的功能。如，允许一个用户以不同的身份执行命令，而只需要输入自己的密码进行验证，不需要输入如超级用户的密码，就可以执行特定身份下的命令。更重要的区别在于sudo命令不需要启动一个新的shell环境，也不需要加载另一个用户的运行环境。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo command  会提示输入密码，输入正确则执行</span><br></pre></td></tr></table></figure>

<h4 id="修改密码-passwd"><a href="#修改密码-passwd" class="headerlink" title="修改密码 passwd"></a>修改密码 passwd</h4><p>passwd命令可以修改用户当前密码</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">passwd</span>  </span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote>
<h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>kill命令用于终止某个指定PID服务进程，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">kill</span> [参数] [进程PID]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">kill</span> 2566</span></span><br></pre></td></tr></table></figure>

<h4 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h4><p>killall命令用于终止某个指定名称服务对应的全部进程，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">killall [服务名称]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">killall httpd</span></span><br></pre></td></tr></table></figure>

<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>top命令用于动态地监视进程活动与系统负载等信息。前5行为系统的整体统计信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">dougwilson@doug:~$ top</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">top - 21:54:05 up 1 min,  1 user,  load average: 0.76, 0.38, 0.14</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">Tasks: 331 total,   1 running, 330 sleeping,   0 stopped,   0 zombie</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">%Cpu(s):  0.1 us,  0.2 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">MiB Mem :   1890.7 total,    524.2 free,    779.6 used,    586.9 buff/cache</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.    945.8 avail Mem</span> </span><br></pre></td></tr></table></figure>

<p>第一行：系统时间，运行时间，登录终端数，系统负载(三个数值为1分钟、5分钟、15分钟内平均值)</p>
<p>第二行：进程总数，运行中的进程数，睡眠中的进程数，停止的进程数，僵死的线程数</p>
<p>第三行：用户占用资源百分比，系统内核占用资源百分比，改变过优先级的进程资源百分比，空闲的资源百分比</p>
<p>第四行：显示物理RAM的使用清空</p>
<p>第五行：显示交换空间的使用情况</p>
<h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>ps命令用于查看系统中的进程状态，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">ps [参数]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">参数有：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-a 显示所有进程</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-u 用户及其他详细信息</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">-x 显示没有控制中断的进程</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ps</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ps -a</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ps -u</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ps -au</span></span><br></pre></td></tr></table></figure>

<p>进程的状态：</p>
<ul>
<li>运行(R)：进程正在运行或在运行队列中等待</li>
<li>中断(S)：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离中断状态</li>
<li>不可中断(D)：进程不响应系统异步信号，即使使用kill命令也不能将其中断</li>
<li>僵死(Z)：进程已经终止，但进程描述符依然存在，直到父进程调用wait4()系统函数将其释放</li>
<li>停止(T)：进程收到停止信号后停止运行</li>
</ul>
<h4 id="暂停进程-Ctrl-Z"><a href="#暂停进程-Ctrl-Z" class="headerlink" title="暂停进程 Ctrl+Z"></a>暂停进程 Ctrl+Z</h4><p>在终端窗口中按下<kbd>Ctrl</kbd>+<kbd>Z</kbd>可以暂停进程执行</p>
<h4 id="中断进程-Ctrl-C"><a href="#中断进程-Ctrl-C" class="headerlink" title="中断进程 Ctrl + C"></a>中断进程 Ctrl + C</h4><p>执行一个程序，如果想中断其执行，可以在终端窗口中按下<kbd>Ctrl</kbd>+<kbd>C</kbd>，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">dougwilson@doug:~$ xlogo</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">^C   这里按下了Ctrl+C</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">dougwilson@doug:~$</span> </span><br></pre></td></tr></table></figure>

<h4 id="使进程在后台运行，但不中断其运行-amp"><a href="#使进程在后台运行，但不中断其运行-amp" class="headerlink" title="使进程在后台运行，但不中断其运行 &amp;"></a>使进程在后台运行，但不中断其运行 &amp;</h4><p>假设我们想shell提示符返回，但不终止程序，则可以将程序设置为后台运行，需要在命令后面加上&amp;符号实现。如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">dougwilson@doug:~$ xlogo &amp;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">[1] 3870           作业编号为1  进程的PID为3870</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">dougwilson@doug:~$</span> </span><br></pre></td></tr></table></figure>

<h4 id="使进程从后台返回到前台执行-fg"><a href="#使进程从后台返回到前台执行-fg" class="headerlink" title="使进程从后台返回到前台执行 fg"></a>使进程从后台返回到前台执行 fg</h4><p>后台运行的进程不会受到键盘输入的影响，因此如键盘输入Ctrl+C无法中断进程的执行。</p>
<p>想要让进程从后台返回到前台执行，需要依靠fg命令，以及对应进程的作业编号，格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">fg</span> %作业编号</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">如：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">dougwilson@doug:~$ <span class="built_in">jobs</span>     查看作业</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">[1]+  Running                 xlogo &amp;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">dougwilson@doug:~$ <span class="built_in">fg</span> %1</span>    </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">xlogo</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">^C</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">dougwilson@doug:~$</span> </span><br></pre></td></tr></table></figure>

<h4 id="使进程移到后台运行-bg"><a href="#使进程移到后台运行-bg" class="headerlink" title="使进程移到后台运行 bg"></a>使进程移到后台运行 bg</h4><p>使用方式和fg一样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="built_in">bg</span> %作业编号</span></span><br></pre></td></tr></table></figure>


</blockquote>
]]></content>
      <tags>
        <tag>linux, 命令</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习Java线程池</title>
    <url>/2020/08/17/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>如果没有线程池，需要通过<code>new Thread</code>来创建一个线程，由于线程的创建和销毁都需要消耗一定的CPU资源，所以在高并发下这种创建线程的方式将严重影响代码执行效率。而线程池的作用就是让一个线程执行结束后不马上销毁，继续执行新的任务，这样就节省了不断创建线程和销毁线程的开销。</p>
<span id="more"></span>

<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>Java线程池最为核心的类为<code>ThreadPoolExecutor</code>，其类结构图为：</p>
<p><img src="/images/ThreadPoolExecutor%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<p>它提供了四种构造函数来创建线程池，其中最为核心的构造函数如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                              RejectedExecutionHandler handler)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>这7个参数的含义如下：</p>
<ol>
<li><strong>corePoolSize</strong> 线程池核心线程数。即线程池中保留的线程个数，即使这些线程是空闲的，也不会被销毁，除非通过ThreadPoolExecutor的<code>allowCoreThreadTimeOut(true)</code>方法开启了核心线程的超时策略；</li>
<li><strong>maximumPoolSize</strong> 线程池中允许的最大线程个数；</li>
<li><strong>keepAliveTime</strong> 用于设置那些超出核心线程数量的线程的最大等待时间，超过这个时间还没有新任务的话，超出的线程将被销毁；</li>
<li><strong>unit</strong> 超时时间单位；</li>
<li><strong>workQueue</strong> 线程队列。用于保存通过execute方法提交的，等待被执行的任务；</li>
<li><strong>threadFactory</strong> 线程创建工程，即指定怎样创建线程；</li>
<li><strong>handler</strong> 拒绝策略。即指定当线程提交的数量超出了maximumPoolSize后，该使用什么策略处理超出的线程。</li>
</ol>
<p>在通过这个构造方法创建线程池的时候，这几个参数必须满足以下条件，否则将抛出<code>IllegalArgumentException</code>异常：</p>
<ol>
<li>corePoolSize不能小于0；</li>
<li>keepAliveTime不能小于0；</li>
<li>maximumPoolSize 不能小于等于0；</li>
<li>maximumPoolSize不能小于corePoolSize；</li>
</ol>
<p>此外，workQueue、threadFactory和handler不能为null，否则将抛出空指针异常。</p>
<p>下面举些例子来深入理解这几个参数的含义。</p>
<p>使用上面的构造方法创建一个线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">System.out.println(<span class="string">&quot;线程池创建完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> activeCount = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> queueSize = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeCount != threadPoolExecutor.getActiveCount()</span><br><span class="line">            || queueSize != threadPoolExecutor.getQueue().size()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;活跃线程个数 &quot;</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">        System.out.println(<span class="string">&quot;核心线程个数 &quot;</span> + threadPoolExecutor.getCorePoolSize());</span><br><span class="line">        System.out.println(<span class="string">&quot;队列线程个数 &quot;</span> + threadPoolExecutor.getQueue().size());</span><br><span class="line">        System.out.println(<span class="string">&quot;最大线程数 &quot;</span> + threadPoolExecutor.getMaximumPoolSize());</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        activeCount = threadPoolExecutor.getActiveCount();</span><br><span class="line">        queueSize = threadPoolExecutor.getQueue().size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码创建了一个核心线程数量为1，允许最大线程数量为2，最大活跃时间为10秒，线程队列长度为1的线程池。</p>
<p>假如通过execute方法向线程池提交1个任务，看看结果如何：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">System.out.println(<span class="string">&quot;线程池创建完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> activeCount = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> queueSize = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeCount != threadPoolExecutor.getActiveCount()</span><br><span class="line">            || queueSize != threadPoolExecutor.getQueue().size()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;活跃线程个数 &quot;</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">        System.out.println(<span class="string">&quot;核心线程个数 &quot;</span> + threadPoolExecutor.getCorePoolSize());</span><br><span class="line">        System.out.println(<span class="string">&quot;队列线程个数 &quot;</span> + threadPoolExecutor.getQueue().size());</span><br><span class="line">        System.out.println(<span class="string">&quot;最大线程数 &quot;</span> + threadPoolExecutor.getMaximumPoolSize());</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        activeCount = threadPoolExecutor.getActiveCount();</span><br><span class="line">        queueSize = threadPoolExecutor.getQueue().size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行sleep方法&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别注意：<strong>ThreadPoolExecutor的execute和submit方法都可以向线程池提交任务，区别是，submit方法能够返回执行结果，返回值类型为Future</strong></p>
<p>控制台输出结果如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">线程池创建完毕</span><br><span class="line">活跃线程个数 <span class="number">1</span></span><br><span class="line">核心线程个数 <span class="number">1</span></span><br><span class="line">队列线程个数 <span class="number">0</span></span><br><span class="line">Th<span class="built_in">read-0</span>线程执行<span class="built_in">sleep</span>方法</span><br><span class="line">最大线程数 <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>线程池核心线程数量为1，通过execute提交了一个任务后，由于核心线程是空闲的，所以任务被执行了。由于这个任务的逻辑是休眠100秒，所以在这100秒内，线程池的活跃线程数量为1。此外，因为提交的任务被核心线程执行了，所以并没有线程需要被放到线程队列里等待，线程队列长度为0。</p>
<p>假如通过execute方法向线程池提交2个任务，看看结果如何：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">threadPoolExecutor.execute<span class="function"><span class="params">(() -&gt; sleep(<span class="number">100</span>))</span>;</span></span><br><span class="line"><span class="function"><span class="title">threadPoolExecutor</span>.<span class="title">execute</span><span class="params">(() -&gt; sleep(<span class="number">100</span>))</span>;</span></span><br></pre></td></tr></table></figure>

<p>控制台输出结果如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">线程池创建完毕</span><br><span class="line">Th<span class="built_in">read-0</span>线程执行<span class="built_in">sleep</span>方法</span><br><span class="line">活跃线程个数 <span class="number">1</span></span><br><span class="line">核心线程个数 <span class="number">1</span></span><br><span class="line">队列线程个数 <span class="number">1</span></span><br><span class="line">最大线程数 <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>线程池核心线程数量为1，通过execute提交了2个任务后，一开始核心线程是空闲的，Thread-0被执行。由于这个任务的逻辑是休眠100秒，所以在这100秒内，线程池的活跃线程数量为1。因为核心线程数量为1，所以另外一个任务在这100秒内不能被执行，于是被放到线程队列里等待，线程队列长度为1。</p>
<p>假如通过execute方法向线程池提交3个任务，看看结果如何：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>

<p>控制台输出结果如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">线程池创建完毕</span><br><span class="line">Th<span class="built_in">read-0</span>线程执行<span class="built_in">sleep</span>方法</span><br><span class="line">Th<span class="built_in">read-1</span>线程执行<span class="built_in">sleep</span>方法</span><br><span class="line">活跃线程个数 <span class="number">2</span></span><br><span class="line">核心线程个数 <span class="number">1</span></span><br><span class="line">队列线程个数 <span class="number">1</span></span><br><span class="line">最大线程数 <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>这三个任务都是休眠100秒，所以核心线程池中第一个任务正在被执行，第二个任务被放入到了线程队列。而当第三个任务被提交进来时，线程队列满了（我们定义的长度为1），由于该线程池允许的最大线程数量为2，所以线程池还可以再创建一个线程来执行另外一个任务，于是乎之前在线程队列里的线程被取出执行（FIFO），第三个任务被放入到了线程队列。</p>
<p>改变第二个和第三个任务的睡眠时间，观察输出：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">threadPoolExecutor.execute<span class="function"><span class="params">(() -&gt; sleep(<span class="number">100</span>))</span>;</span></span><br><span class="line"><span class="function"><span class="title">threadPoolExecutor</span>.<span class="title">execute</span><span class="params">(() -&gt; sleep(<span class="number">5</span>))</span>;</span></span><br><span class="line"><span class="function"><span class="title">threadPoolExecutor</span>.<span class="title">execute</span><span class="params">(() -&gt; sleep(<span class="number">5</span>))</span>;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BA%BF%E7%A8%8B%E8%BE%93%E5%87%BA.png"></p>
<p>第二个任务提交5秒后，任务执行完毕，所以线程队列里的任务被执行，于是队列线程个数为0，活跃线程数量为2（第一个和第三个任务）。再过5秒后，第三个任务执行完毕，于是活跃线程数量为1（第一个100秒还没执行完毕）。</p>
<p>在第三个任务结束的瞬间，我们观察线程快照:</p>
<p><img src="/images/%E7%BA%BF%E7%A8%8B%E5%BF%AB%E7%85%A71.png"></p>
<p>可以看到，线程池中有两个线程，Thread-0在执行第一个任务（休眠100秒，还没结束），Thread-1执行完第三个任务后并没有马上被销毁。过段时间后（10秒钟后）再观察线程快照:</p>
<p><img src="/images/%E7%BA%BF%E7%A8%8B%E5%BF%AB%E7%85%A72.png"></p>
<p>可以看到，Thread-1这个线程被销毁了，因为我们在创建线程池的时候，指定keepAliveTime 为10秒，10秒后，超出核心线程池线程外的那些线程将被销毁。</p>
<p>假如一次性提交4个任务，看看会怎样：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">threadPoolExecutor.execute<span class="function"><span class="params">(() -&gt; sleep(<span class="number">100</span>))</span>;</span></span><br><span class="line"><span class="function"><span class="title">threadPoolExecutor</span>.<span class="title">execute</span><span class="params">(() -&gt; sleep(<span class="number">100</span>))</span>;</span></span><br><span class="line"><span class="function"><span class="title">threadPoolExecutor</span>.<span class="title">execute</span><span class="params">(() -&gt; sleep(<span class="number">100</span>))</span>;</span></span><br><span class="line"><span class="function"><span class="title">threadPoolExecutor</span>.<span class="title">execute</span><span class="params">(() -&gt; sleep(<span class="number">100</span>))</span>;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E7%BA%BF%E7%A8%8B%E8%BE%93%E5%87%BA1.png"></p>
<p>因为设置的拒绝策略为AbortPolicy，所以最后提交的那个任务直接被拒绝了。更多拒绝策略下面会介绍到</p>
<h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><p>线程池包含以下几个状态：</p>
<p><img src="/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png"></p>
<p>当线程池中所有任务都处理完毕后，线程并不会自己关闭。我们可以通过调用<code>shutdown</code>和<code>shutdownNow</code>方法来关闭线程池。两者的区别在于：</p>
<ol>
<li><code>shutdown</code>方法将线程池置为shutdown状态，拒绝新的任务提交，但线程池并不会马上关闭，而是等待所有正在执行的和线程队列里的任务都执行完毕后，线程池才会被关闭。所以这个方法是平滑的关闭线程池。</li>
<li><code>shutdownNow</code>方法将线程池置为stop状态，拒绝新的任务提交，中断正在执行的那些任务，并且清除线程队列里的任务并返回。所以这个方法是比较“暴力”的。</li>
</ol>
<p>举两个例子观察下两者的区别：</p>
<p><code>shutdown</code>例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;已经执行了线程池shutdown方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行shortTask完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;shortTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行longTask完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;longTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出如下：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">已经执行了线程池shutdown方法</span><br><span class="line"><span class="keyword">Thread</span>-<span class="number">0</span>执行shortTask完毕</span><br><span class="line"><span class="keyword">Thread</span>-<span class="number">1</span>执行longTask完毕</span><br><span class="line"><span class="keyword">Thread</span>-<span class="number">1</span>执行shortTask完毕</span><br><span class="line"><span class="keyword">Thread</span>-<span class="number">0</span>执行longTask完毕</span><br></pre></td></tr></table></figure>

<p>可以看到，虽然在任务都被提交后马上执行了<code>shutdown</code>方法，但是并不会马上关闭线程池，而是等待所有被提交的任务都执行完了才关闭。</p>
<p><code>shutdownNow</code>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line"></span><br><span class="line">    List&lt;Runnable&gt; runnables = threadPoolExecutor.shutdownNow(); <span class="comment">// 马上关闭，并返回还未被执行的任务</span></span><br><span class="line">    System.out.println(runnables);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;已经执行了线程池shutdownNow方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行shortTask完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;shortTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行longTask完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;longTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">已经执行了线程池<span class="built_in">shutdown</span>方法</span><br><span class="line">longTask执行过程中被打断<span class="built_in">sleep</span> interrupted</span><br><span class="line">shortTask执行过程中被打断<span class="built_in">sleep</span> interrupted</span><br></pre></td></tr></table></figure>

<p>可以看到，在执行<code>shutdownNow</code>方法后，线程池马上就被关闭了，正在执行中的两个任务被打断，并且返回了线程队列中等待被执行的两个任务。</p>
<p>通过上面两个例子我们还可以看到<code>shutdown</code>和<code>shutdownNow</code>方法都不是阻塞的。常与<code>shutdown</code>搭配的方法有<code>awaitTermination</code>。</p>
<p><code>awaitTermination</code>方法接收timeout和TimeUnit两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测ExecutorService是否已经关闭，若关闭则返回true，否则返回false。该方法是阻塞的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">    <span class="keyword">boolean</span> isShutdown = threadPoolExecutor.awaitTermination(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (isShutdown) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程池在3秒内成功关闭&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;等了3秒还没关闭，不等了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行shortTask完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;shortTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行longTask完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;longTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">Thread-0执行shortTask完毕</span><br><span class="line"><span class="section">等了3秒还没关闭，不等了</span></span><br><span class="line"><span class="section">----------</span></span><br><span class="line">Thread-1执行longTask完毕</span><br><span class="line">Thread-0执行longTask完毕</span><br><span class="line">Thread-1执行shortTask完毕</span><br></pre></td></tr></table></figure>

<h2 id="4大拒绝策略"><a href="#4大拒绝策略" class="headerlink" title="4大拒绝策略"></a>4大拒绝策略</h2><p>当线程池无法再接收新的任务的时候，可采取如下四种策略：</p>
<p><img src="/images/%E7%BA%BF%E7%A8%8B%E6%B1%A04%E5%A4%A7%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5.png"></p>
<h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3><p><code>CallerRunsPolicy</code>策略：由调用线程处理该任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">&quot;任务1&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">&quot;任务2&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">&quot;任务3&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">&quot;任务4&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">&quot;任务5&quot;</span>));</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">shortTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行shortTask-name-&quot;</span> + name + <span class="string">&quot;完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;shortTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">longTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行longTask-name-&quot;</span> + name + <span class="string">&quot;完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;longTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的线程池最多只能一次性提交4个任务，第5个任务提交后会被拒绝策略处理。启动程序输出如下：</p>
<p><img src="/images/CallerRunsPolicy%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5.png"></p>
<p>可以看到，第5个提交的任务由调用线程（即main线程）处理该任务。</p>
<h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3><p><code>AbortPolicy</code>策略：丢弃任务，并抛出<code>RejectedExecutionException</code>异常。前面的例子就是使用该策略，所以不再演示。</p>
<h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3><p><code>DiscardOldestPolicy</code>策略：丢弃最早被放入到线程队列的任务，将新提交的任务放入到线程队列末端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">&quot;任务1&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">&quot;任务2&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">&quot;任务3&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">&quot;任务4&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">&quot;任务5&quot;</span>));</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">shortTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行shortTask-name-&quot;</span> + name + <span class="string">&quot;完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;shortTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">longTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行longTask-name-&quot;</span> + name + <span class="string">&quot;完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;longTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动程序输出如下：</p>
<p><img src="/images/DiscardOldestPolicy%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5.png"></p>
<p>可以看到最后提交的任务被执行了，而第3个任务是第一个被放到线程队列的任务，被丢弃了。</p>
<h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3><p><code>DiscardPolicy</code>策略：直接丢弃新的任务，不抛异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">&quot;任务1&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">&quot;任务2&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">&quot;任务3&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">&quot;任务4&quot;</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">&quot;任务5&quot;</span>));</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">shortTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行shortTask-name-&quot;</span> + name + <span class="string">&quot;完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;shortTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">longTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行longTask-name-&quot;</span> + name + <span class="string">&quot;完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;longTask执行过程中被打断&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动程序，输出如下：</p>
<p><img src="/images/DiscardPolicy%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5.png"></p>
<p>第5个任务直接被拒绝丢弃了，而没有抛出任何异常</p>
<h2 id="线程池工厂方法"><a href="#线程池工厂方法" class="headerlink" title="线程池工厂方法"></a>线程池工厂方法</h2><p>除了使用ThreadPoolExecutor的构造方法创建线程池外，我们也可以使用<code>Executors</code>提供的工厂方法来创建不同类型的线程池：</p>
<p><img src="/images/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0.png"></p>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>查看<code>newFixedThreadPool</code>方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，通过<code>newFixedThreadPool</code>创建的是一个固定大小的线程池，大小由<code>nThreads</code>参数指定，它具有如下几个特点:</p>
<ol>
<li>因为corePoolSize和maximumPoolSize的值都为nThreads，所以线程池中线程数量永远等于nThreads，不可能新建除了核心线程数的线程来处理任务，即keepAliveTime实际上在这里是无效的。</li>
<li>LinkedBlockingQueue是一个无界队列（最大长度为Integer.MAX_VALUE），所以这个线程池理论是可以无限的接收新的任务，这就是为什么上面没有指定拒绝策略的原因。</li>
</ol>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>查看<code>newCachedThreadPool</code>方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是一个理论上无限大小的线程池：</p>
<ol>
<li>核心线程数为0，SynchronousQueue队列是没有长度的队列，所以当有新的任务提交，如果有空闲的还未超时的（最大空闲时间60秒）线程则执行该任务，否则新增一个线程来处理该任务。</li>
<li>因为线程数量没有限制，理论上可以接收无限个新任务，所以这里也没有指定拒绝策略。</li>
</ol>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>查看<code>newSingleThreadExecutor</code>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>核心线程数和最大线程数都为1，每次只能有一个线程处理任务。</li>
<li>LinkedBlockingQueue队列可以接收无限个新任务。</li>
</ol>
<h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>查看<code>newScheduledThreadPool</code>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以<code>newScheduledThreadPool</code>理论是也是可以接收无限个任务，DelayedWorkQueue也是一个无界队列。</p>
<p>使用newScheduledThreadPool创建的线程池除了可以处理普通的Runnable任务外，它还具有调度的功能：</p>
<ol>
<li><p>延迟指定时间后执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 延迟5秒执行</span></span><br><span class="line">executorService.schedule(() -&gt; System.out.println(<span class="string">&quot;hello&quot;</span>), <span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></li>
<li><p>按指定的速率执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 延迟1秒执行，然后每5秒执行一次</span></span><br><span class="line">executorService.scheduleAtFixedRate(</span><br><span class="line">        () -&gt; System.out.println(LocalTime.now()), <span class="number">1</span>, <span class="number">5</span>, TimeUnit.SECONDS</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%8C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E9%80%9F%E7%8E%87%E6%89%A7%E8%A1%8C.png"></p>
</li>
<li><p>按指定的时延执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">executorService.scheduleWithFixedDelay(</span><br><span class="line">        () -&gt; System.out.println(LocalTime.now()), <span class="number">1</span>, <span class="number">5</span>, TimeUnit.SECONDS</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%8C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E6%97%B6%E5%BB%B6%E6%89%A7%E8%A1%8C.png"></p>
</li>
</ol>
<p>看起来，scheduleAtFixedRate和scheduleWithFixedDelay没啥区别，实际它们还是有区别的：</p>
<ul>
<li>scheduleAtFixedRate按照固定速率执行任务，比如每5秒执行一个任务，即使上一个任务没有结束，5秒后也会开始处理新的任务；</li>
<li>scheduleWithFixedDelay按照固定的时延处理任务，比如每延迟5秒执行一个任务，无论上一个任务处理了1秒，1分钟还是1小时，下一个任务总是在上一个任务执行完毕后5秒钟后开始执行。</li>
</ul>
<h3 id="线程池工厂方法使用"><a href="#线程池工厂方法使用" class="headerlink" title="线程池工厂方法使用"></a>线程池工厂方法使用</h3><p><img src="/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8.png"></p>
<p>因为这几个线程池理论是都可以接收无限个任务，所以这就有内存溢出的风险。实际上只要我们掌握了ThreadPoolExecutor构造函数7个参数的含义，我们就可以根据不同的业务来创建出符合需求的线程池。一般线程池的创建可以参考如下规则：</p>
<ul>
<li>IO密集型任务：IO密集型任务线程并不是一直在执行任务，应该配置尽可能多的线程，线程池线程数量推荐设置为2 * CPU核心数；对于IO密集型任务，网络上也有另一种线程池数量计算公式：CPU核心数/(1 - 阻塞系数)，阻塞系数取值0.8~0.9，至于这两种公式使用哪一个，可以根据实际环境测试比较得出；</li>
<li>计算密集型任务：此类型需要CPU的大量运算，所以尽可能的去压榨CPU资源，线程池线程数量推荐设置为CPU核心数 + 1。</li>
</ul>
<p>CPU核心数可以使用<code>Runtime</code>获得：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Runtime</span>.</span></span>get<span class="constructor">Runtime()</span>.available<span class="constructor">Processors()</span></span><br></pre></td></tr></table></figure>

<h2 id="一些API的用法"><a href="#一些API的用法" class="headerlink" title="一些API的用法"></a>一些API的用法</h2><h4 id="ThreadPoolExecutor几个判断线程池状态的方法："><a href="#ThreadPoolExecutor几个判断线程池状态的方法：" class="headerlink" title="ThreadPoolExecutor几个判断线程池状态的方法："></a>ThreadPoolExecutor几个判断线程池状态的方法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;线程池为shutdown状态：&quot;</span> + threadPoolExecutor.isShutdown());</span><br><span class="line">    System.out.println(<span class="string">&quot;线程池正在关闭：&quot;</span> + threadPoolExecutor.isTerminating());</span><br><span class="line">    System.out.println(<span class="string">&quot;线程池已经关闭：&quot;</span> + threadPoolExecutor.isTerminated());</span><br><span class="line">    threadPoolExecutor.awaitTermination(<span class="number">6</span>, TimeUnit.SECONDS);</span><br><span class="line">    System.out.println(<span class="string">&quot;线程池已经关闭&quot;</span> + threadPoolExecutor.isTerminated());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">线程池为shutdown状态：<span class="literal">true</span></span><br><span class="line">线程池正在关闭：<span class="literal">true</span></span><br><span class="line">线程池已经关闭：<span class="literal">false</span></span><br><span class="line">线程池已经关闭<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="allowCoreThreadTimeOut"><a href="#allowCoreThreadTimeOut" class="headerlink" title="allowCoreThreadTimeOut"></a>allowCoreThreadTimeOut</h4><p>前面我们提到，线程池核心线程即使是空闲状态也不会被销毁，除非使用<code>allowCoreThreadTimeOut</code>设置了允许核心线程超时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">               <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">               <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">               <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">       );</span><br><span class="line">       threadPoolExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">       threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">               System.out.println(<span class="string">&quot;任务执行完毕&quot;</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="ThreadPoolExecutor提供了一些remove方法"><a href="#ThreadPoolExecutor提供了一些remove方法" class="headerlink" title="ThreadPoolExecutor提供了一些remove方法"></a>ThreadPoolExecutor提供了一些<code>remove</code>方法</h4><p>查看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = workQueue.remove(task);</span><br><span class="line">    tryTerminate(); <span class="comment">// In case SHUTDOWN and now empty</span></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知，它删除的是线程队列中的任务，而非正在被执行的任务。比如说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;任务执行完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Runnable r = () -&gt; System.out.println(<span class="string">&quot;看看我是否会被删除&quot;</span>);</span><br><span class="line">    threadPoolExecutor.execute(r);</span><br><span class="line">    threadPoolExecutor.remove(r);</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">任务执行完毕</span><br></pre></td></tr></table></figure>

<p>可看到任务并没有被执行，已经被删除，因为唯一一个核心线程已经在执行任务了，所以后提交的这个任务被放到了线程队列里，然后通过remove方法删除。</p>
<h4 id="prestartCoreThread"><a href="#prestartCoreThread" class="headerlink" title="prestartCoreThread"></a>prestartCoreThread</h4><p>默认情况下，只有当往线程池里提交了任务后，线程池才会启动核心线程处理任务。我们可以通过调用<code>prestartCoreThread</code>方法，让核心线程即使没有任务提交，也处于等待执行任务的活跃状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line">    System.out.println(<span class="string">&quot;活跃线程数: &quot;</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">    threadPoolExecutor.prestartCoreThread();</span><br><span class="line">    System.out.println(<span class="string">&quot;活跃线程数: &quot;</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">    threadPoolExecutor.prestartCoreThread();</span><br><span class="line">    System.out.println(<span class="string">&quot;活跃线程数: &quot;</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">    threadPoolExecutor.prestartCoreThread();</span><br><span class="line">    System.out.println(<span class="string">&quot;活跃线程数: &quot;</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">活跃线程数：0</span><br><span class="line">活跃线程数：1</span><br><span class="line">活跃线程数：2</span><br><span class="line">活跃线程数：2</span><br></pre></td></tr></table></figure>

<p>该方法返回boolean类型值，如果所以核心线程都启动了，返回false，反之返回true。</p>
<p>还有一个和它类似的<code>prestartAllCoreThreads</code>方法，它的作用是一次性启动所有核心线程，让其处于活跃地等待执行任务的状态。</p>
<p>ThreadPoolExecutor的invokeAny方法用于随机执行任务集合中的某个任务，并返回执行结果，该方法是同步方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务集合</span></span><br><span class="line">    List&lt;Callable&lt;Integer&gt;&gt; tasks = IntStream.range(<span class="number">0</span>, <span class="number">4</span>).boxed().map(i -&gt; (Callable&lt;Integer&gt;) () -&gt; &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 随机执行结果</span></span><br><span class="line">    Integer result = threadPoolExecutor.invokeAny(tasks);</span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    threadPoolExecutor.shutdownNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>

<h4 id="invokeAll"><a href="#invokeAll" class="headerlink" title="invokeAll"></a>invokeAll</h4><p>ThreadPoolExecutor的invokeAll则是执行任务集合中的所有任务，返回Future集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    List&lt;Callable&lt;Integer&gt;&gt; tasks = IntStream.range(<span class="number">0</span>, <span class="number">4</span>).boxed().map(i -&gt; (Callable&lt;Integer&gt;) () -&gt; &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    List&lt;Future&lt;Integer&gt;&gt; futureList = threadPoolExecutor.invokeAll(tasks);</span><br><span class="line">    futureList.stream().map(f-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdownNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">allowCoreThreadTimeOut(boolean value)</td>
<td align="left">是否允许核心线程空闲后超时，是的话超时后核心线程将销毁，线程池自动关闭</td>
</tr>
<tr>
<td align="left">awaitTermination(long timeout, TimeUnit unit)</td>
<td align="left">阻塞当前线程，等待线程池关闭，timeout用于指定等待时间。</td>
</tr>
<tr>
<td align="left">execute(Runnable command)</td>
<td align="left">向线程池提交任务，没有返回值</td>
</tr>
<tr>
<td align="left">submit(Runnable task)</td>
<td align="left">向线程池提交任务，返回Future</td>
</tr>
<tr>
<td align="left">isShutdown()</td>
<td align="left">判断线程池是否为shutdown状态</td>
</tr>
<tr>
<td align="left">isTerminating()</td>
<td align="left">判断线程池是否正在关闭</td>
</tr>
<tr>
<td align="left">isTerminated()</td>
<td align="left">判断线程池是否已经关闭</td>
</tr>
<tr>
<td align="left">remove(Runnable task)</td>
<td align="left">移除线程队列中的指定任务</td>
</tr>
<tr>
<td align="left">prestartCoreThread()</td>
<td align="left">提前让一个核心线程处于活跃状态，等待执行任务</td>
</tr>
<tr>
<td align="left">prestartAllCoreThreads()</td>
<td align="left">提前让所有核心线程处于活跃状态，等待执行任务</td>
</tr>
<tr>
<td align="left">getActiveCount()</td>
<td align="left">获取线程池活跃线程数</td>
</tr>
<tr>
<td align="left">getCorePoolSize()</td>
<td align="left">获取线程池核心线程数</td>
</tr>
<tr>
<td align="left">threadPoolExecutor.getQueue()</td>
<td align="left">获取线程池线程队列</td>
</tr>
<tr>
<td align="left">getMaximumPoolSize()</td>
<td align="left">获取线程池最大线程数</td>
</tr>
<tr>
<td align="left">shutdown()</td>
<td align="left">让线程池处于shutdown状态，不再接收任务，等待所有正在运行中的任务结束后，关闭线程池</td>
</tr>
<tr>
<td align="left">shutdownNow()</td>
<td align="left">让线程池处于stop状态，不再接受任务，尝试打断正在运行中的任务，并关闭线程池，返回线程队列中的任务</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>java, 线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Spring循环依赖</title>
    <url>/2020/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<p>所谓循环依赖指的是：BeanA对象的创建依赖于BeanB，BeanB对象的创建也依赖于BeanA，这就造成了死循环，如果不做处理的话势必会造成栈溢出。Spring通过提前曝光机制，利用三级缓存解决循环依赖问题。本节将记录单实例Bean的创建过程，并且仅记录两种常见的循环依赖情况：普通Bean与普通Bean之间的循环依赖，普通Bean与代理Bean之间的循环依赖。</p>
<span id="more"></span>

<h2 id="Bean创建过程"><a href="#Bean创建过程" class="headerlink" title="Bean创建过程"></a>Bean创建过程</h2><p>先通过源码熟悉下Bean创建过程（源码仅贴出相关部分）：</p>
<p>IOC容器获取Bean的入口为AbstractBeanFactory类的getBean方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">extends</span> <span class="title">FactoryBeanRegistrySupport</span> <span class="keyword">implements</span> <span class="title">ConfigurableBeanFactory</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法是一个空壳方法，具体逻辑都在doGetBean方法内：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">extends</span> <span class="title">FactoryBeanRegistrySupport</span> <span class="keyword">implements</span> <span class="title">ConfigurableBeanFactory</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Bean名称</span></span><br><span class="line">        String beanName = transformedBeanName(name);</span><br><span class="line">        Object bean;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从三级缓存中获取目标Bean实例</span></span><br><span class="line">        Object sharedInstance = getSingleton(beanName);</span><br><span class="line">        <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 不为空，则进行后续处理并返回</span></span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ......</span><br><span class="line">                RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// 从三级缓存中没有获取到Bean实例，并且目标Bean是单实例Bean的话</span></span><br><span class="line">                <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                    <span class="comment">// 通过getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory)方法创建Bean实例</span></span><br><span class="line">                    sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 创建Bean实例</span></span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                            ......</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="comment">// 后续处理，并返回</span></span><br><span class="line">                    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> (T) bean;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doGetBean方法中先通过getSingleton(String beanName)方法从三级缓存中获取Bean实例，如果不为空则进行后续处理；如果为空，则通过getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory)方法创建Bean实例并进行后续处理。</p>
<p>这两个方法都是AbstractBeanFactory父类DefaultSingletonBeanRegistry的方法，AbstractBeanFactory层级关系图如下所示：</p>
<p><img src="/images/AbstractBeanFactory%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB%E5%9B%BE.png"></p>
<p>getSingleton(String beanName)相关源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从一级缓存中获取目标Bean实例</span></span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="comment">// 如果从一级缓存中没有获取到，并且该Bean处于正在创建中的状态时</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="comment">// 从二级缓存获取目标Bean实例</span></span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">// 如果没有获取到，并且允许提前曝光的话</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">                    <span class="comment">// 在锁内重新从一级缓存中往下查找</span></span><br><span class="line">                    singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 从三级缓存中取出目标Bean工厂对象</span></span><br><span class="line">                            ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                            <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 工厂对象不为空，则通过调用getObject方法实例化Bean实例</span></span><br><span class="line">                                singletonObject = singletonFactory.getObject();</span><br><span class="line">                                <span class="comment">// 放到二级缓存中</span></span><br><span class="line">                                <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                                <span class="comment">// 删除对应的三级缓存</span></span><br><span class="line">                                <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所谓的三级缓存指的是DefaultSingletonBeanRegistry类的三个成员变量：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>singletonObjects</td>
<td>一级缓存，key为Bean名称，value为Bean实例。这里的Bean实例指的是已经完全创建好的，即已经经历实例化-&gt;属性填充-&gt;初始化以及各种后置处理过程的Bean，可直接使用。</td>
</tr>
<tr>
<td>earlySingletonObjects</td>
<td>二级缓存，key为Bean名称，value为Bean实例。这里的Bean实例指的是仅完成实例化的Bean，还未进行属性填充等后续操作。用于提前曝光，供别的Bean引用，解决循环依赖。</td>
</tr>
<tr>
<td>singletonFactories</td>
<td>三级缓存，key为Bean名称，value为Bean工厂。在Bean实例化后，属性填充之前，如果允许提前曝光，Spring会把该Bean转换成Bean工厂并加入到三级缓存。在需要引用提前曝光对象时再通过工厂对象的getObject()方法获取。</td>
</tr>
</tbody></table>
<p>如果通过三级缓存的查找都没有找到目标Bean实例，则通过getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory)方法创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 从一级缓存获取</span></span><br><span class="line">            Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 为空则继续</span></span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// 方法内会将当前Bean名称添加到正在创建Bean的集合（singletonsCurrentlyInCreation）中</span></span><br><span class="line">                beforeSingletonCreation(beanName);</span><br><span class="line">                <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 通过函数式接口创建Bean实例，该实例已经经历实例化-&gt;属性填充-&gt;初始化以及各种后置处理过程，可直接使用</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    newSingleton = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                   ......</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                    <span class="comment">// 添加到缓存中</span></span><br><span class="line">                    addSingleton(beanName, singletonObject);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> singletonObject;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 添加到一级缓存</span></span><br><span class="line">            <span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">            <span class="comment">// 删除对应的二三级缓存</span></span><br><span class="line">            <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码重点关注singletonFactory.getObject()，singletonFactory是一个函数式接口，对应AbstractBeanFactory的doGetBean方法中的lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Bean实例</span></span><br><span class="line">        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>重点关注createBean方法。该方法为抽象方法，由AbstractBeanFactory子类AbstractAutowireCapableBeanFactory实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">AutowireCapableBeanFactory</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建Bean实例</span></span><br><span class="line">            Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">            <span class="keyword">return</span> beanInstance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doCreateBean源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">AutowireCapableBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 实例化Bean</span></span><br><span class="line">        <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line">        Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行MergedBeanDefinitionPostProcessor类型后置处理器</span></span><br><span class="line">                    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果该Bean是单例，并且allowCircularReferences属性为true（标识允许循环依赖的出现）以及该Bean正在创建中</span></span><br><span class="line">        <span class="comment">// 的话，earlySingletonExposure就为true，标识允许单实例Bean提前暴露原始对象引用（仅实例化）</span></span><br><span class="line">        <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">            <span class="comment">// 添加到单实例工厂集合中，即三级缓存对象，该方法第二个参数类型为ObjectFactory&lt;?&gt; singletonFactory，</span></span><br><span class="line">            <span class="comment">// 前面提到过，它是一个函数式接口，这里用lambda表达式() -&gt; getEarlyBeanReference(beanName, mbd, bean)表示</span></span><br><span class="line">            addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object exposedObject = bean;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 属性赋值操作</span></span><br><span class="line">            populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">            <span class="comment">// 初始化Bean（初始化操作主要包括xxxxAware注入，BeanPostProcessor后置处理器方法调用以</span></span><br><span class="line">            <span class="comment">// 及InitializingBean接口方法调用，感兴趣的可以自己查看源码）</span></span><br><span class="line">            exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果earlySingletonExposure为true</span></span><br><span class="line">        <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">            <span class="comment">// 第二个参数为false表示仅从一级和二级缓存中获取Bean实例</span></span><br><span class="line">            Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                    <span class="comment">// 如果从一级和二级缓存中获取Bean实例不为空，并且exposedObject == bean的话，</span></span><br><span class="line">                    <span class="comment">// 将earlySingletonReference赋值给exposedObject返回</span></span><br><span class="line">                    exposedObject = earlySingletonReference;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 返回最终Bean实例</span></span><br><span class="line">        <span class="keyword">return</span> exposedObject;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">        Object exposedObject = bean;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="comment">// SmartInstantiationAwareBeanPostProcessor类型后置处理，常见的场景为AOP代理</span></span><br><span class="line">            <span class="keyword">for</span> (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) &#123;</span><br><span class="line">                exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exposedObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addSingletonFactory方法为父类DefaultSingletonBeanRegistry的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 一级缓存没有目标Bean实例的话，添加三级缓存</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">                <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">                <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述整个过程可以用下图来总结（可右键选择新标签页中打开图片）：</p>
<p><img src="/images/bean%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.svg"></p>
<p>下面我们通过两个场景来加深理解</p>
<h3 id="普通Bean与普通Bean间的循环依赖"><a href="#普通Bean与普通Bean间的循环依赖" class="headerlink" title="普通Bean与普通Bean间的循环依赖"></a>普通Bean与普通Bean间的循环依赖</h3><p>新建CircularReferenceTest类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularReferenceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(BeanA.class, BeanB.class);</span><br><span class="line">        BeanA beanA = context.getBean(BeanA.class);</span><br><span class="line">        BeanB beanB = context.getBean(BeanB.class);</span><br><span class="line">        BeanB beanBInBeanA = beanA.getBeanB();</span><br><span class="line">        BeanA beanAInBeanB = beanB.getBeanA();</span><br><span class="line">        System.out.println(beanA);</span><br><span class="line">        System.out.println(beanB);</span><br><span class="line">        System.out.println(beanB == beanBInBeanA);</span><br><span class="line">        System.out.println(beanA == beanAInBeanB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanB beanB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanB <span class="title">getBeanB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanB</span><span class="params">(BeanB beanB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanB = beanB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanA beanA;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanA <span class="title">getBeanA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanA</span><span class="params">(BeanA beanA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanA = beanA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码通过AnnotationConfigApplicationContext创建了IOC容器，并先后注册了BeanA和BeanB，BeanA和BeanB相互依赖。程序测试结果如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">com.dougWilson.<span class="symbol">BeanA@</span><span class="number">368f</span>2016</span><br><span class="line">com.dougWilson.<span class="symbol">BeanB@</span><span class="number">6f</span>03482</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>可以看到，Spring成功解决了循环依赖。下面配合源码来分析这个过程</p>
<p>上面程序中，先创建BeanA，Spring内部调用doGetBean方法获取BeanA。一开始三级缓存中肯定没有BeanA和BeanB相关实例：</p>
<p><img src="/images/BeanA%E5%92%8CBeanB%E7%9B%B8%E5%85%B3%E5%AE%9E%E4%BE%8B1.png"></p>
<p><img src="/images/BeanA%E5%92%8CBeanB%E7%9B%B8%E5%85%B3%E5%AE%9E%E4%BE%8B2.png"></p>
<p>所以我们直接看doCreateBean相关源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">AutowireCapableBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 实例化BeanA，BeanA的早期对象，属性还未赋值，还未进行后置处理</span></span><br><span class="line">        <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line">        Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BeanA是单例对象，并且allowCircularReferences为true，BeanA正在创建中，所以</span></span><br><span class="line">        <span class="comment">// 最终earlySingletonExposure为true</span></span><br><span class="line">        <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">            <span class="comment">// 将BeanA早期对象传递给Bean工厂，并添加到三级缓存中</span></span><br><span class="line">            addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object exposedObject = bean;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 属性赋值操作</span></span><br><span class="line">            populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码，Spring实例化了BeanA，然后往三级缓存中添加了BeanA的工厂对象，根据前面getEarlyBeanReference方法的源码我们可以知道，在不存在AOP代理的情况下，该方法直接返回原始BeanA对象。所以通过该工厂方法创建的BeanA对象仅仅是进行了实例化操作，属性还未被赋值，换句话说，该工厂用于提前曝光BeanA实例。</p>
<p>接着调用populateBean方法对BeanA属性赋值，赋值过程发现BeanA依赖于BeanB，所以Spring重复以上步骤创建BeanB。创建过程中同样会遇到populateBean方法对BeanB属性赋值，赋值过程中发现BeanB依赖于BeanA，于是Spring又回头创建BeanA，不过这时候情况就开始不一样了！！</p>
<p>doGetBean方法内部从三级缓存中获取BeanA对象时，三级缓存内容如下：</p>
<p><img src="/images/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B8%AD%E8%8E%B7%E5%8F%96BeanA%E5%AF%B9%E8%B1%A11.png"></p>
<p><img src="/images/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B8%AD%E8%8E%B7%E5%8F%96BeanA%E5%AF%B9%E8%B1%A12.png"></p>
<p><img src="/images/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B8%AD%E8%8E%B7%E5%8F%96BeanA%E5%AF%B9%E8%B1%A13.png"></p>
<p>可以看到一级缓存和二级缓存没有什么不一样，但三级缓存中已经存在BeanA和BeanB的工厂对象了！</p>
<p>所以此时getSingleton(String beanName, boolean allowEarlyReference)方法内的逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="comment">// 一级缓存中没有BeanA，并且BeanA正在创建中</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">// 二级缓存中也没有BeanA</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">                    <span class="comment">// 在锁内重新从一级缓存中往下查找</span></span><br><span class="line">                    singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 从三级缓存中取出目标BeanA的工厂对象</span></span><br><span class="line">                            ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                            <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 工厂对象不为空，调用getObject方法获取前面提前曝光的BeanA早期实例</span></span><br><span class="line">                                singletonObject = singletonFactory.getObject();</span><br><span class="line">                                <span class="comment">// 将BeanA早期实例放到二级缓存中</span></span><br><span class="line">                                <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                                <span class="comment">// 删除对应的三级缓存</span></span><br><span class="line">                                <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回BeanA早期实例</span></span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时查看二级缓存：</p>
<p><img src="/images/%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.png"></p>
<p>可以看到，BeanA确实只是早期实例，属性BeanB还未被赋值。随后BeanB在属性填充的时候获取到了BeanA早期实例，完成属性填充、初始化等后续操作，BeanB创建完毕。BeanB完整创建完毕后，BeanA随之也完成属性填充、初始化等后续操作，BeanA也创建完毕，循环依赖得以解决。</p>
<p>BeanB虽然获取到的是BeanA的早期对象，但当BeanA完整创建完毕后，BeanB里的BeanA也将会是完整的，因为指针指向的都是同一个BeanA地址。</p>
<p>画个图总结上面的过程（可右键选择新标签页中打开图片）：</p>
<p><img src="/images/%E6%99%AE%E9%80%9Abean%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%A7%A3%E5%86%B3.svg"></p>
<h3 id="普通bean与代理bean间的循环依赖"><a href="#普通bean与代理bean间的循环依赖" class="headerlink" title="普通bean与代理bean间的循环依赖"></a>普通bean与代理bean间的循环依赖</h3><p>普通Bean和代理Bean之间的循环依赖和上面过程差不多，不过细节上有些许差异。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(MyApplication.class, args);</span><br><span class="line">        BeanA beanA = context.getBean(BeanA.class);</span><br><span class="line">        BeanB beanB = context.getBean(BeanB.class);</span><br><span class="line">        BeanB beanBInBeanA = beanA.getBeanB();</span><br><span class="line">        BeanA beanAInBeanB = beanB.getBeanA();</span><br><span class="line">        System.out.println(<span class="string">&quot;BeanA是否为代理对象：&quot;</span> + AopUtils.isAopProxy(beanA));</span><br><span class="line">        System.out.println(<span class="string">&quot;BeanB是否为代理对象：&quot;</span> + AopUtils.isAopProxy(beanB));</span><br><span class="line">        System.out.println(<span class="string">&quot;beanAInBeanB是否为代理对象：&quot;</span> + AopUtils.isAopProxy(beanAInBeanB));</span><br><span class="line">        System.out.println(beanB == beanBInBeanA);</span><br><span class="line">        System.out.println(beanA == beanAInBeanB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanB beanB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanB <span class="title">getBeanB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanB</span><span class="params">(BeanB beanB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanB = beanB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanA beanA;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanA <span class="title">getBeanA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanA</span><span class="params">(BeanA beanA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanA = beanA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * cc.mrbird.BeanA.getBeanB())&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;onBefore：&quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot;方法开始执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为MyAspect切面类的存在，BeanA将会是个代理类，而BeanB则是普通Bean，程序输出如下：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">onBefore：getBeanB方法开始执行</span><br><span class="line">BeanA是否为代理对象：<span class="literal">true</span></span><br><span class="line">BeanB是否为代理对象：<span class="literal">false</span></span><br><span class="line">beanAInBeanB是否为代理对象：<span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>假设容器先创建BeanA，过程和上面的例子一致，属性填充时，发现BeanA依赖BeanB，然后Spring开始创建BeanB。创建BeanB时候又发现其依赖BeanA，这时三级缓存中已经存在BeanA的工厂对象了，所以直接通过该工厂对象获取BeanA的早期实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="comment">// 一级缓存中没有BeanA，并且BeanA正在创建中</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">// 二级缓存中也没有BeanA</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">                    <span class="comment">// 在锁内重新从一级缓存中往下查找</span></span><br><span class="line">                    singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 从三级缓存中取出目标BeanA的工厂对象</span></span><br><span class="line">                            ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                            <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 工厂对象不为空，调用getObject方法获取前面提前曝光的BeanA早期实例</span></span><br><span class="line">                                singletonObject = singletonFactory.getObject();</span><br><span class="line">                                <span class="comment">// 将BeanA早期实例放到二级缓存中</span></span><br><span class="line">                                <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                                <span class="comment">// 删除对应的三级缓存</span></span><br><span class="line">                                <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回BeanA早期实例</span></span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>singletonFactory.getObject()实际实现为lambda表达式() -&gt; getEarlyBeanReference(beanName, mbd, bean)，getEarlyBeanReference方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) &#123;</span><br><span class="line">            exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在引入AOP依赖后，容器中将会有一个SmartInstantiationAwareBeanPostProcessor接口的实现类AbstractAutoProxyCreator，用于创建AOP代理，所以上面getEarlyBeanReference方法里的bp.getEarlyBeanReference(exposedObject, beanName)逻辑实际上为AbstractAutoProxyCreator实现的getEarlyBeanReference方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生成缓存Key</span></span><br><span class="line">        Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="comment">// 放入earlyProxyReferences集合中，标识BeanA为早期代理对象</span></span><br><span class="line">        <span class="keyword">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line">        <span class="comment">// 在这个例子中，BeanA将被包装为代理对象</span></span><br><span class="line">        <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以BeanB从三级缓存中获取到的为代理后的BeanA实例：</p>
<p><img src="/images/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%8E%B7%E5%8F%96bean%E5%AE%9E%E4%BE%8B.png"></p>
<p>BeanB创建完毕后，BeanA属性填充操作随之结束。</p>
<p>通过《深入理解Spring AOP原理》对AOP的学习我们知道，代理对象是在后置处理BeanPostProcessor的postProcessAfterInitialization方法内完成的，而该方法的调用时机为Bean属性填充后的初始化操作时，所以在BeanA属性填充操作结束时，BeanA还只是一个普通对象，而BeanB里的BeanA已经是代理对象了。</p>
<p>继续BeanA的创建过程，BeanA属性填充完后，执行initializeBean(beanName, exposedObject, mbd)方法进行初始化操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">AutowireCapableBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        Object exposedObject = bean;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 属性赋值操作</span></span><br><span class="line">            populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">            <span class="comment">// 初始化操作</span></span><br><span class="line">            exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们主要关注初始化操作阶段执行动态代理的后置处理方法过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">            <span class="comment">// 在BeanB填充属性时，BeanA已经被放入到earlyProxyReferences集合中了</span></span><br><span class="line">            <span class="comment">// 所以该if不成立，直接跳过，避免二次代理</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">                <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所以这里返回的还是BeanA原始对象，并非代理对象</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<p>到这里BeanA依旧是普通对象，继续查看doCreateBean方法的后续逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">AutowireCapableBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 原始BeanA赋值给exposedObject</span></span><br><span class="line">        Object exposedObject = bean;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 属性赋值操作</span></span><br><span class="line">            populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">            <span class="comment">// 初始化操作，通过上面分析，此时返回的还是原始的BeanA对象</span></span><br><span class="line">            exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">            <span class="comment">// 从缓存中获取BeanA，此时二级缓存中已经存在BeanA的代理对象了，所以</span></span><br><span class="line">            <span class="comment">// 这里earlySingletonReference为BeanA的代理对象（如下图）</span></span><br><span class="line">            Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// exposedObject和bean相等，因为BeanA并未在初始化的时候被二次代理</span></span><br><span class="line">                <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                    <span class="comment">// 这里将代理对象BeanA赋值给exposedObject</span></span><br><span class="line">                    exposedObject = earlySingletonReference;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 最终返回的exposedObject对象为从二级缓存中获取到的BeanA代理对象</span></span><br><span class="line">        <span class="keyword">return</span> exposedObject;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E4%BE%8Bbean%E6%9C%80%E7%BB%88.png"></p>
<p>到这里，无论是BeanB里的BeanA，还是IOC容器中的BeanA，都是代理后的BeanA了。</p>
<p>画张图总结下上面的过程（可右键选择新标签页中打开图片）：</p>
<p><img src="/images/%E6%99%AE%E9%80%9Abean%E4%B8%8E%E4%BB%A3%E7%90%86bean%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%A7%A3%E5%86%B3.svg"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面的例子都是基于属性注入的情况，假如存在构造器注入情况下的循环依赖，Spring将没办法解决。这是因为对象的提前曝光时机发生在对象实例化之后，而构造器注入时机为对象实例化时，所以此时还未进行提前曝光操作，循环依赖也就没办法解决了，比如下面这种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanB beanB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanA</span><span class="params">(BeanB beanB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanB = beanB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanB <span class="title">getBeanB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanB</span><span class="params">(BeanB beanB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanB = beanB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanA beanA;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanB</span><span class="params">(BeanA beanA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanA = beanA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanA <span class="title">getBeanA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanA</span><span class="params">(BeanA beanA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanA = beanA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序将抛出如下异常：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line"><span class="keyword">Description</span>:</span><br><span class="line"></span><br><span class="line">The <span class="keyword">dependencies</span> of some of the beans in the application context form a cycle:</span><br><span class="line"></span><br><span class="line">┌─────┐</span><br><span class="line">|  beanA defined in <span class="keyword">file</span> [<span class="regexp">/Users/m</span>rbird<span class="regexp">/idea workspace/</span>aop-deep-learn<span class="regexp">/target/</span>classes<span class="regexp">/cc/m</span>rbird/BeanA.<span class="keyword">class</span>]</span><br><span class="line">↑     ↓</span><br><span class="line">|  beanB defined in <span class="keyword">file</span> [<span class="regexp">/Users/m</span>rbird<span class="regexp">/idea workspace/</span>aop-deep-learn<span class="regexp">/target/</span>classes<span class="regexp">/cc/m</span>rbird/BeanB.<span class="keyword">class</span>]</span><br><span class="line">└─────┘</span><br></pre></td></tr></table></figure>

<p>此外，这里讨论了普通Bean与普通Bean之间的循环依赖，代理Bean与普通Bean之间的循环依赖，实际情况还可能存在工厂Bean与普通Bean、代理Bean之间的循环依赖，这种情况比较复杂，本文不讨论，因为就理解Spring解决循环依赖的思想而言，上面两种情况搞清楚了就OK了。</p>
]]></content>
      <tags>
        <tag>spring, 循环依赖</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统</title>
    <url>/2020/11/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>对于长期的信息存储，有三个基本要求：</p>
<ol>
<li>必须能够存储大量的信息</li>
<li>在使用信息的进程终止时，信息必须保存下来</li>
<li>多个进程可以并发地存取信息</li>
</ol>
<p>解决上面所有问题的方法就是将信息以一种单元——**文件(file)**的形式存储在磁盘或其他外部介质上。</p>
<p>文件是通过操作系统管理的，通常的内容为：文件结构选取、命名、使用、保护等。通常而言，操作系统中处理文件部分的服务称为**文件系统(file system)**。</p>
<span id="more"></span>

<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>文件是一个抽象的机制，提供了一种把信息保存在磁盘上而且便于后续读取的方法。通过文件的抽象，用户不必了解信息存储的方法、位置以及磁盘实际运作方式等细节。</p>
<p>各种系统的文件命名的规则略有不同，比如windows系统不区分字母大小写，而在Linux系统中则是严格区分大小写。但所有的操作系统都允许采用数字+字母的字符串作为合法的文件名。</p>
<p>文件命名通常包含两部分：文件名和扩展名，两部分间以 <code>.</code>  分隔，比如 <code>file.c</code> 。</p>
<p>常用扩展名如下：</p>
<table>
<thead>
<tr>
<th>扩展名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>.bak</code></td>
<td>备份文件</td>
</tr>
<tr>
<td><code>.c</code></td>
<td>C语言程序</td>
</tr>
<tr>
<td><code>.f77</code></td>
<td>Fortran 77程序</td>
</tr>
<tr>
<td><code>.gif</code></td>
<td>动态图片格式</td>
</tr>
<tr>
<td><code>.hlp</code></td>
<td>帮助文档</td>
</tr>
<tr>
<td><code>.html</code></td>
<td>网页</td>
</tr>
<tr>
<td><code>.mpg</code></td>
<td>MPEG格式图片</td>
</tr>
<tr>
<td><code>.o</code></td>
<td>对象文件</td>
</tr>
<tr>
<td><code>.ps</code></td>
<td>PostScript文件</td>
</tr>
<tr>
<td><code>.tex</code></td>
<td>TEX格式化程序</td>
</tr>
<tr>
<td><code>.txt</code></td>
<td>文本</td>
</tr>
<tr>
<td><code>.zip</code></td>
<td>压缩包</td>
</tr>
</tbody></table>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>许多操作系统都支持几种类型的文件。比如Windows和Linux操作系统都支持文件和目录。而在Linux系统中，文件还包括正规文件、字符设备文件和块文件设备。正规文件含有用户信息以及需要保存的信息。字符设备文件(character special file)和输入/输出有关，用于模仿串行I/O设备，比如终端、打印机、网络等。块设备文件(block special file)则用于模仿磁盘。</p>
<p>一般来说，正规文件是ASCII文件或二进制文件。ASCII我呢见的最大优点是可以原样地打印和显式，也可以用通常的文本编辑器进行编辑。二进制文件往往具有一定的内部结构，通常是一个可执行文件。</p>
<h3 id="文件存取"><a href="#文件存取" class="headerlink" title="文件存取"></a>文件存取</h3><p>早期的操作系统只提供了一种文件存取方式：顺序存取(sequential access)。在这些系统中，进程从文件开始处顺序读取文件中所有字节或记录，不能略过某些内容，也不能非顺序读取。这在早期的存储媒介是磁带而不是磁盘是，还较为使用方便。</p>
<p>当开始用磁盘存储文件后，就可以非顺序地读取文件中的字节或记录，这种读取文件的方式称为**随机存取文件(random access file)**。</p>
<h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>每个文件都有文件名和数据。此外，操作系统还会给文件赋予其他信息，如：文件创建日期、文件长度、文件属主等。将这些额外的项称为**文件属性(file attribute)**。下面的列表为常见的文件属性：</p>
<table>
<thead>
<tr>
<th>项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>protection</td>
<td>不同类别用户对文件的访问权限</td>
</tr>
<tr>
<td>password</td>
<td>访问文件需要提供的密码</td>
</tr>
<tr>
<td>creator</td>
<td>文件创建者</td>
</tr>
<tr>
<td>owner</td>
<td>文件当前属主</td>
</tr>
<tr>
<td>read-only flag</td>
<td>0表示可读可写；1表示可读</td>
</tr>
<tr>
<td>hidden flag</td>
<td>0表示正常；1表示隐藏</td>
</tr>
<tr>
<td>system flag</td>
<td>0表示普通文件；1表示系统文件</td>
</tr>
<tr>
<td>archive flag</td>
<td>0表示已备份完毕；1表示需要备份</td>
</tr>
<tr>
<td>ASCII/binary flag</td>
<td>0表示ASCII文件；1表示二进制文件</td>
</tr>
<tr>
<td>random access flag</td>
<td>0表示顺序读取；1表示随机读取</td>
</tr>
<tr>
<td>temporary flag</td>
<td>0表示正常；1表示进程结束后删除文件</td>
</tr>
<tr>
<td>lock flag</td>
<td>0表示未锁定；非零表示锁定</td>
</tr>
<tr>
<td>record length</td>
<td>记录的字节数</td>
</tr>
<tr>
<td>key position</td>
<td>关键字在记录中的位置</td>
</tr>
<tr>
<td>key length</td>
<td>关键字的字节数</td>
</tr>
<tr>
<td>creation time</td>
<td>文件创建日期以及创建者名称</td>
</tr>
<tr>
<td>time of last access</td>
<td>文件最后一次访问的时间</td>
</tr>
<tr>
<td>time of last change</td>
<td>文件最后一次修改的时间</td>
</tr>
<tr>
<td>current size</td>
<td>文件当前大小</td>
</tr>
<tr>
<td>maximum size</td>
<td>文件可能达到的大小</td>
</tr>
</tbody></table>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>常用文件操作的系统调用：</p>
<ol>
<li>create。声明文件存在，并设置一些属性</li>
<li>delete。删除文件以得到一些磁盘空间</li>
<li>open。将文件属性和磁盘地址表载入主存，便于之后系统调用的快速存取</li>
<li>close。关闭文件以释放内部表空间</li>
<li>read。从文件中读取数据</li>
<li>write。向文件写入数据</li>
<li>append。在文件末尾添加数据</li>
<li>seek。对于随机存取文件，通过seek系统调用将当前位置指针指向文件中特定位置</li>
<li>get attributes。读取文件属性</li>
<li>set attributes。设置文件属性</li>
<li>rename。文件重命名</li>
</ol>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="层次目录系统"><a href="#层次目录系统" class="headerlink" title="层次目录系统"></a>层次目录系统</h3><p>目录通常包含了许多目录项，每个目录项代表一个文件，其中每个目录项包含文件名、文件属性和文件数据在磁盘上的地址等。两种常见的目录项结构都得到了广泛的应用：</p>
<p><img src="/images/%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7.png"></p>
<p>打开文件时，操作系统查找目录，直到找到要打开文件的文件名。然后从目录项或者所指向的数据结构中取得文件属性和磁盘地址，放入内存的相应表中。之后，对该文件的所有引用都使用主存中的信息。</p>
<p>几乎所有的操作系统都会使用层次目录结构，方便管理，并且每个用户可以拥有需要的多个目录，组织自己的文件。</p>
<p><img src="/images/%E5%B1%82%E6%AC%A1%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png"></p>
<h3 id="路径名"><a href="#路径名" class="headerlink" title="路径名"></a>路径名</h3><p><strong>绝对路径名(absolute path name)：</strong></p>
<p>绝对路径名由根目录到文件的路径组成。如 <code>/usr/ast/mailbox</code> 表示根目录含有子目录usr，而usr中又包含子目录ast，文件mailbox就在目录ast下。</p>
<p>绝对路径名总是从根目录开始，并且是唯一的，路径各部分间用”/“表示隔开。如果一个路径以分隔符“/”开始，那么这个路径名就是绝对路径名</p>
<p><strong>相对路径名(relative path name)：</strong></p>
<p>用户可以指定一个目录为当前工作目录，这时，如果所有的路径名不是从根目录开始的，都是相对于工作目录的。比如当前工作目录为 <code>/usr/ast</code> ，则上述的绝对路径名可以用 <code>mailbox</code> 来引用，实现的功能和绝对路径名完全一样。</p>
<h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p>常用系统调用</p>
<ol>
<li>create。创建目录</li>
<li>delete。删除目录，只有空目录可删除</li>
<li>opendir。目录内容可悲读取。为了列出目录所有文件，列表程序必须先打开该目录，然后读取其中所有文件的文件名</li>
<li>closedir。关闭目录以释放内部表空间</li>
<li>readdir。打开目录下的一个目录项</li>
<li>rename。目录重命名</li>
<li>link。建立目录项链接。指定一个存在的文件和一个路径名，建立从文件到路径所指定的名字的链接，这样，同一个文件可以在多个目录中出现</li>
<li>unlink。删除目录项链接</li>
</ol>
<p>大多数支持层次目录结构的操作系统，在每个目录还有两个特殊的目录项 <code>. 和 ..</code>。<code>对于. 和 ..</code>   ：<code>.</code> 指当前目录，<code>..</code> 指其父目录。</p>
<h2 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h2><p>实现文件存储中最重要的问题是记录各个文件分别用到哪些磁盘块。</p>
<h3 id="实现文件"><a href="#实现文件" class="headerlink" title="实现文件"></a>实现文件</h3><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p>最简单分配方案就是将每个文件作为连续数据块存储在磁盘上。因此，在具有1K大小块的磁盘上，50K的文件要分配50个连续的块。连续分配方案有两大优点：首先，简单，容易实现，记录每个文件用到的磁盘块仅需要记住一个数字即可，也就是第一块的磁盘地址；其次，性能较好，一次操作中就能从磁盘上读取出整个文件。</p>
<p><img src="/images/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E6%96%B9%E6%A1%88.png"></p>
<p>缺点就是：1. 除非创建文件时就知道文件的最大长度，否则该方案行不通 2. 当删除文件的时候会产生磁盘碎片，原本可以使用的空间被浪费了，虽然可以通过磁盘压缩来完成清理，但是磁盘压缩的代价很高，不可取</p>
<h4 id="链接表分配"><a href="#链接表分配" class="headerlink" title="链接表分配"></a>链接表分配</h4><p><img src="/images/%E9%93%BE%E6%8E%A5%E8%A1%A8%E5%88%86%E9%85%8D%E6%96%B9%E6%A1%88.png"></p>
<p>每个块的第一个字用于指向下一块的职责，块的其他部分存放数据。</p>
<p>与连续分配方案不同，这种方法中每个磁盘块都被利用，不会因为磁盘碎片而浪费存储空间。同样，只需要在目录项存放第一个文件块的磁盘地址，文件的其他块可以根据这个地址查找。</p>
<p>虽然在链接表分配方案中，顺序读取非常方便，但是随机读取却相当缓慢。此外，因为指针占去了一些字节，每个磁盘块存储的数据不再是2的指数次幂，这个问题会降低系统的运行效率。</p>
<h4 id="使用索引的链接表分配"><a href="#使用索引的链接表分配" class="headerlink" title="使用索引的链接表分配"></a>使用索引的链接表分配</h4><p>通过取出每个磁盘块的指针，将其放在内存的表的索引中，就可以消除链接表上述的两个不足。</p>
<p>使用索引的链接表分配的缺陷是必须将整个链表都存放在内存中，这会占用一部分内存空间，特别是当磁盘块不是特别大的时候。</p>
<h4 id="i节点"><a href="#i节点" class="headerlink" title="i节点"></a>i节点</h4><p>该方法通过给每个文件赋予一张称为i节点的小型表，列出文件属性和各块在磁盘上的地址。比如：</p>
<p><img src="/images/i%E8%8A%82%E7%82%B9%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95.png"></p>
<p>开始几个磁盘地址存放在i节点内，因此对于小文件，所需信息均在i节点，打开文件时，这些信息仓磁盘读入主存。稍大一些的文件，在i节点中有一个称为一次间接块的磁盘块地址，这个磁盘块中含有附加的磁盘地址。如果文件更大，则可以使用i节点的另一个地址，称为二次间接块地址，二次间接块包含了许多一次间接块的地址，而每个一次间接块又指向几百个磁盘数据块。如果这还不够，还可以使用三次间接块。</p>
<h3 id="实现目录"><a href="#实现目录" class="headerlink" title="实现目录"></a>实现目录</h3><p>在读文件前，必须先打开文件，而打开文件需要获取文件的信息。而文件的信息如何保存，就是这里要讨论的内容。</p>
<p>一般的方法是将文件信息直接存放在目录项中。还有一种是将文件信息存放在i节点中。</p>
<h4 id="存放到目录项"><a href="#存放到目录项" class="headerlink" title="存放到目录项"></a>存放到目录项</h4><p>要查找文件名，文件系统需要做的就是查找目录中的目录项。当找到对应的目录项后，也就知道了文件的磁盘块号。如果我呢见的磁盘块数多于一个目录项所能容纳的数目，就为这个文件分配额外的目录项。</p>
<p><img src="/images/%E7%9B%AE%E5%BD%95%E9%A1%B9.png"></p>
<p>上图各域含义为：</p>
<p>User code：记录文件拥有者</p>
<p>File name 和 Extent：文件的文件名和扩展名</p>
<p>Block count：文件实际使用了16个磁盘块的个数</p>
<p>Disk block numbers：磁盘块号本身，最后一个块可能没有写满</p>
<h4 id="存放到i节点"><a href="#存放到i节点" class="headerlink" title="存放到i节点"></a>存放到i节点</h4><p>每个目录项只包含一个文件名和一个i节点。有关文件类型、长度、时间、磁盘块等信息都放在i节点中。</p>
<p><img src="/images/i%E8%8A%82%E7%82%B9%E7%9B%AE%E5%BD%95%E9%A1%B9.png"></p>
<p>比如查找路径名：/usr/ast/mailbox</p>
<p>首先文件系统找到根目录，因为根目录在磁盘上的固定位置，所以这比较容易。然后在根目录中查找路径的第一部分：usr，获得usr的i节点号。因为每个i节点位于磁盘的固定位置，所以根据i节点号找到i节点是很直接的。找到目录usr后，就会查找下一部分ast，找到ast目录项后，得到目录/usr/ast的i节点号，从而找到目录/usr/ast的i节点，并在该目录中查找文件mailbox。接着文件mailbox的i节点被读入内存，并保存在内存中，直到关闭mailbox文件。</p>
<p><img src="/images/i%E8%8A%82%E7%82%B9%E6%9F%A5%E6%89%BE.png"></p>
<h3 id="文件系统可靠性"><a href="#文件系统可靠性" class="headerlink" title="文件系统可靠性"></a>文件系统可靠性</h3><h4 id="文件系统的一致性"><a href="#文件系统的一致性" class="headerlink" title="文件系统的一致性"></a>文件系统的一致性</h4><p>文件的一致性检查分为两种：块的一致性检查和文件的一致性检查。在检查块的一致性时，该程序建立两张表。每张表中，每块对应有一个计数器，初始值设为0。第一张表的技术及记录了每块在文件中出现的次数，第二张表的计数器记录了每块在空闲块链表中出现的次数。</p>
<p>检验程序读取所有的i节点，从i节点开始，建立相应文件中使用的所有块的块号表。每当读到一个块号时，该块在第一张表中的计数器加1，接着这个程序检查空闲块链表或位图，查找所有未使用的块。每当在空闲表中找到一个块时，在第二张表的计数器加1。</p>
<p>如果文件系统一致，则每个块要么在第一张表中为1，要么在第二张表中为1。其他情况表示文件不一致。</p>
<p>文件的一致性检查除了检查每个磁盘块以外，还检查目录系统。这时也会用到一张计数器表，每个计数器对应于一个文件。检验程序从根目录开始，沿目录树递归下降，检查文件系统每个目录，对每个目录中的文件，其i节点对应的计数器全部加1。</p>
<p>当全部检查完后，得到一张表，对应于每个i节点号，表中给出了指向这个i节点的目录数目，然后，检验程序把这些数字和存储在文件i节点中的链接数目相比较。在一致的文件系统中，这两个数目相吻合。否则则出现两种错误，i节点中的链接数太大或太小。</p>
]]></content>
      <tags>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《Minix操作系统设计与实现》读书笔记</title>
    <url>/2020/10/23/%E3%80%8AMinix%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><blockquote>
<p>进程不等同于程序。一个进程本质上为一个程序的执行。每个进程有自己的地址空间，从0到一个最大值，进程可以读写该空间中的内容。地址空间包括可执行程序、程序的数据及堆栈。与每个进程相关的还包括一组寄存器、程序计数器、指针和其他硬件存储器，以及所有其他所需要的信息</p>
</blockquote>
<span id="more"></span>

<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用为操作系统与程序间的接口。由于系统调用的实现往往与机器有关，并且用汇编语言描述，所以为了C语言程序能够使用系统调用，必须额外提供接口进行访问。</p>
<p>虽然不同机器的系统调用不同，但往往是细节上的不相同，多数操作系统都具有相同功能的系统调用。以MINIX系统为例，MINIX的全部系统调用可以分成53条，6大类：</p>
<ol>
<li><p>进程管理</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>pid = fork()</td>
<td>创建一个与父进程相似的进程</td>
</tr>
<tr>
<td>pid = waitpid(pid, &amp;statloc, opts)</td>
<td>等待一个子进程结束</td>
</tr>
<tr>
<td>s = wait(&amp;status)</td>
<td>waitpid的老版本</td>
</tr>
<tr>
<td>s = execve(name, argv, envp)</td>
<td>替换一个进程的核心映像</td>
</tr>
<tr>
<td>exit(status)</td>
<td>终止进程的执行并返回状态</td>
</tr>
<tr>
<td>size = brk(addr)</td>
<td>设置数据段大小</td>
</tr>
<tr>
<td>pid = getpid()</td>
<td>返回调用进程的标识号</td>
</tr>
<tr>
<td>pid = getpgrp()</td>
<td>返回调用进程的组号</td>
</tr>
<tr>
<td>pid = setsid()</td>
<td>创建一个新的会话并返回其组标识</td>
</tr>
<tr>
<td>I(大写i) = ptrace(req, pid, addr, data)</td>
<td>用于调试</td>
</tr>
</tbody></table>
<p>fork系统调用是创建进程的唯一途径。从方法描述来看，它实际上是做一个调用它的进程的精确拷贝，拷贝内容包括文件描述符，寄存器值等所有内容。fork调用完成后，原进程和拷贝进程（父进程和子进程）二者对应的变量都有相同的值，但因为各自执行，互不相关，所以任一进程变量值的改变都不会对另一个进程产生影响。</p>
<p>执行完fork后，对原进程和拷贝进程各自返回一个数值，对拷贝进程（子进程）返回0，对原进程（父进程）返回一个正整数，值为子进程的pid</p>
<p>当一个进程存在子进程时，不可直接结束，需要执行waitpid系统调用等待子进程结束。waitpid系统调用会使得调用进程阻塞，直到子进程中任意一个结束（将第一个参数pid置为-1）或者指定的子进程结束。waitpid系统调用结束时，子进程的终止状态值（正常结束或异常结束的返回值）将放在第二个参数&amp;statloc指向的地址中。waitpid系统调用方法的第三个参数opts为若干选择项，需要具体查询每个选择项功能。此外，waitpid取代了之前的wait系统调用，但依旧提供wait系统调用，这是为了保持兼容性。</p>
<p>execve的执行过程。当键入一条命令时，Shell首先创建一个新进程，该子进程执行用户命令，然后调用execve系统调用，execve用第一个参数指定的可执行文件替换其核心映像，简化过程如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">	read_command(command, parameters);  /*从终端读取输入*/</span><br><span class="line">	if (fork() != 0) &#123; /*创建子进程执行命令*/</span><br><span class="line">		/*等待子进程退出*/</span><br><span class="line">		waitpid(-1, &amp;status, 0);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		execve(command, parameters, 0); /*执行命令*/</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>execve有三个参数：待执行的文件名，指向参数数组的指针，指向环境变量数组的指针。除了execve外，系统还提供了其他接口方来简化这些参数的使用，如execl，execle，execv 。之后可以用exec来泛指所有这些系统调用。</p>
<p>举个示例来说明execve的执行过程。比如，对于命令 <code>cp file1 file2</code></p>
<p>功能是对文件file1做一个拷贝file2，在Shell创建一个子进程后，子进程执行程序cp，同时向该程序传递执行的参数：源文件名file1和目标文件名file2</p>
<p>cp程序主函数格式为：main(argc, argv, envp) 其中，第一个参数argc是命令行中包括程序名在内的参数个数，对于上述例子，argc=3。第二个参数argv是一个指向数组的指针。该数组的第i个元素就是命令行中的第i个字符串，对于上述例子argv[0]=”cp“, argv[1]=”file1”, argv[2]=”file2”。第三个参数envp是一个环境变量指针，用于将环境信息，如终端类型，用户主目录等传递给程序，对于上述例子，没有向子进程传递任何环境变量，因此envp为空。</p>
<p><strong>MINIX进程的存储空间分为3部分：正文段（text segment 程序代码）、数据段（data segment 变量）、堆栈段（stack segment）</strong>。数据段向上增长，堆栈段向下增长，两者间是空闲区。堆栈的增长随程序的执行自动进行，而数据段的扩展则是通过brk系统调用显式地完成。brk系统调用有一个参数指定数据段的结束地址，它可以比当前值大（数据段扩展）或比当前值小（数据段压缩），但是必须小于堆栈指针，否则堆栈和数据段将重叠，这是不允许的。</p>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E5%AD%98%E5%82%A8.png"></p>
<p>出于对程序员的方便考虑，系统还提供了一个库函数sbrk来改变数据段大小，它的参数是数据段的变化量（负数表示数据段缩小）。</p>
<p>getpid系统调用则是用于返回调用进程的进程标识符。注意在调用fork时，只有父进程能够获得子进程的进程标识符。如果子进程要得到自己的进程标识符，必须使用getpid。同样，getgrp返回进程的组标识符，setsid则启动一个新的会话，并将进程组的pid设置为调用者的pid。</p>
<p>最后一个ptrace系统调用，被调试器用来对被调试程序进程控制，通过ptrace，调试器可以读写被控制进程的地址空间并对其实施其他控制。</p>
</li>
<li><p>信号</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>s = sigaction(sig, &amp;act, &amp;oldact)</td>
<td>定义对信号的处理操作</td>
</tr>
<tr>
<td>s = sigreturn(&amp;context)</td>
<td>从信号返回</td>
</tr>
<tr>
<td>s = sigprocmask(how, &amp;set, &amp;old)</td>
<td>检查或修改信号屏蔽码</td>
</tr>
<tr>
<td>s = sigpending(set)</td>
<td>获取阻塞信号集合</td>
</tr>
<tr>
<td>s = kill(pid, sig)</td>
<td>替换信号频闭码并使进程挂起</td>
</tr>
<tr>
<td>residual = alarm(setconds)</td>
<td>设置时间闹钟</td>
</tr>
<tr>
<td>s = pause()</td>
<td>将调用进程挂起直到下一个信号</td>
</tr>
</tbody></table>
<p>尽管大多数进程间通信是计划好的，但同时还需要处理不可预知的通信问题。比如用户使用文本编辑器要求列出一个大文件的全部内容，但随机认识到该操作并不需要，这时就需要一种方法来中止编辑器的工作。在MINIX中，用户可以通过<kbd>Delete</kbd>键实现这一点。按<kbd>Delete</kbd>键实际上是向编辑器发送一个信号，编辑器收到此信号即停止打印文件的内容。信号还可以报告硬件捕获到的特定的陷入，比如非法指令和浮点运算溢出，超时也是通过信号实现。</p>
<p>当一个信号被发送给一个事先并未声明愿意接收它的进程时，该进程只是简单地被撤销，即被杀死。进程用sigaction系统调用来声明它准备接收的某些类型信号，并同时提供两个地址：一个是信号处理过程的地址 &amp;act ，一个是用于保存该信号的原先处理过程的地址 &amp;oldact 。执行完sigaction系统调用后，此进程如果接收到相关类型的信号，则先将该进程的当前状态压栈，然后调用指定的信号处理过程。信号处理过程可能很长，但一般情况下，它往往很短。信号处理过程结束后，就会调用sigreturn系统调用以继续执行被该信号中断的操作，类似于硬件中的中断返回。</p>
<p>信号可以被阻塞。被阻塞的信号会一直被挂起，直到阻塞解除。在阻塞的这段时间内，它不被传递，也不会丢失。sigprocmask系统调用允许一个进程定义其阻塞的信号集，实现方法是向核心提交一张位图。进程也可以通过sigpending系统调用查询当前因阻塞而挂起的信号集，该信号集以位图方式返回。而sigsuspend系统调用则可以使进程原子性地设定一张阻塞信号位图并将其挂起。</p>
<p>除了对信号进行捕获，程序也可以使用常数 SIG_IGN 来忽略指定类型的信号，或使用 SIG_DFL 来恢复缺省的信号处理过程。缺省的处理方式随信号而异，可以是撤销该进程，忽略该信号。举个例子来说明 SIG_IGN 常数的用法：</p>
<p>command &amp;</p>
<p>该命令希望DEL信号不要对后台进程产生影响，所以该命令在创建完子进程后会执行 sigaction(SIGINT, SIG_IGN, NULL) 和 sigaction(SIGQUIT, SIG_IGN, NULL) 来忽略DEL和quit信号。</p>
<p>按下<kbd>Delete</kbd>键并不是发送信号的唯一途径，使用kill系统调可以向另一个进程发送信号。比如上面的子进程，此时SIGINT和SIGQUIT都已经被屏蔽，所以只能使用kill系统调用来向该进程发送一个信号SIGKILL，撤销该进程。SIGKILL不能被捕获或者忽略。</p>
<p>对于许多实时应用，需要在一段指定时间后，中断进程的原有操作，以进行某种其他处理，为了处理此类的情况，系统提供了alarm系统调用。alarm系统调用的参数指定一个以秒为单位的时间间隔，一旦该时间段到点就会向该进程发送一个SIGALRM信号。在任意时刻，一个进程只能设定一个时间闹钟，如果进程先设定了一个10秒的时间闹钟，3秒后又设定了一个20秒的时间闹钟，那么只有第二个有效。如果alarm系统调用的参数为0，则所有挂起的SIGALRM信号都会被取消。</p>
<p>某些情况下进程在信号到达前不需要做任何操作，如果只是执行一种方法执行空操作循环来等待时间结束，这将浪费CPU时间。这时候，比较好的处理方式就是使用PAUSE调用，挂起调用进程，直到信号到来。</p>
</li>
<li><p>文件管理</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">fd = create(name, mode)</td>
<td>创建一个文件</td>
</tr>
<tr>
<td align="left">fd = mknod(name, mode, addr)</td>
<td>创建普通、设备文件或目录i-节点</td>
</tr>
<tr>
<td align="left">fd = open(file, how, …)</td>
<td>打开一个文件进行读、写或读写</td>
</tr>
<tr>
<td align="left">s = close(fd)</td>
<td>关闭一个打开的文件</td>
</tr>
<tr>
<td align="left">n = read(fd, buffer, nbytes)</td>
<td>从一个文件读数据到一个缓冲区</td>
</tr>
<tr>
<td align="left">n = write(fd, buffer, nbytes)</td>
<td>从缓冲区将数据写入文件</td>
</tr>
<tr>
<td align="left">pos = lseek(fd, offset, whence)</td>
<td>移动文件指针</td>
</tr>
<tr>
<td align="left">s = stat(name, &amp;buf)</td>
<td>获取一个文件的状态信息</td>
</tr>
<tr>
<td align="left">s = fstat(fd, &amp;buf)</td>
<td>获取一个文件的状态信息</td>
</tr>
<tr>
<td align="left">fd = dup(fd)</td>
<td>为打开文件分配一个新文件描述符</td>
</tr>
<tr>
<td align="left">s = pipe(&amp;fd[0])</td>
<td>创建一个管道文件</td>
</tr>
<tr>
<td align="left">s = ioctl(ft, request, argp)</td>
<td>对文件进行特殊操作</td>
</tr>
<tr>
<td align="left">s = access(name, amode)</td>
<td>检查文件是否可访问</td>
</tr>
<tr>
<td align="left">s = rename(old, new)</td>
<td>文件改名</td>
</tr>
<tr>
<td align="left">s = fcntl(fd, cmd, …)</td>
<td>文件加锁及其他操作</td>
</tr>
</tbody></table>
<p>以 fd = create(”abc“, 0751) 为例，该命令将创建一个名为abc的文件，其保护模式为0751（000 111 101 001），表示文件属主可读可写可执行，同组用户可读不可写可执行、其他用户不可读不可写可执行</p>
<p>create系统调用在创建文件的同时还会以写方式将其打开，而不管文件模式如何。而create系统调用返回的文件描述符fd可用于对该文件执行写操作。如果对一个已经存在的文件进行create操作，在操作权限许可的情况下，该文件内容会遭到破坏。open系统调用也可创建文件，create系统调用属于过时的系统调用，只不过为了兼容性而得以保留。</p>
<p>以 fd = mknod(“/dev/ttyc2”, 020744, 0x0402) 为例，mknod系统调用用于创建设备文件。该命令会创建一个一个名为”/dev/ttyc2”的文件（二号控制台常用文件名），并将其模式代码设置为八进制的020744（意为该文件是字符设备文件，保护模式为rwxr–r–），第三个文件参数的高字节指定其主设备号为4，低字节指定其设备号为2。主设备号可以取任意值，但是名为/dev/ttyc2的文件设备号应该只为2。mknod系统调用只能被超级用户使用。</p>
<p>读写一个文件之前必须首先用open系统调用打开，open系统调用的第一个参数指定文件路径名，可以使用绝对路径或者相对路径。第二个参数指定文件的打开方式，O_RDONLY，O_WRONLY，O_RDWR表示可读、可写、可读可写。open系统调用返回的文件描述符可以用于文件读写。文件在操作完毕后，要用close系统调用将其关闭，这样，该文件的文件描述符可以供之后的create和open系统调用再次使用。</p>
<p>read和write系统调用是最常见的系统调用，以read系统调用为例，write系统调用和其类似。多数程序对文件的读写是按顺序进行的，但有些却需要随机的访问文件的任意部分。每个文件都有一个指针指明其当前读写位置。在顺序读写时，该指针通常指向下次要读写的字节。使用lseek系统调用可以修改文件指针的值，这样随后的read或write系统调用就可以在文件的任一位置进行操作。</p>
<p>lseek系统调用有3个参数：第一个参数指定文件描述符，第二个参数指定文件的位置，第三个参数指名文件位置是相对文件开头、当前位置、还是文件尾。lseek返回值是文件指针被修改之后的绝对位置。</p>
<p>对于每个文件，MINIX系统记录下了如下文件信息：文件类型（普通文件、设备文件、目录），文件大小，最后修改时间等。程序可以通过stat系统调用或fstat系统调用获取这些信息，不同之处在于stat通过文件名来指定文件，而fstat通过文件描述符来指定文件。也正因如此，fstat系统调用适用于已经打开的文件。stat和fstat系统调用的第二个参数指定一个用于存放所获取信息的数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> st_dev;				<span class="comment">/*i节点所驻留的设备*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> st_ino;		<span class="comment">/*i节点号*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> st_mode;		<span class="comment">/*模式*/</span></span><br><span class="line">    <span class="keyword">short</span> st_nlink;				<span class="comment">/*链接数*/</span></span><br><span class="line">    <span class="keyword">short</span> st_uid;				<span class="comment">/*用户标识符*/</span></span><br><span class="line">    <span class="keyword">short</span> st_gid;				<span class="comment">/*组标识符*/</span></span><br><span class="line">    <span class="keyword">short</span> st_rdev;				<span class="comment">/*设备文件的主次设备号*/</span></span><br><span class="line">    <span class="keyword">long</span> st_size;				<span class="comment">/*文件大小*/</span></span><br><span class="line">    <span class="keyword">long</span> st_atime;				<span class="comment">/*最后访问时间*/</span></span><br><span class="line">    <span class="keyword">long</span> st_mtime;				<span class="comment">/*最后修改时间*/</span></span><br><span class="line">    <span class="keyword">long</span> st_ctime;				<span class="comment">/*对i节点最后修改时间*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>dup系统调用常用于对文件描述符的操作。比如一个程序需要关闭标准输出（文件描述符为1），用一个普通文件取代成为标准输出，随后向标准输出写一些信息，最后恢复原先的状态。为了实现这些功能可以先关闭文件描述符1，再打开另一个文件，这时该文件就成为了标准输出，但这样做无法恢复原先的标准输出。解决方法就是先调用 fd = dup(1) 该操作将为标准输出分配一个新的文件描述符fd，对fd的操作和直接对标准输出的操作完全一样。随后将标准输出关闭，再打开一个新文件，该文件就会成为标准输出。当需要恢复原先的标准输出时，先关闭文件描述符1，再执行 n=dup(fd) 将最小的文件描述符符号 1 ，定向到fd所指向的文件，最后将fd关闭就恢复了最初的状态。</p>
<p>MINIX中的进程间通信使用管道。比如对于一个命令 cat file1 file2 | sort  Shell将创建一个管道并将第一个进程的标准输出信息写到管道中，于是第二个进程的标准输入就可以从该管道中读取。pipe系统调用将创建一个管道并返回两个文件的描述符，一个用于写，一个用于读。pipe系统调用格式为 pipe(&amp;fd[0]) 这里的fd是由两个整数组成的数组，fd[0] 存放供读使用的文件描述符，fd[1] 存放供写使用的文件描述符。通常典型的用法是在本条语句后调用一个fork创建一个子进程，然后父进程关掉用于读的文件描述符，子进程关掉用于写的文件描述符（或者相反），这样便可以做到一个进程从管道读取数据，另一个向管道写数据。下面的程序描述了这一过程。创建了两个进程，通过管道将进程1的输出导向进程2（只是简单描述，省略参数检查等操作）。其处理过程如下：首先创建一个管道，随后调用fork，将父进程作为管道中的进程1，子进程作为进程2，由于待运行的两个文件process1和process2并不知道它们是管道的一部分，所以必须对文件描述符进行控制以使进程1的标准输出和进程2的标准输入都指向管道。父进程首先关掉从管道读的文件描述符和标准输出，随后执行dup系统调用，这样使得文件描述符1可被用于向管道写。然后程序关闭另一个管道描述符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STD_INPUT 0				<span class="comment">/*标准输入的文件描述符*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STD_OUTPUT 1			<span class="comment">/*标准输出的文件描述符*/</span></span></span><br><span class="line"></span><br><span class="line">pipeline(process1, process2) &#123;</span><br><span class="line">    <span class="keyword">char</span> *process1, *process2;  <span class="comment">/*指向程序名的指针*/</span></span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];					<span class="comment">/*创建一个管道*/</span></span><br><span class="line">    pipe(&amp;fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (fork() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*父进程指向如下语句*/</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);			<span class="comment">/*进程1不需要从管道读*/</span></span><br><span class="line">        close(STD_OUTPUT);		<span class="comment">/*准备新的标准输出*/</span></span><br><span class="line">        dup(fd[<span class="number">1</span>]);				<span class="comment">/*将标准输出指向fd[1]*/</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);			<span class="comment">/*此文件描述符不再需要*/</span></span><br><span class="line">        execl(process1, process1, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(fd[<span class="number">1</span>]);			<span class="comment">/*进程2不需要向管道写*/</span></span><br><span class="line">        close(STD_INPUT);		<span class="comment">/*准备新的标准输入*/</span></span><br><span class="line">        dup(fd[<span class="number">0</span>]);				<span class="comment">/*将标准输入指向fd[0]*/</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);			<span class="comment">/*此文件描述符不再需要*/</span></span><br><span class="line">        execl(process2, process2, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在exec系统调用之后，父进程将保留文件描述符0和2，而文件描述符1则用于向管道中写。子进程的代码与父进程类似。execl的参数被重复，因为其第一个参数是待执行的文件名，而第二个参数是执行文件的第一个参数，对多数程序来说，该参数都是文件名。</p>
<p>ioctl系统调用适用于所有设备文件，可用于设备驱动程序。比如SCSI设备驱动程序用它来控制磁带机和CD-ROM。但是其主要还是用于字符设备文件，尤其是终端。POSIX定义的许多函数，最终都转换成了ioctl系统调用，比如tcgetattr和tcsetattr使用ioctl来改变终端的模式和各种属性。常见的终端模式有：Cooked模式，在该模式下，删除键和终止键能正常地工作，<kbd>Ctrl+S</kbd>用于停止终端输出，<kbd>Ctrl+Q</kbd>用于恢复终端输出，<kbd>Ctrl+D</kbd>文件结束，<kbd>Ctrl+\</kbd>退出并强制进行核心映像转储；Raw模式，所有这些功能被取消，每个字符都被不加处理地发送给程序，并且不等一行结束就将从终端读到的每个字符发送给程序；Cbreak模式介于两者之间，删除键，终止键，以及<kbd>Ctrl+D</kbd>被屏蔽，其他仍然有效。 </p>
<p>access系统调用检查对一个文件是否具有某种访问权限。rename系统调用更改文件名字，参数分别指定老文件名和新文件名。fcntl系统调用对文件进行控制，有若干个选项，常用选项就是文件加锁。使用fcntl可以对一个文件的一部分加锁解锁，也可以检测一个文件的某个部分是否被上锁。</p>
</li>
<li><p>目录及文件系统管理</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>s = mkdir(name, mode)</td>
<td>创建一个目录</td>
</tr>
<tr>
<td>s = rmdir(name)</td>
<td>删除一个空目录</td>
</tr>
<tr>
<td>s = link(name1, name2)</td>
<td>创建一个新文件name2指向name1</td>
</tr>
<tr>
<td>s = unlink(special, name, flag)</td>
<td>删除一个目录项</td>
</tr>
<tr>
<td>s = mount(special, name, flag)</td>
<td>安装一个文件系统</td>
</tr>
<tr>
<td>s = unmount(special, name, flag)</td>
<td>卸载一个文件系统</td>
</tr>
<tr>
<td>s = sync()</td>
<td>将缓冲的数据块写回到磁盘</td>
</tr>
<tr>
<td>s = chdir(dirname)</td>
<td>改变工作目录</td>
</tr>
<tr>
<td>s = chroot(dirname)</td>
<td>改变根目录</td>
</tr>
</tbody></table>
<p>mkdir和rmdir用于创建目录和删除<strong>空目录</strong>。link系统调用运行同一个文件按不同路径名出现，比如开发小组几个成员共享一个文件，同时该文件出现在每个人自己的目录下。共享一个文件不同于给每个人一个私有的拷贝，对前者，任何一个人的所有修改都对其他人可见，因为只存在一个文件；而对于后者，所有的修改只对自己可见，而不会更新其他人的拷贝。比如下面这个例子：</p>
<p><img src="/images/link%E6%96%87%E4%BB%B6.png"></p>
<p>link(“/usr/jim/memo”, “/usr/ast/note”)</p>
<p>该命令会将jim目录下的文件memo以文件名note出现在ast目录下，此后/usr/jim/memo和/usr/ast/note指的是同一个文件。而且理解link系统调用工作原理有助于理解文件。MINIX中的每个文件都有一个唯一的数字：i节点号（i-node）来标识。i节点号也是i节点表的索引值，每个文件都有一个i节点，里面存放文件属主以及该文件所占用磁盘块等信息。目录实际上也是文件，只是其内容存放的是一些i节点和文件名的对应信息。link所作的只是创建一个新的目录项，它有一个新文件名，但i节点号则是被链接的文件的i节点号。link目录项中的任何一个被unlink系统调用删除，只有存在目录项，则相关的文件也继续存在，如果都被删除，MINIX检测到没有目录项指向该文件（i节点包含一个字段，记录指向该文件的目录项数），则该文件被从磁盘上删除。</p>
<p>mount系统调用可将两个文件系统合并成一个，通常情况是现有一个存在于RAM盘上的跟文件系统，其中包含有常用命令的可执行文件及其他常用文件。然后用户可以在驱动器0中插入一张存有用户程序的软盘。使用mount系统调用就可以将软盘上的文件系统安装到根文件系统下（执行安装操作的典型C语句为：mount(“/dev/fd0”, “/mnt”, 0) 第一个参数是软驱的设备文件名，第二个参数指定在文件树中的安装点），如下图所示：</p>
<p><img src="/images/mount%E6%96%87%E4%BB%B6%E6%A0%91.png"></p>
<p>执行完mount操作后，软驱上的文件即可通过路径名访问而与具体的物理设备无关。当一个文件系统不需要时，就可用umount系统调用将其卸装。</p>
<p>MINIX在内存中开辟了一个缓冲区以保存最近经常访问的磁盘数据，这样可以避免重复地从磁盘上读取数据。如果缓冲区的某块数据被修改，而在其被写回磁盘之前系统发生崩溃，那么文件系统可能被损坏。为了避免这种现象，必须周期性地将这些缓冲区中的数据写回磁盘。sync系统调用就是用来将被修改的缓冲区数据写回磁盘。MINIX启动后，一个名为update的程序将被启动作为后台进程运作，每隔30秒执行一次sync系统调用，将更新了的数据写回磁盘。</p>
<p>和目录操作有关的另外两个系统调用是chdir和chroot，chdir改变当前工作目录，chroot改变根目录。</p>
</li>
<li><p>保护</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>s = chmod(name, mode)</td>
<td>改变文件的保护位</td>
</tr>
<tr>
<td>uid = getuid()</td>
<td>获取调用进程的uid</td>
</tr>
<tr>
<td>gid = getgid()</td>
<td>获取调用进程的gid</td>
</tr>
<tr>
<td>s = setuid(uid)</td>
<td>设置调用进程的uid</td>
</tr>
<tr>
<td>s = setgid(gid)</td>
<td>设置调用进程的gid</td>
</tr>
<tr>
<td>s = chown(name, owner, group)</td>
<td>改变文件的属主和组</td>
</tr>
<tr>
<td>oldmask = umask(complmode)</td>
<td>改变模式屏蔽码</td>
</tr>
</tbody></table>
<p>MINIX中每个文件都包含一个11比特的保护方式码，其中的9比特标识文件属主，同组用户，其他用户的操作权限。chmod系统调用可以改变文件的保护方式（详情见另外一篇文章《Linux常用命令》）。</p>
<p>当一个进程执行一个setuid或setgid设置文件时，会获得有效uid和有效gid（不同于真实uid或gid）。如果需要获得真实和有效的uid和gid，可以通过getuid和getgid系统调用获取这些信息。</p>
<p>umask和chown系统调用也见另一篇文章《Linux常用命令》</p>
</li>
<li><p>时间管理</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>seconds = time(&amp;seconds)</td>
<td>获取从1970年1月1号以来的时间</td>
</tr>
<tr>
<td>s = stime(tp)</td>
<td>设置从1970年1月1号以来的时间</td>
</tr>
<tr>
<td>s = utime(file, timep)</td>
<td>设置文件的最后访问时间</td>
</tr>
<tr>
<td>s = times(buffer)</td>
<td>获取到当前所用的用户和系统时间</td>
</tr>
</tbody></table>
<p>MINIX有4条用于管理实践的系统调用。功能见描述</p>
</li>
</ol>
<h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><h3 id="整体式系统"><a href="#整体式系统" class="headerlink" title="整体式系统"></a>整体式系统</h3><p>整体式系统是常用的组织方式，整个操作系统是一堆过程的集合，每个过程可以调用任意其他过程。系统在的每个过程都有一个定义完好的接口，有入口参数和返回值，相互间的调用不受约束。</p>
<p>在整体式系统中，为了构造最终的目标操作系统程序，开发人员首先将一些独立的过程进行边缘，然后用链接过程将其链接在一起成为一个单独的目标程序。从信息隐藏的观点看，它没有任何程度的隐藏——每个过程对其他过程可见。</p>
<p>但即使是在整体式系统中，也存在一些程度很低的结构化。比如操作系统提供的系统调用的调用过程：将参数放入预先确定的寄存器或堆栈中，然后执行一条特殊的陷入指令，称为<strong>核心调用（kernel call）</strong>指令。</p>
<p>操作系统随后检查该调用的参数以确定应执行哪条系统调用，然后，操作系统查一张系统调用表，其中记录了每条系统调用的执行古城，它确定了将调用的服务过程。当系统调用结束后，控制又返回给用户程序，于是继续执行系统调用后面的语句。</p>
<p><img src="/images/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81.png"></p>
<p>这种组织方式提出了操作系统一种基本结构：</p>
<ol>
<li>一个用来调用被请求服务例程的主程序</li>
<li>一套执行系统调用的服务例程</li>
<li>一套支持服务例程的实用过程</li>
</ol>
<p><img src="/images/%E6%95%B4%E4%BD%93%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E5%8D%95%E7%BB%93%E6%9E%84.png"></p>
<h3 id="客户-服务器系统"><a href="#客户-服务器系统" class="headerlink" title="客户/服务器系统"></a>客户/服务器系统</h3><p>现代操作系统的一个趋势是将代码移到更高层次的思想进一步发展，从操作系统中去掉尽可能多的东西，而只留一个最小的核心。通常的方法是将大多数操作系统功能由用户进程来实现。比如读取文件中的一块，用户进程将此请求发送给一个服务器进程，服务器进程随后完成此操作并将回答信息送回。</p>
<p>该模型中，核心的全部工作是处理客户与服务器间的通信，操作系统被分割成许多部分，每一部分只处理一方面的功能，如文件服务、进程服务、终端服务或存储服务。这样每一部分变得更小，更易于管理。而且由于所有服务器以用户进程的形式运行，而不是运行在核心态，所以它们不直接访问硬件。这样处理的结果是：加入文件服务器中发生错误，文件服务器可能崩溃，但不会导致整个系统崩溃。</p>
<p><img src="/images/%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B.png"></p>
<p>客户-服务器模型的另一个优点就是它适用于分布式系统。如果一个客户通过消息传递与服务器通信，客户无需知道这条消息是在本机进行处理还是通过网络传送给远程机器的服务器。在这两种情况下，客户机的处理都是一样的：发送一个请求，收回一个应答。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%A2%E6%88%B7%E6%A8%A1%E5%9E%8B.png"></p>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>存储器管理</title>
    <url>/2020/11/12/%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>存储器（内存，主存）是一种需要仔细管理的资源。虽然每个程序员都希望自己计算机的主存有无限大，然后一些麻烦的事情就不用考虑了。但是，这在现实中并不存在，于是，学好如何管理内存，是一个程序员（码农）需要掌握的基本功。</p>
<span id="more"></span>

<h2 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h2><p>交换是一种简单的内存管理方法。通过将各个进程完整地调入主存运行，切换进程时再将进程放回到磁盘上。比如下面的示例：</p>
<p><img src="/images/%E4%BA%A4%E6%8D%A2.png"></p>
<p>开始时只有进程A在主存，然后进程B和C被创建或从磁盘上被调入。之后当进程A结束或被交换到磁盘上，进程D被调入。接着B离开内存，E进程进入。</p>
<p>从这个过程也可以发现，当内存进行进程交换时，相邻进程间会有未使用内存部分，称之为<strong>空洞</strong>。当交换在内存中生成多个空洞时，可以将所有的进程向下移动至相互靠紧，从而将这些空洞结合成一大块，这种计数称为**内存紧缩(memory compaction)**。但通常不进行这个操作，因为需要耗费大量的CPU时间。比如一个32M的主存，假设每微秒可以拷贝16个字节，那么将内存紧缩一次需要2秒钟。</p>
<p>另一个问题就是，如果进程的数据段是可以增长的，那么进程一旦试图增长时问题就出现了。如果要增长的进程紧邻一个空洞，那这还可以通过将空洞的内存空间分配给该增长进程。然而，如果进程邻接的是另一个进程，则需要增长的进程将被移动到一个足够大的空洞中去，或者交换出多个进程以形成一个足够大的空洞。如果一个进程不能在内存中增长并且磁盘的交换分区满了，那么这个进程就必须被杀死。</p>
<p>在实际情况中，大多数进程在运行时都会增长，为了减少进程因为内存空间不够而引起的移动和交换所带来的开销，另一种方法就是：在进程被交换进内存或者在内存中移动时就额外为其多分配一些内存。如下图所示</p>
<p><img src="/images/%E5%A2%9E%E9%95%BF%E7%A9%BA%E9%97%B4.png"></p>
<p>在这个图中可以看到所示进程的栈段在进程所占用内存的顶端并向下增长，紧接在正文段后面的数据段向上增长，处于这两个段间的内存，两个段都可以使用，如果用完了，则这个进程必须必须被移动到足够大的空洞中。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>动态分配内存必须由操作系统管理，而一般有两种方法跟踪内存的使用情况：位图和</p>
<p>链表。</p>
<p>使用位图方法时，内存被划分为若干字节的分配单位，分配单位可能小到几个字节，也有可能大到几千个字节，各有优缺点。每个分配单位对应于位图中的一位，1表示占用，0表示空闲（或者相反）。</p>
<p>使用位图时，分配单位的大小是首先要考虑的设计因素。分配单位越小，位图越大，比如4字节32位内存也只需要位图中的1位，32*n位的内存也只需要n位的位图。如果分配单位选的比较大，需要的位图就比较小。</p>
<p>位图的主要问题就是，当将一个占K个分配单位的进程调入内存时，内存管理器必须搜索位图以找出一串k个连续的0，而在位图中查找长度连续的0串是一个缓慢的操作。</p>
<p><img src="/images/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png"></p>
<p>如上图所示，通过维持一个已分配和空闲的内存段的链表也可以进行内存的管理。当进程和空洞按照地址顺序存放在链表中时，可以通过几种算法来为要换进内存的进程分配空间。</p>
<p>首次适配算法：内存管理器沿着内存段链表搜索直到找到一个足够大的空洞，除非空洞的大小和要分配的空间大小刚好意义，否则这个空洞将被分成两部分，一部分供进程使用，一部分是未使用的内存，依然是空洞。</p>
<p>下次适配算法：工作方式和首次适配相同，区别是每次找到合适的空洞都记下当时的位置，在下次寻找空洞的时候不必从头开始搜索，而是从上次结束的地方开始搜索。</p>
<p>最佳适配算法：搜索整个链表以找出够用的最小的空洞，而不是将一个以后会用到的大空洞先使用。</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>当一个进程比内存还大的时候，该如何执行这个进程？这并不是笑话，随着现代计算机计数以及软件的发展，程序被设计的越来越庞大，用于处理复杂的问题。如何在有限的内存中运行这些庞然大物？这既是这里要讨论的问题。</p>
<p>这个方法被称作**虚拟内存(virtual memory)**。虚拟内存的基本思想是程序、数据】堆栈的总的大小可以超过可用物理存储器的大小，操作系统把程序当前使用的那些部分保留在内存中，而其它部分保留在磁盘上，并在需要的时候在内存和磁盘间交换程序的片段。</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>考虑这样一条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOVE REG, 1000</span><br></pre></td></tr></table></figure>

<p>该指令将地址为1000的内存单元的内容复制到REG中。</p>
<p><strong>由程序产生的地址称为虚拟地址(virtual address)<strong>，虚拟地址构成的空间称为</strong>虚拟地址空间(virtual address space)<strong>。在没有虚拟内存的计算机上，虚拟地址直接送到内存总线上，相应地址的物理内存被读写。而如果使用虚拟内存，虚拟地址不是直接被送到内存总线上，而是送到</strong>内存管理单元（MMU）</strong>，内存管理单元由一个或一组芯片组成，功能是将虚拟地址映射为物理地址。下面举例说明：</p>
<p>一台计算机只有32K的内存，现在有一个64K的程序。很明显，程序不能完全调入内存运行，在磁盘上必须有一个64K的程序的完整内核映像，以保证程序片段在需要时能被调入。</p>
<p><img src="/images/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84.png"></p>
<p>虚拟地址空间被划分成称为<strong>页(page)<strong>的单位，在物理存储器中对应的单位称为</strong>页框(page frame)<strong>。页和页框总是同样大小的，在这个例子中是4K，但现在的操作系统中常用的页的大小是512字节到64K。一定注意：</strong>内存和磁盘间传输的单位总是以页为单位的</strong>。</p>
<p>在这个例子中，一共有16个虚拟页和8个页框。</p>
<p>当程序试图访问地址0时，虚拟地址0将被送往内存管理单元MMU，MMU看到虚拟地址落在页0范围内（0<del>4095），根据对应的映射，可知虚拟页0对应的是页框2(8192</del>12287)，因此MMU将虚拟地址0转换为物理地址8192，并把物理地址8192送到内存总线上。内存板对于MMU一无所知，只知道内存总线上有一个对内存地址8192读或写的请求，并执行它。从而MMU有效地把所有从0到4095的虚拟地址映射到了8192到12287的物理地址。其它存在映射关系的虚拟页情况以此类推。</p>
<p>但是图中还有部分虚拟页并没有被映射到8个页框中的任何一个，如果程序试图访问为映射的页，会怎么样？答案是，当MMU发现页没有映射时，会使CPU陷入操作系统，该陷入称为缺页故障。操作系统会找到一个很少使用的页框并把它的内容写入磁盘，随后把需要引用的页取到刚才释放的页框中，修改映射，然后重新启动引起陷入的指令。</p>
<p>比如，假设操作系统决定放弃页框1，并装入虚拟页8。那么它将把虚拟页8装入物理地址4K，并对MMU作两处修改：1. 标记虚页1为未映射，以便使以后任何对虚拟地址4K到8K的访问都引起陷入 2. 将虚页8对应的表项改为1，因此在引起陷入的指令重新启动时，它将把虚拟地址32780映射为物理地址4108。</p>
<h3 id="MMU内部结构"><a href="#MMU内部结构" class="headerlink" title="MMU内部结构"></a>MMU内部结构</h3><p>通过一个例子：虚拟地址8096（0010 0000 0000 0100）如何在MMU中转换为物理地址24580（1100 0000 0000 0100）</p>
<p><img src="/images/MMU%E6%93%8D%E4%BD%9C.png"></p>
<p>从图中的转换过程可知，输入的16位虚拟地址被划分成4位的页号和12位的偏移量，4位的页号可以表示16个页面，12位的偏移可以 为 一页内的4096个字节 编址。</p>
<p>页号用作页表的索引，以得出对应于这个虚页的页框号。如果Present/absent位是0，则将引发一个操作系统陷入；如果是1，在页表中查到的页框号将被复制到输出寄存器的高3位中，加上输入虚拟地址中的12位偏移量，就构成了15位的物理地址。输出寄存器的内容随机被作为物理地址送到内存总线。</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>从上面的解释可以直到，虚拟地址被分为虚拟页号和偏移量两部分。偏移量直接拷贝到MMU输出寄存器中，而虚拟页号被用作页表的索引以找到该虚夜对应的页表项，从页表项中可以找到页框号（如果有的话），随后页框号直接被拼接到寄存器的高位端，形成内存的物理地址。</p>
<p>这里页表需要面对两个问题：</p>
<ol>
<li>页表可能非常大</li>
<li>地址映射必须十分迅速</li>
</ol>
<p>对于第一个问题，现代计算机的虚拟地址最少也会有32位，当页大小为4K时，意味着有一百万个页，对于64位的虚拟地址，则更多。因此，虚拟地址空间中的一百万个页需要一百万个页表项的页表，并且每个进程也需要有自己的页表。</p>
<p>对于第二个问题，虚拟地址到物理地址的映射几乎每时每刻都在进行。假如执行一条指令需要10纳秒，则页表的查找必须在几个纳秒内完成以避免成为性能的主要瓶颈。</p>
<p>那么对于以上问题，就会有两个解决的思路：第一个就是不将页表放在内存中，放在寄存器或某个特殊的硬件。第二个就是将页表全部放在内存中，这意味着所有指令的执行都需要一次或多次访问内存。这两个思路单独存在都不是最优的方法，下面是解决方案。</p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>多级页表避免将庞大的页表始终保存在内存中，特别是不需要用到的页表就不应该保留。下面是一个具体示例：</p>
<p>32位的虚拟地址被划分成10位的PT1域、10位的PT2域、12位的偏移量。因为偏移量为12位（0~4095），所以页大小为4K。</p>
<p><img src="/images/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8.png"></p>
<p>（4GB=4*1024*1024K=1024*1024个页） 4G表示4G的虚拟地址空间</p>
<p>顶级页表有1024个表项，对应于10位的PT1域，每个表项指向一块4M（1024个页）的虚拟地址空间块。当一个虚拟地址被送到MMU时，MMU首先找出虚拟地址的PT1域并将其作为访问顶级页表的索引。通过索引得到的顶级页表表项包含有二级页表的地址或页框号，<strong>顶级页表的表项0指向程序正文的页表、表项1指向数据的页表、表项1023指向堆栈的页表（这体现了动态扩展），其它表项表项表示未用</strong>。</p>
<p>PT2域用于访问选定的二级页表的索引以找到对应虚夜的页框号。</p>
<p>比如一个虚拟地址4206596，处于数据部分12292字节处，对应的PT1=1，PT2=3，Offset=4。MMU首先用PT1作为索引，访问顶级页表得到表项1，说明指向数据部分，对应地址范围为4M到8M。随后它用PT2作为索引访问刚刚找到的二级页面得到表项3，表项3对应的地址范围为它的4M块范围内的12288~16383。这个表项含有虚拟地址4206596所在页的页框号。如果这个页不在内存中，则present/absent位为0，一个页面将引起陷入；如果这个页在内存中，从二级页表得到的页框号将和偏移量4结合成物理地址并通过内存总线访问内存。</p>
<p>通过多级页表，虽然地址空间超过一百万个页，但实际上只需要4个页表：顶级页表、0<del>4M、4M</del>8M和顶端4M的二级页表。顶级页表中有1021个表项（除了0，1，1023）的present/absent为被设为0，使得访问他们时强制产生一个页面故障。如果这种情况发生了，操作系统将知道进程在试图访问一个不期望被访问的地址并采取行动，比如向进程发出一个信号或杀死进程。</p>
<p>上面所展示的只是二级页表，也可以有三级页表、四级页表等等。尽量不要超过三级页表。</p>
<p>最后讨论一下页表项的结构：</p>
<p><img src="/images/%E9%A1%B5%E8%A1%A8%E9%A1%B9.png"></p>
<ul>
<li>页框号</li>
<li>present/absent bit </li>
<li>保护位，表示这个页允许什么样的访问。最简单的形式保护位只有一位，0表示读写，1表示写。而常用的是使用3位，每个位分别指出是否允许读、写、执行</li>
<li>修改位和引用referenced用于跟踪页的使用。一个页被写入时硬件自动设置修改位。引用位在页被引用时设置</li>
<li>是否允许缓存位可禁止该页被缓存</li>
</ul>
<h4 id="TLB-Translation-Lookaside-Buffers"><a href="#TLB-Translation-Lookaside-Buffers" class="headerlink" title="TLB(Translation Lookaside Buffers)"></a>TLB(Translation Lookaside Buffers)</h4><p>TLB——转义后备缓冲器。为什么需要这个硬件，还是因为页表和内存间关系的问题：</p>
<p>如果将页表放在内存中，这种设计对性能有很大影响。比如把一个寄存器的内容复制到另一个寄存器的指令，在不使用分页时，只需要访问内存一次取出指令，而使用分页时，需要额外的内存访问去读取页表。如果是这样的话，每次访问内存都需要访问两次页表，这样会使得机器的性能降低2/3。</p>
<p>采取的解决方案就是位计算机装一个不需要经过页表就能把虚拟地址映射成物理地址的硬件设备——TLB，有时也称为**相联内存(associative memory)**。TLB通常位于MMU内部，条目的数量较少，一般在64个以内。每个条目包含一个页的信息，主要包括：虚拟页号、修改位、保护码、页所在物理框号、条目有效位（条目是否有效）。下面是一个8个条目的TLB：</p>
<p><img src="/images/TLB.png"></p>
<p>TLB工作过程：当一个虚拟地址被送到MMU时，硬件首先将它和TLB中的所有条目<strong>同时</strong>（这也就意味着TLB条目数量不能过多）进行比较，查看虚拟地址的虚拟页号是否在TLB中，如果找到了并且这个访问没有违反保护位，则它的页框号直接从TLB中取出，而不用查页表。如果虚拟页号在TLB中但是当前指令试图访问一个只读页面，这时将发生一个保护故障。</p>
<p>如果MMU发现在TLB没有名字，则随即进行一次唱歌的页表查找，然后从TLB中淘汰一个条目，并将它替换为刚刚找到的页表项。因此，如果这个页很快再用到的话，第二次访问它就能直接在TLB中找到。（一个TLB条目淘汰时，被修改的位被复制回在内存中的页表项，其他值已经存在，不需要进行复制）。当TLB从页表中装入时，所有域从内存中取得。</p>
<h2 id="页面替换算法"><a href="#页面替换算法" class="headerlink" title="页面替换算法"></a>页面替换算法</h2><p>在发生页面故障时，操作系统必须从内存中选一个页面删除掉，以便为调入的页让出空间。如果被删除的页在内存期间被修改过，则还需要将其写回到磁盘以更新该页在磁盘上的拷贝；如果这个页没有被修改过，则不需要写回，要读入的页面直接进行覆盖操作就可以了。</p>
<p>每次发生页面故障时尽管我们可以随机选择一个页替换，但是选择不常使用的页会使系统性能好很多。而如果一个经常使用的页被淘汰掉，那么极有可能它很快就要被调回来，从而引起不必要的额外开销。所以需要页面替换算法来进行解决上面的问题。</p>
<h3 id="最优页面替换算法"><a href="#最优页面替换算法" class="headerlink" title="最优页面替换算法"></a>最优页面替换算法</h3><p>最优页面算法思想为：在页面故障发生瞬间，有些页在内存中，其中一个页将被紧接着的下条指令访问，其他的页可能要到10、100、1000条指令后才会被访问，每个页都可以在该页首次被引用前所要执行的指令数进行标记，然后替换页面时，淘汰标记最大的页。</p>
<p>这个思想是好的，但是是无法实现的，因为操作系统无法知道各个页面下次被访问是什么时候。</p>
<p>该算法虽然无法实现，但是通常用于和其它实现算法做比较。如果其它实现算法和最优页面替换算法相差百分之一的性能，说明实现算法还有提升空间。</p>
<h3 id="最近未使用页面替换算法"><a href="#最近未使用页面替换算法" class="headerlink" title="最近未使用页面替换算法"></a>最近未使用页面替换算法</h3><p>每个页的页表项都会存在两个状态位：referenced(R)被引用位和modified(M)修改位。这些位在每次内存访问时都需要进行更新，并且由硬件进行设置。一旦一个位被设置成1，就一直保持1，直到操作系统用软件将它复位为0。</p>
<p>R位和M位可以用来构造这样一个简单的换页算法：在一个进程启动时，它的所有页的两个位都由操作系统设置成0。R位被定期清0，以把最近没有被访问的页和被访问的页区分开。</p>
<p>当页面发生陷入时，操作系统检查所有页面并根据当前的R位和M位将值分成4类：</p>
<ol>
<li>00：没有被访问，没有被修改</li>
<li>01：没有被访问，被修改</li>
<li>10：被访问，没有被修改</li>
<li>11：被访问，被修改</li>
</ol>
<p>最近未使用算法随机地从编号最小中 淘汰一个最近在一个时钟周期内没有被访问的已修改页。</p>
<p>NRU算法虽然性能不是最好的，但常常够用。</p>
<h3 id="先进先出页面替换算法"><a href="#先进先出页面替换算法" class="headerlink" title="先进先出页面替换算法"></a>先进先出页面替换算法</h3><p>FIFO算法：由操纵系统维持一个所有当前在内存中的页的链表，最老的页在头部，最新的页在尾部。当发生页面陷入时，淘汰表头的页，并将新调入的页放到末尾。</p>
<p>FIFO的缺陷是，可能会经常把使用的页替换出去，然后又调入加入到尾部，浪费性能。</p>
<h3 id="第二次机会页面替换算法"><a href="#第二次机会页面替换算法" class="headerlink" title="第二次机会页面替换算法"></a>第二次机会页面替换算法</h3><p>为了避免FIFO将经常使用的页替换出去的问题，做一个简单的修改：对最老页面的R位进行检查，如果R位为0，那么这个页既老又没用，应该立刻被替换掉。如果是1，则清除这个位，并将页加入到尾部，然后从头部继续搜索淘汰页面。</p>
<h3 id="时钟页面替换算法"><a href="#时钟页面替换算法" class="headerlink" title="时钟页面替换算法"></a>时钟页面替换算法</h3><p>尽管第二次机会算法是一个比较合理的算法，但是因为经常要在链表中移动页面，降低了效率又是不必要的。一个更好的办法就是把所有的页面保存在一个类似时钟表面的环形链表中。如图所示：</p>
<p><img src="/images/%E6%97%B6%E9%92%9F%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95.png"></p>
<p>一个指针指向最老的页面。当页面发生陷入时，算法首先检查指针指向的页面，如果它的R位是0就淘汰掉这个页面，然后将新页差入到这个位置，然后将指针前移一个位置。如果R位是1就清除R位并将指针前移一个位置。重复上述过程，直到找到一个R位为0的页。</p>
<h3 id="最久未使用页面替换算法"><a href="#最久未使用页面替换算法" class="headerlink" title="最久未使用页面替换算法"></a>最久未使用页面替换算法</h3><p>思想：当前被频繁使用到的页面极有可能在接下来的指令中也会被频繁用到，而已经很久没有使用的页面可能在将来一段比较长的时间内页不会被用到。所以，发生页面陷入时，淘汰掉没有使用时间最长的页。该算法称为LRU算法，和最优页面算法有些类似。</p>
<p>虽然LRU可以实现，但是代价很高。为了实现LRU，需要维持一个在内存中所有页的一个链表，最近使用的页放在头部，最久未使用的页放在尾部。当每次进行内存访问时，该链表都要进行更新，用于在链表中找到被访问的页，并将它移动到表头。这显然是一个非常耗时的操作。</p>
<p><strong>硬件实现LRU</strong></p>
<ol>
<li>要求硬件有一个64位计数器C，它在每条指令执行完后自动加1，每个页表项必须有一个足够容纳这个值的域。在每次访问内存后，当前的C计数值就被保存到被访问页的页表项中。当发生页面缺失时，操作系统检查页表中所有计数器的值，以找出最小的，这个页就是最久未使用的页。</li>
<li>要求硬件一个维持一个n×n的矩阵，开始时，所有位都是0。当页K被访问到时，硬件把K行都设置成1，把K列都设置成0。在任何时刻，<strong>二进制最小的行就是最久未使用的</strong>。</li>
</ol>
<p><strong>软件实现LRU</strong></p>
<p>虽然硬件的LRU算法可实现，但是只有非常少的计算机有这些硬件。因此，对于没有这些硬件的计算机开发者而言，基于硬件的算法是没有意义可言的。所以，需要一个能用软件实现的解决方案。</p>
<p>基于软件的LRU算法实现思想和硬件LRU算法的第一种算法很类似：每个页都和一个软件计数器相联系，计数器的初值为0。在每次时钟中断时由操作系统对内存中的页进行扫描，把每个页的R位加到它的计数器上。当页面发生页面陷入时，计数器值最小的页被选中并替换掉。</p>
<p>但是这样存在一个问题，比如前几次扫描经常使用的页，其计数值会很高。但是最近几次扫描时，之前经常使用的页的计数值都没有变化，说明没有被使用。如果要进行替换的话，结果是操作系统将删除最近使用的页（计数值低）而不是不再使用的页。</p>
<p>所以，需要进行改进，改进后的算法称为老化算法。修改两部分：1. 计数器在R位加进来之前无符号右移一位 2。 R位加到计数器最左端而不是最右端。下面给出几个示例，来验证这一思想：</p>
<p><img src="/images/%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E7%9A%84NRU%E7%AE%97%E6%B3%95.png"></p>
<p>在发生页面陷入时，计数器值最小的页将被淘汰掉。很明显，如果一个页最近被访问，那么它的高位要比不经常使用的页的高位大，这一方法也避免了上面产生的问题：之前的计数器值影响淘汰的页。</p>
<h2 id="分页系统中的设计问题"><a href="#分页系统中的设计问题" class="headerlink" title="分页系统中的设计问题"></a>分页系统中的设计问题</h2><h3 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h3><p>在单纯的分页系统中，当进程启动时它的页面设计没有一个在内存中，在CPU试图取第一条指令时就会引发一个页面故障，使操作系统撞日含有第一条指令的页，其他的由范围跟全局数据和堆栈引起的页面陷入会紧接着发生。一段时间后，进程所需的大部分页已在内存中，进程开始在页面陷入较少的情况下运行。这个策略称为**请调(demand paging)**，因为页是在需要的时候调入，而不是预先装入。</p>
<p>一个进程当前使用的页的集合称为它的**工作集(working set)**。如果整个工作集都在内存中，则进入下个运行阶段之前，进程不会陷入很多的页面陷入。如果内存太小，无法容纳整个工作集，进程运行将引起大量的页面陷入并且速度十分缓慢，因为执行一条指令通常需要几个纳秒，而从磁盘读取一个页面则要几十个毫秒。在几十毫秒内只能执行一到两个指令，这令人难以接受。</p>
<p>而且，在分时系统中，进程常会被换到磁盘上，从而让其他进程有机会占用CPU。如果当一个进程再次被调用进内存后该如何处理？什么都不做，重新开始页面陷入？还是将之前的工作集全部装入？</p>
<p>大部分系统采用第二种方式，即在进程运行前，其工作集就会装入内存中，这种方法称为<strong>工作集模型</strong>，目的就是大大减少页面陷入。而在进程运行前装入页面也叫做<strong>预调</strong>。</p>
<p>工作集模型的实现用到了之前讨论的老化算法：所有计数器的高n位含有1的页都被认为是工作集的成员；如果一个页连续n个时钟滴答都没有被访问到，那么它将从工作集中删除。对于不同系统，n值不同，因此n必须通过试验确定。</p>
<h3 id="局部与全局分配策略"><a href="#局部与全局分配策略" class="headerlink" title="局部与全局分配策略"></a>局部与全局分配策略</h3><p>如何为相互竞争的可运行进程分配内存？比如对于以下的3个进程A、B、C，如果进程A发生页面陷入，替换算法是应该只考虑分配给进程A的页？还是所有在内存中的页？</p>
<p>如果只考虑分配给进程A的页，则对应的算法称为<strong>局部页面替换算法</strong>。如果考虑所有在内存中的页，则对应的算法称为<strong>全局算法</strong>。很明显，局部算法对应于每个进程分配固定的内存片段；全局算法在可运行进程间动态地分配页框，因此分配给各个进程的页框数是随时间变化的。通常情况下，全局算法比局部算法好，尤其是当工作集的大小会在进程的运行期间发生变化时。</p>
<p>使用全局算法时，系统必须不断确定应该给各个进程分配多少页框。常用为进程分配页框的算法：1. 定期确定进程数目，并分配相等的份额，这种算法分配不合理 2. 根据进程大小的比例分配给进程相应数量的页面 3.  每个进程规定最小的页框数</p>
<h3 id="页面大小"><a href="#页面大小" class="headerlink" title="页面大小"></a>页面大小</h3><p>页面大小是一个操作系统可以选择的参数。通常情况下，页面的大小默认为512字节。</p>
<p>选择最优的页面大小需要在几个互相冲突的因素之间进行折中。1. 随便一个正文、数据或堆栈，它不会恰好装满整个页  2. 大的页面相比于小的页面，使更多没有用的程序保留在内存中 3. 小的页面意味着更大的页表，页表占用更多的空间 3. 由于内存与磁盘间的传输一般是一次一个页，所以页面越小，意味着传输时间更长</p>
]]></content>
      <tags>
        <tag>存储器管理</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则与设计模式</title>
    <url>/2020/12/05/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="软件架构设计原则"><a href="#软件架构设计原则" class="headerlink" title="软件架构设计原则"></a>软件架构设计原则</h2><h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><p>软件实体（类、模块、函数）对扩展开放，对修改关闭。该设计原则强调用抽象构建框架，用实现扩展细节，提高软件系统的可复用性和可维护性。</p>
<h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><p>设计代码结构时，抽象不应该依赖于细节，细节则应该依赖于抽象，也就是说要针对接口编程，而不是针对实现编程。通过依赖倒置，可以减少类间的耦合性，提高系统的稳定性、代码的可读性和可维护性。</p>
<p>依赖导致原则要求在程序代码中传递参数或者在关联关系中，尽量引用层次高的抽象类，就是要使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明、数据类型的转换，而不要使用具体类来做这些工作。也因此，为了该原则的使用，一个具体类应该只实现接口或抽象类中声明过的方法，尽量不要自己声明多余的方法，否则将无法调用到在子类中新增加的方法。</p>
<p>在实现依赖倒置原则时，需要针对抽象层进行编程，而将具体的实现类通过依赖注入的方式注入到对象中。依赖注入是指当一个对象与其他对象发生依赖关系时，通过抽象来注入所需要依赖的对象。常用的注入方式有3种：构造器注入、setter注入、接口注入。构造器注入是指通过构造函数来传入具体类的对象；而setter注入则是通过setter方法传入具体类的对象；接口注入则是在接口中声明的业务方法来传入具体类的对象。这些方法在定义的时候使用的是抽象类型，在运行的时候在传入具体类型的对象，由子类对象来覆盖父类对象。</p>
<h4 id="单一责任原则"><a href="#单一责任原则" class="headerlink" title="单一责任原则"></a>单一责任原则</h4><p>一个类只负责一个相应职责，即只有一个引起它变化的原因。也就是说一个类的职责不要过多，一旦发生需求变更，修改其中一个职责的逻辑代码，有可能会导致另一个职责的功能发生故障。将职责进行解耦，不同职责设计不同的类进行实现，后期需求变更时职责间的类互不影响。这样的设计，可以降低类的复杂度，提高类的可读性，提高系统可维护性。</p>
<h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><p>不使用单一的总接口，而将其拆分为多个专门的接口，客户端不应该依赖那些它不需要的接口。注意以下几点：</p>
<ol>
<li>一个类对另一个类的依赖应该建立在最小的接口之上</li>
<li>建立单一的接口，不要庞大臃肿的接口</li>
<li>接口中的方法要适量</li>
</ol>
<p>接口隔离原则符合常说的高内聚、低耦合的设计思想，可以使类具有很好的可读性、可扩展性、可维护性。</p>
<h4 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h4><p>也称最少知道原则，指一个对象应该对其他对象保持最少的了解，尽量降低类与类间的耦合度。</p>
<p>该原则也有一个生动形象的比喻：“不要和陌生人说话，之和自己的直接朋友通信”。这里的“朋友”包括以下几类：</p>
<ol>
<li>当前对象本身</li>
<li>以参数形式传入到当前对象方法中的对象</li>
<li>当前对象的成员对象</li>
<li>如果当前对象的成员对象是一个集合，那么集合中的元素也是朋友</li>
<li>当前对象所创建的对象</li>
</ol>
<p>迪米特原则要求我们在设计系统时，应该尽量减少对象间的交互，如果两个对象间不必直接通信，那么两个对象就不应当发生任何直接的相互作用，如果其中一个对象要调用另一个对象的某个方法，则需要通过第三者转发这个调用。简而言之就是，要引入一个合理的第三者来降低现有对象间的耦合度。</p>
<h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><p>如果对于一个类型为A的对象O1，都有类型为B的对象O2，并且当程序P中类型为A的所有对象被替换成类型B的对象时，程序P的行为都没有发生变化，那么类型B是类型A的子类型。简而言之就是所有引用父类的地方，必须能够使用其子类对象。该原则引申出来的含义如下：</p>
<ol>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</li>
<li>子类可以增加自己特有的方法</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（方法的输入参数）要比父类方法的输入参数更宽松</li>
<li>当子类的方法实现父类的方法时，方法的后置条件（方法的输出/返回值）要比父类的更严格或相同</li>
</ol>
<h4 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h4><p>尽量使用对象组合或者聚合而不是继承关系来达到软件复用的目的。该原则使系统更加灵活，降低类间的耦合度，一个类的变化对其他类造成的影响也相对较少。</p>
<h2 id="常用设计模式"><a href="#常用设计模式" class="headerlink" title="常用设计模式"></a>常用设计模式</h2><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂模式是最常用的一类创建型设计模式。常用工厂模式有三种：简单工厂模式、工厂方法模式、抽象工厂方法模式</p>
<h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>要改进的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String type; <span class="comment">// 图形的类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">drawShape</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;rectangle&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 画长方形</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;square&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 画正方形</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;circle&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 画圆形</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ......</span><br><span class="line">            <span class="comment">// 画椭圆形、三角形......</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">modifyShape</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;rectangle&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 修改长方形参数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;square&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 修改正方形参数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;circle&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 修改圆形参数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ......</span><br><span class="line">            <span class="comment">// 修改椭圆形、三角形......参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，该类设计违反了设计原则和存在如下问题：</p>
<ol>
<li>违反开闭原则，当新增新的图形时，必须要修改Shape的源码</li>
<li>违反单一责任原则，将图形的显式和修改都放在一个类中，不利于类的重用和维护</li>
<li>类中if-else代码块冗长，阅读难度和测试难度都很大，并且在画一个图形时，程序要做大量的判断，这会一定程度上影响程序的性能</li>
<li>客户端要创建一个图形，只能通过new一个Shape对象，这样使得客户端类和Chart类耦合度较高，对象的创建和使用无法分离</li>
</ol>
<p>针对以上问题，采用简单工厂模式进行改进：</p>
<p>简单工厂模式的设计思想为：将要创建的不同对象相关代码封装到不同的类中，这些类称为<strong>具体产品类</strong>。然后将具体产品类的公共代码进行抽象和提取封装后装在一个<strong>抽象产品类</strong>中，每个具体产品类都是抽象产品类的子类。最后，提供一个<strong>工厂类</strong>用于创建各种产品，在工厂类中定义一个<strong>静态方法</strong>用于创建产品，该静态方法可以根据传入的参数创建不同的具体产品对象。客户端只与工厂类打交道，传入参数然后获取对应的具体产品类。</p>
<p><img src="/images/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png"></p>
<p>根据简单工厂模式的思想，对图形类Shape进行改进：</p>
<p><img src="/images/%E6%A0%B9%E6%8D%AE%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%BF%9B%E8%A1%8C%E4%BF%AE%E6%94%B9.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commonMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(String[] args)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 画长方形</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 修改长方形参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 画正方形</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 修改正方形参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 画圆形</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 修改圆形参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getShape</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;rectangle&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;square&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;circle&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对简单工厂模式的简化</strong></p>
<p><img src="/images/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AE%80%E5%8C%96.png"></p>
<p>通过将抽象产品类和工厂类合并，将静态工厂方法移到抽象产品类中。这样，客户端可以通过产品父类的静态工厂方法，根据参数创建不同类型的产品子类对象。</p>
<p><strong>何时使用简单工厂模式？</strong></p>
<ol>
<li>工厂类负责创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象并不关心</li>
</ol>
<p><strong>简单工厂模式缺点</strong></p>
<ol>
<li>很明显，工厂类集中了所有产品的创建逻辑，责任过重，当工厂类不能正常时，整个系统都会受影响</li>
<li>类的数量增加，增加系统的复杂度和理解难度</li>
<li>系统扩展困难，并且不太符合开闭原则，当添加新产品时，就必须修改工厂创建逻辑。并且随着产品数量增多，有可能造成工厂逻辑过去复杂，不利于系统的扩展与维护</li>
<li>简单工厂模式使用了静态工厂方法，使得工厂无法形成基于继承的等级结构</li>
</ol>
<h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>前面提到，简单工厂模式违反开闭原则，当新产品增加时，要通过修改工厂类的源码完成产品添加，客户端才能获得新产品对象。这个问题可以通过工厂方法模式解决：</p>
<p>在简单工厂模式中只提供一个工厂类，该工厂类处于对产品类进行实例化的中心位置，它需要知道每一个产品对象的创建细节，并决定何时实例化哪一个产品类。简单工厂模式最大的缺点就是当有新产品要加入到系统中时，必须修改工厂类，需要在其中加入必要的业务逻辑，这违反了“开闭原则”。此外，在简单工厂模式中，所有的产品都由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品和工厂类间的耦合度高，严重影响了系统的灵活性和扩展性。</p>
<p><em>工厂方法模式不再提供一统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构</em></p>
<p><strong>在工厂方法模式中，定义了一个用于创建对象的接口，让子类决定哪一个类实例化，将一个类的实例化延迟到其子类。</strong></p>
<p><img src="/images/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png"></p>
<p>由图可知，和简单工厂模式相比，工厂方法模式最重要的区别就是引入了抽象工厂。这里的抽象工厂可以是接口、抽象类，甚至也可以是具体类。</p>
<p>抽象工厂声明完工厂方法，但是却并未提供具体实现。具体的产品对象的创建由其子类负责。而客户端可以针对抽象工厂编程，运行时再指定具体的工厂类。</p>
<p>根据工厂方法模式，对图形类Shape进行修改：</p>
<p><img src="/images/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E6%94%B9%E8%BF%9B.png"></p>
<p><strong>何时使用工厂方法模式？</strong></p>
<ol>
<li>客户端不需要知道具体产品的类名，只需要知道对应的工厂即可，具体的产品对象由具体的工厂类进行创建</li>
<li>在工厂方法模式中，对抽象工厂类只需要提供一个创建产品的接口，由子类工厂来确定具体要创建的对象，利用面向对象的多态性和里氏替换原则，在程序运行时，子类对象将覆盖父类对象，从而使系统更容易扩展。</li>
</ol>
<p><strong>工厂方法模式缺点？</strong></p>
<ol>
<li>添加新产品时，要编写新的具体产品类以及对应的具体工厂类，系统中类的个数成对增加，一定程度上增加了系统的复杂度</li>
<li>考虑到系统的扩展性，引入了抽象层，客户端代码均使用抽象层进行定义，增加了系统的抽象性和开发理解难度，增加了实现的难度</li>
</ol>
<h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p>工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责过重以及违反开闭原则的问题。但由于工厂方法模式中的每个工厂只生产一类产品，会导致系统中存在大量的工厂类。因此，可以考虑将一些相关的产品组成一个<strong>产品族</strong>，由同一个工厂来统一生产，这就是抽象工厂模式的基本思想。</p>
<p>抽象工厂模式要了解两个概念：<strong>产品族和产品等级结构</strong></p>
<p>产品族：产品族是指由同一个工厂生产的产品</p>
<p>产品等级结构：即产品的继承结构。比如一个抽象类是Shape，其子类有Rectangle、Square、Circle，那么Shape、Rectangle、Square、Circle则构成了一个产品等级结构。</p>
<p>在抽象工厂模式中，只要指明一个产品所处的产品族以及其产品等级结构，就可以唯一确定这个产品。</p>
<p><img src="/images/%E4%BA%A7%E5%93%81%E6%97%8F%E5%92%8C%E4%BA%A7%E5%93%81%E7%AD%89%E7%BA%A7%E7%BB%93%E6%9E%84.png"></p>
<p>图中共有4个产品族，3个不同的产品等级结构。</p>
<p>当系统提供的工厂生产的具体产品不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式。抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。抽象工厂模式和工厂方法模式的最大区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以复制多个不同产品等级结构中的产品对象的创建。<strong>当一个工厂等级结构可以创建出属于不同产品的等级结构的一个产品中的所有对象时，抽象工厂模式比工厂方法模式更简单，更有效。</strong></p>
<p><img src="/images/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png"></p>
<p>！！！<strong>开闭原则的倾斜性</strong></p>
<p>在抽象工厂模式中，增加新的产品族（新增一个产品）很方便，但是增加新的产品等级结构（新增一个继承关系）很麻烦，当新增一个产品等级结构时，需要修改抽象工厂以及逐个修改具体的工厂类，抽象工厂模式的这种性值称为“开闭原则的倾斜性”。</p>
<ol>
<li>增加产品族。对于增加新的产品族，抽象工厂模式支持开闭原则，只需要增加具体产品并增加一个对应的具体工厂，对已有代码无须修改</li>
<li>增加新的产品等级结构。对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违反了”开闭原则“</li>
</ol>
<p>正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。<br><strong>何时使用抽象工厂模式？</strong></p>
<ol>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型</li>
<li>产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构</li>
</ol>
<p><strong>抽象工厂模式缺点？</strong></p>
<ol>
<li>开闭原则的倾斜性，这可以通过开发人员的初期设计进行规避</li>
</ol>
]]></content>
      <tags>
        <tag>设计模式; 设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title>输入输出系统</title>
    <url>/2020/10/31/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>操作系统的主要功能之一是控制所有的**输入/输出(Input/Output)**设备，它必须向设备发布命令，捕获中断并进行错误处理，还要提供一个设备与系统其余部分之间的简单易用的界面，该界面应该对所有设备尽可能一致。</p>
<span id="more"></span>

<h2 id="I-O硬件原理"><a href="#I-O硬件原理" class="headerlink" title="I/O硬件原理"></a>I/O硬件原理</h2><h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h3><p>I/O设备可粗略地分为两类：<strong>块设备（block devices）和字符设备（character devices）</strong>。</p>
<p>块设备将信息存储在可寻址的固定大小数据块中，通常数据块的大小范围从512字节到32768字节不等。块设备的主要特征是能够独立地读写单个数据块。磁盘则是最常见的块设备。（块设备明显的特征如下：1. 能够定位需要的数据块，比如磁盘的磁头，无论当前磁头处于什么位置，总可以定位到其他柱面并等待需要的数据块旋转到磁头下面；2. 数据块大小是可以固定的）</p>
<p>字符设备可以发送和接收一个字符流。字符设备无法编址，也不存在任何寻址。打印机、网络接口、鼠标等设备均可视为字符设备。</p>
<h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><p>I/O设备通常包含一个机械部件和一个电子部件。为了达到设计的模块性和通用性，一般将其分开。机械部分是设备本身，电子部分称为设备控制器或适配器，在个人计算机中，常常是一块可以插入主板扩展槽的印刷电路板。</p>
<p>设备控制器卡上一般有一个接线器，用于将与设备相连的电缆线接进来。许多控制器可以控制2个、4个、甚至8个相同的设备。如果控制器和设备间的接口采用标准接口，那么许多厂商都可以制造与该接口匹配的控制器和设备。</p>
<p>操作系统大多都是和控制器打交道，而不是机械部分。而计算机的CPU和控制器间的通信采用下图所示的单总线模型：</p>
<p><img src="/images/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B.png"></p>
<p>控制器与设备间的接口通常是一种很低层次的接口。比如一个磁盘，可能会被格式化为每道16个512字节的扇区。实际从驱动器读出来的是一个比特流：以一个前缀开始，随后是一个扇区的4096比特，最后是一个检查和（也称为纠错码ECC）。其中，前缀是磁盘格式化时写进磁盘的，里面包含有柱面数和扇区数、扇区大小之类的数据，以及同步信息。</p>
<p>控制器的任务是将这个串行的比特流转换成字节块，并在需要时进行纠错。字节块通常是在控制器的一个缓冲区中逐个比特汇集而成的，在检查和进行校验证实数据正确之后，该块数据随后被拷贝到主存中。</p>
<p>控制器和CPU通信有两种方案：一种是每个控制器有专门与CPU通信的寄存器，这些寄存器占用内存地址空间的一部分，该方案称为<strong>内存映像I/O</strong>；另一种方案就是计算机有I/O专用的地址，每个控制器占用其中的一部分，设备的I/O地址分配由控制器上的总线解码逻辑完成。第一种方案为常见方案。此外，许多控制器还使用中断来通知CPU自己已经做好准备，使其寄存器或可以读写。中断是一个电信号事件，硬件的中断请求信号线提供了中断控制芯片的物理输入，但这种输入的输入线的数量是有限的。中断控制芯片将每个输入映射到一个中断向量，通过该中断向量便可以找到相应的中断服务程序。</p>
<p>操作系统通过向控制器寄存器写命令来执行I/O功能。其中许多命令带有参数，这些参数也要装入控制器的寄存器中。当某设备控制器接收到一条命令后，CPU可以执行其他进程，而让该设备控制器自行完成具体的I/O操作。而在命令执行完毕后，控制器发出一个中断信号，以便使操作系统重新获得CPU的控制权并检查执行结果。CPU通过从控制器寄存器中读取若干字节信息来获得执行结果和设备的状态信息。</p>
<h3 id="存储器直接存取"><a href="#存储器直接存取" class="headerlink" title="存储器直接存取"></a>存储器直接存取</h3><p><strong>DMA(direct memory access)</strong></p>
<p>先知道没有使用DMA时，磁盘是如何读取数据的：首先控制器逐个比特地从设备完整地读出一块数据放入内部缓冲区中，然后计算该块数据的 检查和 以保证读取正确。接着控制器发出中断信号，操作系统开始逐个字节或字地从控制器的设备寄存器中将数据读入内存，一次只能读取一个字节或字，需要通过一个循环才能将整个数据块读完。</p>
<p>很明显，这种读取效率低下并且费时，为了解决这个问题，引入了DMA存储器直接存储。使用DMA时，CPU除了告诉控制器数据块地址外，还需要告诉控制器两条信息：<strong>数据块要存放的内存地址和要传输的字节数</strong>。接收到信息后，控制器首先从设备中将整个数据块读入内部缓冲区并进行校验，接着控制器会将第一个字节或字拷贝到DMA内存地址处，随后控制器对DMA地址和DMA计数分别增减刚刚传送的字节数。这个过程重复下去，直到DMA计数变为0。此时，设备控制器发出中断信号，通知操作系统数据读取完毕，在这里，操作系统无须再将数据拷贝到主存中，因为数据在读的过程中已经放在那里了。</p>
<p><img src="/images/DMA%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8.png"></p>
<p>图中还有个缓冲区，其作用为：一旦磁盘启动开始读取数据，从磁盘读出比特率的速率是恒定的，无论控制器是否作好接收这些比特的准备。如果此时控制器要将数据直接拷贝到内存中，则它必须在每个字节传送完毕后获得系统总线的控制权。如果由于其他设备的使用而导致总线忙，那么只能等待。而等待过程，如果上个字节还未送入内存前，下个字节到达，那么控制器就只能找个地方将其暂存起来。从另一方面来看，如果采用缓冲区，则在DMA操作启动前不需要使用总线，这样控制器就能够设计的简单一些，因为DMA到主存的传输对时间要求不严格。</p>
<p>此外，控制器读取数据也不像我们想象的那样简单。假设当数据被CPU或控制器从控制器传送到内存时，下一个扇区正好通过磁头下边，同时扇区上存储的信息正在送入控制器。但是简单的控制器不具备同时执行输入和输出的功能，因此，当进行内存传送时，当前通过磁头下的扇区的数据将会丢失。这样的结果就是控制器只能隔一个或多个数据块读取一个数据块，读完一条完整的磁道，磁盘至少需要旋转两周，旋转的周数取决于数据通过总线从控制器传到内存所用的时间相比于从磁盘读取数据到控制器的时间的大小。</p>
<p>因为上面不连续读取的问题存在，有意地跳过一些快，以便为控制器腾出时间将数据传送到内存的计数称为交叉编址。磁盘在格式化的时候，数据块编号就考虑到了交叉系数。</p>
<p><img src="/images/%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80%E7%A4%BA%E4%BE%8B.png"></p>
<p>这种磁盘块编址方案的意图为：使操作系统能够连贯地读取出数据块，并同时达到硬件许可的最大速度。如果按无交叉编址进行编址，控制器只能做到隔一个块读取数据的速度，则操作系统为了保证将8个数据块按照0到7的顺序读出，磁盘需要旋转8周。</p>
<h2 id="I-O软件原理"><a href="#I-O软件原理" class="headerlink" title="I/O软件原理"></a>I/O软件原理</h2><p>将软件组织成一种层次结构，低层软件屏蔽硬件具体细节，高层软件为用户提供简洁、规范的界面。</p>
<h3 id="I-O软件的目标"><a href="#I-O软件的目标" class="headerlink" title="I/O软件的目标"></a>I/O软件的目标</h3><p><strong>设备无关性</strong></p>
<p>I/O软件的设计的一个关键概念就是：<strong>设备无关性</strong>。程序员编写的软件无需根据不同的设备进行修改，只需要按照规范编写，则操作系统会通过调用不同的设备驱动来处理不同设备间的差异。</p>
<p><strong>统一命名</strong></p>
<p><strong>错误处理</strong></p>
<p>错误应尽可能在接近硬件的地方处理。比如，如果控制器发现错误，则应该尽可能在控制器中进行处理，如果控制器处理不了，则交给设备驱动程序，只有在这些低层软件均处理不了错误的情况下，才通知高层软件。</p>
<p><strong>同步（阻塞）——异步（中断驱动）传输</strong></p>
<p>多数物理I/O是异步传输，比如CPU在启动传输操作后便转向其他工作，直到中断到达。如果I/O操作采用阻塞语义，那么用户编程将得到简化：发出一条read系统调用后，程序自动被挂起，直到数据被读到缓冲区中。</p>
<p>综上，可以将I/O软件分成以下四个层次：</p>
<ol>
<li>底层：中断处理程序</li>
<li>设备驱动程序</li>
<li>与设备无关的操作系统软件</li>
<li>高层：用户层软件</li>
</ol>
<p>这和进程的四个层次完全对应，看似偶然，实则并不是。</p>
<h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>中断处理程序应放在操作系统的底层进行处理，以便其余部分尽可能少地与之发生联系。</p>
<h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>设备驱动程序中包括了所有与设备相关的代码。每个设备驱动程序只处理一种设备，或者一类紧密相关的设备。在前面，直到设备控制器的功能是和操作系统打交道，每个控制器都有一个或多个寄存器来接收命令。设备驱动程序发出这些命令并进行检查，因此操作系统中只有硬盘驱动程序才知道磁盘控制器有多少给寄存器，以及它们的用途。磁盘驱动程序知道使磁盘正确操作所需要的全部参数，包括扇区、磁道、柱面、磁头、磁头臂的移动、交叉系数、步进电机、磁头定位时间等。</p>
<p>设备驱动程序工作过程：从软件中接收抽象的请求，并执行。如果请求到来时，驱动程序空闲，则立即执行请求。但如果正在处理另一个请求，则将当前请求挂在一个等待队列中。当执行请求时，驱动程序会将请求转换成更具体的形式，包括确定需要哪些控制器命令以及命令的执行次序。一旦决定向控制器发送什么命令，驱动程序将向控制器的设备寄存器写入这些命令。一些控制器一次只能处理一条命令，而另一些则可以接收一串命令并自行处理。</p>
<p>当控制命令发出后，会有两种可能：一是驱动程序需要等待控制器完成一些操作，驱动程序阻塞，知道中断信号到达才解除阻塞；二是操作没有任何延迟，所有驱动程序无需阻塞。对于第一种情况，被阻塞的驱动程序须由中断唤醒。</p>
<p>无论上面的哪种情况发生，最后都要进行错误检查，如果一切正常，则驱动程序将 数据报 传送给上层的设备无关软件，然后向调用者返回一些状态信息。</p>
<h3 id="与硬件无关的I-O软件"><a href="#与硬件无关的I-O软件" class="headerlink" title="与硬件无关的I/O软件"></a>与硬件无关的I/O软件</h3><p>与硬件无关的I/O软件的基本功能是执行适用于所有设备常用的I/O功能，并向用户层软件提供一个一致的接口。常见的硬件无关软件有：设备命名、设备保护、块设备的存储分配、错误报告等，通常属于文件系统，属于系统的第三层服务层。举例：</p>
<ol>
<li>设备命名。文件系统（与硬件无关的I/O软件）负责将设备名映射到相应的驱动程序。比如在MINIX中，一个设备名 /dev/tty00 唯一确定了一个i节点，节点包含了主设备号、次设备号，通过主设备号可以找到相应的设备驱动程序，通过次设备号则可以指定具体的物理设备</li>
<li>设备保护。通过对设备的保护采用rwx权限机制，为每一台设备设置合理的访问权限</li>
</ol>
<h3 id="用户空间的I-O软件"><a href="#用户空间的I-O软件" class="headerlink" title="用户空间的I/O软件"></a>用户空间的I/O软件</h3><p>大部分的I/O软件属于操作系统，还有<strong>一小部分</strong>是和用户程序链接在一起的库程序，这些库程序的主要工作就是提供参数给相应的系统调用并调用该系统调用。比如常见的 count = write(fd, buffer, nbytes);  库函数write和程序链接在一起，并包含在运行时的程序代码中。这类程序显然是I/O系统的一部分，但是不属于操作系统。</p>
<p>除了库程序外，另一个重要的类别就是Spooling系统。Spooling（英文含义：多任务缓存处理）是处理独占设备的一种方法，防止一个进程空占而导致其他进程无法使用设备。比如打印机，假设一个进程打开它而几个小时都不用，则其他进程都无法进行打印。而Spooling系统通过创建一个特殊的精灵进程（守护进程daemon）以及一个特殊的目录——Spooling目录来避免这种情况。打印一个文件前，需要打印的进程把待打印文件放在Spooling目录下，由该精灵进程进行打印，并且只能由该精灵进程进行打印，从而解决了上述的空占问题。此外，Spooling系统还多用于网络传输文件。</p>
<h3 id="I-O系统层次结构"><a href="#I-O系统层次结构" class="headerlink" title="I/O系统层次结构"></a>I/O系统层次结构</h3><p>从底层开始分别是：硬件、中断处理程序、设备驱动程序、设备无关软件、用户进程</p>
<p><img src="/images/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png"></p>
<p>图中的箭头表示控制流。当用户程序试图从文件读取数据块时，需要通过操作系统来执行此操作。设备无关软件首先在数据块缓冲区中查找此块，如果没有找到，则调用设备驱动程序向硬件发出相应的请求。用户进程随即阻塞，知道数据块被读出。当磁盘操作结束时，硬件发出一个中断，激活中断处理程序。中断处理程序则从设备获取返回状态值并唤醒睡眠的进程来结束此次I/O请求，并使用户进程继续执行。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>进程对设备、文件等获得独占性的访问权时有可能发生死锁。为了便于讨论死锁发生的情况，将这种需要排它使用的对象称为资源，换句话说，资源在任何时刻只能被单个进程使用。</p>
<p>资源分成两类：可剥夺式和不可剥夺式。可剥夺式资源从拥有它的进程处剥夺不会产生其他情况，比如主存，一个进程占用主存中一段内存地址，假如现在要在该段内存地址执行另一个进程，那么进行进程换出换入即可。</p>
<p>而相反，不可剥夺式资源无法再不导致相关计算失败的情况下将资源从属主进程处剥夺。比如一个进程已经开始打印了，如果剥夺进程占用的打印机给另一个进程使用，那么打印结果是混乱的，无效的。</p>
<p>申请一个资源的事件顺序为：</p>
<ol>
<li>申请资源</li>
<li>使用资源</li>
<li>释放资源</li>
</ol>
<h3 id="死锁原理"><a href="#死锁原理" class="headerlink" title="死锁原理"></a>死锁原理</h3><p>死锁的定义：若一个进程集合中的每一个进程都在等待只能由本集合中的另一个进程才能引发的事件，则这种情况被视为死锁。由于所有进程都在等待，所以没有一个进程能够触发能够唤醒本集合另一个进程的事件，于是，所有进程都将永远地等待下去。</p>
<p>死锁的条件：</p>
<ol>
<li>互斥条件。每一个资源要么被分配给一个进程，要么空闲</li>
<li>保持和等待条件。已分配到资源的进程可以申请新的资源</li>
<li>非剥夺条件。已分配给一个进程的资源不可被剥夺，只能被占有它的进程显式地释放</li>
<li>循环等待条件。系统必然有一条：由两个或两个以上进程组成的循环链，链中的每个进程都在等待相邻进程释放占用的资源</li>
</ol>
<p>以上条件就是死锁发生的必然条件，只要一条不成立，死锁就不会发生。</p>
<h3 id="死锁模型——资源图"><a href="#死锁模型——资源图" class="headerlink" title="死锁模型——资源图"></a>死锁模型——资源图</h3><p>术语：</p>
<ol>
<li>圆形表示进程</li>
<li>方形表示资源</li>
<li>资源指向进程表示该资源已被进程占用</li>
<li>进程指向资源表示进程正在申请资源并处于阻塞状态。</li>
</ol>
<p><img src="/images/%E6%AD%BB%E9%94%81%E6%A8%A1%E5%9E%8B.png"></p>
<p>通过资源图，可以分析判断是否发生死锁。通过申请和释放资源的顺序一步步将资源图画出，最后检查是否存在环路，如果有，则发生死锁，如果没有则无。</p>
<h3 id="处理死锁策略"><a href="#处理死锁策略" class="headerlink" title="处理死锁策略"></a>处理死锁策略</h3><ol>
<li>忽略死锁问题</li>
<li>检测死锁并恢复</li>
<li>谨慎对资源进行动态分配，避免死锁</li>
<li>破坏死锁产生的4个条件的其中一个来预防死锁的发生</li>
</ol>
<h4 id="鸵鸟算法"><a href="#鸵鸟算法" class="headerlink" title="鸵鸟算法"></a>鸵鸟算法</h4><p>像鸵鸟一样，对死锁视而不见。（什么也不做也是一种算法）</p>
<h4 id="死锁检测和恢复"><a href="#死锁检测和恢复" class="headerlink" title="死锁检测和恢复"></a>死锁检测和恢复</h4><p>监视资源的申请和释放。每次资源被申请或释放时，资源图随之刷新，同时检测是否存在环路。如果存在一个环，则环中的一个进程被撤销，如果仍然不能去除死锁，则撤销环的另一个进程，如此往复，知道环被破坏。</p>
<h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>对进程施加适当的限制以从根本上消除死锁，即破坏死锁成立的四个条件中的一个，那么死锁将不会发生。</p>
<ol>
<li><p>考虑互斥条件。如果资源不被单一进程独占，则死锁肯定不会发生。</p>
</li>
<li><p>禁止已分配资源的进程再次申请其他资源。该方法容易实现，一种实现方式就是规定所有进程再开始执行前申请所需的全部资源，如果所需的资源全部可用则可进行分配，如果一个或多个资源正在被使用，则不进行分配，进程阻塞。这种方法虽然实现简单，但是不实用。</p>
</li>
<li><p>消除不可剥夺。这很明显不可行，如果这样做的话，系统将无法正确运行。</p>
</li>
<li><p>破坏循环等待条件。这也是目前去除死锁最常用的方式。下面的算法都是在围绕破环循环等待条件进行展开：</p>
<p>赋予所有资源一个全局编号，进程申请资源必须按照编号的顺序。比如：</p>
<p><img src="/images/%E8%B5%84%E6%BA%90%E9%A1%BA%E5%BA%8F%E5%9B%BE.png"></p>
<p>进程可用先申请打印机然后申请磁带机，但是不可以先申请绘图仪，后申请打印机。</p>
<p>那为什么按顺序申请资源不会出现死锁？考虑图中的两种情况，进程A申请资源i，进程B申请资源j，假设i和j是不同的资源，因此它们的资源编号不同。假如i&gt;j，那么进程A不能申请资源j ，进程B可用申请资源i；假如i&lt;j，那么进程A可用申请资源j，进程B不可以申请资源i。无论哪一种情况，都不会出现闭环，也就不会出现死锁的情况。</p>
<p>对于进程数大于2的情况，即多进程的情况，上述逻辑依然成立。无论是哪一种情况，必然有一个资源的编号是最高的，占用该资源的进程不能申请其他已被占用的资源，它要么执行完毕，要么申请资源编号更高的资源，而资源编号更高的资源是肯定可以获得的，那么它最终将执行完毕并释放资源。那么此时，次高编号的资源编号就变成了最高的资源编号，也将会执行上述过程。以此类推，每个进程都将执行完毕，没有死锁发生。</p>
<p>看似资源编号的方法很完美，但是就是难在如何给资源进行资源编号，还有就是当资源包括进程表、Spooling磁盘空间、加锁的数据块积累以及其他抽象资源时，潜在的资源以及不同用途的数目会十分庞大，以至于资源编号法根本无法使用。所以资源编号法也是不太可行的。</p>
</li>
</ol>
<h2 id="RAM盘"><a href="#RAM盘" class="headerlink" title="RAM盘"></a>RAM盘</h2><p><strong>RAM盘也称为虚拟内存盘，通过软件将一部分内存(RAM)模拟为硬盘来使用的一种技术。</strong></p>
<p>通过RAM盘驱动程序可以访问存储器的任何部分，主要用途就是保留一部分存储器，并向普通磁盘一样使用它。RAM盘不提供永久存储，但是一旦文件被拷贝到这一区域，就可以以极快的速度进行访问。</p>
<h3 id="RAM盘硬件和软件"><a href="#RAM盘硬件和软件" class="headerlink" title="RAM盘硬件和软件"></a>RAM盘硬件和软件</h3><p>块设备的数据块存储于旋转存储设备上，而RAM盘则简单地多。RAM盘使用预先分配的主存存储数据块，因此具有快速存取的优点（没有寻道和旋转延迟），适用于需要频繁存取的数据和程序。</p>
<p><img src="/images/RAM%E7%9B%98.png"></p>
<p>RAM盘被分为n块，每块的大小和实际磁盘块的大小相同。当驱动程序收到一条读写一个数据块的消息时，它只计算被请求的块在RAM盘存储区的位置，并读出或写入该块，而不读写软盘或硬盘。</p>
<h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="磁盘硬件概述"><a href="#磁盘硬件概述" class="headerlink" title="磁盘硬件概述"></a>磁盘硬件概述</h3><p>实际的磁盘都组织成许多柱面，一个柱面上的磁道数和垂直放置的磁头个数相同。磁道又被分成许多扇区，每条磁道上扇区数目典型的范围是：软盘为每条磁道8~32扇区；硬盘数目不固定，通常可多达几百扇区。</p>
<p>对于磁盘，最简单的设计是每条磁道具有相同的扇区数，每个扇区包含相同数目的字节。那么很显然，靠近磁盘外沿的扇区比靠近磁盘内边沿的扇区要长一些，最里面的柱面上的数据密度要高一些。内圈磁道和外圈磁道数据密度不同意味着会牺牲一些磁盘容量，也意味着存在更复杂的系统。一种当磁头处于外部磁道时，磁盘旋转速度更快的磁盘，这样外圈磁道就可以有更多的扇区，从而增加磁盘的容量，目前MINIX系统还不支持这种磁盘。</p>
<p>对磁盘驱动程序有重要的一个设备特性是：控制器可以同时控制两个或多个驱动器进行寻道，称为<strong>重叠寻道(overlapped seeks)<strong>。当控制器和软件等待一个驱动器完成寻道时，控制器可以启动另一个驱动器进行寻道。许多控制器可以在对一个或多个其他驱动器寻道的同时在一个驱动器上进行读写操作，比如对于硬盘。在一个有多个硬盘的系统中，这些驱动器就能同时操作，</strong>至少在磁盘和控制器缓冲区之间的数据传输可以并行进行，然而，在控制器和系统内存之间只能同时执行一个传输，同时执行两个或多个操作的能力极大地降低了平均读写时间。</strong></p>
<h3 id="磁盘软件概述"><a href="#磁盘软件概述" class="headerlink" title="磁盘软件概述"></a>磁盘软件概述</h3><p>考虑读写一个磁盘块需要多长时间，需要的时间由下面三个因素决定：</p>
<ol>
<li>寻道时间（将磁头臂移动到相应柱面所需要的时间）</li>
<li>旋转延迟（相应的扇区旋转到磁头下面所需要的时间）</li>
<li>实际的数据传输时间</li>
</ol>
<p>相对于旋转延迟和实际的数据传输时间相比，寻道时间要大的多，因此，减小平均寻道时间将极大提高系统的性能。</p>
<h4 id="磁盘臂调度算法"><a href="#磁盘臂调度算法" class="headerlink" title="磁盘臂调度算法"></a>磁盘臂调度算法</h4><p>如果磁盘驱动程序每次按接收一个请求并按照接收顺序执行，则很难优化寻道时间。许多磁盘驱动器都维护了一张表格，按柱面号索引，每一柱面的全部请求用一个链接表链在一起，链表头指针存放在表格相应的表目中。</p>
<p>有了这种数据结构，就可以改进顺序执行服务（FCFS）的调度算法。比如一个具有40个柱面的磁盘，假设一个请求请求读取柱面11上的一个数据块，当对柱面11寻道时，又顺序到达了新的寻道请求：1、36、16、34、9、12，则它们会被安排到请求等待表，每个柱面对应一个单独的链表：</p>
<p><img src="/images/%E5%AF%BB%E9%81%93%E9%A1%BA%E5%BA%8F.png"></p>
<p>比较：</p>
<p>按顺序执行服务：11、1、36、16、34、9、12，磁盘臂分别需要移动10、35、20、18、25、3 总共111个柱面</p>
<p>改进后的服务：11、12、9、16、2、34、36，磁盘臂分别需要移动1、3、7、15、33、2 总共61个柱面 ，柱面移动数大概减少了一半。该算法也称为<strong>最短寻道算法(shortest seek first SSF)</strong></p>
<p>但是SSF算法存在远离柱面中部区域的请求的服务很差的问题。比如当机械臂移到柱面16的时候，又有对柱面8、柱面10等等临近柱面的请求，那么柱面2、34、36极端区域的请求处理就不得不等待，直到中部区域没有请求为止。如何解决这个问题？这里参考了日常生活。</p>
<p>比如高层建筑都有电梯，电梯运行的时候都是朝着一个方向运行。比如当一个电梯在2楼时，4楼按下了上升按钮，5楼按下上升按钮，6楼按下下降按钮，1楼也按下上升按钮，这时候电梯并不会回到一楼，而是继续网上，先在4楼停靠，然后在5楼停靠，6楼不停靠。当电梯到达目的地下降的时候，才在6楼停靠，最后停到1楼。根据这个思路，就设计了一个算法叫**电梯算法(elevator algorithm)**。该算法需要维护一个二进制位：当前方向是向上还是向下。当一个请求结束之后，磁盘的驱动程序就检查该二进制位，如果是向上，则磁盘臂移动到下一个更高的等待请求，如果没有更高的位置请求，就翻转方向，如果存在一个低位置的请求，则移向该位置。则我们可以对上面的SSF算法进行改进，得到如下新的结果：</p>
<p><img src="/images/%E6%96%B0%E5%AF%BB%E9%81%93%E9%A1%BA%E5%BA%8F.png"></p>
<h3 id="磁盘常见错误"><a href="#磁盘常见错误" class="headerlink" title="磁盘常见错误"></a>磁盘常见错误</h3><ol>
<li>程序性错误（请求读写区不存在的扇区）</li>
<li>暂时性校验和错误（磁头上的灰尘引起）</li>
<li>永久性校验和错误（磁盘块的物理损坏）</li>
<li>寻道出错（磁盘臂定位柱面出现错误）</li>
<li>控制器出错（控制器拒绝接受命令）</li>
</ol>
<h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><h3 id="时钟硬件"><a href="#时钟硬件" class="headerlink" title="时钟硬件"></a>时钟硬件</h3><p>计算机通常使用两种类型的时钟，一种时钟连接到110V或220V的电力线上，以50或60HZ的频率在每个电压周期产生一次中断。另一种时钟由三个元件组成：晶振、计数器、保持寄存器。当把石英晶体进行合适的切削并安装于一定压力之下时，它会产生非常精确的周期信号。根据所选晶体的不同，典型范围在5~100MHz之间。在任何计算机系统中，至少都可以发现这样的电路向计算机的各种电路提供同步信号：将信号送入计数器并使其递减计数至零，当计数至零时，产生一个中断。</p>
<p><img src="/images/%E5%8F%AF%E7%BC%96%E7%A8%8B%E6%97%B6%E9%92%9F.png"></p>
<p>可编程时钟有几种操作模式。在<strong>单触发模式（One-shot Mode）</strong>中，当一个时钟启动时，它把保持寄存器的值拷贝到计数器中，然后每从晶振来一个脉冲，计数器的值就减1，当计数器为零时，产生一个中断，并停止工作，直到再次被软件启动为止。<strong>方波模式（Square-wave Mode）</strong>中，每次计数至零并引起中断后，保持寄存器自动拷贝到计数器，整个过程不断重复执行。这些周期性的中断称为<strong>时钟滴答（Clock Tick）</strong>。</p>
<p>此外，可编程时钟的中断频率可以由软件控制。</p>
<h3 id="时钟软件"><a href="#时钟软件" class="headerlink" title="时钟软件"></a>时钟软件</h3><p>硬件所做的工作是按已知时间间隔产生中断，其他和时间有关的工作都必须由软件驱动程序实现。时钟驱动程序的任务一般包括以下内容:</p>
<ol>
<li>维护日期时间</li>
<li>防止进程的运行时间超出其允许的时间</li>
<li>对CPU使用进行记费</li>
<li>处理用户进程提出的时间闹钟系统调用</li>
<li>对系统某些部分提高监视定时器</li>
</ol>
<h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><p>这里之后再回来补。</p>
<h2 id="系统任务"><a href="#系统任务" class="headerlink" title="系统任务"></a>系统任务</h2><p>文件系统和存储管理器服务进程处于系统结构的第三层——服务层，也就是说这两个服务并不在内核中（第一、二层）。有时候它们拥有内核所需要的信息，但不被允许直接将信息写入到内核表中，也就无法与内核进行通信。为了解决这个问题，引入了系统任务（位于第二层），系统任务使得内核任务可以通过消息机制和文件系统和存储管理器通信，并且系统任务拥有对内核表的存取权。它和其它任务相似，唯一区别就是它不控制任何的I/O设备，而是面向系统中的大部分内部组件。</p>
<p>系统任务接受的19种消息如下：</p>
<table>
<thead>
<tr>
<th>消息类型</th>
<th>消息源</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SYS_FORK</td>
<td>MM(Main Memory)</td>
<td>产生了一个新进程</td>
</tr>
<tr>
<td>SYS_NEWMAP</td>
<td>MM</td>
<td>新建进程的存储映像并通知内核</td>
</tr>
<tr>
<td>SYS_GETMAP</td>
<td>MM</td>
<td>获取进程的存储映像信息</td>
</tr>
<tr>
<td>SYS_EXEC</td>
<td>MM</td>
<td>将exec系统调用后堆栈的指针传给内核</td>
</tr>
<tr>
<td>SYS_XIT</td>
<td>MM</td>
<td>进程结束</td>
</tr>
<tr>
<td>SYS_TIMES</td>
<td>FS(File System)</td>
<td>文件系统想要一个进程的运行时间</td>
</tr>
<tr>
<td>SYS_ABORT</td>
<td>Both</td>
<td>发现根设备的超级块有致命损坏，将陷入混乱状态</td>
</tr>
<tr>
<td>SYS_SENDSIG</td>
<td>MM</td>
<td>发送一个信号给一个进程</td>
</tr>
<tr>
<td>SYS_SIGRETURN</td>
<td>MM</td>
<td>将sigcontext结构拷贝回内核空间，然后恢复进程的寄存器</td>
</tr>
<tr>
<td>SYS_KILL</td>
<td>FS</td>
<td>文件系统用来请求产生一个信号</td>
</tr>
<tr>
<td>SYS_ENDSIG</td>
<td>MM</td>
<td>减少等待信号的计数，如果计数减到零，则重置进程的SIG_PENDING位</td>
</tr>
<tr>
<td>SYS_COPY</td>
<td>Both</td>
<td>主存从用户进程拷贝信息</td>
</tr>
<tr>
<td>SYS_VCOPY</td>
<td>Both</td>
<td>进程间多个数据块的复制</td>
</tr>
<tr>
<td>SYS_GBOOT</td>
<td>FS</td>
<td>获取启动参数</td>
</tr>
<tr>
<td>SYS_MEM</td>
<td>MM</td>
<td>主存想知道下一个物理内存空闲块</td>
</tr>
<tr>
<td>SYS_UMAP</td>
<td>FS</td>
<td>将虚拟地址转换成实际物理地址</td>
</tr>
<tr>
<td>SYS_TRACE</td>
<td>MM</td>
<td>执行PTRACE调用的操作</td>
</tr>
<tr>
<td>SYS_GETSP</td>
<td>MM</td>
<td>找出某些进程当前堆栈指针的值</td>
</tr>
<tr>
<td>SYS_TIMES</td>
<td>Both</td>
<td>向调用者返回记账时间</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>进程</title>
    <url>/2020/10/26/%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>之前大致了解了进程的概念：进程实质上是一个正在执行的程序。而进程也是操作系统最核心的概念，因此这篇文章则是深入地研究进程的概念，希望学完后，自己能够掌握进程的知识。</p>
<span id="more"></span>

<h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><p>在进程模型中，计算机上所以可运行的软件，包括操作系统，都被组织成若干进程。而一个进程就是一个正在执行的程序，包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程拥有它自己的虚拟CPU，而实际上是CPU在各进程间来回切换。这种快速的切换称作多道程序。</p>
<p>由于CPU在各进程间来回切换，每个进程执行运算的速度是不确定的，而且当同一进程再次运行，其运算速度也不可再现。所以，进程的编程不能对时序做任何固定的假设。比如，考虑一个I/O进程用流式磁带机恢复被备份的文件，它执行一个10000次的空循环以等待磁带机达到正常速度，然后发出命令读取第一个记录。如果CPU决定在空循环期间将处理机调度给其他进程，则磁带机进程可能在第一条记录通过磁头后还未被再次调度。当一个进程具有如此严格的实时要求时（某些特定实践要在指定的若干秒内发生），那么就必须采取特殊措施保证它们一定在这段时间中发生。</p>
<p>这里再区分一下进程和程序。进程和程序间的区别很微妙，但又十分重要。用一个类比来说明：想象有一位好厨艺的程序员正在为他的女儿烘培生日蛋糕。他有做生日蛋糕的食谱，厨房里有原料：鸡蛋、免费、糖等。在这个类比中，做蛋糕的食谱就是程序，程序员就是CPU，而做蛋糕的各种原料则是输入数据。<strong>进程就是厨师阅读食谱，取原料混合，以及烘焙蛋糕的一系列动作的综合</strong>。现在假设程序员的儿子哭着跑了进来，手被蜜蜂蛰了，程序员就会记下食谱完成到哪了（保存进程的当前状态），然后拿出医疗箱处理伤口。这里，就是CPU从一个进程切换到另一个进程，每个进程都有自己的程序（食谱和医疗箱）。当处理完伤口后，程序员又继续回去做蛋糕，从记录的食谱的下一步继续做下去。</p>
<h3 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h3><p>在MINIX系统中，进程通过fork系统调用来创建进程，它将创建一个与调用进程相同的进程拷贝。子进程也能进行fork调用，以此类推。因此，会形成一棵完整的进程树。注意，在这个概念中，每个进程只有一个父进程，但可以有若干个子进程（0个、1个等）。也就是说，在系统启动后，进程树必须得有个进程树的根，在MINIX系统中，进程树的根就是<strong>init进程</strong>。</p>
<p>在MINIX的引导映像中有一个称为init的特殊进程，当它开始运行时，会读取一个记录存在多少个终端文件，然后为每个终端创建一个新的进程，这些进程等待用户进行登录。如果登录成功，登录进程执行一个shell程序来接受命令，这些命令启动更多的进程，以此类推。这样，系统中的所有进程都属于一棵进程树，而init进程是进程树的根。</p>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>尽管每个进程是一个独立的实体，有自己的程序计数器和内部状态，但进程间常常需要进行通信，一个进程的输出结果可能会作为另外一个进程的输入。</p>
<p>当一个进程在逻辑上不能继续运行时，就会阻塞，比如等待用户输入的进程。还有一种可能就是进程能够运行，但被迫停止，原因就是操作系统调度另一个进程占用CPU。这两种条件是完全不同的，第一种情况，挂起的程序是程序自身所固有的；第二种情况是系统引起的。因此线程会产生3种状态：</p>
<ol>
<li>运行（Running）。CPU正在执行进程</li>
<li>就绪（Ready）。可运行，但是因为其他进程需要运行被暂时挂起</li>
<li>阻塞（Blocked）。除非某个事件发生，否则不能运行</li>
</ol>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png"></p>
<p>通过进程模型以及进程的状态，我们就可以简单地推断出系统内部的操作状况。</p>
<p>关于调度程序，它可以是如下的基本结构：</p>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B.png"></p>
<p>在调度程序上面有许多进程，所有关于中断处理、启动、中止进程的具体细节被隐藏在调度程序中。实际上它是一段非常短小的程序。操作系统的其他部分被简洁地组织成进程形式。上面的进程调度模型在MINIX中得到使用，但是对于其中的调度程序，不应该之理解为对进程的调度安排，它也包括了中断处理和所有进程间的通信。</p>
<h2 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h2><p>为了实现进程模型（进程树），操作系统维持着一张表格（一个结构数组），该表格称为**进程表(process table)**。每个进程占用一个进程表项。该表项包含了进程的状态、程序计数器、栈指针、内存分配状况、打开文件的状态、计费和调度信息，以及其他在进程由运行态转为就绪态所必须保存的信息，只有这样才能使进程随后被再次启动，就像从未被中断过一样。</p>
<table>
<thead>
<tr>
<th>进程管理</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
</tr>
<tr>
<td>程序计数器</td>
</tr>
<tr>
<td>程序状态字</td>
</tr>
<tr>
<td>栈指针</td>
</tr>
<tr>
<td>进程状态</td>
</tr>
<tr>
<td>进程开始时间</td>
</tr>
<tr>
<td>使用的CPU时间</td>
</tr>
<tr>
<td>子进程的CPU时间</td>
</tr>
<tr>
<td>下次报警时间</td>
</tr>
<tr>
<td>消息队列指针</td>
</tr>
<tr>
<td>挂起的信号位</td>
</tr>
<tr>
<td>进程标识号</td>
</tr>
<tr>
<td>各种标志位</td>
</tr>
</tbody></table>
<p><strong>调度程序工作过程：</strong></p>
<p>与每类I/O设备（硬盘、终端等）相关的都有一个靠近内存底部的位置，称为中断向量。中断向量包含了中断服务程序的入口地址。假设当一个磁盘发生中断时，用户进程3正在运行，则中断硬件会将程序计数器、程序状态字、多个寄存器压入当前堆栈，然后计算机随机跳转到磁盘中断向量所指的地址处。上面这些部分都是由硬件完成的操作，下面就开始由软件完成相关任务。</p>
<p>中断服务程序将当前进程全部寄存器的值存入进程表的表项。当前进程号以及一个指向其表项的指针被保存在全局变量中以便能够快速地找到进程表。随后将中断存入的那部分信息从堆栈中删除，并将栈指针执行一个被进程管理者所使用的临时堆栈。然后调用一个短小的汇编语言例程来保存寄存器值和设置栈指针等任务。当该例程结束后，调用一个C语言过程来完成剩下的工作。</p>
<p>在MINIX中，进程间通信通过消息完成，所以下一步是构造一条发送给磁盘进程的消息。这时，磁盘进程正在阻塞并等待该消息，这条消息通知说发生了一次中断，以此将它和那些由用户进程发送的消息加以区分。现在磁盘进程的状态由阻塞转换到就绪，然后，中断服务程序调用调度程序，如果当前磁盘进程是优先级最高的就绪进程，则它将被调度执行。如果中断进程具有与磁盘进程相等或更高的优先级，则中断进程将被再次调度运行，磁盘进程继续处于就绪状态。</p>
<p>无论磁盘进程是否得到执行，被汇编语言中断代码所调用的C过程现在返回，汇编语言代码为新的当前进程装入寄存器值和内存映像并启动它运行。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在传统进程中，每个进程只存在一条控制线程和一个程序计数器。但是在现代操作系统中，通常单个进程会有多条控制线程的支持。这些控制线索通常称为**线程(threads)<strong>，有时也称为</strong>轻量级进程(lightweight processes)**。</p>
<p><img src="/images/%E4%BC%A0%E7%BB%9F%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B.png"></p>
<p>第一个图中，我们看到三个传统的进程，每个进程有自己的地址空间和单一的控制线程。第二个图则看到一个进程有三条控制线程。尽管这两种情况都有3个线程，但是第一个图中各线程在不同的地址空间中操作，而第二个图中三个线程共享同一个地址空间。</p>
<p>使用多线程的例子：考虑一个文件服务器进程，它接收读写文件的请求并将请求的数据送回或者接受更新的数据。为了提高性能，服务器在内存中维护一个高速缓存，里面存放最近使用过的文件，需要时从缓存中读取数据或者写数据。</p>
<p>这时候就非常适合多线程模型。当一个请求到来时，将它递交给一个线程处理。如果这个线程因为等待磁盘传输而中途阻塞，其他线程仍然可以运行，这样服务器就可以在磁盘I/O的同时，继续处理新的请求。</p>
<p>需要注意的是，当一个进程的地址空间有多个线程时，就需要单独一张线程表，每个线程占用一项。针对每个线程的信息包括：程序计数器、寄存器值及状态。需要程序计数器是因为线程可以像进程一样被挂起和恢复执行。需要寄存器是因为当线程被挂起时，它的寄存器值必须被保存下来。最后，线程可以像进程一样，处于运行、就绪、阻塞状态。</p>
<p>线程的产生带来两个问题，线程是应该在用户空间进行管理还是应该在内核中进行管理。在用户空间进行管理的线程，其切换速度要比在核心调用的情况快得多。而若线程完全由用户空间管理，当一个线程阻塞时，核心会将整个进程阻塞，因为核心不知道有其他的现场存在。所以，最终的妥协结果为，两者情况的混合方案。</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程常常需要与其他进程通信。例如，在一个shell管道中，第一个进程的输出必须传送到第二个进程，这样沿着管道传递下去。因此在需要通信的进程间，最好使用一种结构较好的方式，不要使用中断。</p>
<p>进程间通信要解决3个问题：一个进程如何向另一个进程传送信息；如何保证两个或多个进程在涉及临界活动的时候不会彼此影响（设想两个进程都试图获取最后一部分内存的情况）；涉及依赖关系时进行适当的定序（进程A产生数据，进程B打印数据，那么B在打印前必须等到A产生一些数据为止）</p>
<h3 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h3><p>如果多个进程共享一些彼此都可以读写的公共存储区（内存或者磁盘），此时，一个进程修改一个文件的同时另一个进程同时也在读取该文件，那么进程得到的结果就会取决于进程运行时的时许，即不同时候得到的结果不同，这是件令人头疼的事情，这样的情况也称为**竞争条件(race conditions)**。</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>要避免竞争条件，关键就是在于找到某种手段，确保一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作。</p>
<p>对避免竞争的问题做一种抽象的方式描述：一个进程的一部分时间做内部计算和其他不会引发竞争条件的操作。在另外一些时候进程会访问共享内存或共享文件，执行一些会导致竞争的操作。我们将对共享内存进行访问的程序片段称为**临界区(critical region)或临界段(critical section)**。如果我们能够适当地安排两个进程不可能同时处于临界区，那么就能够避免竞争条件。这样的要求防止了竞争条件，但还不能保证使用期间共享数据的并发进程能够正确和高效地执行操作。我们还需要以下4个条件：</p>
<ol>
<li>任何两个进程不能同时处于临界区</li>
<li>不对CPU的数目和速度做任何目标假设</li>
<li>临界区外的进程不能阻塞其他进程</li>
<li>不得使进程在临界区外无休止地等待</li>
</ol>
<h3 id="忙等待的互斥"><a href="#忙等待的互斥" class="headerlink" title="忙等待的互斥"></a>忙等待的互斥</h3><h4 id="关中断"><a href="#关中断" class="headerlink" title="关中断"></a>关中断</h4><p>一个简单的方法是使每个进程在进入共享变量或文件的临界区后<strong>先关中断，离开前再开中断</strong>。中断被关掉后，时钟中断也会被屏蔽。而CPU只有在发生了时钟中断或者其他中断时才会切换进程，这样一来，关中断之后CPU就不会切换到其他进程执行，于是，执行关中断的进程就可以检查和修改共享内存而不必担心其他进程的介入。</p>
<p>但很明显，这种方法不行，将中断的权力交给用户是不明智的，危险的。假如一个进程关中断后并没有开中断，那么系统就会因此而终止。而且该方法对于多CPU的操作系统是不可行的，因为关中断只对执行指令的CPU有效，其他CPU仍将继续运行，并可以访问共享内存。</p>
<p>该方法违反条件1，不可行。</p>
<h4 id="锁变量"><a href="#锁变量" class="headerlink" title="锁变量"></a>锁变量</h4><p>第二种尝试是使用软件解决方案。假设有一个锁（共享变量），初始值为0。当一个进程想进入锁的临界区时，会首先尝试获取锁。如果锁的值为0，则进程将其设置为1并进入临界区。如果锁为1，则进程将等待，直到锁变成0。所以0表示临界区内没有进程，1表示有某个进程进入了临界区。</p>
<p>这种办法也有纰漏，比如当一个进程读取锁的值时发现它为0，而恰好在该进程要将锁的值置为1之前，另一个进程被调度执行，读取了锁的值并将锁的值置为1，当第一个进程再次运行时，它也将锁的值置为1，则此时会同时有两个进程处于临界区中。</p>
<p>该方法违反条件1，不可行。</p>
<h4 id="严格的轮换法"><a href="#严格的轮换法" class="headerlink" title="严格的轮换法"></a>严格的轮换法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">    <span class="keyword">while</span> (turn != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*等待*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    critical_region();  <span class="comment">//临界区</span></span><br><span class="line">    turn = <span class="number">1</span>;</span><br><span class="line">    noncritical_region();  <span class="comment">//非临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">    <span class="keyword">while</span> (turn != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/*等待*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    critical_region(); <span class="comment">//临界区</span></span><br><span class="line">    turn = <span class="number">0</span>;</span><br><span class="line">    noncritical_region();  <span class="comment">//非临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现假设有两个进程：进程0和进程1，以及一个整型变量turn。当turn=0时，进程0进入临界区，进程1如果要进入临界区，则要进行忙等待；当turn=1时，进程1进入临界区，进程0如果要进入临界区，则也要进行忙等待。</p>
<p>整型变量turn初始值为0，用于<strong>跟踪哪个进程进入临界区</strong>来检查或更新共享内存。一开始进程0检查turn，发现它是0，于是进程0进入临界区。进程1发现turn是0，于是执行一个等待循环不停检测它是否变成1。持续地检测一个变量直到它具有某一特定值就称作**忙等待(busy waiting)**。忙等待是应该避免的，因为它会浪费CPU的时间。</p>
<p>当进程0离开临界区时，它将turn置为1，以允许进程1进入临界区。当进程1离开临界区，turn值又会被置为0。此时两个进程都在临界区外。现在进程0更早地比进程1执行完了一次循环，并再次执行到非临界区部分，并将turn值置为1（看代码）。此时，进程0又结束了非临界区部分的操作并回到了循环的开始，需要执行临界区部分，但此时它并不能进入临界区，因为turn的值为1，而且进程1还在执行非临界区代码。</p>
<p>这种情况违反了条件3：临界区外的进程不能阻塞其他进程，进程1执行非临界区代码阻塞了进程0</p>
<h4 id="Peterson解决方案"><a href="#Peterson解决方案" class="headerlink" title="Peterson解决方案"></a>Peterson解决方案</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLASE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N     2			<span class="comment">/*进程数量*/</span></span></span><br><span class="line"><span class="keyword">int</span> turn;				<span class="comment">/*轮到哪个进程？*/</span></span><br><span class="line"><span class="keyword">int</span> interested[N];		<span class="comment">/*初始值为FALSE*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enter_region</span><span class="params">(<span class="keyword">int</span> process)</span> </span>&#123;  <span class="comment">/*进程号为0或1*/</span></span><br><span class="line">    <span class="keyword">int</span> other;					<span class="comment">/*另一个进程的进程号*/</span></span><br><span class="line">    other = <span class="number">1</span> - process;	</span><br><span class="line">    interested[process] = TRUE;		<span class="comment">/*标识出进入临界区的进程*/</span></span><br><span class="line">    turn = process;					<span class="comment">/*设置标志位*/</span></span><br><span class="line">    <span class="keyword">while</span> (turn == process &amp;&amp; interested[other] == TRUE) &#123;&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leave_region</span><span class="params">(<span class="keyword">int</span> process)</span> </span>&#123;		<span class="comment">/*即将离开临界区的进程*/</span></span><br><span class="line">    interested[process] = FALSE;		<span class="comment">/*还原离开临界区的进程的标识*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方案工作过程：</p>
<p>起初没有任何进程处于临界区，现在进程0调用enter_region，通过将其数组元素置为TRUE和将turn置为0来标识它希望进入临界区。由于进程1并不想进入临界区，所以enter_region很快便返回。</p>
<p>现在考虑两个进程同时调用enter_region的情况。它们都将自己的进程号存入turn，但只有后一个被保存进去的进程号才会保存到turn，前一个是无效的。假设进程1后存，则turn=1。当两个进程都运行到while语句时，进程0的判断条件为 <code>1 == 0 &amp;&amp; interested[1] == TRUE</code> 进程1的判断条件为 <code>1 == 1 &amp;&amp; interested[0] == TRUE</code> 很明显进程1会执行循环，进程0不会执行循环并进入临界区。</p>
<p>该方案的神奇之处还在于是会按顺序执行的，这从上面的过程也可以看出。</p>
<h4 id="TSL指令"><a href="#TSL指令" class="headerlink" title="TSL指令"></a>TSL指令</h4><p>该方案需要硬件支持。TSL指令工作过程：该指令经一个存储器字读取到一个寄存器中，然后在该内存地址上存一个非零值。读数和写数操作保证是不可分割的——该指令结束之前，其他处理器均不允许访问该存储器字。执行TSL指令的CPU将锁住内存总线以禁止其他CPU在指令结束之前访问内存。</p>
<p>下面是使用过程：</p>
<p>为了使用TSL指令，需要使用一个共享变量lock来协调对内存的访问。当lock=0时，任何进程都可以访问，并使用TSL指令将其置为1并读写共享内存。当操作结束时，进程用一条MOVE指令将lock重新置为0.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enter_region:</span><br><span class="line">	tsl register, lock		|复制lock到寄存器，并将lock置为1</span><br><span class="line">	cmp register, #0		|lock=0 ?</span><br><span class="line">	jne enter_region		|如果不等于0，已上锁，再次循环</span><br><span class="line">	ret						|返回调用程序，进入临界区</span><br><span class="line">leave_region:</span><br><span class="line">	move lock, #0			|置lock=0</span><br><span class="line">	ret						|返回调用程序</span><br></pre></td></tr></table></figure>

<h3 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a>睡眠和唤醒</h3><p>虽然Peterson解法和TSL指令都是正确的，但它们都存在忙等待的缺点——一个进程想进入临界区，需要先检测是否允许进入，如果不允许，则进程将踏步等待，直到许可为止。这将会耗费CPU时间。</p>
<p>另外，忙等待也会导致一个问题——优先级翻转。比如有两个进程，H进程优先级高，L进程优先级低。调度规则规定只要H处于就绪态它就可以运行。而此时，如果L进程在临界区中，H进程切换到就绪态准备运行。那么H进程会开始忙等待。但由于H处于就绪状态时，L进程不会被调度，所以L进程无法离开临界区，H进程将一直忙等待下去。</p>
<p>因此，为了解决上述问题，就出现了以下进程间通信原语：**睡眠(sleep)和唤醒(wakeup)**。睡眠是指sleep系统调用将调用进程阻塞（挂起），直到另一进程将其唤醒。而唤醒则会执行wakeup系统调用，wakeup系统调用有一个参数，即要被唤醒的进程。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>使用一个整型变量来累计唤醒次数，该整型变量就称为**信号量(semaphore)**。一个信号量的值可以是0，表示没有积累下来的唤醒操作；或者是正值，表示有一个或多个被积累下来的唤醒操作。</p>
<p>对信号量有两者操作：down和up。对一信号量执行down操作是检查其值是否大于0。如果是则将其值减1并继续。如果值为0，则进程睡眠，此时down操作并未结束，而是等待信号量的值大于0。检查数值、改变数值，以及可能发生的睡眠操作均为一个单一的、不可分割的**原子操作(atomic action)**完成。即保证一但一个信号量操作开始，则在操作完成或阻塞之前，别的进程均不允许访问该信号量。</p>
<p>up操作递增信号量的值。如果一个或多个进程在该信号量上睡眠，无法完成先前的down操作，则由系统选择其中一个并允许该选择的进程完成它的down操作。因此，对一个有进程在其上睡眠的信号量执行一次up操作之后，该信号量的值仍旧是0，但睡眠进程却少了一个。递增信号量的值和唤醒一个进程同样也是不可分割的，不会有进程因为执行up操作而阻塞。</p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>使用信号量需要非常小心，一处很小的错误会导致很大的麻烦，比如死锁，竞争条件，以及其他不可预测的行为。</p>
<p>为了编写正确的程序，提出了一种高级的同步原语，称为**管程(monitor 监视器)**。一个管程是由过程、变量以及数据结构等组成的一个集合，组成一个特殊的模块或软件包。进程在任何需要的时候调用管程中的过程，但不能在管程外的过程中直接访问管程内的数据结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monitor example</span><br><span class="line">		integer i;</span><br><span class="line">		condition c;</span><br><span class="line">		procedure producer(x);</span><br><span class="line">		......</span><br><span class="line">		end;</span><br><span class="line">		procedure consumer(x);</span><br><span class="line">		......</span><br><span class="line">		end;</span><br><span class="line">end monitor;</span><br></pre></td></tr></table></figure>

<p>管程有一个很重要的特性（这也是它取名字的原因）：任意时刻管程中只能有一个活跃进程。当一个进程调用管程中的过程时，前几条指令会检查管程中是否有其他的活跃进程，如果有，则将进程挂起，直到另一个进程离开管程。如果没有，则调用进程便进入管程。</p>
<p>对管程实现互斥由编译器负责。开发人员无需关心编译器如何实现代码互斥，他只需要知道将所有的临界区转换成管程中的过程即可，绝不会有两个进程同时执行临界区中的代码。</p>
<p>有了管程之后，还需要一种办法使得进程在无法继续运行时被阻塞，当满足条件时被唤醒.解决办法就是引入<strong>条件变量(condition variables)<strong>，以及相关的两个操作：</strong>wait和signal</strong>。当一个管程的过程发现进程无法继续时，就会在某些条件变量下执行wait操作，该动作引起调用进程阻塞，允许另一个之前被挡在管程外的进程进入管程。</p>
<p>当某些条件变量满足唤醒条件时，就会执行signal操作来唤醒正在睡眠的进程，让被唤醒的进程执行，让执行唤醒操作的进程立即退出管程。</p>
<p>下面是使用管程来解决生产者—消费者问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">	condition full, empty;</span><br><span class="line">	integer count;</span><br><span class="line">	procedure enter;</span><br><span class="line">	begin</span><br><span class="line">		if count=N then wait(full);</span><br><span class="line">		enter_item;</span><br><span class="line">		count=count+1;</span><br><span class="line">		if count=1 then signam(empty)</span><br><span class="line">	end;</span><br><span class="line">	procedure remove;</span><br><span class="line">	begin</span><br><span class="line">		if count=0 then wait(empty);</span><br><span class="line">		remove_item;</span><br><span class="line">		count=count-1;</span><br><span class="line">		if count=N-1 then signal(full);</span><br><span class="line">	end;</span><br><span class="line">	count=0;</span><br><span class="line">	end monitor;</span><br><span class="line">	</span><br><span class="line">	procedure producer;</span><br><span class="line">	begin</span><br><span class="line">		while true do</span><br><span class="line">		begin</span><br><span class="line">			produce_item;</span><br><span class="line">			ProducerConsumer.enter</span><br><span class="line">		end</span><br><span class="line">	end;</span><br><span class="line">	procedure consumer;</span><br><span class="line">	begin</span><br><span class="line">		while true do</span><br><span class="line">		begin</span><br><span class="line">			ProducerConsumer.remove;</span><br><span class="line">			consume_item</span><br><span class="line">		end</span><br><span class="line">	end;</span><br></pre></td></tr></table></figure>

<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>**消息传递(message passing)**，该进程间通信方法使用两个系统调用send和receive：</p>
<ul>
<li>send(destination, &amp;message)</li>
<li>receive(source, &amp;message)</li>
</ul>
<p>send系统调用像一个给定的目标发生一条消息，receive调用从一个给定的源接收一条消息。如果没有消息可用，则接收者可能阻塞，直到一条消息可达，或者它也可以立即返回，并带回一个错误码。</p>
<p>消息传递可以有许多变体。一种方法是为每个进程分配一个唯一的地址，按进程为消息指定地址。另一种方法则是引入一种新的数据结果，称为**信箱(mailbox)**。一个信箱就是一个用来对一定数量的消息进行缓冲的地方。当使用信箱时，send和receive系统调用中的地址参数使用信箱，而不是进程。当一个进程试图像一个满的信箱发消息时，它将被挂起，直到信箱内有消息被取走而为新消息腾出空间。</p>
<p>在MINIX中用户进程间的通信采用管道，它和信箱在效果上等价。采用信箱的消息系统和管道机制的区别在于管道没有预先设定消息的边界。换言之，如果一个进程想管道写入10条100字节的消息，而另一个进程从管道中读取1000个字节，则读进程将一次性获得这所有10条消息。此外，进程还需要达成一致：总是从管道中读写固定大小的消息还是每个消息以一个特殊的字符结束。在MINIX消息系统中，MINIX进程间使用消息大小固定的消息机制进行通信。</p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>当有多个进程就绪时，操作系统必须决定先运行哪一个。操作系统中做出这种决定的部分称为**调度程序(scheduler)<strong>，使用的算法称作</strong>调度算法(scheduling algorithm)**。</p>
<p>在讨论具体的调度算法之前，需要考虑调度程序要达到的目标：</p>
<ol>
<li>公平。确保每个进程获得合理的CPU份额</li>
<li>有效。使CPU百分百忙碌</li>
<li>响应时间。使交互用户的响应时间尽可能短</li>
<li>周转时间。使批处理用户等待输出的时间尽可能短</li>
<li>吞吐量。每小时处理的作业数最多</li>
</ol>
<p>上述条件间是存在矛盾的，比如条件3和条件4，要使响应时间短，那么对于批处理作业应该不予调度，然而这又会使得条件1无法得到保证。所以，调度算法应该尽可能在多个条件间平衡。</p>
<p>此外，为了保证不让进程运行太久，所有计算机都会内置一个时钟，它将定期发出中断，通常为每秒钟50次到60次（赫兹，Hz），操作系统也能根据需要将时钟频率设置成任意值。每发生一次时钟中断，操作系统都将运行，并决定当前进程是否应该继续运行，还是它已经占用了足够长的CPU时间，应该暂停让其他进程运行。</p>
<p>术语：允许将逻辑上可运行的进程暂时挂起的策略称为**可剥夺调度(preemptive scheduling)<strong>；运行直到结束的调度方式称为</strong>非剥夺调度(nonpreemptive scheduling)**。</p>
<h3 id="时间片轮转调度"><a href="#时间片轮转调度" class="headerlink" title="时间片轮转调度"></a>时间片轮转调度</h3><p>时间片轮转调度是最古老、最简单、最公平且使用最广泛的算法。<strong>每个进程被分配一个时间片，在时间片内进程才能够运行</strong>。如果时间片结束进程还在运行，那么执行进程的CPU将会被剥夺并分配给另外一个进程；如果进程在时间片结束前阻塞或者结束，则CPU会立即进行切换到另一个进程执行。</p>
<p>时间片轮转调度依靠调度程序维护一张就绪进程表，当进程使用完它的时间片后，就被移到队列的末尾。</p>
<p><img src="/images/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6.png"></p>
<p>时间片轮转调度需要注意的一点就是时间片的长度。从一个进程切换到另一个进程是需要一定时间的：保存和装入寄存器值和内存映像，更新各种表格和队列。假如**进程切换(process switch)，也称为上下文切换(context switch)**，需要5毫秒。再假设时间片设为20毫秒。则在做完20毫秒的有用工作之后，CPU将花费5毫秒来进行进程切换，CPU有20%的时间被浪费在管理开销上。</p>
<p>虽然为了提高CPU效率，可以将时间片的长度设置的更长，从而使得浪费的管理开销时间占比下降。但是，系统的实时性却并不出色：假如时间片长度设为500毫秒，此时，10个用户同时按下回车键，那么就会有10个进程挂在就绪队列中，而最后一个用户的进程需要等待5秒后才得到执行，这显然会使得用户无法忍受。</p>
<p>所以，可以总结如下：时间片设定的过短会导致过多的进程切换，降低了CPU效率；而设的太长，又可能会引起对短交互请求的响应变差。<strong>将时间片长度设为100毫秒，是一个比较合理的折中</strong></p>
<h3 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h3><p>基本思想：每个进程被赋予一个优先级，优先级高的就绪进程优先执行。</p>
<p>为了防止高优先级的进程无休止地运行下去，调度程序可能在每个时钟中断后降低当前进程的优先级，如果该次动作使得当前进程的优先级低于次优先级进程，则将进行进程切换。另一种做法是给每个进程设定一段它能够连续使用CPU的时间片，一旦这段时间使用完，则运行次高优先级的进程。</p>
<p>一般来说，会将一组进程按优先级分成若干类，各类之间采用优先级调度，而各类进程内部采用时间片轮转调度。如图所示：</p>
<p><img src="/images/%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png"></p>
<h3 id="多重队列"><a href="#多重队列" class="headerlink" title="多重队列"></a>多重队列</h3><p>通过设立优先级，属于最高级的进程运行1个时间片，次高优先级的进程运行2个时间片，再次一级的进程运行4个时间片，以此类推。当一个进程用完分配的时间片后，移到下一类级别。比如，一个进程需要100个时间片才能完成任务。最初被分配1个时间片，然后被换出。下次它将获得2个时间片，接下来是4、8、16、32、64。最后一次只使用了64个时间片的37个便可以结束工作。整个过程需要7次交换（包括最初的装入）。而如果纯粹是时间片轮转调度，则需要100次交换。而且，随着进程优先级的不断降低，它的运行频率开始逐渐放慢，从而为短的交互进程让出CPU。</p>
<h3 id="最短作业优先"><a href="#最短作业优先" class="headerlink" title="最短作业优先"></a>最短作业优先</h3><p>前3个算法都是为了交互系统设计的，而最短作业优先适用于运行时间可以预知的批作业的调度算法。</p>
<p>考虑4个作业：A、B、C、D，运行时间分别为8、4、4、4分钟。如果按次序执行，则A的周转时间为8分钟，B的周转时间为12分钟，C的周转时间为16分钟，D的周转时间为20分钟，平均为14分钟。</p>
<p>现考虑用最短作业优先算法，则4个作业执行次序为：B、C、D、A。则现在的周转时间分别为4、8、12、20，平均为11分钟。</p>
<p>证明最短作业优先是最优的：</p>
<p>考虑有n个作业的情况，其运行时间分别为a1、a2、… 、an</p>
<p>则第一个作业在时间a1结束</p>
<p>第二个作业在a1+a2结束</p>
<p>…… 第n个作业在a1+a2+……+an结束</p>
<p>平均周转时间为 (a1*n+a2*(n-1)+……+an) / n</p>
<p>显然，a1对平均值的影响最大，它应该是作业时间最短的那个，a2次之，以此类推。</p>
<p>现在的问题就是如何在就绪进程中找到最短的那个进程：</p>
<p>一种办法是根据进程过去的行为进行推测，并执行估计运行时间最短的那个。比如某个进程的估计运行时间为T0，现假设测量到的下一次运行时间为T1。则可以通过两个值的加权和来改进估计时间，即 a*T0+(1-a)*T1</p>
<p>当a取1/2时，可以得到如下序列：<br>$$<br>T_{0}、(T_{0}/2+T_{1}/2)、(T_{0}/4+T_{1}/4+T_{2}/2)、(T_{0}/8+T_{1}/8+T_{2}/4+T_{3}/2)<br>$$<br>可以看到，3轮过后，T0在新的估计值中占到的比重下降到1/8。这种通过将当前测量值和先前估计值进行加权平均而得到下个估计值的技术称为老化算法，适用于许多预测值必须基于先前值的情况。</p>
<h3 id="保证调度算法"><a href="#保证调度算法" class="headerlink" title="保证调度算法"></a>保证调度算法</h3><p>通过跟踪进程自创建以来已使用了多少CPU时间，然后计算各进程应该获得的CPU时间，并计算已用CPU时间的百分比。比如0.5说明一个进程只获得了应得时间的一半，2.0则说明获得了应得时间的2倍。于是，算法随后转向比率最低的进程，直到该进程的比率超过次低进程为止。</p>
<h3 id="彩票调度算法"><a href="#彩票调度算法" class="headerlink" title="彩票调度算法"></a>彩票调度算法</h3><p>该算法基本思想为：违禁词发放对系统各种资源（如CPU时间）的彩票。当调度程序需要做出决策时，随机选一张彩票，而持有该彩票的进程将获得系统资源。比如对于CPU调度，系统可能每秒钟抽50次彩票，每次的中奖者获得20毫秒的运行时间。</p>
<p>如果一些进程需要更多的机会，则给它更多的额外彩票，增加其中奖的机会。</p>
<h3 id="两级调度算法"><a href="#两级调度算法" class="headerlink" title="两级调度算法"></a>两级调度算法</h3><p>如果没有足够的内存，某些就绪的进程就会部分或全部地被放在磁盘上，这种情况对调度有很大影响，因为从磁盘上读入一个进程运行比单纯在内存中进行进程切换要慢几个数量级。</p>
<p>两级调度算法就是处理内存之外的进程。调度程序会分为低级调度程序和高级调度程序。低级调度程序对那些驻留在内存中的进程进行调度，高级调度程序周期性地将那些在内存中驻留时间足够长的进程换出，而将那些在磁盘上等候时间过长的进程换入。这样，低级调度程序只需要关心在内存中的就绪进程，而高级调度程序则关心将进程在内存和磁盘间来回交换。</p>
<h3 id="调度策略与机制"><a href="#调度策略与机制" class="headerlink" title="调度策略与机制"></a>调度策略与机制</h3><p>考虑这样的情况：一个进程有许多子进程在其控制下运行。例如，一个数据库管理系统可能会有许多子进程，每个子进程可能处理不同的请求，或者每个子进程实现不同的功能。主进程需要掌握哪个子进程最重要，哪个最不重要，这需要从用户进程中接受有关的调度决策信息，而不是从系统中得出。</p>
<p>解决该问题的方法就是将**调度机制(scheduling mechanism)和调度策略(scheduling policy)**分开。将调度算法以某种方式参数化，参数由用户进程选择。</p>
<h2 id="MINIX进程概述"><a href="#MINIX进程概述" class="headerlink" title="MINIX进程概述"></a>MINIX进程概述</h2><h3 id="MINIX系统的内部结构"><a href="#MINIX系统的内部结构" class="headerlink" title="MINIX系统的内部结构"></a>MINIX系统的内部结构</h3><p>MINIX系统被分成4层，每一层执行一套定义完好的功能。</p>
<p><img src="/images/MINIX%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84.png"></p>
<p><strong>底层</strong></p>
<p>底层捕获所有的中断和陷入，完成进程调度，并向高层提供一个采用消息进行通信的独立顺序进程模型。该层代码有两大主要功能。第一是捕获陷入和中断、保存和恢复寄存器、调度以及向高层提供一个独立顺序进程模型。第二是处理消息机制：检查目标进程的合法性、定位物理内存中发生和接收缓冲区、以及从发送方 向 接收方拷贝数据。其中中断处理的最底层部分用汇编语言编写，其余部分和其他层次用C语言编写。</p>
<p><strong>第二层</strong></p>
<p>第二层包括I/O进程，每类设备都有一个I/O进程。为了将其与普通用户进程相区别，称之为**任务(tasks)<strong>。任务与进程间的区别几乎没有，在许多系统中I/O任务也被称为</strong>设备驱动程序(device driver)**。这里的三个概念：任务、进程、设备驱动程序可以换用。</p>
<p>第二层所有任务和底层代码链接成一个单一的二进制程序，称作**核心(kernel)**。某些任务共享公共的子例程，但它们相互之间完全独立，分别进行调度，并采用消息进行通信。尽管任务和核心被编译在一起，但当核心和中断处理程序被执行时，它们被赋予比任务更改的优先级。所以，真正的核心代码可以访问任一一部分内存，以及任一处理器寄存器，这意味着和欣客运使用系统中任何地方的数据，执行任何指令。而任务则不能执行全部的机器指令，也不能访问所有CPU寄存器或者所有内存。</p>
<p><strong>第三层</strong></p>
<p>第三层包含向用户进程提供有用服务的进程。这些服务器进程在低于核心和任务优先级上运行，不能直接访问I/O端口，也不能访问属于自己的内存段以外的内存。内存管理器（Memory Manager，简称MM）负责执行所有牵涉到内存管理的系统调用，比如fork、exec、brk。文件系统（File System，简称FS）负责执行文件系统的调用，read、mount、chdir。</p>
<p>通过三层结构可以看出，在MINIX系统中，资源管理主要在核心（1，2层），系统调用的解释在第3层.</p>
<p><strong>第四层</strong></p>
<p>第四层包含所有的用户进程：shell、编译器、编辑器、用户的程序。</p>
<h2 id="MINIX进程管理概述"><a href="#MINIX进程管理概述" class="headerlink" title="MINIX进程管理概述"></a>MINIX进程管理概述</h2><p>计算机开机时，硬件从引导盘上将第一道第一扇区读入内存并从那里开始执行。具体细节根据引导盘是软盘还是硬盘而不同，这里只讨论硬盘。硬盘被分为若干分区(partition)，整个硬盘的第一个扇区包括一段小程序和磁盘分区表，通常称为<strong>主引导记录</strong>。程序部分被执行以读入分区表并选择活跃分区。活跃分区的第一个扇区有一个引导程序，它随后被装入并执行以查找启动程序boot。</p>
<p>启动程序boot会在硬盘分区上找一个包含多个部分的文件，并将各部分装到内存的适当位置。这些部分包括：核心、内存管理器、文件系统、init进程。这个部分比较复杂，这里只需要先知道一旦装入操作完成，核心便开始运行。</p>
<p>在初始化阶段，核心先启动各任务（第二层），然后是内存管理器、文件系统以及所有在第三层运行的服务器。当所有这些都开始运行并初始化完成之后，它们将阻塞，等待执行某种操作。当所有任务和服务器被阻塞后，将执行一个用户进程——init进程。init进程已位于内存中，只不过在它启动时其他部分均已就位，所有它可以作为一个独立的程序从磁盘上装入。但是，由于init进程只启动一次，而且不会再从硬盘上装入，所以最简便的方法就是把它和核心、任务、服务器一起包括在系统的核心映像文件中(iso)。</p>
<p><strong>init启动后先读/etc/ttytab文件</strong>，该文件列出了所有可能的终端设备。而终端设备都在/etc/ttytab的getty域有一项。而init进程为每个终端创建一个子进程。通常，每个子进程都执行文件/usr/bin/getty，打印出一条信心，然后等待输入一个用户名。随后将该用户名作为参数来调用/usr/bin/login。如果某个终端需要特殊的处理，则/etc/ttytab可以指定一条命令（如/usr/bin/stty），在执行getty之前执行该命令并对线路进行初始化。</p>
<p>在成功登录之后，/bin/login执行用户的shell（在/etc/passwd文件中指定，通常是/bin/sh或/usr/bin/ash）。</p>
<p>shell等待用户键入命令，并为每条命令创建一个新进程。采用这种方式时，每个shell都是init的子进程，而用户进程则是init的孙子进程，并且所有的用户进程都是一棵进程树的组成部分。</p>
<p>在MINIX进程管理中，最重要的系统调用是fork和exec系统调用。fork是创建一个新进程的唯一途径。exec允许一个进程执行一个指定的程序，当一个程序被执行时，按照文件头中指定的大小为其分配一部分内存。尽管在进程运行期间，数据段、栈段和空闲未使用部分的大小可以不时地改变，但进程分配到的内存总量将保持不变。</p>
<p>一个进程的所有信息被保存在进程表中，进程表划分成核心、内存管理和文件系统三部分，分别拥有它们各自所需要的域。当一个新进程出现，或者一个老进程结束时，内存管理器首先更新对应部分的进程表，然后向文件系统和核心发送消息，以通知它们进行相应的操作。</p>
<h2 id="MINIX进程间通信概述"><a href="#MINIX进程间通信概述" class="headerlink" title="MINIX进程间通信概述"></a>MINIX进程间通信概述</h2><p>MINIX提供三条原语来发送和接收消息，它们均通过C语言例程库例程调用：</p>
<ol>
<li>send(dest, &amp;message) 向进程dest发送一条消息</li>
<li>receive(source, &amp;message)  进程source接收一条消息</li>
<li>send_rec(src_dst, &amp;message)  发送一条消息并等待同一个进程的应答</li>
</ol>
<p>以上三条原语的第二个参数是消息数据的本地地址。核心中的消息传递机制将消息从发送者拷贝到接收者。应答消息（对于send_rec而言）则覆盖原先的消息。</p>
<p>每个进程或任务都可以从或者向同层或下一层的进程或任务发送或接收消息，用户进程不能直接与I/O任务通信，这一限制是强制的。而当一个进程或任务像一个当前没有在等待消息的进程发送一条消息时，发送者将阻塞，直到目标进程执行receive。</p>
<h2 id="MINIX进程调度概述"><a href="#MINIX进程调度概述" class="headerlink" title="MINIX进程调度概述"></a>MINIX进程调度概述</h2><p><img src="/images/%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png"></p>
<p>MINIX调度层出使用一个三级排队系统分别对应图中的第2、3、4层。任务和服务器级别的进程一直运行到阻塞，而用户进程则采用时间片轮转调度。</p>
<p>任务具有最高优先级、内存管理器和文件管理器次之，用户进程最低。</p>
<p>当调度程序选择一个进程来运行时，它首先会检查是否有就绪的任务，如果有一个或多个，则队首的任务先运行，如果没有任务就绪，则检查并运行服务器进程（MM或FS）。若没有合适的服务器进程，则运行一个用户进程。如果没有进程就绪，则选择IDLE进程，这个循环一直执行到下一个中断到来。</p>
<p>在每个时钟中断，都会检查当前进程是否是一个运行超过100毫秒的用户进程。如果是，则调用调度程序来查看是否有另一个用户进程在等待CPU，如果发现一个这样的进程，则当前进程别移到队列的末尾，而运行当前的队首进程。<strong>特别注意：任务、内存管理器、文件系统不会被时钟中断剥夺，无论它们运行了多久</strong>。</p>
<h2 id="MINIX进程的实现-源码"><a href="#MINIX进程的实现-源码" class="headerlink" title="MINIX进程的实现(源码)"></a>MINIX进程的实现(源码)</h2><p>术语：“过程”、“函数”、“例程”几个词可以混用</p>
]]></content>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat总体架构解析</title>
    <url>/2020/11/26/Tomcat%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>之前学习了Tomcat的请求解析流程，也对Tomcat整体有一个大概的了解，但是对于其整体的学习还不够深入，比如启动Tomcat的时候经常会见到 “Catalina” 这个单词，它是什么含义？Tomcat是如何启动的？启动需要哪些内容？等等问题，都想了解，这里记录一下学习过程。</p>
<span id="more"></span>

<h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h2><ol>
<li><p>首先考虑一个最简单的服务器Server。很明显，Server应该具有基本功能：接收客户端的请求数据并进行解析，完成相关业务处理后，将处理结果响应给客户端</p>
<p><img src="/images/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD.png"></p>
<p>start()方法启动服务器，打开Socket链接，监听服务器端口，并在接收到请求后进行响应</p>
<p>stop()方法停止服务器并释放网络资源</p>
</li>
<li><p>解耦，将请求监听和请求处理分开。</p>
<p>为什么这么做？比如我们想适配多种不同的网络协议，服务器在多种不同协议的部署下进行切换时，请求处理都是相同的，只是网络协议部分不同，那么我们应该确保web应用不用做任何变更。所以，我们需要将请求处理和网络协议从概念上分开，也就是请求处理和请求监听进行解耦</p>
<p><img src="/images/%E8%AF%B7%E6%B1%82%E7%9B%91%E5%90%AC%E5%92%8C%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E8%A7%A3%E8%80%A6.png"></p>
<p><strong>一个Server包含多个Container和多个Connector</strong>。其中Connector负责开启Socket并监听客户端请求，返回响应数据；Container负责具体的请求处理。各自的start()和stop()方法则用于加载和释放自己维护的资源。</p>
</li>
<li><p>更灵活的设计，Connector和Container的关系为<strong>多对一</strong>。</p>
<p>“一个Server包含多个Container和多个Connector”，如何知晓哪个Connector对应哪个Container？设计一个映射表？可行，但是否有更简单的设计？那么需要先了解Connector和Container的具体功能。Connector是用于负责监听，响应。Container则是负责具体的请求处理。那么既然是这样，就可以只设计一个Container，来处理<strong>一个服务Service</strong>的所有请求，这样一来可以省去设计映射表和维护映射表Connector和Container间的映射关系，Connector的请求也只能由Service所属的Container处理，不同服务Service间的Connector和Container相互隔离。</p>
<p><img src="/images/%E8%AE%BE%E8%AE%A1Service%E5%B1%82.png"></p>
<p>为了和Tomcat组件的名称一致，用Engine代替Container（这里的Container是一个宽泛的概念，后面还会再提到）。注意，Engine只是一个处理引擎，或者说处理容器，并非指Servlet容器。表示Servlet容器的是Server，Engine只负责请求处理，而不需要考虑请求监听和链接，协议等处理</p>
<p><img src="/images/Container%E6%8D%A2%E6%88%90Engine.png"></p>
</li>
<li><p>部署web应用。</p>
<p>前面的设计解决了网络协议和容器的解耦。而容器是用来部署和运行web应用的。因此，需要在Engine引擎(容器)中支持管理web应用。当接收到Connector请求时，Engine容器能够从多个web应用中找到一个合适的进行请求处理。考虑到web应用应该是相互间独立的，所以这里应该进一步进行解耦设计</p>
<p><img src="/images/%E5%AE%B9%E5%99%A8%E9%97%B4%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%A7%A3%E8%80%A6.png"></p>
</li>
<li><p>进一步优化。</p>
<p>设想有一台服务器，承担了多个域名服务。该如何实现？部署多个服务器实例完成相应的域名请求？当然可行。但能不能只运行一个服务器实例，通过灵活部署来解决这个问题？如果这样想，要提供多个域名的服务，那么可以将每个域名视为一个虚拟的主机，每个虚拟的主机下包含多个web应用，虚拟的主机间在服务器实例中相互独立，而这样做并不会影响客户的请求，因为对于客户端来说，只需要能获得正确的响应就行。</p>
<p><img src="/images/%E8%AE%BE%E7%BD%AE%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA.png"></p>
</li>
<li><p>Servlet容器化。对于一个web应用，是由若干个Servlet实例构成的。Tomcat中用Wrapper容器包装每一个Servlet实例，以便于抽象设计和进一步解耦。</p>
<p><img src="/images/Servlet%E5%AE%B9%E5%99%A8%E5%8C%96.png"></p>
</li>
<li><p>定义父类容器组件Container。</p>
<p>在上述过程中，多次提到容器这个概念。虽然在具体的表示中，容器的含义并不相同，有时候指Engine，有时候是Context。但Container代表了一类组件：处理用户请求并返回响应数据。也就是说，这些具体的容器组件的行为定义和目标是相同的。</p>
<p><img src="/images/%E5%AE%B9%E5%99%A8Container%E7%BB%84%E4%BB%B6%E7%88%B6%E7%B1%BB.png"></p>
<p>从Container的两个方法和类关系可知。Container可以添加并维护子容器。因此，Engine、Host、Context、Wrapper均继承自Container。将他们的组合关系改为虚线，以表示它们之间是弱依赖关系，即它们之间的关系是通过Container父子容器的概念体现的。</p>
<p>此外，Container还有一个重要的功能，就是后台处理。在很多情况下，Container需要执行一些异步处理，并且是定期执行，比如，每隔30秒执行一次。Tomcat对web文件变更的扫描就是通过该机制实现的。</p>
<p>在后台进行异步处理的方法是backgroundProcess，并且Container的接口的基础抽象类ContainerBase确保在启动组件的同时异步启动后台处理。因此，在绝大多数情况下，各个容器仅需要实现Container的backgroundProcess方法即可，而不必考虑创建异步线程。</p>
</li>
<li><p>定义组件生命周期管理接口LifCycle。</p>
<p>很容易发现，上述组件均存在启动、停止等生命周期方法，拥有生命周期管理的特性。因此，可以基于对生命周期的管理进行一次接口抽象，即LifeCycle接口。该接口定义了生命周期管理的核心方法：</p>
<ul>
<li>init() 初始化组件</li>
<li>start() 启动组件</li>
<li>stop() 停止组件</li>
<li>destroy() 销毁组件</li>
</ul>
<p><img src="/images/%E5%8A%A0%E5%85%A5LifeCycle.png"></p>
<p>从图中可知，除了核心方法以外，还有两个方法addLifeCycleListener()和removeLifeCycleListener()。这两个方法支持添加和删除事件监听器（LifeListener）用于监听组件的状态变化。这也说明了LifeCycle接口支持组件状态间的转换。比如我们可以采用一致的机制来初始化、启动、停止以及销毁各个组件。</p>
<p>Tomcat核心组件的默认实现继承自LifecycleBeanBase抽象类，该类负责组件各个状态的转换和事件处理，通过将组件自身注册为MBean，以便通过Tomcat管理工具进行动态维护。</p>
<p>下面是组件在生命周期过程中状态的转换：（注意，每个生命周期阶段都会分成三部分，比如：初始化前(新建)、初始化中、初始化后(已初始化)；启动前、启动中、启动后(已启动)；停止前、停止中、停止后(已停止)；销毁前、销毁中、销毁后(已销毁)；auto表示为自动转换过程，不需要调用额外方法）</p>
<p><img src="/images/%E7%BB%84%E4%BB%B6%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png"></p>
</li>
<li><p>添加Pipeline和Valve。前8个步骤，已经完成了对核心概念的分解，确保了整体架构的可伸缩性和可扩展性。此外，我们需要考虑各个组件的灵活性，使其易于扩展功能。</p>
<p>在增强组件的灵活性和可扩展性方面，责任链模式是一个好的选择。Tomcat也是采用该模式来实现客户端的请求处理，通过每个Container组件执行责任链的一个环节来完成具体的请求处理。</p>
<p>Tomcat定义了<strong>Pipeline（管道）、Valve（阀）</strong>两个接口。Pipeline用于构造责任链，Valve代表责任链上的每个处理器。（可以将管道想象成水，阀想象成水龙头）</p>
<p><img src="/images/%E7%AE%A1%E9%81%93%E5%92%8C%E9%98%80.png"></p>
<p>Pipeline中维护了一个基础的Valve，它始终位于Pipeline的末端（最后执行），用于封装具体的请求处理和输出响应的过程。而通过addValve()方法，我们可以为Pipeline添加其他的Valve，添加的Valve位于基础Valve之前（基础Valve总是最后一个才执行），并且Pipeline会<strong>按照添加顺序执行</strong>。Pipeline通过获取首个Valve来启动整个责任链的执行。</p>
<p>上述过程的灵活性体现在，每个层级的容器（Engine、Host、Context、Wrapper）均有对应基础的Valve实现，同时维护了一个Pipeline实例，也就是说，我们可以在任何层级的容器对请求处理进行扩展。</p>
<p>修改后的设计如下：</p>
<p><img src="/images/%E5%85%B3%E7%B3%BB%E5%8A%A0%E5%85%A5%E7%AE%A1%E9%81%93%E5%92%8C%E9%98%80.png"></p>
</li>
<li><p>修改Connector。Connector至少要完成如下的功能：</p>
<ul>
<li>监听服务器端口，读取来自客户端的请求</li>
<li>将请求数据按照指定协议进行解析</li>
<li>根据请求地址匹配正确的容器进行处理</li>
<li>将响应返回客户端</li>
</ul>
<p>前面提到过这个问题：Tomcat支持多协议，比如默认支持HTTP和AJP。此外，Tomcat还支持多种I/O方式，如BIO、NIO等。所以Connector部分需要根据协议、I/O进行抽象和建模。在Tomcat中，是这样设计的：</p>
<p><img src="/images/Connector%E6%89%A9%E5%B1%95.png"></p>
<p>ProtocolHandler为协议处理器，根据不同的协议和I/O方式，提供不同的实现。比如HttpllNioProtocol表示基于NIO的HTTP协议处理器。</p>
<p>ProtocolHandler包含一个EndPoint用于启动Socket监听，该接口按照I/O方式进行分类实现，比如Nio2EndPoint表示非阻塞Socket I/O。（Tomcat没有EndPoint接口，仅有AbstractEndPoint抽象类，这里只是为了方便讨论）</p>
<p>Processor用于按照指定协议读取数据，并将请求交给容器处理，比如HttpllNioProcessor表示在NIO的方式下处理HTTP请求的处理类。</p>
<p>当Connector启动时，EndPoint会启动线程来监听服务器端口，并在接收到请求后调用Processor进行数据读取。当Processor读取请求后，按照请求中的url映射到具体的容器进行处理，这个过程称为请求映射。</p>
<p>由于Tomcat组件采用同用的生命周期管理，因此还需要通过管理工具进行状态的变更，因此请求映射除了考虑映射规则的实现以外，还需要考虑容器组件的注册和销毁。</p>
<p>Tomcat通过Mapper和MapperListener两个类完成上述功能。其中，Mapper用于维护容器映射信息，同时按照映射规则查找容器。MapperListener实现ContainerListener和LifecycleListener（前面提到过，还记得吗，在Lifecycle接口有两个方法用于注册和删除LifecycleListener），用于在容器组件状态发生变更时，注册或者取消对应的容器映射信息。MapperListener也实现了Lifecycle接口，当其启动时，就会自动作为监听器注册到各个容器组件上，同时将已创建的容器注册到Mapper。（Mapper和MapperListener由Service进行维护）</p>
<p>Tomcat通过适配器模式实现了Connector和Mapper、Container的解耦。通过类的关系，我们能更明白这一点：</p>
<p><img src="/images/Connector%E6%94%B9%E5%8F%98.png"></p>
</li>
<li><p>考虑服务器的并发。</p>
<p>完成Connector设计之后，需要考虑到服务器的一个非常重要的问题——并发。我们不可能让所有来自客户的请求以串行的方式执行，必须采用多线程并发的方式。并且为了降低线程创建的消耗，也会进一步采用线程池。那么如何设计？</p>
<p>首先，我们希望线程池作为一个组件，能够方便管理。所以Tomcat的设计者设计了一个Executor接口，该接口继承自Lifecycle，可按照通用的组件进行管理。其次，确定线程池的使用范围。在Tomcat中，Executor由Service进行维护，因此同一个Service中的组件都可以使用线程池。</p>
<p>添加Executor后的设计：</p>
<p><img src="/images/%E6%B7%BB%E5%8A%A0Executor.png"></p>
</li>
<li><p>最后，配置环境来支持和优化服务器。</p>
<p>前面的部分已经将Tomcat总体架构中的主要核心组件都介绍了。除了核心部分以外，还需要提供一套配置环境来支持系统的可配置性，以便于通过修改相关配置来优化服务器。比如修改服务器端口、连接超时等待时间等等。因此，Tomcat提供了相关类来完成这些服务：</p>
<p>Catalina提供一个Shell程序，用于解析server.xml创建各个组件，同时，负责启动、停止应用服务器。</p>
<p>Digester解析XML文件，包括server.xml以及web.xml等。</p>
<p>Bootstrap作为应用服务器启动入口，负责创建Catalina实例，根据执行参数调用Catalina相关方法完成服务器的启动、停止。</p>
<p>考虑一个问题：Tomcat不直接通过Catalina启动服务器，而是通过Bootstrap间接地完成服务器的启动停止。我得到的解释是：这样做的目的是，Bootstrap通过反射调用Catalina，实现了与Tomcat服务器完全松耦合，Bootstrap可以直接依赖JRE运行并为服务器创建 <strong>共享类加载器</strong>，用于构造Catalina实例和整个Tomcat服务器。这样一来，启动入口就和核心环境解耦，不仅简化了启动，而且便于灵活地组织中间件产品的结构，特别是类加载器方案。（我还不是很明白，等之后回来再思考）</p>
<p>至此，完整的设计方案如下：</p>
<p><img src="/images/%E5%AE%8C%E6%95%B4%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88.png"></p>
</li>
</ol>
<p>总结：</p>
<table>
<thead>
<tr>
<th>组件名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Server</td>
<td>表示整个Servlet容器，因此Tomcat运行环境中只有唯一一个Server实例</td>
</tr>
<tr>
<td>Service</td>
<td>Service表示一个或多个Connector的集合，这些Connector共享一个Container来处理器请求。在同一个Tomcat实例内可以包含任意多个Service实例，它们彼此独立</td>
</tr>
<tr>
<td>Connector</td>
<td>Connector用于监听并转化Socket请求，同时将读取的Socket请求交给Container处理，支持不同协议以及I/O方式</td>
</tr>
<tr>
<td>Container</td>
<td>Container表示能够执行客户端请求并返回响应的一类对象。在Tomcat中存在不同级别的容器：Engine、Host、Context、Wrapper</td>
</tr>
<tr>
<td>Engine</td>
<td>Engine表示整个Servlet引擎。在Tomcat中，Engine为最高层级的容器对象，尽管Engine不是直接处理请求的容器，却是获取目标容器的入口</td>
</tr>
<tr>
<td>Host</td>
<td>Host作为一类容器，表示Servlet引擎中的虚拟主机，与一个服务器的域名有关。客户端可以使用域名连接服务器，但该域名必须要在DNS服务器上注册</td>
</tr>
<tr>
<td>Context</td>
<td>Context作为一类容器，用于表示ServletContext，在Servlet规范中，一个ServletContext就表示一个独立的web应用</td>
</tr>
<tr>
<td>Wrapper</td>
<td>Wrapper作为一类容器，用于表示Web应用中定义的Servlet</td>
</tr>
<tr>
<td>Executor</td>
<td>Executor表示Tomcat组件间可以共享的线程池</td>
</tr>
</tbody></table>
<h2 id="Tomcat启动过程"><a href="#Tomcat启动过程" class="headerlink" title="Tomcat启动过程"></a>Tomcat启动过程</h2><p><img src="/images/Tomcat%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.png"></p>
<h2 id="Tomcat请求处理过程"><a href="#Tomcat请求处理过程" class="headerlink" title="Tomcat请求处理过程"></a>Tomcat请求处理过程</h2><p><img src="/images/%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png"></p>
<h2 id="Tomcat类加载器"><a href="#Tomcat类加载器" class="headerlink" title="Tomcat类加载器"></a>Tomcat类加载器</h2><p>服务器通常会自行创建类加载器以实现更灵活的控制，主要体现在以下方面：</p>
<ol>
<li>隔离性：web应用类库相互隔离，避免一来库或者应用包相互影响。比如说，我们有两个web应用，一个采用Spring 2.5 ，一个采用 Spring 4.0，而服务器如果只使用一个类加载器，那么web应用将会因为jar包覆盖而导致无法启动成功。</li>
<li>灵活性：web应用间的类加载器相互独立，所以我们可以只针对一个web应用进行重新部署，则此时该web应用的类加载器将会重新创建，而不会影响其他web应用。如果只采用一个类加载器，显然无法实现，因为只有一个类加载器时，类之间的一来是杂乱无意的，无法完整地移除某个web应用的类。</li>
<li>性能：由于每个web应用都有一个类加载器，因此web应用在加载类时，不会搜索其他web应用包含的jar包，性能自然高于应用服务器只有一个类加载器的情况。</li>
</ol>
<p>Tomcat的类加载方案：</p>
<p><img src="/images/Tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%85%B3%E7%B3%BB.png"></p>
<p>可以看到，除了每个web应用的类加载器外，Tomcat也提供了3个基础的类加载器和web应用类加载器，而且这3个类加载器指向的路径和包列表均可由catalina.properties配置。</p>
<ol>
<li>CommonClassLoader：父类加载器为SystemClassLoader，是位于服务器顶层的公用类加载器，其路径为common.loader，默认指向 <code>$CATALINA_HOME/lib</code> 下的包</li>
<li>CatalinaClassLoader：父类加载器为CommonClassLoader，用于加载Tomcat服务器的类加载器，其路径为server.loader，默认为空。此时Tomcat使用CommonClassLoader类加载器加载服务器</li>
<li>SharedClassLoader：父类加载器为CommonClassLoader，是所有web应用的父类加载器，其路径为shared.loader，默认为空。此时Tomcat使用CommonClassLoader类加载器作为web应用的父类加载器</li>
<li>web应用：父类加载器为SharedClassLoader，加载/WEB-INF/classes目录下未压缩的Class和资源文件以及/WEB-INF/lib目录下的jar包。该类加载器只对当前web应用可见，对其他web应用均不可见</li>
</ol>
<p>虽然默认情况下，都使用CommonClassLoader作为类加载器，但是可以通过配置创建3个不同的类加载器，完成各自的功能。</p>
<p>首先是CommonClassLoader。CommonClassLoader类加载器负责加载Tomcat服务器内部和web应用均可见的类，比如Servlet规范相关包和一些通用的工具包。</p>
<p>其次是CatalinaClassLoader。CatalinaClassLoader类加载器负责加载只有Tomcat服务器内部可见的类，这些类对web应用不可见。</p>
<p>最后是SharedClassLoader。SharedClassLoader类加载器负责加载web应用共享的类，Tomcat服务器不会依赖这些类。</p>
<h3 id="web应用类加载器"><a href="#web应用类加载器" class="headerlink" title="web应用类加载器"></a>web应用类加载器</h3><p>Java默认的类加载机制过程如下：</p>
<ol>
<li>从缓存中加载</li>
<li>如果缓存中没有，则从父类加载器加载</li>
<li>如果父类加载器没有，则从当前类加载器加载</li>
<li>如果没有相应类加载器加载，则抛出异常</li>
</ol>
<p>Tomcat提供的web应用类加载器和上述过程不停。它会首先尝试通过当前类加载器加载，然后才会进行委派。Servlet规范相关的API禁止通过web应用类加载器加载，因此，不要在web应用中包含这些包。</p>
<p>所以，web应用类加载器加载过程如下：</p>
<ol>
<li>从缓存中加载</li>
<li>如果没有，则从JVM的Bootstrap类加载器加载</li>
<li>如果没有，则从当前类加载器加载</li>
<li>如果没有，则从父类加载器加载。由于父类加载器采用默认的委派模式（不启用Java委派模式），所以默认的加载顺序为：SystemClassLoader、CommomClassLoader、SharedClassLoader</li>
</ol>
<p>Tomcat提供delegate属性用于控制是否启用Java委派模式，默认为false（不启用），当配置为true时，Tomcat将使用Java默认的委派模式，则会按如下顺序加载：</p>
<ol>
<li>从缓存中加载</li>
<li>如果没有，则从JVM的Bootstrap类加载器加载</li>
<li>如果没有，则从父类加载器加载。加载顺序为：SystemClassLoader、CommomClassLoader、SharedClassLoader</li>
<li>如果没有，则从当前类加载器加载</li>
</ol>
<h2 id="Catalina"><a href="#Catalina" class="headerlink" title="Catalina"></a>Catalina</h2><p>前面有简单提到过 “Catalina提供一个Shell程序，用于解析server.xml创建各个组件，同时，负责启动、停止应用服务器“。除了启动入口，Shell程序，Catalina还包括了前面提到的所有容器，因此其实质上是一个Servlet容器。</p>
<p>Tomcat模块分层示意图：</p>
<p><img src="/images/Tomcat%E6%A8%A1%E5%9D%97%E5%88%86%E5%B1%82%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<p>Catalina是Tomcat的核心，其他模块均为Catalina提供支持。Coyote模块提供链接通信，Jasper模块提供JSP引擎，Naming提供JNDI服务，Juli提供日志服务。</p>
<h3 id="Digester"><a href="#Digester" class="headerlink" title="Digester"></a>Digester</h3><p>(英文含义：消化，吸收，融会贯通，摘要)</p>
<p>Tomcat在Catalina创建过程中通过Digester结合LifecycleListener做了大量初始化工作。其中，Digester用于将XML转换为Java对象，是对SAX的高层次封装。</p>
<p>Digester通过读取XML文件，识别出特定XML节点后便会执行特定的动作，或者创建Java对象，或执行对象的某个方法。因此Digester的核心是匹配模式以及处理规则。</p>
<p>此外，Digester提供一套对象栈机制用于构造Java对象，这是因为XML是分层结构，所以创建的Java对象也应该是分层级的树状结构，而且还要根据XML内容构建Java对象的内部结构并设置相关属性。</p>
<p>综上，学习Digester要学习其：匹配模式、处理规则、对象栈机制。</p>
<h4 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h4><p>匹配模式即当读取到某个约定的XML节点是需要进行什么样的操作，这需要通过匹配模式指定约定。</p>
<p>Digester常用匹配模式</p>
<table>
<thead>
<tr>
<th>匹配模式</th>
<th>XML节点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>&lt;a&gt;</td>
<td>匹配所有名字为 “a” 的根节点</td>
</tr>
<tr>
<td>a/b</td>
<td>&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;\a&gt;</td>
<td>匹配所有父节点为根节点“a” ，名称为“b”的节点</td>
</tr>
</tbody></table>
<p>还可以进行模糊匹配。比如希望所有的节点都采用同一个处理规则，那么直接指定匹配规则为“*”即可。还可以指定“*/b”来处理所有名称为“b”的节点，而不限制其层次或上级节点名称。</p>
<h4 id="处理规则"><a href="#处理规则" class="headerlink" title="处理规则"></a>处理规则</h4><p>匹配模式确定何时触发处理操作，而处理规则定义模式匹配时的具体操作。处理规则需要实现接口：</p>
<p><code>org.apache.commons.digester.Rule</code> 该接口定义模式匹配时触发的事件方法。</p>
<ul>
<li>begin() ：当读取到匹配节点的开始部分时调用，并将该节点所有的属性作为参数传入</li>
<li>body() ：当读取到匹配节点的内容时调用，注意是内容，不是子节点，指的是嵌入内容</li>
<li>end() ：当读取到匹配节点的结束部分时调用，如果存在子节点，只有当子节点处理完毕后该方法才会被调用</li>
<li>finish() ：当整个parse()方法完成时调用，用于清除临时数据和缓存数据</li>
</ul>
<p>有了这些触发的事件方法，就可以通过Digester类的addRule()方法为某个匹配模式指定一个处理规则，或者根据需要实现自己的规则。Digester提供了默认的处理规则实现类：</p>
<table>
<thead>
<tr>
<th>规则类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ObjectCreateRule</td>
<td>当begin()方法调用时，该规则会将指定的Java类实例化，并将其放入对象栈。当end()方法调用时，该规则创建的对象从栈中取出</td>
</tr>
<tr>
<td>FactoryCreateRule</td>
<td>用于处理Java类无默认构造方法的情况，规则和ObjectCreateRule类似</td>
</tr>
<tr>
<td>SetPropertiesRule</td>
<td>当begin()方法调用时，Digester使用标准的Java Bean属性操作方式(setter)将当前XML节点的属性值设置到栈顶部的对象中</td>
</tr>
<tr>
<td>SetPropertyRule</td>
<td>同上，只不过是设置特定属性的值</td>
</tr>
<tr>
<td>SetNextRule</td>
<td>当end()方法调用时，Digester会找到位于栈顶部对象之后的对象调用指定的方法，同时将栈顶部对象作为参数传入，用于设置父对象的子对象，以在栈对象间建立父子关系，从而形成对象树</td>
</tr>
<tr>
<td>SetTopRule</td>
<td>与setNextRule对象对应，只不过是设置当前对象的父对象</td>
</tr>
<tr>
<td>CallMethodRule</td>
<td>在end()方法调用时执行栈顶部对象的某个方法，参数值由CallParamRule获取</td>
</tr>
<tr>
<td>CallParamRule</td>
<td>该规则与CallMethodRule配合使用，作为其子节点的处理规则创建方法参数，参数值可以取自某个特殊属性，也可以取自节点的内容</td>
</tr>
<tr>
<td>NodeCreateRule</td>
<td>用于将XML文档树的一部分转换为DOM节点，并放入栈</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; extension = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> code; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(String code)</span> </span>&#123; <span class="keyword">this</span>.code = code; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123; <span class="keyword">this</span>.users.add(user); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putExtension</span><span class="params">(String name, String value)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.extension.put(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> code; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(String code)</span> </span>&#123; <span class="keyword">this</span>.code = code; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">department</span> <span class="attr">name</span>=<span class="string">&quot;departmentName001&quot;</span> <span class="attr">code</span>=<span class="string">&quot;departmentCode001&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;username001&quot;</span> <span class="attr">code</span>=<span class="string">&quot;usercode001&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;username002&quot;</span> <span class="attr">code</span>=<span class="string">&quot;usercode002&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">property-name</span>&gt;</span>director<span class="tag">&lt;/<span class="name">property-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property-value</span>&gt;</span>joke<span class="tag">&lt;/<span class="name">property-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">department</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>解析代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Digester digester = <span class="keyword">new</span> Digester();</span><br><span class="line">digester.setValidating(<span class="keyword">false</span>);</span><br><span class="line">digester.setRulesValidation(<span class="keyword">true</span>);</span><br><span class="line">digester.addObjectCreate(<span class="string">&quot;department&quot;</span>, Department.class); <span class="comment">//匹配department节点时创建Department对象</span></span><br><span class="line">digester.addSetProperties(<span class="string">&quot;department&quot;</span>); <span class="comment">//匹配department节点时设置对象属性</span></span><br><span class="line">digester.addObjectcreate(<span class="string">&quot;department/user&quot;</span>, User.class);</span><br><span class="line">digester.addSetProperties(<span class="string">&quot;department/user&quot;</span>);</span><br><span class="line">digester.addSetNext(<span class="string">&quot;department/user&quot;</span>, <span class="string">&quot;addUser&quot;</span>);  <span class="comment">//匹配department/user节点时，调用addUser方法</span></span><br><span class="line"><span class="comment">// 匹配department/extension节点时，调用Department对象的putExtension方法</span></span><br><span class="line">digester.addCallMethod(<span class="string">&quot;department/extension&quot;</span>, <span class="string">&quot;putExtension&quot;</span>, <span class="number">2</span>);</span><br><span class="line">digester.addCallParam(<span class="string">&quot;department/extension/property-name&quot;</span>, <span class="number">0</span>);</span><br><span class="line">digester.addCallParam(<span class="string">&quot;department/extension/property-value&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 解析XML文件</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Department department = (Department) digester.parse(<span class="keyword">new</span> File(<span class="string">&quot;test.xml&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建Server"><a href="#创建Server" class="headerlink" title="创建Server"></a>创建Server</h3><p>Catalina(Server)结构图</p>
<p><img src="/images/Server%E6%A1%86%E6%9E%B6%E5%9B%BE.png"></p>
<h4 id="Server解析"><a href="#Server解析" class="headerlink" title="Server解析"></a>Server解析</h4><p>了解了Digester的使用方式，接下来就通过Tomcat源码来分析 Catalina解析server.xml创建Server的详细过程。</p>
<p>server.xml（删去注释后的文件）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">&quot;8005&quot;</span> <span class="attr">shutdown</span>=<span class="string">&quot;SHUTDOWN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.startup.VersionLoggerListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.AprLifecycleListener&quot;</span> <span class="attr">SSLEngine</span>=<span class="string">&quot;on&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">&quot;UserDatabase&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;Container&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">&quot;org.apache.catalina.UserDatabase&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">description</span>=<span class="string">&quot;User database that can be updated and saved&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">factory</span>=<span class="string">&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">pathname</span>=<span class="string">&quot;conf/tomcat-users.xml&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span> <span class="attr">defaultHost</span>=<span class="string">&quot;localhost&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.LockOutRealm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">resourceName</span>=<span class="string">&quot;UserDatabase&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span>  <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.valves.AccessLogValve&quot;</span> <span class="attr">directory</span>=<span class="string">&quot;logs&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">&quot;localhost_access_log&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;.txt&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">&quot;%h %l %u %t <span class="symbol">&amp;quot;</span>%r<span class="symbol">&amp;quot;</span> %s %b&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>创建Server实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Catalina.createStartDigester</span></span><br><span class="line">digester.addObjectCreate(<span class="string">&quot;Server&quot;</span>, <span class="string">&quot;org.apache.catalina.core.StandardServer&quot;</span>, <span class="string">&quot;className&quot;</span>);</span><br><span class="line">digester.addSetProperties(<span class="string">&quot;Server&quot;</span>);</span><br><span class="line">digester.addSetNext(<span class="string">&quot;Server&quot;</span>, <span class="string">&quot;setServer&quot;</span>, <span class="string">&quot;org.apache.catalina.Server&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>很明显，上述过程在于解析serve.xml文件，当解析到Server节点时，触发事件方法，创建Server实例，并设置Server的相关属性，最后通过addSetNext触发事件放将Server实例对象通过setServer方法设置到Catalina对象中。</p>
</li>
<li><p>为Server添加生命周期监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Catalina.createStartDigester</span></span><br><span class="line">digester.addObjectCreate(<span class="string">&quot;Server/Listener&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;className&quot;</span>);</span><br><span class="line">digester.addSetProperties(<span class="string">&quot;Server/Listener&quot;</span>);</span><br><span class="line">digester.addSetNext(<span class="string">&quot;Server/Listenner&quot;</span>, <span class="string">&quot;addLifecycleListener&quot;</span>, <span class="string">&quot;org.apache.catalina.LifecycleListener&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过前面的server.xml文件可以知道，一共为当前的Server实例添加了5个默认的LifecycleListener监听器，如下表所示：</p>
<table>
<thead>
<tr>
<th>类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AprLifecycleListener</td>
<td>在Server初始化之前加载APR库，并在Server停止之后销毁</td>
</tr>
<tr>
<td>VersionLoggerListener</td>
<td>在Server初始化之前打印操作系统、JVM以及服务器的版本信息（你现在知道Tomcat启动，控制台会有那么多的信息是怎么来的了吧，就是这个类打印的）</td>
</tr>
<tr>
<td>JreMemoryLeakPreventionListener</td>
<td>在Server初始化之前调用，以解决单例对象创建导致的JVM内存泄漏问题以及锁文件问题</td>
</tr>
<tr>
<td>GlobalResourcesLifecycleListener</td>
<td>在Server启动时，将JNDI资源注册为MBean进行管理</td>
</tr>
<tr>
<td>ThreadLocalLeakPreventionListener</td>
<td>用于在Context停止时重建Executor池中的线程，避免导致内存泄漏</td>
</tr>
</tbody></table>
</li>
<li><p>创建全局J2EE命名上下文</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Catalina.createStartDigester</span></span><br><span class="line">digester.addObjectCreate(<span class="string">&quot;Server/GlobalNamingResources&quot;</span>, <span class="string">&quot;org.apache.catalina.deploy.NamingResourceImpl&quot;</span>);  <span class="comment">//查看前面的server.xml，一目了然</span></span><br><span class="line">digester.addSetProperties(<span class="string">&quot;Server/GlobalNamingResources&quot;</span>);</span><br><span class="line">digester.addSetNext(<span class="string">&quot;Server/GlobalNamingResources&quot;</span>, <span class="string">&quot;setGlobalNamingResources&quot;</span>, <span class="string">&quot;org.apache.catalina.deploy.NamingResourcesImpl&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Catalina根据GlobalNamingResources配置，创建全局的J2EE命名上下文（JNDI），设置属性并将其设置到Server实例中（setGlobalNamingResources）。</p>
</li>
<li><p>构造Service实例</p>
<p>在server.xml中，GlobalNamingResources、Listener、Service三个节点是同级关系，因此，另外两个加载完后，自然要进行Service节点的解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Catalina.createStartDigester</span></span><br><span class="line">digester.addObjectCreate(<span class="string">&quot;Server/Service&quot;</span>, <span class="string">&quot;org.apache.catalina.core.StandardService&quot;</span>, <span class="string">&quot;className&quot;</span>);</span><br><span class="line">digester.addSetProperties(<span class="string">&quot;Server/Service&quot;</span>);</span><br><span class="line">digester.addSetNext(<span class="string">&quot;Server/Service&quot;</span>, <span class="string">&quot;addService&quot;</span>, <span class="string">&quot;org.apache.catalina.Service&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里可以看出，Catalina默认的Service实现为org.apache.catalina.core.StandardService。如果有需要，就可以修改server.xml中的className属性自己的实现类。创建完成后，通过addService()方法添加到Server实例中。</p>
</li>
<li><p>为Service添加生命周期监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Catalina.createStartDigester</span></span><br><span class="line">digester.addObjectCreate(<span class="string">&quot;Server/Service/Listener&quot;</span>, <span class="keyword">null</span>,  <span class="string">&quot;className&quot;</span>);  </span><br><span class="line">digester.addSetProperties(<span class="string">&quot;Server/Service/Listener&quot;</span>);</span><br><span class="line">digester.addSetNext(<span class="string">&quot;Server/Service/Listener&quot;</span>, <span class="string">&quot;addLifecycleListener&quot;</span>, <span class="string">&quot;org.apache.catalina.LifecycleListener&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>从server.xml可知，默认情况下，Catalina未指定Service监听器。</p>
</li>
<li><p>为Service添加Executor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Catalina.createStartDigester</span></span><br><span class="line">digester.addObjectCreate(<span class="string">&quot;Server/Service/Executor&quot;</span>, <span class="string">&quot;org.apache.catalina.core.StandardThreadExecutor&quot;</span>,  <span class="string">&quot;className&quot;</span>);  </span><br><span class="line">digester.addSetProperties(<span class="string">&quot;Server/Service/Executor&quot;</span>);</span><br><span class="line">digester.addSetNext(<span class="string">&quot;Server/Service/Executor&quot;</span>, <span class="string">&quot;addExecutor&quot;</span>, <span class="string">&quot;org.apache.catalina.Executor&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>从上述代码可知，默认实现为org.apache.catalina.core.StandardThreadExecutor，同样也可以通过className属性指定自己的实现类。而从server.xml文件可知，Catalina默认情况下未配置Executor，即不共享。</p>
</li>
<li><p>为Service添加Connector</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Catalina.createStartDigester</span></span><br><span class="line">digester.addRule(<span class="string">&quot;Server/Service/Connector&quot;</span>, <span class="keyword">new</span> ConnectorCreateRule());  </span><br><span class="line">digester.addRule(<span class="string">&quot;Server/Service/Connector&quot;</span>, <span class="keyword">new</span> SetAllPropertiesRule(<span class="keyword">new</span> String[] &#123; <span class="string">&quot;executor&quot;</span>, <span class="string">&quot;sslImplementationName&quot;</span>&#125;));</span><br><span class="line">digester.addSetNext(<span class="string">&quot;Server/Service/Connector&quot;</span>, <span class="string">&quot;addConnector&quot;</span>, <span class="string">&quot;org.apache.catalina.connector.Connector&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>为Connector添加虚拟主机SSL配置(后面再详细说明意义)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Catalina.createStartDigester</span></span><br><span class="line">digester.addObjectCreate(<span class="string">&quot;Server/Service/Connector/SSLHostConfig&quot;</span>, <span class="string">&quot;org.apache.tomcat.util.net.SSLHostConfig&quot;</span>);  </span><br><span class="line">digester.addSetProperties(<span class="string">&quot;Server/Service/Connector/SSLHostConfig&quot;</span>);</span><br><span class="line">digester.addSetNext(<span class="string">&quot;Server/Service/Connector/SSLHostConfig&quot;</span>, <span class="string">&quot;addSslHostConfig&quot;</span>, <span class="string">&quot;org.apache.tomcat.util.net.SSLHostConfig&quot;</span>);</span><br><span class="line"></span><br><span class="line">digester.addRule(<span class="string">&quot;Server/Service/Connector/SSLHostConfig/Certificate&quot;</span>, <span class="keyword">new</span> Certificate());</span><br><span class="line">digester.addRule(<span class="string">&quot;Server/Service/Connector/SSLHostConfig/Certificate&quot;</span>, <span class="keyword">new</span> SetAllPropertiesRule(<span class="keyword">new</span> String[] &#123; <span class="string">&quot;type&quot;</span>&#125;));</span><br><span class="line">digester.addSetNext(<span class="string">&quot;Server/Service/Connector/SSLHostConfig/Certificate&quot;</span>, <span class="string">&quot;addCertificate&quot;</span>, <span class="string">&quot;org.apache.tomcat.util.net.SSLHostConfigCertificate&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>为Connector添加生命周期监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Catalina.createStartDigester</span></span><br><span class="line">digester.addObjectCreate(<span class="string">&quot;Server/Service/Connector/Listener&quot;</span>, <span class="keyword">null</span>,  <span class="string">&quot;className&quot;</span>);  </span><br><span class="line">digester.addSetProperties(<span class="string">&quot;Server/Service/Connector/Listener&quot;</span>);</span><br><span class="line">digester.addSetNext(<span class="string">&quot;Server/Service/Connector/Listener&quot;</span>, <span class="string">&quot;addLifecycleListener&quot;</span>, <span class="string">&quot;org.apache.catalina.LifecycleListener&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>由server.xml可知，默认情况下，Catalina未指定Connector监听器</p>
</li>
<li><p>为Connector添加升级协议</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Catalina.createStartDigester</span></span><br><span class="line">digester.addObjectCreate(<span class="string">&quot;Server/Service/Connector/UpgradeProtocol&quot;</span>, <span class="keyword">null</span>,  <span class="string">&quot;className&quot;</span>);  </span><br><span class="line">digester.addSetProperties(<span class="string">&quot;Server/Service/Connector/UpgradeProtocol&quot;</span>);</span><br><span class="line">digester.addSetNext(<span class="string">&quot;Server/Service/Connector/UpgradeProtocol&quot;</span>, <span class="string">&quot;addUpgradeProtocol&quot;</span>, <span class="string">&quot;org.apache.coyote.UpgradeProtocol&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>用于支持HTTP/2，后面再了解</p>
</li>
<li><p>添加子元素解析规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Catalina.createStartDigester</span></span><br><span class="line">digester.addResultSet(<span class="keyword">new</span> NamingRuleSet(<span class="string">&quot;Server/GlobalNamingResources/&quot;</span>));</span><br><span class="line">digester.addResultSet(<span class="keyword">new</span> EngineRuleSet(<span class="string">&quot;Server/Service/&quot;</span>));</span><br><span class="line">digester.addResultSet(<span class="keyword">new</span> HostRuleSet(<span class="string">&quot;Server/Service/Engine/&quot;</span>));</span><br><span class="line">digester.addResultSet(<span class="keyword">new</span> ContextRuleSet(<span class="string">&quot;Server/Service/Engine/Host/&quot;</span>));</span><br><span class="line">addClusterRuleSet(digest, <span class="string">&quot;Server/Service/Engine/Host/Cluster/&quot;</span>);</span><br><span class="line">digester.addResultSet(<span class="keyword">new</span> NamingRuleSet(<span class="string">&quot;Server/Service/Engine/Host/Context/&quot;</span>));</span><br><span class="line">digester.addRule(<span class="string">&quot;Server/Service/Engine&quot;</span>, <span class="keyword">new</span> SetParentClassLoaderRule(parentClassLoader));</span><br><span class="line">addClusterRuleSet(digest, <span class="string">&quot;Server/Service/Engine/Cluster/&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>此部分指定了Servlet容器相关的各级嵌套子节点的解析规则，明确每类嵌套子节点的解析封装为一个RuleSet，包括GlobalNamingResources、Engine、Host、Context、Cluster的解析。</p>
</li>
</ol>
<h4 id="Engine解析"><a href="#Engine解析" class="headerlink" title="Engine解析"></a>Engine解析</h4><p>EngineRuleSet类</p>
<ol>
<li><p>创建Engine实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EngineRuleSet.addRuleInstances</span></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Engine&quot;</span>, <span class="string">&quot;org.apache.catalina.core.StandardEngine&quot;</span>, className);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Engine&quot;</span>);</span><br><span class="line">digester.addRule(prefix + <span class="string">&quot;Engine&quot;</span>, <span class="keyword">new</span> LifecycleListenerRule(<span class="string">&quot;org.apache.catalina.startup.EngineConfig&quot;</span>, <span class="string">&quot;engineConfigClass&quot;</span>));  <span class="comment">// 添加默认生命周期监听器 EngineConfig</span></span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Engine&quot;</span>, <span class="string">&quot;setContainer&quot;</span>, <span class="string">&quot;org.apache.catalina.Engine&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Engine的默认实现为 <code>org.apache.catalina.core.StandardEngine</code> 并通过setContainer()方法添加到Service实例。同时，还未Engine添加了一个生命周期监听器EngineConfig。EngineConfig是默认添加的，并非由server.xml配置实现，功能是用于打印Engine启动和停止日志。</p>
</li>
<li><p>为Engine添加集群配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EngineRuleSet.addRuleInstances</span></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Engine/Cluster&quot;</span>, <span class="keyword">null</span>, className);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Engine/Cluster&quot;</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Engine/Cluster&quot;</span>, <span class="string">&quot;setCluster&quot;</span>, <span class="string">&quot;org.apache.catalina.Cluster&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>具体集群实现类由className属性指定</p>
</li>
<li><p>为Engine添加生命周期监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EngineRuleSet.addRuleInstances</span></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Engine/Listener&quot;</span>, <span class="keyword">null</span>, className);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Engine/Listener&quot;</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Engine/Listener&quot;</span>, <span class="string">&quot;addLifecycleListener&quot;</span>, <span class="string">&quot;org.apache.catalina.LifecycleListener&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>该部分由server.xml配置，默认情况下，Catalina未指定Engine监听器</p>
</li>
<li><p>为Engine添加安全配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EngineRuleSet.addRuleInstances</span></span><br><span class="line">digester.addRuleSet(<span class="keyword">new</span> RealmRuleSet(prefix + <span class="string">&quot;Engine/&quot;</span>));</span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Engine/Valve&quot;</span>, <span class="keyword">null</span>, className);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Engine/Valve&quot;</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Engine/Valve&quot;</span>, <span class="string">&quot;addValve&quot;</span>, <span class="string">&quot;org.apache.catalina.Valve&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>添加安全配置RealmRuleSet以及拦截器Valve，具体拦截器类由className属性指定</p>
</li>
</ol>
<h4 id="Host解析"><a href="#Host解析" class="headerlink" title="Host解析"></a>Host解析</h4><p>HostRuleSet类</p>
<ol>
<li><p>创建Host实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HostRuleSet.addRuleInstances</span></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Host&quot;</span>, <span class="string">&quot;org.apache.catalina.core.StandardHost&quot;</span>, <span class="string">&quot;className&quot;</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Host&quot;</span>);</span><br><span class="line">digester.addRule(prefix + <span class="string">&quot;Host&quot;</span>, <span class="keyword">new</span> CopyParentClassLoaderRule());</span><br><span class="line">digester.addRule(prefix + <span class="string">&quot;Host&quot;</span>, <span class="keyword">new</span> LifecycleListenerRule(<span class="string">&quot;org.apache.catalina.startup.HostConfig&quot;</span>, <span class="string">&quot;hostConfigClass&quot;</span>));</span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Host&quot;</span>, <span class="string">&quot;addChild&quot;</span>, <span class="string">&quot;org.apache.catalina.Container&quot;</span>);</span><br><span class="line">digester.addCallMethod(prefix + <span class="string">&quot;Host/Alias&quot;</span>, <span class="string">&quot;addAlias&quot;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>Host默认实现为 <code>org.apache.catalina.core.Standard.Host</code> 并通过addChild()方法添加到Engine上。同时，Host还添加了一个生命周期监听器HostConfig，同样，该监听器由Catalina默认添加，而不是由server.xml配置。此外，通过Alias，Host还支持配置别名。</p>
</li>
<li><p>为Host添加集群</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HostRuleSet.addRuleInstances</span></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Host/Cluster&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;className&quot;</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Host/Cluster&quot;</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Host/Cluster&quot;</span>, <span class="string">&quot;setCluster&quot;</span>, <span class="string">&quot;org.apache.catalina.Cluster&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>从这里可以知道，集群配置可以为Engine级别，也可以为Host级别</p>
</li>
<li><p>为Host添加生命周期管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HostRuleSet.addRuleInstances</span></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Host/Listener&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;className&quot;</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Host/Listener&quot;</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Host/Listener&quot;</span>, <span class="string">&quot;addLifecycleListener&quot;</span>, <span class="string">&quot;org.apache.catalina.LifecycleListener&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>此部分由server.xml配置，默认情况下，Catalina未指定Host监听器</p>
</li>
<li><p>为Host添加安全配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HostRuleSet.addRuleInstances</span></span><br><span class="line">digester.addRuleSet(<span class="keyword">new</span> RealmRuleSet(prefix + <span class="string">&quot;Host/&quot;</span>));</span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Host/Valve&quot;</span>, <span class="keyword">null</span>, className);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Host/Valve&quot;</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Host/Valve&quot;</span>, <span class="string">&quot;addValve&quot;</span>, <span class="string">&quot;org.apache.catalina.Valve&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Context解析"><a href="#Context解析" class="headerlink" title="Context解析"></a>Context解析</h4><p>ContextRuleSet</p>
<ol>
<li><p>Context实例化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ContextRuleSet.addRuleInstances</span></span><br><span class="line"><span class="keyword">if</span> (create) &#123;</span><br><span class="line">    digester.addObjectCreate(prefix + <span class="string">&quot;Context&quot;</span>, <span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span>, <span class="string">&quot;className&quot;</span>);</span><br><span class="line">    digester.addSetProperties(prefix + <span class="string">&quot;Context&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    digester.addRule(prefix + <span class="string">&quot;Context&quot;</span>, <span class="keyword">new</span> SetContextPropertiesRule());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (create) &#123;</span><br><span class="line">    digester.addRule(prefix + <span class="string">&quot;Context&quot;</span>, <span class="keyword">new</span> LifecycleListenerRule(<span class="string">&quot;org.apache.catalina.startup.ContextConfig&quot;</span>, <span class="string">&quot;configClass&quot;</span>));</span><br><span class="line">    digester.addSetNext(prefix + <span class="string">&quot;Context&quot;</span>, <span class="string">&quot;addChild&quot;</span>, <span class="string">&quot;org.apache.catalina.Container&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Context的解析会根据create属性的不同而有所区别，这主要是由于Context来源于多出。通过server.xml配置Context时，create为true，因此需要创建Context实例；而通过HostConfig自动创建Context时，create为false，此时仅需要解析子节点即可。</p>
<p>此外，除了创建Context实例，还添加了一个生命周期监听器ContextConfig，用于详细配置Context，如解析web.xml等。</p>
</li>
<li><p>为Context添加生命周期监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ContextRuleSet.addRuleInstances</span></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Context/Listener&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;className&quot;</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Context/Listener&quot;</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Context/Listener&quot;</span>, <span class="string">&quot;addLifecycleListener&quot;</span>, <span class="string">&quot;org.apache.catalina.LifecycleListener&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>为Context指定类加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ContextRuleSet.addRuleInstances</span></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Context/Loader&quot;</span>, <span class="string">&quot;org.apache.catalina.loader.WebappLoader&quot;</span>, <span class="string">&quot;className&quot;</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Context/Loader&quot;</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Context/Loader&quot;</span>, <span class="string">&quot;setLoader&quot;</span>, <span class="string">&quot;org.apache.catalina.Loader&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>默认实现类为 <code>org.apache.catalina.loader.WebappLoader</code> </p>
</li>
<li><p>为Context添加会话管理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ContextRuleSet.addRuleInstances</span></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Context/Manager&quot;</span>, <span class="string">&quot;org.apache.catalina.session.StandardManager&quot;</span>, <span class="string">&quot;className&quot;</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Context/Manager&quot;</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Context/Manager&quot;</span>, <span class="string">&quot;setManager&quot;</span>, <span class="string">&quot;org.apache.catalina.Manager&quot;</span>);</span><br><span class="line"></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Context/Manager/Store&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;className&quot;</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Context/Manager/Store&quot;</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Context/Manager/Store&quot;</span>, <span class="string">&quot;setStore&quot;</span>, <span class="string">&quot;org.apache.catalina.Store&quot;</span>);</span><br><span class="line"></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Context/Manager/SessionIdGenerator&quot;</span>, <span class="string">&quot;org.apache.catalina.util.StandardSessionIdGenerator&quot;</span>, <span class="string">&quot;className&quot;</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Context/Manager/SessionIdGenerator&quot;</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Context/Manager/SessionIdGenerator&quot;</span>, <span class="string">&quot;setSessionIdGenerator&quot;</span>, <span class="string">&quot;org.apache.catalina.SessionIdGenerator&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>默认实现为 <code>org.apache.catalina.ssession.StandardManager</code> ，同时为管理器指定会话存储方式和会话标识生成器。</p>
</li>
<li><p>为Context添加初始化参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ContextRuleSet.addRuleInstances</span></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Context/Parameter&quot;</span>, <span class="string">&quot;org.apache.catalina.deploy.ApplicationParameter&quot;</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Context/Parameter&quot;</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Context/Parameter&quot;</span>, <span class="string">&quot;addApplicationParameter&quot;</span>, <span class="string">&quot;org.apache.catalina.deploy.ApplicationParameter&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过该配置，为Context添加初始化参数。初始化参数可以再context.xml中添加，以实现在所有web应用中的复用，而不必每个web应用重复配置。这种配置方式也有缺点，就是和Tomcat紧耦合，所以，尽量不采用通过context.xml配置的方式。</p>
</li>
<li><p>为Context添加安全配置以及Web资源配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ContextRuleSet.addRuleInstances</span></span><br><span class="line">digester.addRuleSet(<span class="keyword">new</span> RealmRuleSet(prefix + <span class="string">&quot;Context/&quot;</span>));</span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Context/Resources&quot;</span>, <span class="string">&quot;org.apache.catalina.webresources.StandardRoot&quot;</span>, <span class="string">&quot;className&quot;</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Context/Resources&quot;</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Context/Resources&quot;</span>, <span class="string">&quot;setResources&quot;</span>, <span class="string">&quot;org.apache.catalina.WebResourceRoot&quot;</span>);</span><br><span class="line"></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Context/Resources/PreResources&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;className&quot;</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Context/Resources/PreResources&quot;</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Context/Resources/PreResources&quot;</span>, <span class="string">&quot;addPreResources&quot;</span>, <span class="string">&quot;org.apache.catalina.WebResourceSet&quot;</span>);</span><br><span class="line"></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Context/Resources/JarResources&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;className&quot;</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Context/Resources/JarResources&quot;</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Context/Resources/JarResources&quot;</span>, <span class="string">&quot;addJarResources&quot;</span>, <span class="string">&quot;org.apache.catalina.WebResourceSet&quot;</span>);</span><br><span class="line"></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Context/Resources/PostResources&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;className&quot;</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Context/Resources/PostResources&quot;</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Context/Resources/PostResources&quot;</span>, <span class="string">&quot;addPostResources&quot;</span>, <span class="string">&quot;org.apache.catalina.WebResourceSet&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>为Context添加资源链接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ContextRuleSet.addRuleInstances</span></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Context/ResourceLink&quot;</span>, <span class="string">&quot;org.apache.catalina.deploy.ContextResourceLink&quot;</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Context/ResourceLink&quot;</span>);</span><br><span class="line">digester.addRule(prefix + <span class="string">&quot;Context/ResourceLink&quot;</span>, <span class="keyword">new</span> SetNextNamingRule(<span class="string">&quot;addResourceLink&quot;</span>, <span class="string">&quot;org.apache.catalina.deploy.ContextResourceLink&quot;</span>));</span><br></pre></td></tr></table></figure></li>
<li><p>为Context添加Valve</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ContextRuleSet.addRuleInstances</span></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Context/Valve&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;className&quot;</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Context/Valve&quot;</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Context/Valve&quot;</span>, <span class="string">&quot;addValve&quot;</span>, <span class="string">&quot;org.apache.catalina.Valve&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>为Context添加守护资源配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ContextRuleSet.addRuleInstances</span></span><br><span class="line">digester.addCallMethod(prefix + <span class="string">&quot;Context/WatchedResource&quot;</span>, <span class="string">&quot;addWatchedResource&quot;</span>, <span class="number">0</span>);</span><br><span class="line">digester.addCallMethod(prefix + <span class="string">&quot;Context/WrapperLifecycle&quot;</span>, <span class="string">&quot;addWrapperLifecycle&quot;</span>, <span class="number">0</span>);</span><br><span class="line">digester.addCallMethod(prefix + <span class="string">&quot;Context/wrapperListener&quot;</span>, <span class="string">&quot;addWrapperListener&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Context/JarScanner&quot;</span>, <span class="string">&quot;org.apache.tomcat.util.scan.StandardJarScanner&quot;</span>, <span class="string">&quot;className&quot;</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Context/JarScanner&quot;</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Context/JarScanner&quot;</span>, <span class="string">&quot;setJarScanner&quot;</span>, <span class="string">&quot;org.apache.tomcat.JarScanner&quot;</span>);</span><br><span class="line"></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Context/JarScanner/JarScanFilter&quot;</span>, <span class="string">&quot;org.apache.tomcat.util.scan.StandardJarScanFilter&quot;</span>, <span class="string">&quot;className&quot;</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Context/JarScanner/JarScanFilter&quot;</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Context/JarScanner/JarScanFilter&quot;</span>, <span class="string">&quot;setJarScanFilter&quot;</span>, <span class="string">&quot;org.apache.tomcat.JarScanFilter&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>WatchedResource标签用于为Context添加监视资源，当资源发生变更时，web应用将会被重新加载，默认为 <code>WEB-INF/web.xml</code></p>
<p>WrapperLifecycle标签用于为Context添加一个生命周期监听器类，此类的实例不是添加到Context上，而是添加到Context包含的Wrapper上</p>
<p>WrapperListener标签用于为Context添加一个容器监听器类（ContainerListener），此类的实例同样添加到Wrapper上</p>
<p>JarScanner标签则用于为Context添加一个Jar扫描器，默认实现为 <code>org.apache.tomcat.util.scan.StandardJarScanner</code>。JarScanner扫描web应用和类加载器层级的jar包，主要用于TLD扫描和web-fragment.xml</p>
<p>JarScanFilter标签可以为JarScanner指定一个过滤器，只有符合条件的jar包才会被除了，默认实现为 <code>org.apache.tomcat.util.scan.StandardJarScanFilter</code></p>
</li>
<li><p>为Context添加Cookie处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ContextRuleSet.addRuleInstances</span></span><br><span class="line">digester.addObjectCreate(prefix + <span class="string">&quot;Context/CookieProcessor&quot;</span>, <span class="string">&quot;org.apache.tomcat.util.http.Rfc6265CookiedProcessor&quot;</span>, <span class="string">&quot;className&quot;</span>);</span><br><span class="line">digester.addSetProperties(prefix + <span class="string">&quot;Context/CookieProcessor&quot;</span>);</span><br><span class="line">digester.addSetNext(prefix + <span class="string">&quot;Context/CookieProcessor&quot;</span>, <span class="string">&quot;setCookieProcessor&quot;</span>, <span class="string">&quot;org.apache.tomcat.util.http.CookieProcessor&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="web应用加载"><a href="#web应用加载" class="headerlink" title="web应用加载"></a>web应用加载</h3><p>web应用加载属于Server启动的核心处理过程，主要由 <code>StandardHost、HostConfig、StandardContext、ContextConfig、StandardWrapper</code> 5个类完成</p>
<p>web应用加载过程：</p>
<p><img src="/images/web%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD.png"></p>
<h4 id="StandardHost"><a href="#StandardHost" class="headerlink" title="StandardHost"></a>StandardHost</h4><p>从时序图可以看出，StandardHost加载web应用（StandardContext）的入口（children.start以及child.start）有两个。其中一个入口是在Catalina构造Server实例时，如果过Host存在Context（server.xml中），那么Context将会作为Host容器的子容器添加到Host实例中，并在Host启动时，由生命周期管理接口的start()方法启动。另一个入口是由HostConfig自动扫描部署目录，创建Context实例并启动，这时大多数web应用的加载方式。</p>
<p>StandardHost的启动加载过程如下：</p>
<ol>
<li><p>为Host添加一个Valve实现ErrorReportValve（也可以通过修改Host的errorReportValveClass属性指定自己的错误处理Valv，该类主要用于在服务器处理异常时输出错误页面。如果我们没有在web.xml中添加错误处理页面，Tomcat返回的异常栈页面便是由ErrorReportValve生成的</p>
</li>
<li><p>调用StandardHost父类ContainerBase的startInternal()方法启动虚拟主机，其处理主要分为如下几步：</p>
<ol>
<li>如果配置了集群组件Cluster，则启动</li>
</ol>
</li>
<li><p>如果配置了安全组件Realm，则启动</p>
<ol start="3">
<li>启动子节点(通过server.xml中的&lt;Context&gt;创建的StandardContext实例)</li>
</ol>
</li>
<li><p>启动Host持有的Pipeline组件</p>
<ol start="5">
<li>设置Host状态为STARTING，此时会触发 <code>START_EVENT</code> 生命周期事件。HostConfig监听该事件，扫描web部署目录，对于部署描述文件、WAR包、目录会自动创建StandardContext实例，添加到Host并启动</li>
</ol>
</li>
<li><p>启动Host层级的后台任务处理：Cluster后台任务处理、Realm后台任务处理、Pipeline中Valve的后台任务处理</p>
</li>
</ol>
<h4 id="HostConfig"><a href="#HostConfig" class="headerlink" title="HostConfig"></a>HostConfig</h4><p> HostConfig是一个LifecycleListener实现，并由Catalina默认添加到Host实例上。HostConfig处理的生命周期事件包括：START_EVENT、PERIODIC_EVENT、STOP_EVENT。其中，前两者和web应用部署密切相关，后者用于在Host停止时，注销其对应的MBean。</p>
<p><strong>START_EVENT</strong></p>
<p>该事件在Host启动时触发，完成服务器启动过程中的web应用部署，主要包括三个部分：Context描述文件部署、Web目录部署、WAR部署</p>
<ul>
<li><p>Context描述文件部署</p>
<p>Tomcat支持通过一个独立的Context描述文件来配置并启动Web应用，配置方式同server.xml中的&lt;Context&gt;元素。该配置文件的存储路径由Host的xmlBase属性指定。如果未指定，则默认值为 <code>$CATALINA_BASE/conf/&lt;Engine名称&gt;/&lt;Host名称&gt;</code>，因此，对于Tomcat默认的Host，Context描述文件的路径为 <code>$CATALINA_BASE/conf/Catalina/localhost</code> </p>
<p>Context描述文件的部署过程如下：</p>
<ol>
<li>扫描Host配置文件基础目录，即 <code>$CATALINA_BASE/conf/&lt;Engine名称&gt;/&lt;Host名称&gt;</code> ，对于该目录下的每个配置文件，由线程池完成解析部署</li>
<li>对每个文件部署线程，进行如下操作<ul>
<li>使用Digester解析配置文件，创建Context实例</li>
<li>更新Context实例的名称、路径，因此&lt;Context&gt;元素中配置的path属性无效</li>
<li>为Context添加ContextConfig生命周期监听器</li>
<li>通过Host的addChild()方法将Context实例添加到Host，该方法会判断Host是否已经启动，如果是，则直接启动Context</li>
<li>将Context描述文件、Web应用目录以及web.xml等添加到守护资源，当文件发生变更时，重新负数或者加载Web应用</li>
</ul>
</li>
</ol>
</li>
<li><p>Web目录部署</p>
<p>以目录的形式发布并部署Web应用是Tomcat中最常见的部署方式。只需要将所有的资源文件、jar包、描述文件（WEB-INF/web.xml）的目录复制到Host指定的appBase目录下即可完成部署。该方式部署过程如下：</p>
<ol>
<li><p>对于Host的appBase目录下所有符合条件的目录，由线程池完成部署</p>
</li>
<li><p>对于每个目录进行如下操作</p>
<ul>
<li><p>如果Host的deployXML属性值为true（通过Context描述文件部署），并且存在META-INF/context.xml文件，则使用Digester解析context.xml文件创建Context对象。如果Context的copyXML属性为true，则将描述文件复制到  <code>$CATALINA_BASE/conf/&lt;Engine名称&gt;/&lt;Host名称&gt;</code> 目录下，文件名和web应用目录名相同。</p>
<p>如果deployXML属性值为false，但是存在META-INF/context.xml文件，则构造FailedContext实例。</p>
<p>其他情况，根据Host的 <code>contextClass</code> 属性指定的类型创建Context对象。如果不指定，则为 <code>org.apache.catalina.core.StandardContext</code> 。此时，所有的Context属性均采用默认配置，除了 name/path/webappVersion/docBase会根据web应用目录的路径和名称进行设置外</p>
</li>
<li><p>为Context实例添加ContextConfig生命周期监听器</p>
</li>
<li><p>通过Host的addChild()方法将Context实例添加到Host，该方法会判断Host是否以及启动，如果是，则直接启动Context</p>
</li>
<li><p>Context描述文件、web应用目录以及web.xml等添加到守护资源，以便文件发送变更时重新部署或者加载web应用。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>WAR包部署</p>
<p>WAR包部署和web目录部署基本类似，只是由于WAR包作为一个压缩文件，增加了部分对压缩文件的处理</p>
</li>
</ul>
<p><strong>PERIODIC_EVENT事件</strong></p>
<p>Catalina的容器支持定期执行自身以及其子容器的后台处理过程，具体处理过程在容器的backgroundProcess()方法中定义。该机制经常用于定时扫描Web应用的变更，并进行重新加载。后台任务处理完成后，就会触发 PERIODIC_EVENT 事件。</p>
<p>在HostConfig中通过DeployedApplication维护了两个守护资源列表：redeployResources和reloadResources，前者用于守护导致应用重新部署的资源，后者守护导致应用重新加载的资源。两个列表分别维护资源及其最后的修改时间。</p>
<p>当HostConfig接收到 PERIODIC_EVENT事件后，会检测守护资源的变更情况。如果发生变更，将重新加载或者部署应用以及更新资源的最后修改时间。（重新加载是指同一个Context对象的重启，而重新部署则是重新创建了一个新的Context对象。如果是Context描述文件变更，则需要重新部署应用；如果是web.xml文件更新，则只需要重新加载）</p>
<p>具体部署过程如下（当Host的 autoDeploy 属性为true时处理）：</p>
<ol>
<li>对于每一个已部署的Web应用，检查用于重新部署的守护资源。对于每个守护的资源文件或目录，如果发生变更，则会有以下几种情况：<ul>
<li>如果资源为目录，则更新守护资源列表中的上次修改时间</li>
<li>如果Web应用存在Context描述文件并且当前变更的是WAR包文件，则得到原Context的docBase。如果docBase不以 “.war” 结尾，则删除解压目录并重新加载，否则直接重新加载，更新守护资源</li>
<li>其他情况，直接俄卸载应用，并按后续步骤重新部署</li>
</ul>
</li>
<li>对于每个已经部署的Web应用，检测用于重新加载的守护资源，如果资源发生变更，则重新加载Context对象</li>
<li>如果Host配置为卸载旧版本应用，则检查并卸载</li>
<li>部署Web应用</li>
</ol>
<h4 id="StandardContext"><a href="#StandardContext" class="headerlink" title="StandardContext"></a>StandardContext</h4><p>StandardHost和HostConfig只是根据不同的情况创建并启动Context对象，并不包含具体的Web应用初始化以及启动工作，这部分工作由组件Context完成。</p>
<p><img src="/images/web%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%85%B3%E7%B3%BB.png"></p>
<p>从上图可知：</p>
<ul>
<li><p>Tomcat提供的ServletContext实现类为ApplicationContext。但是，该类仅提供Tomcat服务器使用，web应用使用的是其门面类ApplicationContextFacade。</p>
</li>
<li><p>FilterConfig实现类为ApplicationFilterConfig，同时该类也负责Filter的实例化。</p>
</li>
<li><p>FilterMap用于存储filter-mapping配置。</p>
</li>
<li><p>NamingResources用于存储web应用声明的命名服务（JNDI）</p>
</li>
<li><p>StandardContext通过servletMapping属性存储servlet-mapping配置</p>
</li>
</ul>
<p>StandardContext的启动过程（StandardContext.startInternal）</p>
<ol>
<li>发布正在启动的JMX通知，这样可以通过添加NotificationListener来监听web应用的启动</li>
<li>启动当前Context维护的JNDI资源</li>
<li>初始化当前Context使用的WebResourceRoot并启动。(WebResourceRoot维护了web应用所有的资源集合——class文件、jar包以及其他资源文件。主要用于类加载和按照路径查找资源文件)</li>
<li>创建web应用类加载器（WebappLoader）。WebappLoader继承自LifecycleMBeanBase，在其启动时创建Web应用类加载器（WebappClassLoader）。此外，该类还提供了background-Process，用于Context后台处理。当检测到Web应用的类文件、jar包发生变更时，重新加载Context</li>
<li>如果没有设置Cookie处理器，则创建默认的Rfc6265CookieProcessor</li>
<li>设置字符集映射（CharsetMapper），该映射主要用于根据Locale获取字符集编码</li>
<li>初始化临时目录，默认为 <code>$CATALINA_BASE/conf/&lt;Engine名称&gt;/&lt;Host名称&gt;</code> </li>
<li>web应用的依赖检测，主要检测依赖扩展点的完整性</li>
<li>如果当前Context使用JNDI，则为其添加NamingContextListener</li>
<li>启动Web应用类加载器（WebappLoader.start），此时才真正创建WebappClassLoader实例</li>
<li>启动安全组件（Realm）</li>
<li>发布CONFIGURE_START_EVENT事件，ContextConfig监听该事件以完成Servlet的创建</li>
<li>启动Context子节点（Wrapper）</li>
<li>启动Context维护的Pipeline</li>
<li>创建会话管理器。在集群环境下，需要将会话管理器注册到集群组件</li>
<li>将Context的web资源集合（WebResourceRoot）添加到ServletContext属性，属性名为：<code>org.apache.catalina.resources</code></li>
<li>创建实例管理器（InstanceManager），用于创建对象实例，如Servlet、Filter等</li>
<li>将Jar包扫描器（JarScanner）添加到ServletContext属性，属性名为 <code>org.apache.tomcat.JarScanner</code></li>
<li>合并ServletContext初始化参数和Context组件中的ApplicationParameter。合并原则：如果配置为可以覆盖，那么只有当ServletContext没有相关参数或者相关参数为空时添加；如果配置为不可覆盖，则强制添加</li>
<li>启动添加到当前Context的ServletContainerInitializer。该类的实例具体由ContextConfig查找并添加，主要以可编程的方式添加web应用的配置，如 Servlet、Filter等</li>
<li>实例化应用监听器（ApplicationListener），分为事件监听器（ServletContextAttributeListener、ServletRequestAttributeListener、ServletRequestListener、HttpSessionIdListener、HttpSessionAttributeListener）、生命周期监听器（HttpSessionListener、ServletContextListener）。这些监听器可以通过Context部署描述文件、可编程的方式或者web.xml添加，并且触发ServletContextListener.contextInitialized</li>
<li>检测未覆盖的HTTP方法的安全约束</li>
<li>启动会话管理器</li>
<li>实例化FilterConfig、Filter，并调用Filter.init初始化</li>
<li>对于loadOnStartup&gt;=0的Wrapper，调用wrapper.load()，该方法负责实例化Servlet，并调用Servlet.init进行初始化</li>
<li>启动后台定时处理线程。只有当backgroundProcessorDelay&gt;0时启动，用于监控守护文件的变更等。当backgroundProcessorDelay&lt;=0时，表示Context的后台任务由上级容器（Host）调度</li>
<li>发布正在运行的JMX通知</li>
<li>调用WebResourceRoot.gc()释放资源</li>
<li>设置Context状态，如果启动成功，设置为STARTING，否则设置为FAILED</li>
</ol>
<h4 id="ContextConfig"><a href="#ContextConfig" class="headerlink" title="ContextConfig"></a>ContextConfig</h4><p>StandardContext的启动过程并不包括如何解析web.xml中的Servlet、请求映射、Filter等相关配置。这部分工作由ContextConfig完成。</p>
<p>ContextConfig一共处理6类事件，这里主要了解三类：<code>AFTER_INIT_EVENT/BEFORE_START_EVENT/CONFIGURE_START_EVENT</code></p>
<ol>
<li><p><strong>AFTER_INIT_EVENT</strong></p>
<p>该事件属于Context初始化阶段，主要用于Context属性配置工作。具体过程如下</p>
<ul>
<li>如果Context的override属性为false（采用默认配置）：<ul>
<li>如果存在conf/context.xml文件，那么解析该文件，更新当前Context实例属性</li>
<li>如果存在conf/&lt;Engine名称&gt;/&lt;Host名称&gt;/context.xml.default文件，那么解析该文件，更新当前Context实例属性</li>
</ul>
</li>
<li>如果Context的configFile属性不为空，那么解析该文件，更新当前Context实例的属性</li>
</ul>
</li>
<li><p><strong>BEFORE_START_EVENT</strong></p>
<p>该事件在Context启动前触发，用于更新Context的docBase属性和解决Web目录锁的问题。更新Context的docBase属性主要是为了满足WAR部署的情况。当web应用为一个WAR压缩包且需要解压部署时，docBase属性指向的是解压后的文件夹目录，而非WAR包的路径。具体过程如下（ContextConfig.fixDocBase）：</p>
<ul>
<li>根据Host的appBase以及Context的docBase计算docBase的绝对路径</li>
<li>如果docBase为WAR文件，且需要进行解压部署：解压WAR文件、将Context的docBase更新为解压后的路径；如果不需要解压部署，则只检测WAR包，不更新docBase</li>
<li>如果docBase为一个有效目录，且存在与该目录同名的WAR包，同时需要解压部署，则重新解压WAR包</li>
<li>如果docBase为一个不存在的目录，但是存在与该目录同名的WAR包，同时需要解压部署，则：解压WAR文件、将Context的docBase更新为解压后的路径</li>
</ul>
<p>当Context的antiResourceLocking属性为true时，Tomcat会将当前的web应用目录复制到临时文件夹下，以避免对原目录的资源加锁。具体过程如下（ContextConfig.antiLocking）：</p>
<ul>
<li>根据Host的appBase以及Context的docBase计算docBase的绝对路径</li>
<li>计算临时文件夹中的web应用根目录或WAR包名</li>
<li>复制web目录或者WAR包到临时目录</li>
<li>将Context的docBase更新为临时目录下的web应用目录或者WAR包路径</li>
</ul>
</li>
<li><p>CONFIGURE_START_EVENT事件</p>
<p>该事件主要工作内容如下：</p>
<ul>
<li>根据配置创建Wrapper（Servlet）、Filter、ServletContextListener等，完成Web容器的初始化。主要是解析web应用目录下的web.xml</li>
<li>如果StandardContext的ignoreAnnotations为false，则解析应用程序注解配置，添加相关的JNDI资源引用</li>
<li>基于解析完的web容器，检测web用于部署描述中使用的安全角色名称，当发现使用了未定义的角色时，提示警告同时将未定义的角色添加到Context安全角色列表中</li>
<li>当Context需要进行安全认证，但是没有指定具体的Authenticator时，根据服务器配置自动创建默认实例</li>
</ul>
<p>对着上面这些内容再分别细化讨论：</p>
<ol>
<li><p><strong>web容器初始化</strong></p>
<p>根据Servlet规范，web应用部署描述可来源于：WEB-INF/web.xml、web应用JAR包中的META-INF/web-fragment.xml 以及 META-INF/services/javax.servlet.ServletContainerInitializer</p>
<p>其中META-INF/services/javax.servlet.ServletContainerInitializer文件中配置了所属jar中该接口的实现了，用于动态注册Servlet，这是Servlet规范基于SPI机制的可编程实现。</p>
<p>除了Servlet规范中提到的部署描述方式，Tomcat还支持默认配置，以简化web应用的配置工作。这些默认配置包括容器级别（conf/web.xml）和Host级别（conf/&lt;Engine名称&gt;/&lt;Host名称&gt;/web.xml.default）。Tomcat解析时确保web应用中的配置优先级最高，其次为Host级，最后为容器级别。</p>
<p>Tomcat初始化web容器的过程如下（ContextConfig.webConfig）</p>
<ul>
<li>解析默认配置，生成WebXml对象（Tomcat使用该对象表示web.xml的解析结果）。先解析容器级别配置，然后再解析Host级别配置。这样对于同名配置，Host将覆盖容器级。为了提升性能，ContextConfig对默认WebXml进行缓存，以避免重复解析。（默认WebXml）</li>
<li>解析web应用的web.xml文件。如果StandardContext的altDDName不为空，则将该属性指向的文件作为web.xml，否则使用默认路径，即WEB-INF/web.xml。解析结构同样为WebXml对象。(主WebXml)</li>
<li>扫描web应用所有jar包，如果包含META-INF/web-fragment.xml，则解析文件并创建WebXml对象。（片段WebXml）</li>
<li>将web-fragment.xml创建的WebXml对象按照Servlet规范进行排序，同时将排序结构对应的JAR文件名列表设置到ServletContext属性中，属性名为javax.servlet.context.orderedLibs。该排序决定了Filter等的执行顺序</li>
<li>查找ServletContainerInitializer实现，并创建实例。查找部分分为两部分：web应用下的包以及容器包（搜索所有包）</li>
<li>根据ServletContainerInitializer查询结构以及javax.servlet.annotation.HandlesTypes注解配置，初始化typeInitializerMap和initializerClassMap两个映射，前者表示类对应的ServletContainerInitializer集合，后者表示每个ServletContainerInitializer对应的类的集合，具体类由javax.servlet.annotation.HandlesTypes注解指定</li>
<li>当 “主WebXml” 的 metadataComplete为false或者typeInitializerMap不为空时：1. 处理WEB-INF/classes下的注解   2. 处理JAR包内的注解</li>
<li>如果 “主WebXml”的 metadataComplete为false，将所有的“片段WebXml”按顺序合并到“主WebXml”</li>
<li>将“默认WebXml”合并到“主WebXml”</li>
<li>配置JspServlet。对于当前web应用中JspFile属性不为空的Servlet，将其servletClass设置为org.apache.jasper.servlet.JspServlet，将JspFile设置为Servlet的初始化参数，同时将名称为“jsp”的Servlet的初始化参数也复制到该Servlet中</li>
<li>使用“主WebXml”配置当前StandardContext，包括Servlet、Filter、Listener等Servlet规范中支持的组件。对于ServletContext层级的对象，直接由StandardContext维护，对于Servlet，则创建StandardWrapper子对象，并添加到StandardContext实例</li>
<li>将合并后的WebXml保存到ServletContext属性中，便于后续处理复用</li>
<li>查找JAR包“META-INF/resources/”下的静态资源，并添加到StandardContext</li>
<li>将ServletContainerInitializer扫描结构添加到StandardContext，以便StandardContext启动时使用</li>
</ul>
</li>
<li><p><strong>应用程序注解配置</strong></p>
<p>当StandardContext的ignoreAnnotations为false时，Tomcat支持读取如下接口的Java命名服务注解配置：</p>
<ul>
<li>javax.servlet.ServletContextAttributeListener</li>
<li>javax.servlet.ServletRequestListener</li>
<li>javax.servlet.ServletRequestAttributeListener</li>
<li>javax.servlet.http.HttpSessionAttributeListener</li>
<li>javax.servlet.http.HttpSessionListener</li>
<li>javax.servlet.ServletContextListener</li>
<li>javax.servlet.Filter</li>
<li>javax.servlet.Servlet</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="StandardWrapper"><a href="#StandardWrapper" class="headerlink" title="StandardWrapper"></a>StandardWrapper</h4><p>StandardWrapper具体维护了Servlet实例。其加载过程具体如下：</p>
<ol>
<li>创建Servlet实例，如果添加了JNDI资源注解，将进行依赖注入</li>
<li>读取javax.servlet.annotation.MultipartConfig注解配置，以用于multipart/form-data请求处理，包括临时文件存储路径、上传文件最大字节数、请求最大字节数、文件大小阈值</li>
<li>读取javax.servlet.annotation.ServletSecurity()注解配置，添加Servlet安全</li>
<li>调用javax.servlet.Servlet.init()方法进行Servlet初始化</li>
</ol>
<h3 id="Web请求处理"><a href="#Web请求处理" class="headerlink" title="Web请求处理"></a>Web请求处理</h3><h4 id="总体过程"><a href="#总体过程" class="headerlink" title="总体过程"></a>总体过程</h4><p>前面提到，Tomcat通过 <code>org.apache.tomcat.util.http.mapper.Mapper</code> 维护请求链接于Host、Context、Wrapper等Container的映射。同时，通过 <code>org.apache.catalina.connector.MapperListener</code> 监听器监听所有的组件，并在组件启动、停止时注册或者移除相关映射。</p>
<p>此外，通过 <code>org.apache.catalina.connector.CoyoteAdapter</code> 将Connector与Mapper、Container联系起来。当 Connector 接收到请求后，首先读取请求数据，然后调用 CoyoteAdapter.service()方法完成请求处理。</p>
<p>CoyoteAdapter.service()方法具体处理过程如下（细节省略）：</p>
<ol>
<li>根据 Connector的请求和响应（org.apache.coyote.Request和org.apache.coyote.Response）对象创建Servlet请求（org.apache.catalina.connector.Request 和 org.apache.catalina.connector.Response）</li>
<li>转换请求参数并完成请求映射<ul>
<li>请求URI界面，初始化请求的路径参数</li>
<li>检测URI是否合法，如果非法，则返回响应码400</li>
<li>请求映射，映射结果保存到 org.apache.catalina.connector.Request.mappingData ，类型为org.apache.tomcat.util.http.mapper.MappingData，请求映射处理最终会根据URI定位到一个有效的Wrapper</li>
<li>如果当前Connector不允许追踪，且当前请求的Method为TRACE，则返回响应码405</li>
<li>执行连接器的认证和授权</li>
</ul>
</li>
<li>得到当前Enginde的第一个Valve并执行，已完成客户端请求处理</li>
<li>如果为异步请求：<ul>
<li>获取请求读取事件监听器（ReadListener）</li>
<li>如果请求读取已经结束，触发ReadListener.onAllDataRead</li>
</ul>
</li>
<li>如果为同步请求：<ul>
<li>Flush并关闭请求输入流</li>
<li>Flush并关闭响应输出流</li>
</ul>
</li>
</ol>
<h4 id="请求映射"><a href="#请求映射" class="headerlink" title="请求映射"></a>请求映射</h4><p>请求映射过程具体分为两部分：一部分位于CoyoteAdapter.postParseRequest，负责根据请求路径匹配的结果，按照会话等信息获取最终的映射结果。第二部分位于Mapper.map，负责完成具体的请求路径的匹配</p>
<h5 id="CoyoteAdapter-postParseRequest"><a href="#CoyoteAdapter-postParseRequest" class="headerlink" title="CoyoteAdapter.postParseRequest()"></a>CoyoteAdapter.postParseRequest()</h5><p>请求映射算法流程：</p>
<p><img src="/images/%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E7%AE%97%E6%B3%95.png"></p>
<p>算法步骤：</p>
<ol>
<li>定义3个局部变量<ul>
<li>version：需要匹配的版本号，初始化为空，表示匹配所有版本</li>
<li>versionContext：用于暂存按照会话ID匹配的Context，初始化为空</li>
<li>mapRequired：是否需要映射，用于控制映射匹配循环，初始化为true</li>
</ul>
</li>
<li>通过一个循环来处理映射匹配</li>
<li>在循环中，调用Mapper.map()方法按照请求路径进行匹配，参数为serverName、url、version。因为version初始化为空，所以第一次执行时，所有匹配该请求路径的Context均会返回，此时MappingData.contexts中存放了所有结果，而MappingData.context中存放了最新版本。</li>
<li>如果没有任何匹配结果，那么返回404响应码，匹配结束</li>
<li>尝试从请求的URL、Cookie、SSL会话获取请求会话ID，并将mapRequired设置为false</li>
<li>如果version不为空，且MappingData.context与versionContext相等，表明当前匹配结果是会话查询的结果，此时不再执行第7步。（当前步骤用于重复匹配，第一次执行时，version和versionContext均为空，所以需要执行第7步，而重复执行时，已经指定了版本，可以得到唯一匹配结果）</li>
<li>如果不存在会话ID，那么第3步的匹配结果即为最终结果。否则，从MappingData.contexts中查找包含请求会话ID的最新版本，查询结果分如下情况：<ul>
<li>没有查询结果（表明会话ID过去）或者查询结果与第3步的匹配结果想的，这时用的是第3步的匹配结果</li>
<li>有查询结果但与第3步的匹配结果不相等。将version设置为查询结果的版本，versionContext设置为查询将结果，将mapRequired设置为true，重置MappingData。</li>
</ul>
</li>
<li>如果mapRequired为false（即已经找到唯一的匹配结果），但匹配的Context状态为暂停，此时等待一秒钟，并将mapRequired设置为true，重置MappingData。此种情况下需要重新匹配，知道匹配到一个有效的Context或者无任何匹配结果为止</li>
</ol>
<h5 id="Mapper-map"><a href="#Mapper-map" class="headerlink" title="Mapper.map"></a>Mapper.map</h5><p>请求路径的具体匹配算法：即 “调用Mapper.map(serverName, url, version) ，将匹配的Context、Wrapper设置到请求中” </p>
<p>先了解Mapper的静态结构：</p>
<p><img src="/images/Mapper%E9%9D%99%E6%80%81%E7%B1%BB%E5%9B%BE.png"></p>
<p>从Mapper的静态类图可见，Mapper对于Host、Context、Wrapper均提供了对应的封装类：MappedHost、MappedContext、MappedWrapper</p>
<p>该算法的请求映射结果为 <code>org.apache.tomcat.util.http.mapper.MappingData</code> 对象，保存在请求的mappingData属性中。MappingData的结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappingData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object host = <span class="keyword">null</span>;			<span class="comment">// 匹配的Host</span></span><br><span class="line">    <span class="keyword">public</span> Object context = <span class="keyword">null</span>;		<span class="comment">// 匹配的Context</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> contextSlashCount = <span class="number">0</span>;	<span class="comment">// Context路径中的&quot;/&quot;数量</span></span><br><span class="line">    <span class="keyword">public</span> Object wrapper = <span class="keyword">null</span>;		<span class="comment">// 匹配的wrapper</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> jspWildCard = <span class="keyword">false</span>;	<span class="comment">// 对于JspServlet，其对应的匹配pattern是否包含通配符</span></span><br><span class="line">    <span class="keyword">public</span> MessageBytes ContextPath = MessageBytes.newInstance();	<span class="comment">// Context路径</span></span><br><span class="line">    <span class="keyword">public</span> MessageBytes requestPath = MessageBytes.newInstance(); <span class="comment">// 相对于Context的请求路径</span></span><br><span class="line">    <span class="keyword">public</span> MessageBytes wrapperPath = MessageBytes.newInstance();	<span class="comment">// Servlet路径</span></span><br><span class="line">    <span class="keyword">public</span> MessageBytes pathInfo = MessageBytes.newInstance(); <span class="comment">// 相对于Servlet的请求路径</span></span><br><span class="line">    <span class="keyword">public</span> MessageBytes redirectPath = MessageBytes.newInstance(); <span class="comment">// 重定向路径</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mapper.map具体算法过程：</p>
<p><img src="/images/Mapper%E6%98%A0%E5%B0%84%E7%AE%97%E6%B3%95.png"></p>
<h5 id="MapperWrapper映射"><a href="#MapperWrapper映射" class="headerlink" title="MapperWrapper映射"></a>MapperWrapper映射</h5><p>ContextVersion将MappedWrapper分为：默认Wrapper（defaultWrapper）、精确Wrapper（exactWrappers）、前缀加通配符匹配Wrapper（wildcardWrappers）和扩展名匹配Wrapper（extensionWrappers）。之所以分类，是因为它们之间存在匹配优先级。</p>
<p>此外，在ContextVersion中，并非每一个Wrapper对应一个MappedWrapper对象，而是每个url-pattern对应一个。比如在 web.xml中的servlet-mapping配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>example<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么，在ContextVersion中将存在两个MappedWrapper封装对象，分别指向同一个Wrapper实例。</p>
<p>Mapper按照如下规则将Wrapper添加到ContextVersion对应的MappedWrapper分类中去：</p>
<ul>
<li>如果url-pattern以“/*”结尾，则为wildcardWrappers。此时，MappedWrapper的名称为url-pattern去除结尾的“/*”</li>
<li>如果url-pattern以“*.”结尾，则为extensionWrappers。此时，MappedWrapper的名称为url-pattern去除开头的的“*.”</li>
<li>如果url-pattern等于“/”，则为defaultWrapper。此时，MappedWrapper的名称为空字符串</li>
<li>其他情况均为 exactWrappers</li>
</ul>
<p>MappedWrapper详细匹配过程：</p>
<ol>
<li>依据url和Context路径计算MappedWrapper匹配路径。例如，如果Context路径为“/myapp”，url为”/myapp/appl/index.jsp”，那么MappedWrapper的匹配路径为 “/appl/index.jsp”；如果url为“/myapp”，那么MappedWrapper的匹配路径为“/”</li>
<li>先精确查找exactWrappers</li>
<li>如果未找到，然后再按照前缀查找wildcardWrappers，逐步降低精度</li>
<li>如果未找到，然后按照扩展名查找extensionWrappers</li>
<li>如果未找到，则尝试匹配欢迎文件列表（web.xml中的welcom-file-list配置）。主要用于输入的请求路径是一个目录而非文件的情况</li>
<li>如果未找到，则使用默认MappedWrapper。因此，无论请求链接是什么，只要匹配到合适的Context，那么就肯定回存在一个匹配的Wrapper</li>
</ol>
<h4 id="Catalina请求处理"><a href="#Catalina请求处理" class="headerlink" title="Catalina请求处理"></a>Catalina请求处理</h4><p>Tomcat采用责任链模式来处理客户端请求，以提高Servlet容器的灵活性和可扩展性。Tomcat定义了Pipeline（管道）和 Valve（阀）两个接口。Pipeline用于构造责任链，Valve代表责任链上的每个处理器。由于Tomcat每一层Container均维护了一个Pipeline实例，因此，我们可以在任何层级添加Valve配置，以拦截客户端请求进行定尺处理（比如打印日志）。</p>
<p>与Filter相比，Valve更靠近Servlet容器，而非web应用，因此可以获得更多的信息。而且Valve可以添加到任意一级的Container，便于针对服务器进行统一的处理。而Filter仅限于单独的web应用。</p>
<p>Tomcat的每一级容器均提供了基础的Valve实现以完成当前容器的请求处理过程，而基础Valve始终位于责任链的末尾，以确保执行。因此，我们只要得到Pipeline中的第一个Valve即可启动整个责任链的执行。</p>
<p>在完成请求映射之后，Tomcat请求处理过程：</p>
<p><img src="/images/Catalina%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82.png"></p>
<h2 id="Coyote"><a href="#Coyote" class="headerlink" title="Coyote"></a>Coyote</h2><p>Coyote是Tomcat链接器框架的名称，是Tomcat服务器提供的供客户端访问的外部接口。客户端通过Coyote和服务器建立链接、发送请求并接收响应。</p>
<p>Coyote封装了底层的网络通信（Socket请求及响应处理），为Catalina容器提供了统一的接口，使Catalina容器与具体的请求协议及I/O方式解耦。Coyote将Socket输入转换为Request对象，交由Catalina容器进行处理，处理请求完成以后，Catalina通过Coyote提供的Response对象将结果写入输出流。</p>
<p>Coyote作为独立的模块，只负责具体协议和I/O的处理，和Servlet规范的实现没有直接关系。因此，Request和Response对象也没有实现Servlte规范对应的接口，而是在Catalina容器中将他们进一步封装为ServletRequest和ServletResponse。</p>
<p>Coyote和Catalina交互过程：</p>
<p><img src="/images/Coyote%E5%92%8CCatalina%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.png"></p>
<p>Tomcat支持的协议及I/O方式：</p>
<p><img src="/images/Coyote%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82.png"></p>
<h3 id="Web请求处理-1"><a href="#Web请求处理-1" class="headerlink" title="Web请求处理"></a>Web请求处理</h3><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ul>
<li>Endpoint：Coyote通信端点，即通信监听的接口，是具体的Socket接收处理类，对传输层的抽象。Tomcat并没有Endpoint接口，只是提供了一个抽象类 AbstractEndpoint 。根据I/O方式的不同，提供了 NioEndpoint(NIO)、AprEndpoint(APR)一级Nio2Endpoint(NIO2) 3个实现。</li>
<li>Processor：Coyote协议处理接口，负责构造Request和Response对象，并通过Adapter将其提交到Catalina容器进行处理，是对应用层的抽象。Processor是单线程的，Tomcat在同一次链接中复用Processor。Tomcat按照协议的不同提供了3个实现类：Http11Processor（Http/1.1）、AjpProcessor（AJP）、StreamProcessor（HTTP/2.0）。除此之外，还提供了两个用于升级协议处理的实现：UpgradeProcessorInternal和UpgradeProcessorExternal，前者用于处理内部支持的升级协议，后者用于外部扩展的升级协议支持</li>
<li>ProtocolHandler：Coyote协议接口，通过封装Endpoint和Processor，实现针对具体协议的处理功能。Tomcat按照协议和I/O提供了6个实现类：Http11NioProtocol、Http11AprProtocol、Http11Nio2Protocol、AjpNioProtocol、AjpAprProtocol、AjpNio2Protocol</li>
<li>UpgradeProtocol：Tomcat采用UpgradeProtocol接口表示HTTP升级协议，当前只提供了一个实现Http2Protocol用于处理HTTP/2.0 。它根据请求创建一个用于升级处理的令牌UpgradeToken，该令牌中包含了具体的HTTP升级处理器HttpUpgradeHandler，HTTP/2.0的处理器实现为Http2UpgradeHandler。</li>
</ul>
<p><img src="/images/Coyote%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%85%B3%E7%B3%BB.png"></p>
<h4 id="请求处理过程"><a href="#请求处理过程" class="headerlink" title="请求处理过程"></a>请求处理过程</h4><ol>
<li><p>当Connector启动时，会同时启动持有的Endpoint实例。Endpoint并行运行多个线程，每个线程运行一个AbstractEndpoint.Acceptor实例。在AbstractEndpoint.Accptor实例中监听端口通信，而且只要Endpoint处于运行状态，始终循环监听。</p>
</li>
<li><p>当监听到请求时，Acceptor将Socket封装为SocketWrapper实例，并交由一个SocketProcessor对象处理。此部分根据I/O方式的不同处理会有所不同，比如NIO采用轮询的方式检测SelectionKey是否就绪。如果就绪，则获取一个有效的SocketProcessor对象并提交线程池处理</p>
</li>
<li><p>SocketProcessor是一个线程池Worker实例，每一个I/O方式均有自己的实现。首先判断Socket的状态，然后提交到ConnectionHandler处理</p>
</li>
<li><p>ConnectionHandler为链接选择一个合适的Processor实现进行请求处理。</p>
<p>为了提升性能，对每个有效的链接都会缓存其Processor对象。不仅如此，当前链接关闭时，其Processor对象还会被释放到一个回收队列，这样后续链接可以重置并重复利用，以减少对象构造。因此，在处理请求时，会首先从缓存中获取当前链接的Processor对象。如果不存在，则尝试根据协商协议构造Processor（HTTP/2.0请求）。如果不存在协商协议（HTTP/1.1请求），则从回收队列中获取一个已释放的Processor对象使用。如果回收队列中没有可用的对象，那么由具体的协议创建一个Processor使用。</p>
<p>然后，ConnectionHandler调用Processor.process()方法进行请求处理。如果不是协议协商的请求（非HTTP/2.0），那么Processor则会直接调用CoyoteAdapter.service()方法将其提交到Catalina容器进行处理。如果是协议协商请求，Processor会返回SocketState.UPGRADING，由ConnectionHandler进行协议升级。</p>
</li>
<li><p>协议升级时，ConnectionHandler会从当前Processor得到一个UpgradeToken对象，并构造一个升级Processor实例替换当前的Processor，并将当前的Processor释放回收。替换后，该链接的后续处理将由升级Processor完成。</p>
</li>
<li><p>通过UpgradeToken中的HttpUpgradeHandler对象的init()方法进行初始化，以便准备开始启用新协议。</p>
</li>
</ol>
<h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h3><p>SPDY协议是Google开发的用于传输web内容的开放网络协议，是HTTP/2.0的母体。SPDY通过巧妙地控制HTTP通信，以达到降低web页面加载延迟和提高web安全的目标。SPDY通过压缩、多路复用、优先级来实现降低延迟，但是这依赖于网络和web应用部署条件的组合。</p>
<p>SPDY的设计目标是降低web页面加载事件。通过优先级和多路复用，SPDY使得只需要建立一个TCP链接即可传送网页内容及图片等资源。SPDY中广泛应用了TLS加密，传输内容也均以GZIP或DEFALATE格式压缩。另外，除了像HTTP网页服务器被动等待浏览器发起请求以外，SPDY网页服务器还可以主动向浏览器推送内容。。</p>
<p>SPDY并不是用于取代HTTP协议，它修改了HTTP请求和响应子啊网络上传输方式。这意味着只需要增加一个SPDY传输层，现有的所有服务端应用均不需要做任何的修改。SPDY是HTTP和HTTPS协议的有效隧道。当通过SPDY发送时，HTTP请求会被处理、标记简化和压缩。比如，每个SPDY断点会持续跟踪在之前请求中已经发送的HTTP报文头部，从而避免重复发送还未改变的头部，未发送的报文数据部分将在压缩后发送。</p>
<p>考虑到SPDY获得了如Mozilla、Nginx的支持，以及相比HTTP/1.1性能的提升，HTTP的工作小组绝定采用SPDY/2作为HTTP/2的基础，发展HTTP/2.0。</p>
<p>HTTP/2.0虽然依托于SPDY/2，但是仍有不同之处，在于以下两点：</p>
<ol>
<li>HTTP/2.0支持明文传输，而SPDY强制使用HTTPS</li>
<li>HTTP/2.0消息头的压缩算法采用HPACK，而SPDY采用DELEFT</li>
</ol>
<p>相比HTTP/1.1，HTTP/2.0在传输方面做了如下改进：</p>
<ol>
<li>采用二进制格式传输数据而非HTTP/1.1的文本格式</li>
<li>HTTP/2.0对消息头采用HPACK压缩，提升了传输效率</li>
<li>基于帧和流的多路复用，真正实现了基于一个链接的多情情并发处理</li>
<li>支持服务器推送</li>
</ol>
<p>在HTTP/2.0中，一个基本的协议单元是 <strong>帧（Frame）</strong>。按照不同的用途，可用分为不同类型的帧，比如HEADERS和DATA帧用于HTTP请求和响应，而 SETTINGS、WINDOW_UPDATE、PUSH_PROMISE等则用于支持HTTP/2.0的特性。</p>
<p>一个帧由9字节的定长头和变长的Playload组成，具体格式为：</p>
<p><img src="/images/%E5%B8%A7%E7%BB%93%E6%9E%84.png"></p>
<ul>
<li>Length：24位，表示Playload部分的长度</li>
<li>Type：8位，表示帧的类型</li>
<li>Flags：8位，每一位是一个布尔标记，用于特定的帧类型。对于每个类型的帧，这些标记都被赋予了特殊的语义。比如发送最后一个DATA类型的Frame时，就会将Flags最后一位设置为1，表示END_STREAM，说明当前帧是流的最后一个数据包</li>
<li>R：预留的1位，无明确语义</li>
<li>Stream Identifier：帧所属流的标识。标识0除外，只是作为预留值用于链接初始化，而不是哪个帧</li>
<li>Playload：帧的有效荷载，每种类型的帧的Playload格式和语义均不相同。</li>
</ul>
<h4 id="HTTP-1-1到HTTP-2-0的转换"><a href="#HTTP-1-1到HTTP-2-0的转换" class="headerlink" title="HTTP/1.1到HTTP/2.0的转换"></a>HTTP/1.1到HTTP/2.0的转换</h4><p><img src="/images/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BD%AC%E6%8D%A2.png"></p>
<h4 id="流-Stream"><a href="#流-Stream" class="headerlink" title="流 Stream"></a>流 Stream</h4><p>Stream是客户端与服务器间通过HTTP/2.0链接交换的 独立的、双向的帧序列，可以将流视为一个完整的请求响应过程。流的概念的提出是为了实现HTTP请求的多路复用，具有以下特征：</p>
<ol>
<li>一个HTTP/2.0链接可以并发地打开多个流，并可以从多个流的任意端点交换帧</li>
<li>流可以创建并被客户端/服务器单边或共享地使用</li>
<li>流可以被任意端点关闭</li>
<li>同一个流中的帧按顺序发送，接收者按照接收顺序进行处理</li>
<li>流通过一个整数标识，由初始化流的端点分配</li>
<li>流是相互独立的，因此一个流的阻塞或停止的请求/响应不会影响到其他流的处理</li>
</ol>
<p><img src="/images/%E6%B5%81%E7%9A%84%E4%BC%A0%E8%BE%93.png"></p>
<h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>从8.5版本开始，Tomcat移除了对BIO的支持。这里只是为了提及一下BIO的通信方式：</p>
<p>BIO即阻塞式I/O，是Java提供的最基本的I/O方式。在网络通信中，需要通过Socket在客户端与服务端建立双向链接以实现通信，主要步骤如下：</p>
<ol>
<li>服务端监听某个端口释放有链接请求</li>
<li>客户端向服务端发出链接请求</li>
<li>服务端向客户端返回Accept消息，此时链接成功</li>
<li>客户端和服务器端通过Send()、Write()等方法与对方通信</li>
<li>关闭链接</li>
</ol>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>传统的BIO方式是基于流进行读写的，而且是阻塞的，整体性能比较差。为了提高I/O性能，引入NIO，弥补BIO方式的不足，在标准Java代码中提供了高速、面向块的I/O。通过定义包含数据的类以及块的形式处理数据，NIO可以在不编写本地代码的情况下利用底层优化，这是BIO无法做到的。</p>
<p>与BIO相比，NIO的几个新的概念：</p>
<ol>
<li>通道（Channel）是对BIO中流的模拟，到任何目的地的所有数据都必须通过一个通道对象。通道和流的不同之处在于通道是双向的。流只是在一个方向上移动，而通道可以用于读、可以用于写、或者读写同时进行。因为通道是双向的，所以它可以比流更好地反映底层操作系统的真实情况。</li>
<li>缓冲区（Buffer）。尽管通道用于读写数据，但是并不直接通过通道进行读写。而是通过缓冲区完成。缓冲区实质上是一个容器对象。发送给通道的所有数据都必须先放到缓冲区。缓冲区体通常是一个字节数组。</li>
<li>选择器（Selector）。选择器用于同时检测多个通道的事件以实现异步I/O。通过将事件注册到Selector上，当事件发生时，可以通过选择器获取事件发生的通道，并进行相关的操作。异步I/O的优势在于，允许同时根据大量的输入、输出执行I/O操作。而同步I/O则要借助轮询，或者创建许多线程处理大量的链接。使用异步I/O，可以监听任意数量的通道事件，不必轮询，也不必启动额外的线程。</li>
</ol>
]]></content>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
</search>
